<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言</title>
    <link href="/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80/"/>
    <url>/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>[[2.C语言Char和string]]</p><p>[[3.C语言指针]]</p><p>[[4.C语言函数]]</p><p>[[C语言代码集]]</p><p>[[C++速转Python]]</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h2><p>在最新的 C99 标准中，只有以下两种定义方式是正确的：</p><p>int main( void ) &#x2F;* 无参数形式 *&#x2F;<br>{<br>  …<br>  return 0;<br>}<br>int main( int argc, char <em>argv[] ) &#x2F;</em> 带参数形式 *&#x2F;<br>{<br>  …<br>  return 0;<br>}</p><p>在C90标准中也可以</p><p>int main(){</p><p>​return 0;</p><p>}</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>变量名以英文字母开头</p></li><li><p>不可以包含空格、标点符号和类型说明符（%、&amp;、！、#、@、$）</p></li><li><p>字母是<strong>区分大小写</strong></p><p>字符数组中如果分配的空间多余字符的数目，后面是用0填充的，通过验证可以知道这里是数字0而不是字符0</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="signed与unsigned"><a href="#signed与unsigned" class="headerlink" title="signed与unsigned"></a>signed与unsigned</h3><p>signed的作用是：声明有符号类型的整数类型。</p><ul><li><strong>signed</strong>意思为有符号的，也就是第一个位代表正负，剩余的代表大小，例如：signed int 大小区间为-32768 到 +32767的整数</li></ul><p>unsigned的作用是：声明无符号的整数类型。</p><ul><li><strong>unsigned</strong>意思为无符号的，所有的位都为大小，没有负数，例如：unsigned int 大小区间为：0到   的非负整数</li></ul><h3 id="Float-与Double"><a href="#Float-与Double" class="headerlink" title="Float 与Double"></a>Float 与Double</h3><p>float和double都属于浮点数。区别在于：double所表示的范围，整数部分范围大于float，小数部分，精度也高于float</p><p>浮点数不可以直接用<code>==</code>与<code>!=</code>比较</p><h3 id="Char与String"><a href="#Char与String" class="headerlink" title="Char与String"></a>Char与String</h3><p>char取值为[-127,127]，如果超过127则为-128+（超出128的部分），如128&#x3D;-128，129为-127</p><p>原因是129二进制是10000001，char存储八位，将第一位认为是符号位</p><p>string 是字符串，char是单个的字符。string相当于一个容器，char可以放在里面。string有结束符，char没有</p><p>char 用<code>&#39;&#39;</code>，string用<code>&quot;&quot;</code></p><p>char数组的最后应该是<code>&#39;\0&#39;</code>变量</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>不能用作变量名</p><p>这些关键字如下：</p><table><thead><tr><th><a href="https://baike.baidu.com/item/auto/10128?fromModule=lemma_inlink">auto</a></th><th><a href="https://baike.baidu.com/item/break/405784?fromModule=lemma_inlink">break</a></th><th><a href="https://baike.baidu.com/item/case/7146375?fromModule=lemma_inlink">case</a></th><th><a href="https://baike.baidu.com/item/char/5156054?fromModule=lemma_inlink">char</a></th><th><a href="https://baike.baidu.com/item/const/1036?fromModule=lemma_inlink">const</a></th><th><a href="https://baike.baidu.com/item/continue/3009735?fromModule=lemma_inlink">continue</a></th><th><a href="https://baike.baidu.com/item/default?fromModule=lemma_inlink">default</a></th><th><a href="https://baike.baidu.com/item/do/18599594?fromModule=lemma_inlink">do</a></th></tr></thead><tbody><tr><td><a href="https://baike.baidu.com/item/double?fromModule=lemma_inlink">double</a></td><td><a href="https://baike.baidu.com/item/else?fromModule=lemma_inlink">else</a></td><td><a href="https://baike.baidu.com/item/enum/10934073?fromModule=lemma_inlink">enum</a></td><td><a href="https://baike.baidu.com/item/extern?fromModule=lemma_inlink">extern</a></td><td><a href="https://baike.baidu.com/item/float/19167524?fromModule=lemma_inlink">float</a></td><td><a href="https://baike.baidu.com/item/for?fromModule=lemma_inlink">for</a></td><td><a href="https://baike.baidu.com/item/goto/12755716?fromModule=lemma_inlink">goto</a></td><td><a href="https://baike.baidu.com/item/if/4529589?fromModule=lemma_inlink">if</a></td></tr><tr><td><a href="https://baike.baidu.com/item/int/944671?fromModule=lemma_inlink">int</a></td><td><a href="https://baike.baidu.com/item/long/412402?fromModule=lemma_inlink">long</a></td><td><a href="https://baike.baidu.com/item/register?fromModule=lemma_inlink">register</a></td><td><a href="https://baike.baidu.com/item/return/16284?fromModule=lemma_inlink">return</a></td><td><a href="https://baike.baidu.com/item/short?fromModule=lemma_inlink">short</a></td><td><a href="https://baike.baidu.com/item/signed?fromModule=lemma_inlink">signed</a></td><td><a href="https://baike.baidu.com/item/sizeof?fromModule=lemma_inlink">sizeof</a></td><td><a href="https://baike.baidu.com/item/static?fromModule=lemma_inlink">static</a></td></tr><tr><td><a href="https://baike.baidu.com/item/struct?fromModule=lemma_inlink">struct</a></td><td><a href="https://baike.baidu.com/item/switch/18601752?fromModule=lemma_inlink">switch</a></td><td><a href="https://baike.baidu.com/item/typedef?fromModule=lemma_inlink">typedef</a></td><td><a href="https://baike.baidu.com/item/union/1974872?fromModule=lemma_inlink">union</a></td><td><a href="https://baike.baidu.com/item/unsigned?fromModule=lemma_inlink">unsigned</a></td><td><a href="https://baike.baidu.com/item/void/5126319?fromModule=lemma_inlink">void</a></td><td><a href="https://baike.baidu.com/item/volatile?fromModule=lemma_inlink">volatile</a></td><td><a href="https://baike.baidu.com/item/while?fromModule=lemma_inlink">while</a></td></tr></tbody></table><h2 id="Printf函数细节"><a href="#Printf函数细节" class="headerlink" title="Printf函数细节"></a>Printf函数细节</h2><p>%是C语言的格式符号</p><table><thead><tr><th align="center">print type</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>i</strong> or d</td><td align="center">signed integer</td></tr><tr><td align="center"><strong>u</strong></td><td align="center">unsigned integer&#x2F;&#x2F;最高位不是符号位，没有符号</td></tr><tr><td align="center">f,lf</td><td align="center">floating point number with”.”,标准是f</td></tr><tr><td align="center">e</td><td align="center">floating point number with”e”(以指数方式输出实数)</td></tr><tr><td align="center">o,x</td><td align="center">octal（八进制）,hexadecimal（16进制）</td></tr><tr><td align="center">c,s</td><td align="center">Character（仅输出最后一位）, String</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">将光标移到最接近8的倍数的位置</td></tr></tbody></table><p>%<w><x>.<n><t>(e.g. %3.1f).</p><ol><li><w>零标志</li><li><x>最小字段宽度（如果实际宽度大，就正常输出）</li><li><n>精度(小数点后有几位)</li><li><t>转换说明符</li></ol><p>比如printf(“%7s%13s”,”tht”,”nb”);输出为“    tht           nb”</p><p>tht前有4个空格，nb前有11个空格</p><p><img src="https://img-blog.csdnimg.cn/20200129132355344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4OTg0MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200129132432924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4OTg0MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><table><thead><tr><th align="center">字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">结果左对齐，右边填空格；默认右对齐，左边填空格</td></tr><tr><td align="center">+</td><td align="center">输出符号（正好或负号）</td></tr><tr><td align="center">space</td><td align="center">输出值为正时加上空格，为负时加上负号</td></tr><tr><td align="center">#</td><td align="center">type是0，x，X时，增加前缀0，0x，0X</td></tr><tr><td align="center">0</td><td align="center">在输出前补上零，直到占满指定列宽为止</td></tr></tbody></table><h3 id="小数的输出-e的用法"><a href="#小数的输出-e的用法" class="headerlink" title="小数的输出 %e的用法"></a>小数的输出 %e的用法</h3><p>C语言中小数的指数形式为：aEn 或 aen</p><p>a 为尾数部分，是一个十进制数；n 为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于 a×10n。</p><p>2.1E5 &#x3D; 2.1×10^5，其中 2.1 是尾数，5 是指数。</p><p>3.7E-2 &#x3D; 3.7×10^-2，其中 3.7 是尾数，-2 是指数。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。</p><p>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</p><p>case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</p><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</p><p>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p><p>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</p><p>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> inchar=<span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">switch</span>(inchar)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A&quot;</span>); <br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//将输出Ab </span><br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//没有break则将一直执行 </span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br><span class="hljs-keyword">default</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<span class="hljs-comment">//非必须</span><br>&#125; <br></code></pre></td></tr></table></figure><h3 id="赋值语句作判断条件"><a href="#赋值语句作判断条件" class="headerlink" title="赋值语句作判断条件"></a>赋值语句作判断条件</h3><p>它并不是以是否赋值成功作为true和false的判断机制，而是看赋值的值是多少，如果为0自动就作为false了<br>判断句优先级低于运算</p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for(x&#x3D;999;x&gt;&#x3D;1;x-&#x3D;2)printf(“%d\n”,x);<br>&#x2F;&#x2F;最后输出1，for循环先判断-2后是否满足，再进入循环</p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><p>do{<br>        if(x%2&#x3D;&#x3D;0)<br>            printf(“%d\n”,x);<br>        x+&#x3D;2;<br>    }while(x&lt;100);&#x2F;&#x2F;注意这里的“；”<br>&#x2F;&#x2F;最后是98</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">float</span> x=<span class="hljs-number">3.1415</span>;<br><span class="hljs-type">double</span> y=<span class="hljs-number">3.1415</span>,n=<span class="hljs-number">1234567.1234567</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">1234567</span>;<br><span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;c&#x27;</span>;<span class="hljs-comment">//可以有多个字符，但只看最后一个 </span><br><span class="hljs-type">char</span> m[]=<span class="hljs-string">&quot;sbaxc&quot;</span>;<span class="hljs-comment">//char数组表示string，或者用char* m定义,用双引号，不然报错 ,</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,x==y);<span class="hljs-comment">//0(double float 不能直接比较)，==表示判断句 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%e\n&quot;</span>,x);<span class="hljs-comment">//3.141500e+000</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf limited decimal is %6.5lf\n&quot;</span>,n,n);<span class="hljs-comment">//lf默认六位，.后面表示小数点后的位数 （5），并且会四舍五入,.前面没有影响 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&#x27;s ascill number is %d\n&quot;</span>,a,a);<span class="hljs-comment">//C输出字符与数字</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,m);<span class="hljs-comment">//s输出字符串 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%1.2lf\n&quot;</span>,<span class="hljs-number">99.996</span>);<span class="hljs-comment">//输出为100.00</span><br><span class="hljs-type">int</span> inte=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,inte++);<span class="hljs-comment">//++在后面，先输出，后+1 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,++inte); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3e&quot;</span>,<span class="hljs-number">2.71</span>);<span class="hljs-comment">//2.710e+00（补齐）</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3e&quot;</span>,<span class="hljs-number">2.71855</span>);<span class="hljs-comment">//2.719e+00（四舍五入）</span><br><span class="hljs-type">int</span> j=<span class="hljs-number">5</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,++j,j++,—j);<span class="hljs-comment">//先+1后输出，后输出后+1，再-1后输出</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>在<code>#include&lt;stdlib.h&gt;</code>中</p><p><code>rand()</code>能产生伪随机数</p><p><code>srand(time(NULL));</code> &#x2F;&#x2F;初始化随机过程</p><p>需要搭配<code>#inlcude&lt;time.h&gt;</code></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><code>a[3][4]</code></p><table><thead><tr><th align="center">0,0</th><th>0,1</th><th align="center">0,2</th><th>0,3</th></tr></thead><tbody><tr><td align="center">1,0</td><td>1,1</td><td align="center">1,2</td><td>1,3</td></tr><tr><td align="center">2,0</td><td>2,1</td><td align="center">2,2</td><td>2,3</td></tr></tbody></table><p>for(int i&#x3D;1;i&lt;&#x3D;n;i++)</p><p>​for(int j&#x3D;1;j&lt;&#x3D;n;j++)a[i][j]</p><p>最终是一行一行扫下来</p><p><code>int matrix[4][3] = &#123;[0][0]=1,[1][1]=5, [2][2]=9&#125;;</code></p><h1 id="期末考复习"><a href="#期末考复习" class="headerlink" title="期末考复习"></a>期末考复习</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">////输出问题点 </span><br><span class="hljs-comment">//int n=4,cd=4,de=60;</span><br><span class="hljs-comment">//float z=19.0;</span><br><span class="hljs-comment">//double z2=19.0;</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">19</span>,y = <span class="hljs-number">4</span>; <br><span class="hljs-type">float</span> z = <span class="hljs-number">19.0</span>;<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%d\n&quot;</span>, x / y);<span class="hljs-comment">//4 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, z / y);<span class="hljs-comment">//4.750000 lf和f都是打出6位 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, x/(<span class="hljs-type">float</span>)y);<span class="hljs-comment">//4.750000 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, (<span class="hljs-type">float</span>)(x / y));<span class="hljs-comment">//4.000000，只有这种情况是除出为整数后输出 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, z / ++y);<span class="hljs-comment">//3.800000 （先加，后除 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%.2f&quot;</span>,z/cd);<span class="hljs-comment">//4.75,.后面是几就打出几位</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%7s%13s&quot;</span>,<span class="hljs-string">&quot;tht&quot;</span>,<span class="hljs-string">&quot;nb&quot;</span>);<span class="hljs-comment">//tht前有4个空格，nb前有11个空格</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%8.2f&quot;</span>,z);<span class="hljs-comment">//   19.00小数点也算一格，前面三格</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%i&quot;</span>,cd);<span class="hljs-comment">//%i=%d</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d %d %f&quot;</span>,z,z2,n);<span class="hljs-comment">//输出格式错全为0 (0 0 0.000000)</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>,<span class="hljs-number">10e5</span>);<span class="hljs-comment">//e前后都必须有数字，并且e后面必须是整数,2.1E5 = 2.1×10^5，其中 2.1 是尾数，5 是指数</span><br><br>    <span class="hljs-comment">//输入问题点 </span><br><span class="hljs-comment">//scanf中float用f，double用lf，long long用lld ，printf没有lf !!!</span><br><span class="hljs-type">char</span> c,*str;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,c);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<span class="hljs-comment">//注意字符串输入无地址符 </span><br><span class="hljs-type">char</span> strr[<span class="hljs-number">20</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[^\n]&quot;</span>,strr);<span class="hljs-comment">//注意这里变量必须是数组形式，这种输入可以接受空格</span><br>    <br>    <br><span class="hljs-comment">//switch case </span><br> <span class="hljs-type">char</span> inchar=<span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">switch</span>(inchar)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A&quot;</span>); <br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//将输出Ab </span><br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//没有break则将一直执行 </span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c&quot;</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br><span class="hljs-keyword">default</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<span class="hljs-comment">//非必须</span><br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="下半学期"><a href="#下半学期" class="headerlink" title="下半学期"></a>下半学期</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">time</span>&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span>&#123;</span><br><span class="hljs-type">int</span> ttt;<br>&#125;tt;<br><span class="hljs-type">int</span> ti,tj,tq;<br>&#125;t1,t[<span class="hljs-number">100</span>]; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> data;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">mystery</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> p)</span> ; <span class="hljs-comment">/* function prototype */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swaps</span><span class="hljs-params">(<span class="hljs-type">char</span> **a,<span class="hljs-type">char</span> **b)</span>&#123;<br><span class="hljs-type">char</span> *c=*a;<br>*a=*b;<br>*b=c;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swapi</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span>&#123;<br><span class="hljs-type">int</span> *c=*a;<br>*a=*b;<br>*b=c; <br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">calculateLength</span><span class="hljs-params">(<span class="hljs-type">char</span>* a)</span>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(*a)&#123;<br>a++;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//char，string复习 </span><br><span class="hljs-type">signed</span> <span class="hljs-type">char</span> c=<span class="hljs-number">128</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,c);<br><span class="hljs-type">int</span> a=<span class="hljs-number">5</span>,b=<span class="hljs-number">6</span>;<br>swapi(&amp;a,&amp;b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,a,b);<br><span class="hljs-comment">//char *x=&quot;abc&quot;,*y=&quot;def&quot;;</span><br><span class="hljs-comment">//swaps(&amp;x,&amp;y);</span><br><span class="hljs-comment">//printf(&quot;%s %s&quot;,x,y);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,calculateLength(<span class="hljs-string">&quot;abcdefg&quot;</span>)); <br><span class="hljs-type">char</span> chr[<span class="hljs-number">100</span>],s[<span class="hljs-number">4</span>]=<span class="hljs-string">&quot; &quot;</span>,*tok,*rev[<span class="hljs-number">20</span>]; <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[^\n]&quot;</span>,chr);<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>,i;<br>    <span class="hljs-comment">// Use of strtok to get first token</span><br>    tok = strtok(chr, s);<br>    <span class="hljs-keyword">while</span> (tok != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s\n&quot;</span>, tok);<br>        rev[n]=tok;<br>        n++;<br>        tok = strtok(<span class="hljs-number">0</span>, s);<span class="hljs-comment">//!!!!!!千万注意这里是NULL或者0</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,rev[i]);<span class="hljs-comment">//反向输出 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <br>    <span class="hljs-comment">//struct复习 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">time</span> *<span class="hljs-title">ptr</span>;</span><br>ptr=&amp;t1;<br><span class="hljs-comment">//三种struct结构赋值方式 </span><br>ptr-&gt;ti=<span class="hljs-number">5</span>;<br>t1.ti=<span class="hljs-number">6</span>;<br>t1.tt.ttt=<span class="hljs-number">4</span>;<span class="hljs-comment">//多重struct结构（nested） </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">time</span> <span class="hljs-title">t1</span>=</span>&#123;<span class="hljs-comment">//多重struct赋值 </span><br>.tt.ttt=<span class="hljs-number">3</span>,<br>.tj=<span class="hljs-number">2</span><br>&#125;;<span class="hljs-comment">//顺序赋值 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d \n&quot;</span>,t1.tt.ttt);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tme</span> <span class="hljs-title">t2</span>=</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//顺序赋值 </span><br><span class="hljs-comment">//struct tme t2=&#123;//无序赋值 （运行时注意注释前面） </span><br><span class="hljs-comment">//.tj=2,</span><br><span class="hljs-comment">//.ti=3,</span><br><span class="hljs-comment">//.tq=1 </span><br><span class="hljs-comment">//&#125;;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>,t2.ti,t2.tj,t2.tq);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言Char和string</title>
    <link href="/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80Char%E5%92%8Cstring/"/>
    <url>/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80Char%E5%92%8Cstring/</url>
    
    <content type="html"><![CDATA[<h1 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>char字符其实是数字，根据ascil码可查</p><blockquote><p>65-90是A-Z，97-122是a-z</p></blockquote><p>字符串一般以’\0’结尾</p><p>注意在赋值时，字符char c&#x3D;’a’，字符串char * a&#x3D;”abc”或者</p><p>char a[]&#x3D;&#x3D;{‘a’,’b’,’c’};注意这样赋值字符串不会以’\0’结尾</p><h2 id="char-与char-x"><a href="#char-与char-x" class="headerlink" title="char * 与char x[]"></a>char * 与char x[]</h2><p>由于C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。</p><p>C语言中规定数组代表数组所在<strong>内存位置的首地址</strong>，也是 str[0]的地址，即str &#x3D; &amp;str[0];</p><p>在C语言中<strong>字符串常量的本质表示其实是一个地址</strong></p><p>%s的原理其实也是<strong>通过字符串首地址输出字符串</strong>，所以可以char *str; printf(“%s”,str);</p><p>char * 与 char a[ ] 的本质区别：</p><p>当定义 char a[10 ] 时，编译器会给数组<strong>分配十个单元</strong>，每个单元的数据类型为字符。。</p><p>而定义 char *s 时， 这是个指针变量，只占四个字节，32位，用来<strong>保存一个地址</strong>。。</p><p>写程序是尽量用char a[]; 来定义string，免得出锅</p><h2 id="单个字符的输入与输出。"><a href="#单个字符的输入与输出。" class="headerlink" title="单个字符的输入与输出。"></a>单个字符的输入与输出。</h2><p>通常，我们用char定义的字符型变量可以用以下形式进行输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> ch;<br>ch = getchar();<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;ch);<br></code></pre></td></tr></table></figure><p>同样的，输出的格式我们也有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">ch = <span class="hljs-built_in">putchar</span>()；<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,ch);<br></code></pre></td></tr></table></figure><h2 id="字符串的输入输出"><a href="#字符串的输入输出" class="headerlink" title="字符串的输入输出"></a>字符串的输入输出</h2><p>scanf遇到空格、回车就会终止！而gets认为空格也是字符，可以将空格输入，遇到回车才会终止！</p><p>printf输出时，需要加\n才会换行；而puts函数自带换行功能！</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a);<span class="hljs-comment">//注意这里没有地址符！！！</span><br><span class="hljs-comment">//当输入的字符串中有空格就会停止</span><br><span class="hljs-type">char</span>* str;<br>str=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*<span class="hljs-number">10</span>);<br>gets(str);<br>fgets(str, <span class="hljs-keyword">sizeof</span>(str), <span class="hljs-built_in">stdin</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[^\n]&quot;</span>,a);<br></code></pre></td></tr></table></figure><p>下面是 fgets() 函数的声明。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">char</span> *fgets(<span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span> n, FILE *stream)<br></code></pre></td></tr></table></figure><p>参数</p><ul><li><strong>str</strong> – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li><li><strong>n</strong> – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li></ul><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(str);<br></code></pre></td></tr></table></figure><h2 id="string-h库"><a href="#string-h库" class="headerlink" title="string.h库"></a>string.h库</h2><p>C 中有大量操作字符串的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 目的</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。（后到前）</td></tr><tr><td align="left">2</td><td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td align="left">3</td><td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td align="left">4</td><td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr><tr><td align="left">5</td><td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td align="left">6</td><td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr><tr><td align="left">7</td><td align="left"><strong>strtok()</strong> <strong>Method:</strong> Splits str[] according to given delimiters and returns the next token. It needs to be called in a loop to get all tokens. It returns NULL when there are no more tokens.</td></tr></tbody></table><p>islower(), isupper(), isalpha(), isdigit()</p><p>在第一次循环中，strtok函数将第一个人信息后的这个逗号，改为了’\0，这时strtok内部的this指针指向的是逗号的后一个字符。</p><p>而在第一个循环结束后，函数第一个参数被设定为NULL，strtok将以this指针指向的位置作为分解起始位置，此时this指针指向的是’\0’，strtok对一个空串无法切分，返回NULL，所以得到上面的结果。</p><p>正确返回大于0的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[]= “The quick brown fox”; <span class="hljs-comment">// string to be searched</span><br><span class="hljs-type">char</span> ch= ‘q’; <span class="hljs-comment">// The character we are looking for</span><br><span class="hljs-type">char</span> *pGot_char= <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// Pointer initialized to NULL</span><br>pGot_char= <span class="hljs-built_in">strchr</span>(str,chr); <span class="hljs-comment">// stores address where chis found</span><br><br><br>tokenize<br>    <span class="hljs-comment">// Declaration of string</span><br>    <span class="hljs-type">char</span> gfg[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;Geeks-for - geeks - Contribute&quot;</span>;<br>    <span class="hljs-comment">// Declaration of delimiter</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> s[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;-&quot;</span>;<br>    <span class="hljs-type">char</span>* tok;<br>    <span class="hljs-comment">// Use of strtok</span><br>    <span class="hljs-comment">// get first token</span><br>    tok = strtok(gfg, s);<br>    <span class="hljs-comment">// Checks for delimiter</span><br>    <span class="hljs-keyword">while</span> (tok != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s\n&quot;</span>, tok);<br>        <span class="hljs-comment">// Use of strtok</span><br>        <span class="hljs-comment">// go through other tokens</span><br>        tok = strtok(<span class="hljs-number">0</span>, s);<span class="hljs-comment">//!!!!!!千万注意这里是NULL或者0</span><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="define-constant-srings"><a href="#define-constant-srings" class="headerlink" title="define constant srings"></a>define constant srings</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MONTHS 12 </span><br></code></pre></td></tr></table></figure><p>Important things to remember</p><p>– No semicolon at the end</p><p>– No equal sign used to assign values to string</p><p>– There is no such thing as local define since they can appear anywhere </p><p>in the program</p><p>– String Messages</p><p>• #define Message “You have won the game!”</p><h2 id="指针与string"><a href="#指针与string" class="headerlink" title="指针与string"></a>指针与string</h2><p>const int* ptr&#x3D;&a;&#x2F;&#x2F;指针指向地址会变</p><p>int *const ptr&#x3D;&a;&#x2F;&#x2F;不会变，变化时报错</p><h2 id="交换字符串"><a href="#交换字符串" class="headerlink" title="交换字符串"></a>交换字符串</h2><p>第一行代码的意思是定义了一个char*类型的指针，我们将关注的是代码的存储问题，这里str变量是存储于栈区的，而”hello”, 则是存放在字符串常量区，字符串常量区的数据是不可更改的。所以无法直接更改“hello”和“world”的存储位置来达到交换的目的</p><p>正确的思路是，再分别定义一个指针来指向str1和str2,即指向指针的指针（二级指针）——把函数的参数定义为二级指针，作用是为了通过交换栈区的str1， 和str2存储的字符串所在内存空间的地址来达到目的</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言Char和string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax内容爬取</title>
    <link href="/Blogs/2025/08/28/Ajax%E5%86%85%E5%AE%B9%E7%88%AC%E5%8F%96/"/>
    <url>/Blogs/2025/08/28/Ajax%E5%86%85%E5%AE%B9%E7%88%AC%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Ajax？"><a href="#什么是-Ajax？" class="headerlink" title="什么是 Ajax？"></a>什么是 Ajax？</h1><p>Ajax，全称为 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML。它不是一门编程语言，而是利用 JavaScript 在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p><p>对于传统的网页，如果想更新其内容，那么必须刷新整个页面，但有了 Ajax，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上是在后台与服务器进行了数据交互，获取到数据之后，再利用 JavaScript 改变网页，这样网页内容就会更新了。</p><p>可以到 W3School 上体验几个示例感受一下：<a href="http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp">http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp</a>。</p><h2 id="1-实例引入"><a href="#1-实例引入" class="headerlink" title="1. 实例引入"></a><a href="https://cuiqingcai.com/202251.html#1-%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5" title="1. 实例引入"></a>1. 实例引入</h2><p>浏览网页的时候，我们会发现很多网页都有下滑查看更多的选项。比如，拿微博来说，以我的主页为例：<a href="https://m.weibo.cn/u/2830678474">https://m.weibo.cn/u/2830678474</a>，切换到微博页面，一直下滑，可以发现下滑几个微博之后，再向下就没有了，转而会出现一个加载的动画，不一会儿下方就继续出现了新的微博内容，这个过程其实就是 Ajax 加载的过程，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/2jqaq.png"></p><p>我们注意到页面其实并没有整个刷新，也就意味着页面的链接没有变化，但是网页中却多了新内容，也就是后面刷出来的新微博。这就是通过 Ajax 获取新数据并呈现的过程。</p><h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a><a href="https://cuiqingcai.com/202251.html#2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" title="2. 基本原理"></a>2. 基本原理</h2><p>初步了解了 Ajax 之后，我们再来详细了解它的基本原理。发送 Ajax 请求到网页更新的这个过程可以简单分为以下 3 步：</p><ol><li>发送请求</li><li>解析内容</li><li>渲染网页</li></ol><p>下面我们分别来详细介绍一下这几个过程。</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a><a href="https://cuiqingcai.com/202251.html#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" title="发送请求"></a>发送请求</h3><p>我们知道 JavaScript 可以实现页面的各种交互功能，Ajax 也不例外，它也是由 JavaScript 实现的，</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>var xmlhttp;  <br>if (window.XMLHttpRequest) {  <br>  &#x2F;&#x2F;code for IE7+, Firefox, Chrome, Opera, Safari  <br>  xmlhttp &#x3D; new XMLHttpRequest();  <br>} else {  <br>  &#x2F;&#x2F;code for IE6, IE5  <br>  xmlhttp &#x3D; new ActiveXObject(“Microsoft.XMLHTTP”);  <br>}  <br>xmlhttp.onreadystatechange &#x3D; function () {  <br>  if (xmlhttp.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlhttp.status &#x3D;&#x3D; 200) {  <br>    document.getElementById(“myDiv”).innerHTML &#x3D; xmlhttp.responseText;  <br>  }  <br>};  <br>xmlhttp.open(“POST”, “&#x2F;ajax&#x2F;“, true);  <br>xmlhttp.send();</td></tr></tbody></table><p>这是 JavaScript 对 Ajax 最底层的实现，实际上就是新建了 <code>XMLHttpRequest</code> 对象，然后调用 <code>onreadystatechange</code> 属性设置了监听，然后调用 <code>open</code> 和 <code>send</code> 方法向某个链接（也就是服务器）发送了请求。前面用 Python 实现请求发送之后，可以得到响应结果，但这里请求的发送变成 JavaScript 来完成。由于设置了监听，所以当服务器返回响应时，<code>onreadystatechange</code> 对应的方法便会被触发，然后在这个方法里面解析响应内容即可。</p><h3 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a><a href="https://cuiqingcai.com/202251.html#%E8%A7%A3%E6%9E%90%E5%86%85%E5%AE%B9" title="解析内容"></a>解析内容</h3><p>得到响应之后，<code>onreadystatechange</code> 属性对应的方法便会被触发，此时利用 <code>xmlhttp</code> 的 <code>responseText</code> 属性便可取到响应内容。这类似于 Python 中利用 requests 向服务器发起请求，然后得到响应的过程。那么返回内容可能是 HTML，可能是 JSON，接下来只需要在方法中用 JavaScript 进一步处理即可。比如，如果是 JSON 的话，可以进行解析和转化。</p><h3 id="渲染网页"><a href="#渲染网页" class="headerlink" title="渲染网页"></a><a href="https://cuiqingcai.com/202251.html#%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5" title="渲染网页"></a>渲染网页</h3><p>JavaScript 有改变网页内容的能力，解析完响应内容之后，就可以调用 JavaScript 来针对解析完的内容对网页进行下一步处理了。比如，通过 <code>document.getElementById().innerHTML</code> 这样的操作，便可以对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这样的操作也被称作 DOM 操作，即对网页文档进行操作，如更改、删除等。</p><p>上例中，<code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText</code> 便将 ID 为 <code>myDiv</code> 的节点内部的 HTML 代码更改为服务器返回的内容，这样 <code>myDiv</code> 元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。</p><p>我们观察到，这 3 个步骤其实都是由 JavaScript 完成的，它完成了整个请求、解析和渲染的过程。</p><p>再回想微博的下拉刷新，这其实就是 JavaScript 向服务器发送了一个 Ajax 请求，然后获取新的微博数据，将其解析，并将其渲染在网页中。</p><p>因此，我们知道，真实的数据其实都是一次次 Ajax 请求得到的，如果想要抓取这些数据，需要知道这些请求到底是怎么发送的，发往哪里，发了哪些参数。如果我们知道了这些，不就可以用 Python 模拟这个发送操作，获取到其中的结果了吗？</p><h1 id="Ajax分析方法"><a href="#Ajax分析方法" class="headerlink" title="Ajax分析方法"></a>Ajax分析方法</h1><p>这里还以前面的微博为例，我们知道拖动刷新的内容由 Ajax 加载，而且页面的 URL 没有变化，那么应该到哪里去查看这些 Ajax 请求呢？</p><h2 id="1-分析案例"><a href="#1-分析案例" class="headerlink" title="1. 分析案例"></a><a href="https://cuiqingcai.com/202252.html#1-%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B" title="1. 分析案例"></a>1. 分析案例</h2><p>这里还需要借助浏览器的开发者工具，下面以 Chrome 浏览器为例来介绍。</p><p>首先，用 Chrome 浏览器打开微博的链接 <a href="https://m.weibo.cn/u/2830678474">https://m.weibo.cn/u/2830678474</a>，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择) “检查” 选项，此时便会弹出开发者工具，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/7040b.png"></p><p>前面也提到过，这里其实就是在页面加载过程中浏览器与服务器之间发送请求和接收响应的所有记录。</p><p>Ajax 其实有其特殊的请求类型，它叫作 xhr。在图中我们可以发现一个名称以 getIndex 开头的请求，其 Type 为 xhr，这就是一个 Ajax 请求。用鼠标点击这个请求，可以查看这个请求的详细信息。</p><p><img src="https://cdn.cuiqingcai.com/1kiqe.png"></p><p>在右侧可以观察到其 Request Headers、URL 和 Response Headers 等信息。其中 Request Headers 中有一个信息为 <code>X-Requested-With:XMLHttpRequest</code>，这就标记了此请求是 Ajax 请求，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/t4hm0.png"></p><p>随后点击一下 Preview，即可看到响应的内容，它是 JSON 格式的。这里 Chrome 为我们自动做了解析，点击箭头即可展开和收起相应内容。</p><p>观察可以发现，这里的返回结果是我的个人信息，如昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。JavaScript 接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。</p><p><img src="https://cdn.cuiqingcai.com/kah0s.png"></p><p>另外，也可以切换到 Response 选项卡，从中观察到真实的返回数据，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/l1z1j.png"></p><p>接下来，切回到第一个请求，观察一下它的 Response 是什么，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/yfn4s.png"></p><p>这是最原始的链接 <a href="https://m.weibo.cn/u/2830678474">https://m.weibo.cn/u/2830678474</a> 返回的结果，其代码只有不到 50 行，结构也非常简单，只是执行了一些 JavaScript。</p><p>所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是后来执行 JavaScript 后再次向后台发送了 Ajax 请求，浏览器拿到数据后再进一步渲染出来的。</p><h2 id="2-过滤请求"><a href="#2-过滤请求" class="headerlink" title="2. 过滤请求"></a><a href="https://cuiqingcai.com/202252.html#2-%E8%BF%87%E6%BB%A4%E8%AF%B7%E6%B1%82" title="2. 过滤请求"></a>2. 过滤请求</h2><p>接下来，再利用 Chrome 开发者工具的筛选功能筛选出所有的 Ajax 请求。在请求的上方有一层筛选栏，直接点击 XHR，此时在下方显示的所有请求便都是 Ajax 请求了，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/0xqyh.png"></p><p>接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也一个个地出现 Ajax 请求，这样我们就可以捕获到所有的 Ajax 请求了。</p><p>随意点开一个条目，都可以清楚地看到其 Request URL、Request Headers、Response Headers、Response Body 等内容，此时想要模拟请求和提取就非常简单了。</p><p>下图所示的内容便是我的某一页微博的列表信息：</p><p><img src="https://cdn.cuiqingcai.com/3gv1x.png"></p><p>到现在为止，我们已经可以分析出 Ajax 请求的一些详细信息了，接下来只需要用程序模拟这些 Ajax 请求，就可以轻松提取我们所需要的信息了。</p><h1 id="Ajax实战"><a href="#Ajax实战" class="headerlink" title="Ajax实战"></a>Ajax实战</h1><p>在上一节中我们已经学习了 Ajax 的基本原理和分析方法，这一节我们来结合一个实际的案例来看一下 Ajax 分析和爬取页面的具体实现。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a><a href="https://cuiqingcai.com/202253.html#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1. 准备工作"></a>1. 准备工作</h2><p>在本节开始之前，我们需要做好如下准备工作：</p><ul><li>安装好 Python 3（最低为 3.6 版本），并成功运行 Python 3 程序。</li><li>了解 Python HTTP 请求库 requests 的基本用法。</li><li>了解 Ajax 基础知识和分析 Ajax 的基本方法。</li></ul><p>以上内容在前面的章节中均有讲解，如尚未准备好，建议先熟悉一下这些内容。</p><h2 id="2-爬取目标"><a href="#2-爬取目标" class="headerlink" title="2. 爬取目标"></a><a href="https://cuiqingcai.com/202253.html#2-%E7%88%AC%E5%8F%96%E7%9B%AE%E6%A0%87" title="2. 爬取目标"></a>2. 爬取目标</h2><p>本节我们以一个示例网站来试验一下 Ajax 的爬取，其链接为：<a href="https://spa1.scrape.center/%EF%BC%8C%E8%AF%A5%E7%A4%BA%E4%BE%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%98%AF%E9%80%9A%E8%BF%87">https://spa1.scrape.center/，该示例网站的数据请求是通过</a> Ajax 完成的，页面的内容是通过 JavaScript 渲染出来的，页面如图所示：</p><p><img src="https://cdn.cuiqingcai.com/add5o.png" alt="image-20210705004644681"></p><p>可能大家看着这个页面似曾相识，心想这不就是上一个案例的网站吗？但其实不是。这个网站的后台实现逻辑和数据加载方式完全不同。只不过最后呈现的样式是一样的。</p><p>这个网站同样支持翻页，可以点击最下方的页码来切换到下一页，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/lyy4e.png" alt="image-20210705004704636"></p><p>点击每一个电影的链接进入详情页，页面结构也是完全一样的，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/y712p.png" alt="image-20210705004718813"></p><p>我们需要爬取的数据也是和原来相同的，包括电影的名称、封面、类别、上映日期、评分、剧情简介等信息。</p><p>本节中我们需要完成的目标如下。</p><ul><li>分析页面数据的加载逻辑。</li><li>用 requests 实现 Ajax 数据的爬取。</li><li>将每部电影的数据保存成一个 JSON 数据文件。</li></ul><p>由于本节主要讲解 Ajax，所以对于数据存储和加速部分就不再展开详细实现，主要是讲解 Ajax 的分析和爬取实现。</p><p>好，我们现在就开始吧。</p><h2 id="3-初步探索"><a href="#3-初步探索" class="headerlink" title="3. 初步探索"></a><a href="https://cuiqingcai.com/202253.html#3-%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2" title="3. 初步探索"></a>3. 初步探索</h2><p>首先，我们先尝试用之前的 requests 来直接提取页面，看看会得到怎样的结果。用最简单的代码实现一下 requests 获取首页源码的过程，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>url &#x3D; ‘<a href="https://spa1.scrape.center/">https://spa1.scrape.center/</a>‘  <br>html &#x3D; requests.get(url).text  <br>print(html)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><title>Scrape | Movie</title><link href=/css/chunk-700f70e1.1126d090.css rel=prefetch><link href=/css/chunk-d1db5eda.0ff76b36.css rel=prefetch><link href=/js/chunk-700f70e1.0548e2b4.js rel=prefetch><link href=/js/chunk-d1db5eda.b564504d.js rel=prefetch><link href=/css/app.ea9d802a.css rel=preload as=style><link href=/js/app.1435ecd5.js rel=preload as=script><link href=/js/chunk-vendors.77daf991.js rel=preload as=script><link href=/css/app.ea9d802a.css rel=stylesheet></head><body><noscript><strong>We’re sorry but portal doesn’t work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id=app></div><script src=/js/chunk-vendors.77daf991.js></script><script src=/js/app.1435ecd5.js></script></body></html></td></tr></tbody></table><p>可以看到，爬取结果就只有这么一点 HTML 内容，而我们在浏览器中打开这个页面，却能看到如图所示的结果：</p><p><img src="https://cdn.cuiqingcai.com/p2u8d.png" alt="image-20210705004644681"></p><p>在 HTML 中，我们只能看到在源码中引用了一些 JavaScript 和 CSS 文件，并没有观察到有任何电影数据信息。</p><p>如果遇到这样的情况，这说明我们现在看到的整个页面便是 JavaScript 渲染得到的，浏览器执行了 HTML 中所引用的 JavaScript 文件，JavaScript 通过调用一些数据加载和页面渲染方法，才最终呈现了图中所示的结果。</p><p>在一般情况下，这些数据都是通过 Ajax 来加载的， JavaScript 在后台调用这些 Ajax 数据接口，得到数据之后，再把数据进行解析并渲染呈现出来，得到最终的页面。所以说，要想爬取这个页面，我们可以直接爬取 Ajax 接口获取数据就好了。</p><p>在上一节中，我们已经了解了 Ajax 分析的基本方法，下面我们就来分析一下 Ajax 接口的逻辑并实现数据爬取吧。</p><h2 id="4-爬取列表页"><a href="#4-爬取列表页" class="headerlink" title="4. 爬取列表页"></a><a href="https://cuiqingcai.com/202253.html#4-%E7%88%AC%E5%8F%96%E5%88%97%E8%A1%A8%E9%A1%B5" title="4. 爬取列表页"></a>4. 爬取列表页</h2><p>首先我们来分析一下列表页的 Ajax 接口逻辑，打开浏览器开发者工具，切换到 Network 面板，勾选上 Preserve Log 并切换到 XHR 选项卡，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/dpns6.png" alt="image-20210705004826230"></p><p>接着重新刷新页面，再点击第二页、第三页、第四页的按钮，这时候可以观察到页面上的数据发生了变化，同时开发者工具下方就监听到了几个 Ajax 请求，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/x22b1.png" alt="image-20210705004904893"></p><p>由于我们切换了 4 页，每次翻页也出现了对应的 Ajax 请求，我们可以点击查看其请求详情。观察其请求的 URL 和参数以及响应内容是怎样的，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/1ro2i.png" alt="image-20210705004957327"></p><p>这里我们点开了最后个结果，观察到其 Ajax 接口请求的 URL 地址为：<a href="https://spa1.scrape.center/api/movie/?limit=10&amp;offset=40%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF">https://spa1.scrape.center/api/movie/?limit=10&offset=40，这里有两个参数，一个是</a> <code>limit</code>，这里是 10；一个是 <code>offset</code>，这里也是 40。</p><p>通过多个 Ajax 接口的参数，我们可以观察到这么一个规律：<code>limit</code> 一直为 10，这就正好对应着每页 10 条数据；<code>offset</code> 在依次变大，页面每加 1 页，<code>offset</code> 就加 10，这就代表着页面的数据偏移量，比如第二页的 <code>offset</code> 为 10 则代表着跳过 10 条数据，返回从 11 条数据开始的结果，再加上 <code>limit</code> 的限制，那就是第 11 条至第 20 条数据的结果。</p><p>接着我们再观察一下响应的数据，切换到 Preview 选项卡，结果如图所示：</p><p><img src="https://cdn.cuiqingcai.com/0ldhk.png" alt="image-20210705005115792"></p><p>可以看到，结果就是一些 JSON 数据，它有一个 <code>results</code> 字段，是一个列表，列表中每一个元素都是一个字典。观察一下字典的内容，这里我们正好可以看到有对应的电影数据的字段了，如 <code>name</code>、<code>alias</code>、<code>cover</code>、<code>categories</code>，对比下浏览器中的真实数据，各个内容完全一致，而且这个数据已经非常结构化了，完全就是我们想要爬取的数据，真的是得来全不费工夫。</p><p>这样的话，我们只需要把所有页面的 Ajax 接口构造出来，所有列表页的数据我们都可以轻松获取到了。</p><p>我们先定义一些准备工作，导入一些所需的库并定义一些配置，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>import logging  <br>  <br>logging.basicConfig(level&#x3D;logging.INFO,  <br>                    format&#x3D;’%(asctime)s - %(levelname)s: %(message)s’)  <br>  <br>INDEX_URL &#x3D; ‘<a href="https://spa1.scrape.center/api/movie/?limit=%7Blimit%7D&offset=%7Boffset%7D">https://spa1.scrape.center/api/movie/?limit={limit}&amp;offset={offset}</a>‘</td></tr></tbody></table><p>这里我们引入了 requests 和 logging 库，并定义了 logging 的基本配置，接着我们定义了 <code>INDEX_URL</code>，这里把 <code>limit</code> 和 <code>offset</code> 预留出来了变成了占位符，可以动态传入参数构造一个完整的列表页 URL。</p><p>下面我们来实现一下详情页的爬取。还是和原来一样，我们先定义一个通用的爬取方法，其代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>def scrape_api(url):  <br>    logging.info(‘scraping %s…’, url)  <br>    try:  <br>        response &#x3D; requests.get(url)  <br>        if response.status_code &#x3D;&#x3D; 200:  <br>            return response.json()  <br>        logging.error(‘get invalid status code %s while scraping %s’, response.status_code, url)  <br>    except requests.RequestException:  <br>        logging.error(‘error occurred while scraping %s’, url, exc_info&#x3D;True)</td></tr></tbody></table><p>这里我们定义了一个 <code>scrape_api</code> 方法，和之前不同的是，这个方法专门用来处理 JSON 接口，最后的 <code>response</code> 调用的是 <code>json</code> 方法，它可以解析响应的内容并将其转化成 JSON 字符串。</p><p>接着在这个基础之上，我们定义一个爬取列表页的方法，其代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>LIMIT &#x3D; 10  <br>  <br>def scrape_index(page):  <br>    url &#x3D; INDEX_URL.format(limit&#x3D;LIMIT, offset&#x3D;LIMIT * (page - 1))  <br>    return scrape_api(url)</td></tr></tbody></table><p>这里我们定义了一个 <code>scrape_index</code> 方法，它接收一个参数 <code>page</code>，该参数代表列表页的页码。</p><p>这里我们先构造了一个 <code>url</code>，通过字符串的 <code>format</code> 方法，传入 <code>limit</code> 和 <code>offset</code> 的值。这里 <code>limit</code> 就直接使用了全局变量 <code>LIMIT</code> 的值；<code>offset</code> 则是动态计算的，就是页码数减一再乘以 <code>limit</code>，比如第一页 <code>offset</code> 就是 0，第二页 <code>offset</code> 就是 10，以此类推。构造好了 <code>url</code> 之后，直接调用 <code>scrape_api</code> 方法并返回结果即可。</p><p>这样我们就完成了列表页的爬取，每次请求都会得到一页 10 部的电影数据。</p><p>由于这时爬取到的数据已经是 JSON 类型了，所以我们不用像之前那样去解析 HTML 代码来提取数据了，爬到的数据就是我们想要的结构化数据，因此解析这一步就可以直接省略啦。</p><p>到此为止，我们能成功爬取列表页并提取出电影列表信息了。</p><h2 id="5-爬取详情页"><a href="#5-爬取详情页" class="headerlink" title="5. 爬取详情页"></a><a href="https://cuiqingcai.com/202253.html#5-%E7%88%AC%E5%8F%96%E8%AF%A6%E6%83%85%E9%A1%B5" title="5. 爬取详情页"></a>5. 爬取详情页</h2><p>这时候我们已经可以拿到每一页的电影数据了，但是看看这些数据实际上还缺少了一些我们想要的信息，如剧情简介等信息，所以需要进一步进入到详情页来获取这些内容。</p><p>这时候点击任意一部电影，如《教父》，进入其详情页，这时可以发现页面的 URL 已经变成了 <a href="https://spa1.scrape.center/detail/40">https://spa1.scrape.center/detail/40</a>，页面也成功展示了详情页的信息，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/tuum6.png" alt="image-20210705005243372"></p><p>另外，我们也可以观察到在开发者工具中又出现了一个 Ajax 请求，其 URL 为 <a href="https://spa1.scrape.center/api/movie/40/">https://spa1.scrape.center/api/movie/40/</a>，通过 Preview 选项卡也能看到 Ajax 请求对应响应的信息，如图 所示。</p><p><img src="https://cdn.cuiqingcai.com/y1o4n.png" alt="image-20200601141202684"><br>稍加观察就可以发现，Ajax 请求的 URL 后面有一个参数是可变的，这个参数就是电影的 <code>id</code>，这里是 40，对应《教父》这部电影。</p><p>如果我们想要获取 <code>id</code> 为 50 的电影，只需要把 URL 最后的参数改成 50 即可，即 <a href="https://spa1.scrape.center/api/movie/50/">https://spa1.scrape.center/api/movie/50/</a>，请求这个新的 URL 我们就能获取 <code>id</code> 为 50 的电影所对应的数据了。</p><p>同样，响应结果也是结构化的 JSON 数据，字段也非常规整，我们直接爬取即可。</p><p>现在分析好了详情页的数据提取逻辑，那么怎么和列表页关联起来呢？这个 <code>id</code> 哪里来呢？我们回过头来再看看列表页的接口返回数据，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/bzc8x.png"></p><p>可以看到，列表页原本的返回数据就带了 <code>id</code> 这个字段，所以我们只需要拿列表页结果中的 <code>id</code> 来构造详情页的 Ajax 请求的 URL 就好了。</p><p>接着，我们就先定义一个详情页的爬取逻辑，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>DETAIL_URL &#x3D; ‘<a href="https://spa1.scrape.center/api/movie/%7Bid%7D">https://spa1.scrape.center/api/movie/{id}</a>‘  <br>  <br>def scrape_detail(id):  <br>    url &#x3D; DETAIL_URL.format(id&#x3D;id)  <br>    return scrape_api(url)</td></tr></tbody></table><p>这里我们定义了一个 <code>scrape_detail</code> 方法，它接收一个参数 <code>id</code>。这里的实现也非常简单，先根据定义好的 <code>DETAIL_URL</code> 加 <code>id</code> 构造一个真实的详情页 Ajax 请求的 URL，然后直接调用 <code>scrape_api</code> 方法传入这个 <code>url</code> 即可。</p><p>接着，我们定义一个总的调用方法，将以上方法串联调用起来，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>TOTAL_PAGE &#x3D; 10  <br>  <br>def main():  <br>    for page in range(1, TOTAL_PAGE + 1):  <br>        index_data &#x3D; scrape_index(page)  <br>        for item in index_data.get(‘results’):  <br>            id &#x3D; item.get(‘id’)  <br>            detail_data &#x3D; scrape_detail(id)  <br>            logging.info(‘detail data %s’, detail_data)  <br>  <br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:  <br>    main()</td></tr></tbody></table><p>这里我们定义了一个 <code>main</code> 方法，首先遍历获取了页码 <code>page</code>，然后把 <code>page</code> 当参数传递给了 <code>scrape_index</code> 方法，得到列表页的数据。接着我们遍历每个列表页的每个结果，获取到每部电影的 <code>id</code>，然后把 <code>id</code> 当作参数传递给 <code>scrape_detail</code> 方法来爬取每部电影的详情数据，并将其赋值为 <code>detail_data</code>，输出即可。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>2020-03-19 02:51:55,981 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/?limit=10&offset=0">https://spa1.scrape.center/api/movie/?limit=10&amp;offset=0</a>…  <br>2020-03-19 02:51:56,446 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/1">https://spa1.scrape.center/api/movie/1</a>…  <br>2020-03-19 02:51:56,638 - INFO: detail data {‘id’: 1, ‘name’: ‘霸王别姬’, ‘alias’: ‘Farewell My Concubine’, ‘cover’: ‘<a href="https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c">https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c</a>‘, ‘categories’: [‘剧情’, ‘爱情’], ‘regions’: [‘中国大陆’, ‘中国香港’], ‘actors’: [{‘name’: ‘张国荣’, ‘role’: ‘程蝶衣’, …}, …], ‘directors’: [{‘name’: ‘陈凯歌’, ‘image’: ‘<a href="https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c'%7D]">https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c&#39;}]</a>, ‘score’: 9.5, ‘rank’: 1, ‘minute’: 171, ‘drama’: ‘影片借一出《霸王别姬》的京戏，牵扯出三个人之间一段随时代风云变幻的爱恨情仇。段小楼（张丰毅 饰）与程蝶衣（张国荣 饰）是一对打小一起长大的师兄弟，…’, ‘photos’: […], ‘published_at’: ‘1993-07-26’, ‘updated_at’: ‘2020-03-07T16:31:36.967843Z’}  <br>2020-03-19 02:51:56,640 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/2">https://spa1.scrape.center/api/movie/2</a>…  <br>2020-03-19 02:51:56,813 - INFO: detail data {‘id’: 2, ‘name’: ‘这个杀手不太冷’, ‘alias’: ‘Léon’, ‘cover’: ‘<a href="https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c">https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c</a>‘, ‘categories’: [‘剧情’, ‘动作’, ‘犯罪’], ‘regions’: [‘法国’], ‘actors’: [{‘name’: ‘让·雷诺’, ‘role’: ‘莱昂 Leon’, …}, …], ‘directors’: [{‘name’: ‘吕克·贝松’, ‘image’: ‘<a href="https://p0.meituan.net/movie/0e7d67e343bd3372a714093e8340028d40496.jpg@128w_170h_1e_1c'%7D]">https://p0.meituan.net/movie/0e7d67e343bd3372a714093e8340028d40496.jpg@128w_170h_1e_1c&#39;}]</a>, ‘score’: 9.5, ‘rank’: 3, ‘minute’: 110, ‘drama’: ‘里昂（让·雷诺 饰）是名孤独的职业杀手，受人雇佣。一天，邻居家小姑娘马蒂尔德（纳塔丽·波特曼 饰）敲开他的房门，要求在他那里暂避杀身之祸。…’, ‘photos’: […], ‘published_at’: ‘1994-09-14’, ‘updated_at’: ‘2020-03-07T16:31:43.826235Z’}  <br>…</td></tr></tbody></table><p>由于内容较多，这里省略了部分内容。</p><p>可以看到，其实整个爬取工作就已经完成了，这里会顺次爬取每一页列表页 Ajax 接口，然后去顺次爬取每部电影的详情页 Ajax 接口，打印出每部电影的 Ajax 接口响应数据，而且都是 JSON 格式。这样，所有电影的详情数据都会被我们爬取到啦。</p><h2 id="6-保存数据"><a href="#6-保存数据" class="headerlink" title="6. 保存数据"></a><a href="https://cuiqingcai.com/202253.html#6-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE" title="6. 保存数据"></a>6. 保存数据</h2><p>好，成功提取到详情页信息之后，我们下一步就要把数据保存起来了。在前面我们学习了 MongoDB 的相关操作，接下来我们就把数据保存到 MongoDB 吧。</p><p>在这之前，请确保现在有一个可以正常连接和使用的 MongoDB 数据库，这里我就以本地 localhost 的 M 哦能够 DB 数据库为例来进行操作，其运行在 27017 端口上，无用户名和密码。</p><p>将数据导入 MongoDB 需要用到 PyMongo 这个库。接下来我们把它们引入一下，然后同时定义一下 MongoDB 的连接配置，实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>MONGO_CONNECTION_STRING &#x3D; ‘mongodb:&#x2F;&#x2F;localhost:27017’  <br>MONGO_DB_NAME &#x3D; ‘movies’  <br>MONGO_COLLECTION_NAME &#x3D; ‘movies’  <br>  <br>import pymongo  <br>client &#x3D; pymongo.MongoClient(MONGO_CONNECTION_STRING)  <br>db &#x3D; client[‘movies’]  <br>collection &#x3D; db[‘movies’]</td></tr></tbody></table><p>在这里我们声明了几个变量，介绍如下：</p><ul><li>MONGO_CONNECTION_STRING：MongoDB 的连接字符串，里面定义了 MongoDB 的基本连接信息，如 host、port，还可以定义用户名密码等内容。</li><li>MONGO_DB_NAME：MongoDB 数据库的名称。</li><li>MONGO_COLLECTION_NAME：MongoDB 的集合名称。</li></ul><p>这里我们用 MongoClient 声明了一个连接对象，然后依次声明了存储的数据库和集合。</p><p>接下来，我们再实现一个将数据保存到 MongoDB 的方法，实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>def save_data(data):  <br>    collection.update_one({  <br>        ‘name’: data.get(‘name’)  <br>    }, {  <br>        ‘$set’: data  <br>    }, upsert&#x3D;True)</td></tr></tbody></table><p>在这里我们声明了一个 save_data 方法，它接收一个 data 参数，也就是我们刚才提取的电影详情信息。在方法里面，我们调用了 update_one 方法，第一个参数是查询条件，即根据 name 进行查询；第二个参数就是 data 对象本身，就是所有的数据，这里我们用 <code>$set</code> 操作符表示更新操作；第三个参数很关键，这里实际上是 upsert 参数，如果把这个设置为 True，则可以做到存在即更新，不存在即插入的功能，更新会根据第一个参数设置的 name 字段，所以这样可以防止数据库中出现同名的电影数据。</p><blockquote><p>注：实际上电影可能有同名，但该场景下的爬取数据没有同名情况，当然这里更重要的是实现 MongoDB 的去重操作。</p></blockquote><p>好的，那么接下来 main 方法稍微改写一下就好了，改写如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>def main():  <br>    for page in range(1, TOTAL_PAGE + 1):  <br>        index_data &#x3D; scrape_index(page)  <br>        for item in index_data.get(‘results’):  <br>            id &#x3D; item.get(‘id’)  <br>            detail_data &#x3D; scrape_detail(id)  <br>            logging.info(‘detail data %s’, detail_data)  <br>            save_data(detail_data)  <br>            logging.info(‘data saved successfully’)</td></tr></tbody></table><p>这里就是加了 save_data 方法的调用，并加了一些日志信息。</p><p>重新运行，我们看下输出结果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>2020-03-19 02:51:06,323 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/?limit=10&offset=0">https://spa1.scrape.center/api/movie/?limit=10&amp;offset=0</a>…  <br>2020-03-19 02:51:06,440 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/1">https://spa1.scrape.center/api/movie/1</a>…  <br>2020-03-19 02:51:06,551 - INFO: detail data {‘id’: 1, ‘name’: ‘霸王别姬’, ‘alias’: ‘Farewell My Concubine’, ‘cover’: ‘<a href="https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c">https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c</a>‘, ‘categories’: [‘剧情’, ‘爱情’], ‘regions’: [‘中国大陆’, ‘中国香港’], ‘actors’: [{‘name’: ‘张国荣’, ‘role’: ‘程蝶衣’, ‘image’: ‘<a href="https://p0.meituan.net/movie/5de69a492dcbd3f4b014503d4e95d46c28837.jpg@128w_170h_1e_1c'%7D">https://p0.meituan.net/movie/5de69a492dcbd3f4b014503d4e95d46c28837.jpg@128w_170h_1e_1c&#39;}</a>, …, {‘name’: ‘方征’, ‘role’: ‘嫖客’, ‘image’: ‘<a href="https://p1.meituan.net/movie/39687137b23bc9727b47fd24bdcc579b97618.jpg@128w_170h_1e_1c'%7D]">https://p1.meituan.net/movie/39687137b23bc9727b47fd24bdcc579b97618.jpg@128w_170h_1e_1c&#39;}]</a>, ‘directors’: [{‘name’: ‘陈凯歌’, ‘image’: ‘<a href="https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c'%7D]">https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c&#39;}]</a>, ‘score’: 9.5, ‘rank’: 1, ‘minute’: 171, ‘drama’: ‘影片借一出《霸王别姬》的京戏，牵扯出三个人之间一段随时代风云变幻的爱恨情仇。段小楼（张丰毅 饰）与程蝶衣（张国荣 饰）是一对打小一起长大的师兄弟，两人一个演生，一个饰旦，一向配合天衣无缝，尤其一出《霸王别姬》，更是誉满京城，为此，两人约定合演一辈子《霸王别姬》。但两人对戏剧与人生关系的理解有本质不同，段小楼深知戏非人生，程蝶衣则是人戏不分。段小楼在认为该成家立业之时迎娶了名妓菊仙（巩俐 饰），致使程蝶衣认定菊仙是可耻的第三者，使段小楼做了叛徒，自此，三人围绕一出《霸王别姬》生出的爱恨情仇战开始随着时代风云的变迁不断升级，终酿成悲剧。’, ‘photos’: [‘<a href="https://p0.meituan.net/movie/45be438368bb291e501dc523092f0ac8193424.jpg@106w_106h_1e_1c">https://p0.meituan.net/movie/45be438368bb291e501dc523092f0ac8193424.jpg@106w_106h_1e_1c</a>‘, …, ‘<a href="https://p0.meituan.net/movie/0d952107429db3029b64bf4f25bd762661696.jpg@106w_106h_1e_1c']">https://p0.meituan.net/movie/0d952107429db3029b64bf4f25bd762661696.jpg@106w_106h_1e_1c&#39;]</a>, ‘published_at’: ‘1993-07-26’, ‘updated_at’: ‘2020-03-07T16:31:36.967843Z’}  <br>2020-03-19 02:51:06,583 - INFO: data saved successfully  <br>2020-03-19 02:51:06,583 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/2">https://spa1.scrape.center/api/movie/2</a>…</td></tr></tbody></table><p>由于输出内容较多，这里省略了部分内容。</p><p>我们可以看到这里我们成功爬取到了数据，并且提示了数据存储成功的信息，没有任何报错信息。</p><p>接下来我们使用 Robo 3T 连接 MongoDB 数据库看下爬取的结果，由于我使用的是本地的 MongoDB，所以在 Robo 3T 里面我直接输入 localhost 的连接信息即可，这里请替换成自己的 MongoDB 连接信息，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/imum3.png"></p><p>连接之后我们便可以在 movies 这个数据库，movies 这个集合下看到我们刚才爬取的数据了，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/ammal.png"></p><p>可以看到数据就是以 JSON 格式存储的，一条数据就对应一部电影的信息，各种嵌套信息也一目了然，同时第三列还有数据类型标识。</p><p>这样就证明我们的数据就成功存储到 MongoDB 里了。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><a href="https://cuiqingcai.com/202253.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>本节中我们通过一个案例来体会了 Ajax 分析和爬取的基本流程，希望大家通过本节能够更加熟悉 Ajax 的分析和爬取实现。</p><p>另外，我们也观察到，由于 Ajax 接口大部分返回的是 JSON 数据，所以在一定程度上可以避免一些数据提取的工作，这也在一定程度上减轻了工作量。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/ScrapeSpa1%E3%80%82">https://github.com/Python3WebSpider/ScrapeSpa1。</a></p><h1 id="经典动态渲染工具-Selenium-的使用"><a href="#经典动态渲染工具-Selenium-的使用" class="headerlink" title="# 经典动态渲染工具 Selenium 的使用"></a># 经典动态渲染工具 Selenium 的使用</h1><p>前面我们讲解了 Ajax 的分析方法，利用 Ajax 接口我们可以非常方便地完成数据爬取。只要我们能找到 Ajax 接口的规律，就可以通过某些参数构造出对应的请求，数据自然就能轻松爬取到。</p><p>但是在很多情况下，一些 Ajax 请求的接口通常会包含加密参数，如 <code>token</code>、<code>sign</code> 等，如：<a href="https://spa2.scrape.center/%EF%BC%8C%E5%AE%83%E7%9A%84">https://spa2.scrape.center/，它的</a> Ajax 接口是包含一个 <code>token</code> 参数的，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/y6w4q.png" alt="包含 `token` 参数的 Ajax 接口"></p><p>由于请求接口时必须加上 <code>token</code> 参数，所以我们如果不深入分析找到 <code>token</code> 的构造逻辑，是难以直接模拟这些 Ajax 请求的。</p><p>此时解决方法通常有两种：一种就是深挖其中的逻辑，把其中 <code>token</code> 的构造逻辑完全找出来，再用 Python 复现，构造 Ajax 请求；另外一种方法就是直接通过模拟浏览器的方式来绕过这个过程，因为在浏览器里我们可以看到这个数据，如果能把看到的数据直接爬取下来，当然也就能获取对应的信息了。</p><p>由于第一种方法难度较高，这里我们就先介绍第二种方法：模拟浏览器爬取。</p><p>这里使用的工具为 Selenium，这里就来先了解一下 Selenium 的基本使用方法。</p><p>Selenium 是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些 JavaScript 动态渲染的页面来说，此种抓取方式非常有效。本节中，就让我们来感受一下它的强大之处吧。</p><h2 id="1-准备工作-1"><a href="#1-准备工作-1" class="headerlink" title="1. 准备工作"></a><a href="https://cuiqingcai.com/202261.html#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1. 准备工作"></a>1. 准备工作</h2><p>本节以 Chrome 为例来讲解 Selenium 的用法。在开始之前，请确保已经正确安装好了 Chrome 浏览器并配置好了 ChromeDriver。另外，还需要正确安装好 Python 的 Selenium 库。</p><p>安装方法可以参考：<a href="https://setup.scrape.center/selenium%EF%BC%8C%E5%85%A8%E9%83%A8%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BE%BF%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E6%9C%AC%E8%8A%82%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%86%E3%80%82">https://setup.scrape.center/selenium，全部配置完成之后，我们便可以开始本节的学习了。</a></p><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a><a href="https://cuiqingcai.com/202261.html#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" title="2. 基本用法"></a>2. 基本用法</h2><p>准备工作做好之后，首先来大体看一下 Selenium 的功能。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver.common.by import By  <br>from selenium.webdriver.common.keys import Keys  <br>from selenium.webdriver.support import expected_conditions as EC  <br>from selenium.webdriver.support.wait import WebDriverWait  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>try:  <br>    browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>    input &#x3D; browser.find_element_by_id(‘kw’)  <br>    input.send_keys(‘Python’)  <br>    input.send_keys(Keys.ENTER)  <br>    wait &#x3D; WebDriverWait(browser, 10)  <br>    wait.until(EC.presence_of_element_located((By.ID, ‘content_left’)))  <br>    print(browser.current_url)  <br>    print(browser.get_cookies())  <br>    print(browser.page_source)  <br>finally:  <br>    browser.close()</td></tr></tbody></table><p>运行代码后发现，会自动弹出一个 Chrome 浏览器。浏览器首先会跳转到百度，然后在搜索框中输入 Python，接着跳转到搜索结果页，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/fu94j.png"></p><p>此时在控制台的输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=Python&rsv_pq=c94d0df9000a72d0&rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F+CQ&rqlang=cn&rsv_enter=1&rsv_sug3=6&rsv_sug2=0&inputT=87&rsv_sug4=87">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=Python&amp;rsv_pq=c94d0df9000a72d0&amp;rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F%2BCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=6&amp;rsv_sug2=0&amp;inputT=87&amp;rsv_sug4=87</a>  <br>[{‘secure’: False, ‘value’: ‘B490B5EBF6F3CD402E515D22BCDA1598’, ‘domain’: ‘.baidu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘BDORZ’, ‘expiry’: 1491688071.707553}, {‘secure’: False, ‘value’: ‘22473_1441_21084_17001’, ‘domain’: ‘.baidu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘H_PS_PSSID’}, {‘secure’: False, ‘value’: ‘12883875381399993259_00_0_I_R_2_0303_C02F_N_I_I_0’, ‘domain’: ‘.<a href="http://www.baidu.com/">www.baidu.com</a>‘, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘__bsi’, ‘expiry’: 1491601676.69722}]  <br><!DOCTYPE html><!--STATUS OK-->…</html></td></tr></tbody></table><p>源代码过长，在此省略。可以看到，我们得到的当前 URL、Cookies 和源代码都是浏览器中的真实内容。</p><p>所以说，如果用 Selenium 来驱动浏览器加载网页的话，就可以直接拿到 JavaScript 渲染的结果了，不用担心使用的是什么加密系统。</p><p>下面来详细了解一下 Selenium 的用法。</p><h2 id="3-声明浏览器对象"><a href="#3-声明浏览器对象" class="headerlink" title="3. 声明浏览器对象"></a><a href="https://cuiqingcai.com/202261.html#3-%E5%A3%B0%E6%98%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1" title="3. 声明浏览器对象"></a>3. 声明浏览器对象</h2><p>Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器。我们可以用如下方式初始化：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser &#x3D; webdriver.Firefox()  <br>browser &#x3D; webdriver.Edge()  <br>browser &#x3D; webdriver.Safari()</td></tr></tbody></table><p>这样就完成了浏览器对象的初始化并将其赋值为 <code>browser</code> 对象。接下来，我们要做的就是调用 <code>browser</code> 对象，让其执行各个动作以模拟浏览器操作。</p><h2 id="4-访问页面"><a href="#4-访问页面" class="headerlink" title="4. 访问页面"></a><a href="https://cuiqingcai.com/202261.html#4-%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2" title="4. 访问页面"></a>4. 访问页面</h2><p>我们可以用 <code>get</code> 方法来请求网页，其参数传入链接 URL 即可。比如，这里用 <code>get</code> 方法访问淘宝，然后打印出源代码，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>print(browser.page_source)  <br>browser.close()</td></tr></tbody></table><p>运行后发现，此时弹出了 Chrome 浏览器并且自动访问了淘宝，然后控制台输出了淘宝页面的源代码，随后浏览器关闭。</p><p>通过这几行简单的代码，我们可以实现浏览器的驱动并获取网页源码，非常便捷。</p><h2 id="5-查找节点"><a href="#5-查找节点" class="headerlink" title="5. 查找节点"></a><a href="https://cuiqingcai.com/202261.html#5-%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9" title="5. 查找节点"></a>5. 查找节点</h2><p>Selenium 可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。比如，我们想要完成向某个输入框输入文字的操作，总需要知道这个输入框在哪里吧？而 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便下一步执行一些动作或者提取信息。</p><h3 id="单个节点"><a href="#单个节点" class="headerlink" title="单个节点"></a><a href="https://cuiqingcai.com/202261.html#%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9" title="单个节点"></a>单个节点</h3><p>比如，想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/lwmpo.png" alt="源代码"></p><p>可以发现，它的 <code>id</code> 是 <code>q</code>，<code>name</code> 也是 <code>q</code>。此外，还有许多其他属性，此时我们就可以用多种方式获取它了。比如，<code>find_element_by_name</code> 是根据 <code>name</code> 值获取，<code>find_element_by_id</code> 是根据 <code>id</code> 获取。另外，还有根据 XPath、CSS 选择器等获取的方式。</p><p>下面我们用代码实现一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>input_first &#x3D; browser.find_element_by_id(‘q’)  <br>input_second &#x3D; browser.find_element_by_css_selector(‘#q’)  <br>input_third &#x3D; browser.find_element_by_xpath(‘&#x2F;&#x2F;*[@id&#x3D;”q”]’)  <br>print(input_first, input_second, input_third)  <br>browser.close()</td></tr></tbody></table><p>这里我们使用 3 种方式获取输入框，分别是根据 ID、CSS 选择器和 XPath 获取，它们返回的结果完全一致。运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”5e53d9e1c8646e44c14c1c2880d424af”, element&#x3D;”0.5649563096161541-1”)&gt;  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”5e53d9e1c8646e44c14c1c2880d424af”, element&#x3D;”0.5649563096161541-1”)&gt;  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”5e53d9e1c8646e44c14c1c2880d424af”, element&#x3D;”0.5649563096161541-1”)&gt;</td></tr></tbody></table><p>可以看到，这 3 个节点都是 <code>WebElement</code> 类型，是完全一致的。</p><p>下面列出所有获取单个节点的方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>find_element__id  <br>find_element__name  <br>find_element__xpath  <br>find_element__link_text  <br>find_element__partial_link_text  <br>find_element__tag_name  <br>find_element__class_name  <br>find_element__css_selector</td></tr></tbody></table><p>另外，Selenium 还提供了通用方法 <code>find_element</code>，它需要传入两个参数：查找方式 <code>By</code> 和值。实际上，它就是 <code>find_element_by_id</code> 这种方法的通用函数版本，比如 <code>find_element_by_id(id)</code> 就等价于 <code>find_element(By.ID, id)</code>，二者得到的结果完全一致。我们用代码实现一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver.common.by import By  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>input_first &#x3D; browser.find_element(By.ID, ‘q’)  <br>print(input_first)  <br>browser.close()</td></tr></tbody></table><p>实际上，这种查找方式的功能和上面列举的查找函数完全一致，不过参数更加灵活。</p><h3 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a><a href="https://cuiqingcai.com/202261.html#%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9" title="多个节点"></a>多个节点</h3><p>如果查找的目标在网页中只有一个，那么完全可以用 <code>find_element</code> 方法。但如果有多个节点，再用 <code>find_element</code> 方法查找，就只能得到第一个节点了。如果要查找所有满足条件的节点，需要用 <code>find_elements</code> 这样的方法。注意，在这个方法的名称中，element 多了一个 s，注意区分。</p><p>比如，要查找淘宝左侧导航条的所有条目，就可以这样来实现：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>lis &#x3D; browser.find_elements_by_css_selector(‘.service-bd li’)  <br>print(lis)  <br>browser.close()</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-1”)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-2”)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-3”)&gt;…&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-16”)&gt;]</td></tr></tbody></table><p>这里简化了输出结果，中间部分省略。</p><p>可以看到，得到的内容变成了列表类型，列表中的每个节点都是 <code>WebElement</code> 类型。</p><p>也就是说，如果我们用 <code>find_element</code> 方法，只能获取匹配的第一个节点，结果是 <code>WebElement</code> 类型。如果用 <code>find_elements</code> 方法，则结果是列表类型，列表中的每个节点都是 <code>WebElement</code> 类型。</p><p>这里列出所有获取多个节点的方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>find_elements_by_id  <br>find_elements_by_name  <br>find_elements_by_xpath  <br>find_elements_by_link_text  <br>find_elements_by_partial_link_text  <br>find_elements_by_tag_name  <br>find_elements_by_class_name  <br>find_elements_by_css_selector</td></tr></tbody></table><p>当然，我们也可以直接用 <code>find_elements</code> 方法来选择，这时可以这样写：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>lis &#x3D; browser.find_elements(By.CSS_SELECTOR, ‘.service-bd li’)</td></tr></tbody></table><p>结果是完全一致的。</p><h2 id="6-节点交互"><a href="#6-节点交互" class="headerlink" title="6. 节点交互"></a><a href="https://cuiqingcai.com/202261.html#6-%E8%8A%82%E7%82%B9%E4%BA%A4%E4%BA%92" title="6. 节点交互"></a>6. 节点交互</h2><p>Selenium 可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用 <code>send_keys</code> 方法，清空文字时用 <code>clear</code> 方法，点击按钮时用 <code>click</code> 方法。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>import time  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>input &#x3D; browser.find_element_by_id(‘q’)  <br>input.send_keys(‘iPhone’)  <br>time.sleep(1)  <br>input.clear()  <br>input.send_keys(‘iPad’)  <br>button &#x3D; browser.find_element_by_class_name(‘btn-search’)  <br>button.click()</td></tr></tbody></table><p>这里首先驱动浏览器打开淘宝，然后用 <code>find_element_by_id</code> 方法获取输入框，然后用 <code>send_keys</code> 方法输入 iPhone 文字，等待一秒后用 <code>clear</code> 方法清空输入框，再次调用 <code>send_keys</code> 方法输入 iPad 文字，之后再用 <code>find_element_by_class_name</code> 方法获取搜索按钮，最后调用 <code>click</code> 方法完成搜索动作。</p><p>通过上面的方法，我们完成了一些常见节点的操作，更多的操作可以参见官方文档的交互动作介绍 ：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement。</a></p><h2 id="7-动作链"><a href="#7-动作链" class="headerlink" title="7. 动作链"></a><a href="https://cuiqingcai.com/202261.html#7-%E5%8A%A8%E4%BD%9C%E9%93%BE" title="7. 动作链"></a>7. 动作链</h2><p>在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按钮，就调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。</p><p>比如，现在实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处，可以这样实现：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver import ActionChains  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable">http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable</a>‘  <br>browser.get(url)  <br>browser.switch_to.frame(‘iframeResult’)  <br>source &#x3D; browser.find_element_by_css_selector(‘#draggable’)  <br>target &#x3D; browser.find_element_by_css_selector(‘#droppable’)  <br>actions &#x3D; ActionChains(browser)  <br>actions.drag_and_drop(source, target)  <br>actions.perform()</td></tr></tbody></table><p>首先，打开网页中的一个拖曳实例，然后依次选中要拖曳的节点和拖曳到的目标节点，接着声明 <code>ActionChains</code> 对象并将其赋值为 <code>actions</code> 变量，然后通过调用 <code>actions</code> 变量的 <code>drag_and_drop</code> 方法，再调用 <code>perform</code> 方法执行动作，此时就完成了拖曳操作，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/7650u.jpg" alt="拖曳前页面"></p><p><img src="https://cdn.cuiqingcai.com/z8xjy.jpg" alt="拖曳后页面"></p><p>更多的动作链操作可以参考官方文档的动作链介绍：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains。</a></p><h2 id="8-执行-JavaScript"><a href="#8-执行-JavaScript" class="headerlink" title="8. 执行 JavaScript"></a><a href="https://cuiqingcai.com/202261.html#8-%E6%89%A7%E8%A1%8C-JavaScript" title="8. 执行 JavaScript"></a>8. 执行 JavaScript</h2><p>对于某些操作，Selenium API 并没有提供。比如，下拉进度条，它可以直接模拟运行 JavaScript，此时使用 <code>execute_script</code> 方法即可实现，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.zhihu.com/explore">https://www.zhihu.com/explore</a>‘)  <br>browser.execute_script(‘window.scrollTo(0, document.body.scrollHeight)’)  <br>browser.execute_script(‘alert(“To Bottom”)’)</td></tr></tbody></table><p>这里就利用 <code>execute_script</code> 方法将进度条下拉到最底部，然后弹出 alert 提示框。</p><p>所以说有了这个方法，基本上 API 没有提供的所有功能都可以用执行 JavaScript 的方式来实现了。</p><h2 id="9-获取节点信息"><a href="#9-获取节点信息" class="headerlink" title="9. 获取节点信息"></a><a href="https://cuiqingcai.com/202261.html#9-%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF" title="9. 获取节点信息"></a>9. 获取节点信息</h2><p>前面说过，通过 <code>page_source</code> 属性可以获取网页的源代码，接着就可以使用解析库（如正则表达式、Beautiful Soup、pyquery 等）来提取信息了。</p><p>不过，既然 Selenium 已经提供了选择节点的方法，返回的是 <code>WebElement</code> 类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，我们就可以不用通过解析源代码来提取信息了，非常方便。</p><p>接下来，我们就来看看怎样获取节点信息吧。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a><a href="https://cuiqingcai.com/202261.html#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7" title="获取属性"></a>获取属性</h3><p>我们可以使用 <code>get_attribute</code> 方法来获取节点的属性，但是其前提是先选中这个节点，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘  <br>browser.get(url)  <br>logo &#x3D; browser.find_element_by_class_name(‘logo-image’)  <br>print(logo)  <br>print(logo.get_attribute(‘src’))</td></tr></tbody></table><p>运行之后，程序便会驱动浏览器打开该页面，然后获取 <code>class</code> 为 <code>logo-image</code> 的节点，最后打印出它的 <code>src</code>。</p><p>控制台的输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”7f4745d35a104759239b53f68a6f27d0”, element&#x3D;”cd7c72b4-4920-47ed-91c5-ea06601dc509”)&gt;  <br><a href="https://spa2.scrape.center/img/logo.a508a8f0.png">https://spa2.scrape.center/img/logo.a508a8f0.png</a></td></tr></tbody></table><p>通过 <code>get_attribute</code> 方法，然后传入想要获取的属性名，就可以得到它的值了。</p><h3 id="获取文本值"><a href="#获取文本值" class="headerlink" title="获取文本值"></a><a href="https://cuiqingcai.com/202261.html#%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%80%BC" title="获取文本值"></a>获取文本值</h3><p>每个 <code>WebElement</code> 节点都有 <code>text</code> 属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于 pyquery 的 <code>text</code> 方法，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘  <br>browser.get(url)  <br>input &#x3D; browser.find_element_by_class_name(‘logo-title’)  <br>print(input.text)</td></tr></tbody></table><p>这里依然先打开页面，然后获取 <code>class</code> 为 <code>logo-title</code> 这个节点，再将其文本值打印出来。</p><p>控制台的输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Scrape</td></tr></tbody></table><h3 id="获取-ID、位置、标签名和大小"><a href="#获取-ID、位置、标签名和大小" class="headerlink" title="获取 ID、位置、标签名和大小"></a><a href="https://cuiqingcai.com/202261.html#%E8%8E%B7%E5%8F%96-ID%E3%80%81%E4%BD%8D%E7%BD%AE%E3%80%81%E6%A0%87%E7%AD%BE%E5%90%8D%E5%92%8C%E5%A4%A7%E5%B0%8F" title="获取 ID、位置、标签名和大小"></a>获取 ID、位置、标签名和大小</h3><p>另外，<code>WebElement</code> 节点还有一些其他属性，比如 <code>id</code> 属性可以获取节点 ID，<code>location</code> 属性可以获取该节点在页面中的相对位置，<code>tag_name</code> 属性可以获取标签名称，<code>size</code> 属性可以获取节点的大小，也就是宽高，这些属性有时候还是很有用的。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘  <br>browser.get(url)  <br>input &#x3D; browser.find_element_by_class_name(‘logo-title’)  <br>print(input.id)  <br>print(input.location)  <br>print(input.tag_name)  <br>print(input.size)</td></tr></tbody></table><p>这里首先获得 <code>class</code> 为 <code>logo-title</code> 这个节点，然后调用其 <code>id</code>、<code>location</code>、<code>tag_name</code>、<code>size</code> 属性来获取对应的属性值。</p><h2 id="10-切换-Frame"><a href="#10-切换-Frame" class="headerlink" title="10. 切换 Frame"></a><a href="https://cuiqingcai.com/202261.html#10-%E5%88%87%E6%8D%A2-Frame" title="10. 切换 Frame"></a>10. 切换 Frame</h2><p>我们知道网页中有一种节点叫作 iframe，也就是子 Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。Selenium 打开页面后，它默认是在父级 Frame 里面操作，而此时如果页面中还有子 Frame，它是不能获取到子 Frame 里面的节点的。这时就需要使用 <code>switch_to.frame</code> 方法来切换 Frame。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import time  <br>from selenium import webdriver  <br>from selenium.common.exceptions import NoSuchElementException  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable">http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable</a>‘  <br>browser.get(url)  <br>browser.switch_to.frame(‘iframeResult’)  <br>try:  <br>    logo &#x3D; browser.find_element_by_class_name(‘logo’)  <br>except NoSuchElementException:  <br>    print(‘NO LOGO’)  <br>browser.switch_to.parent_frame()  <br>logo &#x3D; browser.find_element_by_class_name(‘logo’)  <br>print(logo)  <br>print(logo.text)</td></tr></tbody></table><p>控制台输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>NO LOGO  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”4bb8ac03ced4ecbdefef03ffdc0e4ccd”, element&#x3D;”0.13792611320464965-2”)&gt;  <br>RUNOOB.COM</td></tr></tbody></table><p>这里还是以前面演示动作链操作的网页为实例，首先通过 <code>switch_to.frame</code> 方法切换到子 Frame 里面，然后尝试获取子 Frame 里的 logo 节点（这是找不到的），如果找不到的话，就会抛出 <code>NoSuchElementException</code> 异常，异常被捕捉之后，就会输出 <code>NO LOGO</code>。接下来，重新切换回父级 Frame，然后再次重新获取节点，发现此时可以成功获取了。</p><p>所以，当页面中包含子 Frame 时，如果想获取子 Frame 中的节点，需要先调用 <code>switch_to.frame</code> 方法切换到对应的 Frame，然后再进行操作。</p><h2 id="11-延时等待"><a href="#11-延时等待" class="headerlink" title="11. 延时等待"></a><a href="https://cuiqingcai.com/202261.html#11-%E5%BB%B6%E6%97%B6%E7%AD%89%E5%BE%85" title="11. 延时等待"></a>11. 延时等待</h2><p>在 Selenium 中，<code>get</code> 方法会在网页框架加载结束后结束执行，此时如果获取 <code>page_source</code>，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的 Ajax 请求，我们在网页源代码中也不一定能成功获取到。所以，这里需要延时等待一定时间，确保节点已经加载出来。</p><p>这里等待方式有两种：一种是隐式等待，一种是显式等待。</p><h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a><a href="https://cuiqingcai.com/202261.html#%E9%9A%90%E5%BC%8F%E7%AD%89%E5%BE%85" title="隐式等待"></a>隐式等待</h3><p>当使用隐式等待执行测试的时候，如果 Selenium 没有在 DOM 中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，当查找节点而节点并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.implicitly_wait(10)  <br>browser.get(‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘)  <br>input &#x3D; browser.find_element_by_class_name(‘logo-image’)  <br>print(input)</td></tr></tbody></table><p>这里我们用 <code>implicitly_wait</code> 方法实现了隐式等待。</p><h3 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a><a href="https://cuiqingcai.com/202261.html#%E6%98%BE%E5%BC%8F%E7%AD%89%E5%BE%85" title="显式等待"></a>显式等待</h3><p>隐式等待的效果其实并没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响。</p><p>这里还有一种更合适的显式等待方法，它指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver.common.by import By  <br>from selenium.webdriver.support.ui import WebDriverWait  <br>from selenium.webdriver.support import expected_conditions as EC  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com/</a>‘)  <br>wait &#x3D; WebDriverWait(browser, 10)  <br>input &#x3D; wait.until(EC.presence_of_element_located((By.ID, ‘q’)))  <br>button &#x3D; wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, ‘.btn-search’)))  <br>print(input, button)</td></tr></tbody></table><p>这里首先引入 <code>WebDriverWait</code> 这个对象，指定最长等待时间，然后调用它的 <code>until</code>方法，传入等待条件 <code>expected_conditions</code>。比如，这里传入了 <code>presence_of_element_located</code> 这个条件，代表节点出现的意思，其参数是节点的定位元组，也就是 ID 为 <code>q</code> 的节点搜索框。</p><p>这样可以做到的效果就是，在 10 秒内如果 ID 为 <code>q</code> 的节点（即搜索框）成功加载出来，就返回该节点；如果超过 10 秒还没有加载出来，就抛出异常。</p><p>对于按钮，可以更改一下等待条件，比如改为 <code>element_to_be_clickable</code>，也就是可点击，所以查找按钮时查找 CSS 选择器为 <code>.btn-search</code> 的按钮，如果 10 秒内它是可点击的，也就是成功加载出来了，就返回这个按钮节点；如果超过 10 秒还不可点击，也就是没有加载出来，就抛出异常。</p><p>运行代码，在网速较佳的情况下是可以成功加载出来的。</p><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”07dd2fbc2d5b1ce40e82b9754aba8fa8”, element&#x3D;”0.5642646294074107-1”)&gt;  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”07dd2fbc2d5b1ce40e82b9754aba8fa8”, element&#x3D;”0.5642646294074107-2”)&gt;</td></tr></tbody></table><p>可以看到，控制台成功输出了两个节点，它们都是 <code>WebElement</code> 类型。</p><p>如果网络有问题，10 秒内没有成功加载，那就抛出 <code>TimeoutException</code> 异常，此时控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>TimeoutException Traceback (most recent call last)  <br><ipython-input-4-f3d73973b223> in <module>()  <br>      7 browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com/</a>‘)  <br>      8 wait &#x3D; WebDriverWait(browser, 10)  <br>—-&gt; 9 input &#x3D; wait.until(EC.presence_of_element_located((By.ID, ‘q’)))</td></tr></tbody></table><p>关于等待条件，其实还有很多，比如判断标题内容，判断某个节点内是否出现了某文字等。下表列出了所有的等待条件。</p><table><thead><tr><th>等待条件</th><th>含义</th></tr></thead><tbody><tr><td><code>title_is</code></td><td>标题是某内容</td></tr><tr><td><code>title_contains</code></td><td>标题包含某内容</td></tr><tr><td><code>presence_of_element_located</code></td><td>节点加载出来，传入定位元组，如 <code>(By.ID, &#39;p&#39;)</code></td></tr><tr><td><code>visibility_of_element_located</code></td><td>节点可见，传入定位元组</td></tr><tr><td><code>visibility_of</code></td><td>可见，传入节点对象</td></tr><tr><td><code>presence_of_all_elements_located</code></td><td>所有节点加载出来</td></tr><tr><td><code>text_to_be_present_in_element</code></td><td>某个节点文本包含某文字</td></tr><tr><td><code>text_to_be_present_in_element_value</code></td><td>某个节点值包含某文字</td></tr><tr><td><code>frame_to_be_available_and_switch_to_it frame</code></td><td>加载并切换</td></tr><tr><td><code>invisibility_of_element_located</code></td><td>节点不可见</td></tr><tr><td><code>element_to_be_clickable</code></td><td>节点可点击</td></tr><tr><td><code>staleness_of</code></td><td>判断一个节点是否仍在 DOM，可判断页面是否已经刷新</td></tr><tr><td><code>element_to_be_selected</code></td><td>节点可选择，传入节点对象</td></tr><tr><td><code>element_located_to_be_selected</code></td><td>节点可选择，传入定位元组</td></tr><tr><td><code>element_selection_state_to_be</code></td><td>传入节点对象以及状态，相等返回 <code>True</code>，否则返回 <code>False</code></td></tr><tr><td><code>element_located_selection_state_to_be</code></td><td>传入定位元组以及状态，相等返回 <code>True</code>，否则返回 <code>False</code></td></tr><tr><td><code>alert_is_present</code></td><td>是否出现 Alert</td></tr></tbody></table><p>更多等待条件的参数及用法介绍可以参考官方文档：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions。</a></p><h2 id="12-前进后退"><a href="#12-前进后退" class="headerlink" title="12. 前进后退"></a><a href="https://cuiqingcai.com/202261.html#12-%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80" title="12. 前进后退"></a>12. 前进后退</h2><p>平常使用浏览器时，都有前进和后退功能，Selenium 也可以完成这个操作，它使用 <code>back</code> 方法后退，使用 <code>forward</code> 方法前进。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import time  <br>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com/</a>‘)  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com/</a>‘)  <br>browser.get(‘<a href="https://www.python.org/">https://www.python.org/</a>‘)  <br>browser.back()  <br>time.sleep(1)  <br>browser.forward()  <br>browser.close()</td></tr></tbody></table><p>这里我们连续访问 3 个页面，然后调用 <code>back</code> 方法回到第二个页面，接下来再调用 <code>forward</code> 方法又可以前进到第三个页面。</p><h2 id="13-Cookies"><a href="#13-Cookies" class="headerlink" title="13. Cookies"></a><a href="https://cuiqingcai.com/202261.html#13-Cookies" title="13. Cookies"></a>13. Cookies</h2><p>使用 Selenium，还可以方便地对 Cookies 进行操作，例如获取、添加、删除 Cookies 等。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.zhihu.com/explore">https://www.zhihu.com/explore</a>‘)  <br>print(browser.get_cookies())  <br>browser.add_cookie({‘name’: ‘name’, ‘domain’: ‘<a href="http://www.zhihu.com/">www.zhihu.com</a>‘, ‘value’: ‘germey’})  <br>print(browser.get_cookies())  <br>browser.delete_all_cookies()  <br>print(browser.get_cookies())</td></tr></tbody></table><p>首先，我们访问了知乎。加载完成后，浏览器实际上已经生成 Cookies 了。接着，调用 <code>get_cookies</code> 方法获取所有的 Cookies。然后，我们添加一个 Cookie，这里传入一个字典，有 <code>name</code>、<code>domain</code> 和 <code>value</code> 等内容。接下来，再次获取所有的 Cookies。可以发现，结果就多了这一项新加的 Cookie。最后，调用 <code>delete_all_cookies</code> 方法删除所有的 Cookies。再重新获取，发现结果就为空了。</p><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[{‘secure’: False, ‘value’: ‘“NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY&#x3D;|1491604091|236e34290a6f407bfbb517888849ea509ac366d0”‘, ‘domain’: ‘.zhihu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘l_cap_id’, ‘expiry’: 1494196091.403418}, …]  <br>[{‘secure’: False, ‘value’: ‘germey’, ‘domain’: ‘.<a href="http://www.zhihu.com/">www.zhihu.com</a>‘, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘name’}, {‘secure’: False, ‘value’: ‘“NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY&#x3D;|1491604091|236e34290a6f407bfbb517888849ea509ac366d0”‘, ‘domain’: ‘.zhihu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘l_cap_id’, ‘expiry’: 1494196091.403418}, …]  <br>[]</td></tr></tbody></table><p>通过以上方法来操作 Cookies 还是非常方便的。</p><h2 id="14-选项卡管理"><a href="#14-选项卡管理" class="headerlink" title="14. 选项卡管理"></a><a href="https://cuiqingcai.com/202261.html#14-%E9%80%89%E9%A1%B9%E5%8D%A1%E7%AE%A1%E7%90%86" title="14. 选项卡管理"></a>14. 选项卡管理</h2><p>在访问网页的时候，会开启一个个选项卡。在 Selenium 中，我们也可以对选项卡进行操作。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import time  <br>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>browser.execute_script(‘window.open()’)  <br>print(browser.window_handles)  <br>browser.switch_to.window(browser.window_handles[1])  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>time.sleep(1)  <br>browser.switch_to.window(browser.window_handles[0])  <br>browser.get(‘<a href="https://python.org/">https://python.org</a>‘)</td></tr></tbody></table><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[‘CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435’, ‘CDwindow-6e05f076-6d77-453a-a36c-32baacc447df’]</td></tr></tbody></table><p>这里首先访问了百度，然后调用了 <code>execute_script</code> 方法，这里传入 <code>window.open</code>这个 JavaScript 语句新开启一个选项卡。接下来，我们想切换到该选项卡。这里调用 <code>window_handles</code> 属性获取当前开启的所有选项卡，返回的是选项卡的代号列表。要想切换选项卡，只需要调用 <code>switch_to.window</code> 方法即可，其中参数是选项卡的代号。这里我们将第二个选项卡代号传入，即跳转到第二个选项卡，接下来在第二个选项卡下打开一个新页面，然后切换回第一个选项卡重新调用 <code>switch_to.window</code> 方法，再执行其他操作即可。</p><h2 id="15-异常处理"><a href="#15-异常处理" class="headerlink" title="15. 异常处理"></a><a href="https://cuiqingcai.com/202261.html#15-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" title="15. 异常处理"></a>15. 异常处理</h2><p>在使用 Selenium 的过程中，难免会遇到一些异常，例如超时、节点未找到等错误，一旦出现此类错误，程序便不会继续运行了。这里我们可以使用 <code>try except</code> 语句来捕获各种异常。</p><p>首先，演示一下节点未找到的异常，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>browser.find_element_by_id(‘hello’)</td></tr></tbody></table><p>这里首先打开百度页面，然后尝试选择一个并不存在的节点，此时就会遇到异常。</p><p>运行之后控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>NoSuchElementException Traceback (most recent call last)  <br><ipython-input-23-978945848a1b> in <module>()  <br>      3 browser &#x3D; webdriver.Chrome()  <br>      4 browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>—-&gt; 5 browser.find_element_by_id(‘hello’)</td></tr></tbody></table><p>可以看到，这里抛出了 <code>NoSuchElementException</code> 异常，这通常是节点未找到的异常。为了防止程序遇到异常而中断，我们需要捕获这些异常，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.common.exceptions import TimeoutException, NoSuchElementException  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>try:  <br>    browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>except TimeoutException:  <br>    print(‘Time Out’)  <br>try:  <br>    browser.find_element_by_id(‘hello’)  <br>except NoSuchElementException:  <br>    print(‘No Element’)  <br>finally:  <br>    browser.close()</td></tr></tbody></table><p>这里我们使用 <code>try except</code> 来捕获各类异常。比如，我们对 <code>find_element_by_id</code>查找节点的方法捕获 <code>NoSuchElementException</code> 异常，这样一旦出现这样的错误，就进行异常处理，程序也不会中断了。</p><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>No Element</td></tr></tbody></table><p>关于更多的异常类，可以参考官方文档：：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions。</a></p><h2 id="16-反屏蔽"><a href="#16-反屏蔽" class="headerlink" title="16. 反屏蔽"></a><a href="https://cuiqingcai.com/202261.html#16-%E5%8F%8D%E5%B1%8F%E8%94%BD" title="16. 反屏蔽"></a>16. 反屏蔽</h2><p>现在很多网站都加上了对 Selenium 的检测，来防止一些爬虫的恶意爬取。即如果检测到有人在使用 Selenium 打开浏览器，那就直接屏蔽。</p><p>在大多数情况下，检测的基本原理是检测当前浏览器窗口下的 <code>window.navigator</code> 对象是否包含 <code>webdriver</code> 这个属性。因为在正常使用浏览器的情况下，这个属性是 <code>undefined</code>，然而一旦我们使用了 Selenium，Selenium 会给 <code>window.navigator</code> 设置 <code>webdriver</code> 属性。很多网站就通过 JavaScript 判断如果 <code>webdriver</code> 属性存在，那就直接屏蔽。</p><p>这边有一个典型的案例网站：<a href="https://antispider1.scrape.center/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%B0%B1%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%8A%E8%BF%B0%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%BA%86">https://antispider1.scrape.center/，这个网站就使用了上述原理实现了</a> WebDriver 的检测，如果使用 Selenium 直接爬取的话，那就会返回如图所示的页面。</p><p><img src="https://cdn.cuiqingcai.com/l13mw.png" alt="image-20210705014022028"></p><p>这时候我们可能想到直接使用 JavaScript 语句把这个 <code>webdriver</code> 属性置空，比如通过调用 <code>execute_script</code> 方法来执行如下代码：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Object.defineProperty(navigator, “webdriver”, { get: () &#x3D;&gt; undefined });</td></tr></tbody></table><p>这行 JavaScript 语句的确可以把 <code>webdriver</code> 属性置空，但是 <code>execute_script</code> 调用这行 JavaScript 语句实际上是在页面加载完毕之后才执行的，执行太晚了，网站早在最初页面渲染之前就已经对 <code>webdriver</code> 属性进行了检测，所以用上述方法并不能达到效果。</p><p>在 Selenium 中，我们可以使用 CDP（即 Chrome Devtools-Protocol，Chrome 开发工具协议）来解决这个问题，通过它我们可以实现在每个页面刚加载的时候执行 JavaScript 代码，执行的 CDP 方法叫作 <code>Page.addScriptToEvaluateOnNewDocument</code>，然后传入上文的 JavaScript 代码即可，这样我们就可以在每次页面加载之前将 <code>webdriver</code> 属性置空了。另外，我们还可以加入几个选项来隐藏 WebDriver 提示条和自动化扩展信息，代码实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver import ChromeOptions  <br>  <br>option &#x3D; ChromeOptions()  <br>option.add_experimental_option(‘excludeSwitches’, [‘enable-automation’])  <br>option.add_experimental_option(‘useAutomationExtension’, False)  <br>browser &#x3D; webdriver.Chrome(options&#x3D;option)  <br>browser.execute_cdp_cmd(‘Page.addScriptToEvaluateOnNewDocument’, {  <br>    ‘source’: ‘Object.defineProperty(navigator, “webdriver”, {get: () &#x3D;&gt; undefined})’  <br>})  <br>browser.get(‘<a href="https://antispider1.scrape.center/">https://antispider1.scrape.center/</a>‘)</td></tr></tbody></table><p>这样整个页面就能被加载出来了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/tywxa.png"></p><p>对于大多数情况，以上方法均可以实现 Selenium 反屏蔽。但对于一些特殊网站，如果它有更多的 WebDriver 特征检测，可能需要具体排查。</p><h2 id="17-无头模式"><a href="#17-无头模式" class="headerlink" title="17. 无头模式"></a><a href="https://cuiqingcai.com/202261.html#17-%E6%97%A0%E5%A4%B4%E6%A8%A1%E5%BC%8F" title="17. 无头模式"></a>17. 无头模式</h2><p>我们可以观察到，上面的案例在运行的时候，总会弹出一个浏览器窗口，虽然有助于观察页面爬取状况，但在有时候窗口弹来弹去也会形成一些干扰。</p><p>Chrome 浏览器从 60 版本已经支持了无头模式，即 Headless。无头模式在运行的时候不会再弹出浏览器窗口，减少了干扰，而且它减少了一些资源的加载，如图片等，所以也在一定程度上节省了资源加载时间和网络带宽。</p><p>我们可以借助于 ChromeOptions 来开启 Chrome Headless 模式，代码实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver import ChromeOptions  <br>  <br>option &#x3D; ChromeOptions()  <br>option.add_argument(‘–headless’)  <br>browser &#x3D; webdriver.Chrome(options&#x3D;option)  <br>browser.set_window_size(1366, 768)  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>browser.get_screenshot_as_file(‘preview.png’)</td></tr></tbody></table><p>这里我们通过 ChromeOptions 的 <code>add_argument</code> 方法添加了一个参数 <code>--headless</code>，开启了无头模式。在无头模式下，我们最好设置一下窗口的大小，接着打开页面，最后我们调用 <code>get_screenshot_as_file</code> 方法输出了页面的截图。</p><p>运行代码之后，我们发现 Chrome 窗口就不会再弹出来了，代码依然正常运行，最后输出的页面如图所示。</p><p><img src="https://cdn.cuiqingcai.com/8h0oa.png" alt="输出的页面"></p><p>这样我们就在无头模式下完成了页面的抓取和截图操作。</p><h2 id="18-总结"><a href="#18-总结" class="headerlink" title="18. 总结"></a><a href="https://cuiqingcai.com/202261.html#18-%E6%80%BB%E7%BB%93" title="18. 总结"></a>18. 总结</h2><p>现在，我们基本上对 Selenium 的常规用法有了大体的了解。使用 Selenium，处理 JavaScript 渲染的页面不再是难事，后面我们会用一个实例来演示 Selenium 爬取网站的流程。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/SeleniumTest%E3%80%82">https://github.com/Python3WebSpider/SeleniumTest。</a></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax内容爬取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言代码集</title>
    <link href="/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E9%9B%86/"/>
    <url>/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-代码集date-2020-03-29-19-35-14tags-竞赛categories-技术"><a href="#title-代码集date-2020-03-29-19-35-14tags-竞赛categories-技术" class="headerlink" title="title: 代码集date: 2020-03-29 19:35:14tags:- 竞赛categories: 技术"></a>title: 代码集<br>date: 2020-03-29 19:35:14<br>tags:<br>- 竞赛<br>categories: 技术</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>博主我隔离期间实在无聊于是无聊到整理代码模版</p><p>从入门到放弃</p><span id="more"></span><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="输入类"><a href="#输入类" class="headerlink" title="输入类"></a>输入类</h3><p>读入优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&gt;<span class="hljs-string">&#x27;9&#x27;</span>||c&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>高精度真的是mol鬼，到现在听到要打高精度觉得自己还是打不出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bign</span> &#123;<br><span class="hljs-type">int</span> len, s[mx];<span class="hljs-comment">//高精度长度和存放数值</span><br><span class="hljs-built_in">bign</span>() &#123; <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(s)),len=<span class="hljs-number">1</span>;&#125; <span class="hljs-comment">//构造函数初始化</span><br><span class="hljs-built_in">bign</span> (<span class="hljs-type">int</span> num) &#123; *<span class="hljs-keyword">this</span> = num; &#125;<span class="hljs-comment">//低精度赋值</span><br><span class="hljs-built_in">bign</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *num) &#123; *<span class="hljs-keyword">this</span> = num; &#125; <span class="hljs-comment">//字符串赋值</span><br>bign <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> <span class="hljs-type">int</span> num) &#123;<span class="hljs-comment">//低精度转换成高精度</span><br><span class="hljs-type">char</span> st[mx]; <span class="hljs-built_in">sprintf</span>(st,<span class="hljs-string">&quot;%d&quot;</span>,num);<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>=st;<br>&#125;<br>bign <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *num) &#123;<span class="hljs-comment">//将字符串转成高精度值</span><br>len=<span class="hljs-built_in">strlen</span>(num);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) s[i]=num[len-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//清除高位 0</span><br><span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">1</span> &amp;&amp; s[len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>) len--;<br>&#125;<br>bign <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> bign &amp;b) &#123; <span class="hljs-comment">//重载运算符 +</span><br><span class="hljs-type">int</span> l=<span class="hljs-built_in">max</span>(len,b.len),i;<br>bign c;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;l; i++) &#123;<br>c.s[i]+=(s[i]+b.s[i]);<span class="hljs-comment">//当前位</span><br>c.s[i<span class="hljs-number">+1</span>]+=c.s[i]/<span class="hljs-number">10</span>;<span class="hljs-comment">//进位位</span><br>c.s[i]%=<span class="hljs-number">10</span>;<span class="hljs-comment">//调整本位</span><br>&#125;<br>c.len=l<span class="hljs-number">+1</span>;<br>c.<span class="hljs-built_in">clean</span>();<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>bign <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> bign &amp;x) &#123;<span class="hljs-comment">//重载运算符-</span><br>bign c=*<span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br><span class="hljs-keyword">if</span>(x.s[i]&gt;c.s[i]) &#123;<br>c.s[i<span class="hljs-number">+1</span>]--;<span class="hljs-comment">//从前借一位</span><br>c.s[i]+=<span class="hljs-number">10</span>;<span class="hljs-comment">//当前位加10</span><br>&#125;<br>c.s[i]-=x.s[i];<span class="hljs-comment">//直接减</span><br>&#125;<br>c.<span class="hljs-built_in">clean</span>();<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>bign <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> bign &amp;b) &#123;<span class="hljs-comment">//重载运算符*</span><br>bign c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;b.len; j++) &#123;<br>c.s[i+j]+=s[i]*b.s[j];<span class="hljs-comment">//本位</span><br>c.s[i+j<span class="hljs-number">+1</span>]+=c.s[i+j]/<span class="hljs-number">10</span>;<span class="hljs-comment">//进位</span><br>c.s[i+j]%=<span class="hljs-number">10</span>;<span class="hljs-comment">//调整本位</span><br>&#125;<br>&#125;<br>c.len=len+b.len<span class="hljs-number">+1</span>;<br>c.<span class="hljs-built_in">clean</span>();<br><span class="hljs-keyword">return</span> c;<br>&#125;<br>bign <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> bign &amp;b) &#123;<br>        bign c, f = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            f =f*<span class="hljs-number">10</span>;<br>            f.s[<span class="hljs-number">0</span>] = s[i];<br>            <span class="hljs-keyword">while</span>(f &gt;= b) &#123;<br>                f =f- b;<br>                c.s[i]++;<br>            &#125;<br>        &#125;<br>        c.len = len;<br>        c.<span class="hljs-built_in">clean</span>();<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-type">const</span> bign &amp;b) &#123;<span class="hljs-comment">//重载运算符 &gt;</span><br><span class="hljs-keyword">if</span>(len!=b.len) <span class="hljs-keyword">return</span> len&gt;b.len;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">//从高位开始对比</span><br><span class="hljs-keyword">if</span>(s[i]!=b.s[i]) <span class="hljs-keyword">return</span> s[i]&gt;b.s[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> bign &amp;b) &#123;<br><span class="hljs-keyword">if</span>(len!=b.len) <span class="hljs-keyword">return</span> len&lt;b.len;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span>(s[i]!=b.s[i]) <span class="hljs-keyword">return</span> s[i]&lt;b.s[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> bign &amp;b) &#123;<br><span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span>&gt;b) &amp;&amp; !(*<span class="hljs-keyword">this</span>&lt;b);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;= (<span class="hljs-type">const</span> bign &amp;b) &#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>&gt;b || *<span class="hljs-keyword">this</span>==b;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-comment">//将高度精值转换成字符</span><br>string re=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++) re=(<span class="hljs-type">char</span>)(s[i]+<span class="hljs-string">&#x27;0&#x27;</span>)+re;<br><span class="hljs-keyword">return</span> re;<br>&#125;<br>&#125;;<br>istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt; (istream &amp;in, bign &amp;x) &#123;<span class="hljs-comment">//使高精度支持输入&gt;&gt;</span><br>string s;<br>in&gt;&gt;s;x=s.<span class="hljs-built_in">c_str</span>(); <span class="hljs-keyword">return</span> in;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="hljs-type">const</span> bign &amp;x) &#123;<span class="hljs-comment">//使高精度支持输出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x.len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) out&lt;&lt;x.s[i];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="真香排序"><a href="#真香排序" class="headerlink" title="真香排序"></a>真香排序</h4><p>不论会什么高级模版，总会想用它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&lt;b;<span class="hljs-comment">//从低到高</span><br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+n<span class="hljs-number">+1</span>,cmp);<br></code></pre></td></tr></table></figure><h4 id="桶排"><a href="#桶排" class="headerlink" title="桶排"></a>桶排</h4><p>简单来说就是记录后找下标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x,n;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>cin&gt;&gt;x;<br>a[x]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">1</span>;m&lt;=a[i];m++)<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>相邻元素若不按照顺序则替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j,t;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">+1</span>;j&lt;=n;j++)&#123;<br>          <span class="hljs-keyword">if</span>(a[i]&lt;a[j])&#123;<br>             <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>          &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>递归拆分子序列</p><p><img src="https://i.loli.net/2020/04/02/q8CSv6jAZefsXaE.png" alt="image-20200329201857057.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r , <span class="hljs-type">int</span> *t)</span></span>&#123;<span class="hljs-comment">//要排序数组a,起始l，终止r，暂存空间t</span><br>  <span class="hljs-keyword">if</span>(r-l&gt;<span class="hljs-number">1</span>)&#123;    <br>       <span class="hljs-type">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//中间进行划分</span><br>       <span class="hljs-type">int</span> p=l, q=m, i= l;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,m,t);<span class="hljs-comment">//划分</span><br>     <span class="hljs-built_in">merge_sort</span>(a,m,r,t);<span class="hljs-comment">//划分</span><br>       <span class="hljs-keyword">while</span>(p&lt;m ||q&lt;r)&#123;         <br>         <span class="hljs-keyword">if</span>(q&gt;=r || (p&lt;m &amp;&amp; a[p]&lt;a[q]))<br>              t[i++] = a[p++];<br>              <span class="hljs-comment">//将左则暂存至临时空间         </span><br>         <span class="hljs-keyword">else</span> <br>               t[i++] = a[q++];  <br>               <span class="hljs-comment">//将右则暂存至临时空间</span><br>       &#125;<br>    <span class="hljs-keyword">for</span>(i=l; i&lt;r; i++)a[i]= t[i];<br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>基本思想是通过一趟排序将待排记录分割成独立的两部分,其中一部分记录的均比另一部分小,则可分别对这两部分记录继续进行排序,以达到整个序列有序.</p><p>假定待排序列为{r[s],r[s+1],…..r[t]},首先选取一个记录作为枢轴(pivot),然后按下述原则重新排列其余记录.</p><p>将所有较它小的记录安置在它之前,将所有较它大的记录安置在它之后.由此可见此”枢轴”记录最后所落的位置I作分界线,将原序列分割成两个{r[s],r[s+1],…r[i-1]}和{r[i],r[i+1],…r[t]}.这个过程称做一趟快速排序(或一次划分).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> a[])</span> </span>&#123; <br>    <span class="hljs-type">int</span> p=a[l];<br><span class="hljs-keyword">while</span>(l&lt;r) &#123;<span class="hljs-comment">//保证没有重叠</span><br><span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; a[r]&gt;=p) r--;<br>a[l]=a[r];<span class="hljs-comment">//将右边不适宜的数字放到左边</span><br><span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; a[l]&lt;=p) l++;<br>a[r]=a[l];<br>&#125;<br>a[l]=p;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> a[])</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;r) &#123;<br><span class="hljs-type">int</span> p=<span class="hljs-built_in">part</span>(l,r,a);<br><span class="hljs-built_in">qsort</span>(l,p,a);<br><span class="hljs-built_in">qsort</span>(p<span class="hljs-number">+1</span>,r,a);<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/02/9opqN7LVQXCaEPz.png" alt="排序对比"></p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tenout</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> m)</span></span>&#123;<span class="hljs-comment">//十进制转任意进制</span><br>    <span class="hljs-keyword">while</span>(x)&#123;a[++n]=x%m;x/=m;&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;--i)<br>        (a[i]&lt;<span class="hljs-number">10</span>)?(cout&lt;&lt;a[i]):(cout&lt;&lt;<span class="hljs-built_in">char</span>(a[i]+(<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">-10</span>)));<span class="hljs-comment">//如果小于10就直接输出，else输出字母</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getten</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">char</span> s[])</span></span>&#123;<span class="hljs-comment">//任意进制转十进制</span><br>    ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(s);i++) <br>        ans=ans*x+(<span class="hljs-built_in">isdigit</span>(s[i])?(s[i]^<span class="hljs-string">&#x27;0&#x27;</span>):(s[i]-<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">+10</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h2><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="默认存储及加边"><a href="#默认存储及加边" class="headerlink" title="默认存储及加边"></a>默认存储及加边</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>       <span class="hljs-type">int</span> dest;<span class="hljs-comment">//destination</span><br>       <span class="hljs-type">int</span> val;<span class="hljs-comment">//edge&#x27;s value</span><br>       <span class="hljs-type">int</span> next;<span class="hljs-comment">//next edge</span><br>  &#125;eg[mx*<span class="hljs-number">2</span>];<span class="hljs-comment">//mx is the numer of the edges, if it is undirected you need to double</span><br><span class="hljs-type">int</span> n,m;<span class="hljs-comment">//nomber of point in the graph，number of edge in the graph </span><br><span class="hljs-type">int</span> head[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//The head in the graph</span><br><span class="hljs-type">int</span> top=<span class="hljs-number">0</span>;<span class="hljs-comment">//The exact number of the edeges</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> val)</span></span>&#123; <br>    eg[++top].dest=v;<span class="hljs-comment">//v is the tail of the edge(destination)</span><br>    eg[top].val=val;<span class="hljs-comment">//edge&#x27;s value</span><br>    eg[top].next=head[u];<span class="hljs-comment">//next edge&#x27;s number</span><br>    head[u]=top;<span class="hljs-comment">//Remeber this edge as another edge for the head u.</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> vis[mx]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//To make sure you won&#x27;t travel through the same edge over and over again</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>vis[s]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[s];i;i=eg[i].next)&#123;<span class="hljs-comment">//travel</span><br><span class="hljs-keyword">if</span>(!vis[eg[i].dest])&#123;<span class="hljs-comment">//haven&#x27;t travel through</span><br><span class="hljs-built_in">dfs</span>(eg[i].dest);<span class="hljs-comment">//Then travel</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span><span class="hljs-comment">//Import queue libaray</span></span><br>queue&lt;<span class="hljs-type">int</span>&gt;q;<span class="hljs-comment">//Declare queue</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>q.<span class="hljs-built_in">push</span>(s);vis[s]=<span class="hljs-number">1</span>;<span class="hljs-comment">//push s into the queue and vis</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//As long as there is still elements in the queue</span><br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//Get the front of the queue</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//Get the front of the queue out</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=eg[i].next)&#123;<span class="hljs-comment">//Same old story</span><br><span class="hljs-type">int</span> v=eg[i].dest;<br><span class="hljs-keyword">if</span>(!vis[v])&#123;<br>q.<span class="hljs-built_in">push</span>(v),vis[v]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-comment">//Declare another struct to restore the information for the point</span><br><span class="hljs-type">int</span> dis,pos;<span class="hljs-comment">//pos means the number of the point</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;( <span class="hljs-type">const</span> node &amp;x )<span class="hljs-type">const</span>&#123;<span class="hljs-comment">//declare the operator &#x27;&lt;&#x27; by our own function</span><br><span class="hljs-keyword">return</span> x.dis &lt; dis;<br>&#125;<br>&#125;;<br>std::priority_queue&lt;node&gt; q;<span class="hljs-comment">//priority queue</span><br><span class="hljs-type">int</span> dis[mx],vis[mx];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>dis[s]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>((node)&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-comment">//push into queue as struct node</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node tmp=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=tmp.pos,d=tmp.dis;<br><span class="hljs-keyword">if</span>(!vis[x])&#123;<span class="hljs-comment">//Got to the tail, if we didn&#x27;t visit it</span><br>vis[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=eg[i].next)&#123;<br><span class="hljs-type">int</span> y=eg[i].dest;<br><span class="hljs-keyword">if</span>(dis[y]&gt;dis[x]+eg[i].val)&#123;<br>dis[y]=dis[x]+eg[i].val;<span class="hljs-comment">//The core of the code, to replace for smaller</span><br><span class="hljs-keyword">if</span>(!vis[y])<span class="hljs-comment">//Got to the head, if we didn&#x27;t visit it</span><br>q.<span class="hljs-built_in">push</span>((node)&#123;dis[y],y&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;<br><span class="hljs-keyword">if</span>(g[i][k]&lt;inf&amp;&amp;g[k][j]&lt;inf&amp;&amp;g[i][j]&gt;g[i][k]+g[k][j])<br>g[i][j]=g[i][k]+g[k][j];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-type">int</span> u,v;    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist));<span class="hljs-comment">//Initialize dist</span><br>dist[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//Get start point as 0</span><br>inque[s]=<span class="hljs-number">1</span>;<span class="hljs-comment">//Memorize the s is in the queue</span><br>q.<span class="hljs-built_in">push</span>(s);<span class="hljs-comment">//in queue</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>u=q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">pop</span>();  inque[u]=<span class="hljs-number">0</span>;<span class="hljs-comment">//Get the front of queue out</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u]; i; i=eg[i].next)&#123;<br>  v=eg[i].dest;<br>  <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+eg[i].val)&#123;<span class="hljs-comment">//If find a route with smaller value</span><br>  dist[v]= dist[u]+eg[i].val;<span class="hljs-comment">//change it </span><br>  fa[v]=u;<span class="hljs-comment">//Memorize the tail of v</span><br>  <span class="hljs-keyword">if</span>(!inque[v])&#123;<br>  q.<span class="hljs-built_in">push</span>(v), inque[v]=<span class="hljs-number">1</span>;<br>  &#125;<br>  &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Difference-between-Dij-heap-and-SPFA"><a href="#Difference-between-Dij-heap-and-SPFA" class="headerlink" title="Difference between Dij+heap and SPFA!!!"></a>Difference between Dij+heap and SPFA!!!</h4><p>Dij:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>  <span class="hljs-comment">//If priority queue is not empty</span><br>node tmp=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>  <span class="hljs-comment">//get top out</span><br><span class="hljs-type">int</span> x=tmp.pos,d=tmp.dis;<br><span class="hljs-keyword">if</span>(!vis[x])&#123;<span class="hljs-comment">//Got to the tail, if we didn&#x27;t visit it</span><br>vis[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=eg[i].next)&#123;<br><span class="hljs-type">int</span> y=eg[i].dest;<br><span class="hljs-keyword">if</span>(dis[y]&gt;dis[x]+eg[i].val)&#123;<br>        <span class="hljs-comment">//Relax</span><br>dis[y]=dis[x]+eg[i].val;<span class="hljs-comment">//The core of the code, to replace for smaller</span><br><span class="hljs-keyword">if</span>(!vis[y])<span class="hljs-comment">//Got to the head, if we didn&#x27;t visit it</span><br>q.<span class="hljs-built_in">push</span>((node)&#123;dis[y],y&#125;);<br>        <span class="hljs-comment">//New distance and new point into the queue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SPFA:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>   <span class="hljs-comment">//if regular queue is not empty</span><br>u=q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">pop</span>();  inque[u]=<span class="hljs-number">0</span>;<span class="hljs-comment">//Get the front of queue out</span><br>   <span class="hljs-comment">//Get top out</span><br>   <span class="hljs-comment">//And Remember!!!</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u]; i; i=eg[i].next)&#123;<br>  v=eg[i].dest;<br>  <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+eg[i].val)&#123;<span class="hljs-comment">//If find a route with smaller value</span><br>         <span class="hljs-comment">//Relax</span><br>  dist[v]= dist[u]+eg[i].val;<span class="hljs-comment">//change it </span><br>  fa[v]=u;<span class="hljs-comment">//Memorize the tail of v</span><br>  <span class="hljs-keyword">if</span>(!inque[v])&#123;<br>           <span class="hljs-comment">//the points that are Relaxed but not in queue get into the queue</span><br>  q.<span class="hljs-built_in">push</span>(v), inque[v]=<span class="hljs-number">1</span>;<br>  &#125;<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>So the difference is clear enough:</p><p>Dji+heap: <strong>Small root pile</strong>, every time get the shortest distance, for this point, the shortest distance <strong>won’t change</strong>! </p><p>SPFA: Use <strong>queue</strong>. Get the front out of queue, might be renew in the future, it is <strong>won’t be always the same</strong>. </p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><table><thead><tr><th align="center">Shortest-PathsProblem</th><th align="center">Sparse Graph</th><th align="center">Dense Graph</th><th align="center">With negative value</th></tr></thead><tbody><tr><td align="center">Single-Source</td><td align="center">Dijkstra+heap</td><td align="center">SPFA&#x2F;Dijkstra+heap</td><td align="center">SPFA</td></tr><tr><td align="center">APSP(Undirected graph)</td><td align="center">SPFA&#x2F;Floyd</td><td align="center">SPFA</td><td align="center">SPFA</td></tr><tr><td align="center">APSP(Directed graph)</td><td align="center">Floyd</td><td align="center">SPFA&#x2F;Dijkstra+heap</td><td align="center">SPFA</td></tr></tbody></table><p>​APSP((All Pairs Shortest Path))</p><h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><table><thead><tr><th align="center">Solving ways</th><th align="center">Time Complexity</th><th align="center">Space Complexity</th></tr></thead><tbody><tr><td align="center">Dijkstra+heap</td><td align="center">O(E*lgV)</td><td align="center">O(n^2)</td></tr><tr><td align="center">SPFA</td><td align="center">O(kE) (Not stable)</td><td align="center">O(n)</td></tr><tr><td align="center">Floyd</td><td align="center">O(n^3)</td><td align="center">O(n)</td></tr></tbody></table><h2 id="树论"><a href="#树论" class="headerlink" title="树论"></a>树论</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> l,r;<span class="hljs-comment">//区间左右端点</span><br>ll value;<span class="hljs-comment">//区间和值</span><br>ll add,time;<span class="hljs-comment">//区间同时增加或乘一个数的延迟标记</span><br>&#125;;<br>Node tr[MAX&lt;&lt;<span class="hljs-number">2</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>ll aa[MAX]= &#123;<span class="hljs-number">0</span>&#125;;<br>ll N,M,P;<br><span class="hljs-function">ll <span class="hljs-title">Read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;c=<span class="hljs-built_in">getchar</span>(); &#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>,c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><span class="hljs-comment">//初始化线段树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>tr[i].l=l,tr[i].r=r,tr[i].value=<span class="hljs-number">0</span>,tr[i].time=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l==r) &#123;<br>tr[i].value=aa[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,(l+r)&gt;&gt;<span class="hljs-number">1</span>);<span class="hljs-comment">//建立左子树区间</span><br><span class="hljs-built_in">build</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,((l+r)&gt;&gt;<span class="hljs-number">1</span>)<span class="hljs-number">+1</span>,r);<span class="hljs-comment">//建立右子树区间</span><br>tr[i].value=tr[i&lt;&lt;<span class="hljs-number">1</span>].value+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].value;<span class="hljs-comment">//更新编号为i的区间和(由左右儿子来)</span><br>&#125;<br><span class="hljs-comment">//向下更新</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(tr[i].add==<span class="hljs-number">0</span>&amp;&amp;tr[i].time==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//无需向下更新</span><br><span class="hljs-keyword">if</span>( tr[i].l==tr[i].r ) &#123;<span class="hljs-comment">//避免访问无效内存(叶子没有儿子)</span><br>tr[i].add=<span class="hljs-number">0</span>;<br>tr[i].time=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>tr[i&lt;&lt;<span class="hljs-number">1</span>].value=(tr[i&lt;&lt;<span class="hljs-number">1</span>].value*tr[i].time+tr[i].add*(tr[i&lt;&lt;<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>].l<span class="hljs-number">+1</span>))%P;<br><span class="hljs-comment">//左儿子区间值</span><br>tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].value=(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].value*tr[i].time+tr[i].add*(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].r-tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].l<span class="hljs-number">+1</span>))%P;<br><span class="hljs-comment">//右儿子区间值</span><br>tr[i&lt;&lt;<span class="hljs-number">1</span>].time=tr[i&lt;&lt;<span class="hljs-number">1</span>].time*tr[i].time%P;<span class="hljs-comment">//左儿子更新倍数</span><br>tr[i&lt;&lt;<span class="hljs-number">1</span>].add=(tr[i&lt;&lt;<span class="hljs-number">1</span>].add*tr[i].time+tr[i].add)%P;<span class="hljs-comment">//左儿子更新增加数</span><br>tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].time=tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].time*tr[i].time%P;<span class="hljs-comment">//右儿子更新倍数</span><br>tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add=(tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].add*tr[i].time+tr[i].add)%P;<span class="hljs-comment">//右儿子更新增加数</span><br>tr[i].add=<span class="hljs-number">0</span>;<span class="hljs-comment">//add延迟标记复0</span><br>tr[i].time=<span class="hljs-number">1</span>;<span class="hljs-comment">//time倍增延迟标记恢复1</span><br>&#125;<br><span class="hljs-comment">//区间求和 (区间查询)</span><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=tr[i].l&amp;&amp;r&gt;=tr[i].r) &#123;<span class="hljs-comment">//刚好罩着区间</span><br><span class="hljs-keyword">return</span> tr[i].value;<br>&#125;<br><span class="hljs-keyword">if</span>(l&gt;tr[i].r||r&lt;tr[i].l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//不相关区间</span><br><span class="hljs-built_in">pushdown</span>(i);<span class="hljs-comment">//向下更新延迟标记值</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">query</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r)+<span class="hljs-built_in">query</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r));<span class="hljs-comment">//返回左右儿子区间和值</span><br>&#125;<br><span class="hljs-comment">//区间更新(将区间增加一个值k)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateadd</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-built_in">pushdown</span>(i);<br><span class="hljs-keyword">if</span>(l&lt;=tr[i].l&amp;&amp;r&gt;=tr[i].r) &#123;<br>tr[i].value+=(tr[i].r-tr[i].l<span class="hljs-number">+1</span>)*k%P;<br>tr[i].add=k%P;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(r&lt;tr[i].l||l&gt;tr[i].r) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">updateadd</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-built_in">updateadd</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>tr[i].value=(tr[i&lt;&lt;<span class="hljs-number">1</span>].value+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].value)%P;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//区间更新(将区间每个值*上一个值k)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updatetime</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-built_in">pushdown</span>(i);<br><span class="hljs-keyword">if</span>(l&lt;=tr[i].l&amp;&amp;r&gt;=tr[i].r) &#123;<span class="hljs-comment">//此处对照区间增加一个值</span><br>tr[i].value=tr[i].value*k%P;<br>tr[i].time=k%P;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(r&lt;tr[i].l||l&gt;tr[i].r) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">updatetime</span>(i&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-built_in">updatetime</span>(i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>tr[i].value=(tr[i&lt;&lt;<span class="hljs-number">1</span>].value+tr[i&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].value)%P;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//freopen(&quot;data.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> o,a,b,k;<br>N=<span class="hljs-built_in">Read</span>(),M=<span class="hljs-built_in">Read</span>(),P=<span class="hljs-built_in">Read</span>();<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=N; i++)aa[i]=<span class="hljs-built_in">Read</span>();<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,N);<span class="hljs-comment">//将数据离散到线段树上</span><br><span class="hljs-keyword">while</span>(M--) &#123;<br>o=<span class="hljs-built_in">Read</span>(),a=<span class="hljs-built_in">Read</span>(),b=<span class="hljs-built_in">Read</span>();<br><span class="hljs-keyword">if</span>(o==<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//区间倍增k</span><br>k=<span class="hljs-built_in">Read</span>();<br><span class="hljs-built_in">updatetime</span>(<span class="hljs-number">1</span>,a,b,k);<br>&#125;<br><span class="hljs-keyword">if</span>(o==<span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//区间增加k</span><br>k=<span class="hljs-built_in">Read</span>();<br><span class="hljs-built_in">updateadd</span>(<span class="hljs-number">1</span>,a,b,k);<br>&#125;<br><span class="hljs-keyword">if</span>(o==<span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//区间查询</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,a,b)%P);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p><img src="https://i.loli.net/2020/04/02/LiM8J95WDxcpCd6.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> bit[mx<span class="hljs-number">+1</span>], n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>   <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<span class="hljs-comment">//Calculate the sum</span><br>  <span class="hljs-type">int</span> s =<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>    s+=bit[i];  i-=<span class="hljs-built_in">lowbit</span>(i);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//Add x to i</span><br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>       bit[i]+=x; i+=<span class="hljs-built_in">lowbit</span>(i);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重链剖分-lca"><a href="#重链剖分-lca" class="headerlink" title="重链剖分+lca"></a>重链剖分+lca</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,s;<span class="hljs-comment">//分别表示树的结点个数、询问的个数和树根结点的序号</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mx=<span class="hljs-number">500005</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-type">int</span> d;<br><span class="hljs-type">int</span> w;<br><span class="hljs-type">int</span> next;<br>&#125; eg[mx&lt;&lt;<span class="hljs-number">1</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dis[mx]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,head[mx]= &#123;<span class="hljs-number">0</span>&#125;,dep[mx]= &#123;<span class="hljs-number">0</span>&#125;,siz[mx]= &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> son[mx]= &#123;<span class="hljs-number">0</span>&#125;,fa[mx]= &#123;<span class="hljs-number">0</span>&#125;,top[mx]= &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//增加边</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Read</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>) c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>) x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>,c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span> </span>&#123;<br>eg[++cnt].d=v,eg[cnt].w=w,eg[cnt].next=head[u],head[u]=cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>siz[u]=<span class="hljs-number">1</span>, son[u]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=head[u]; i; i=eg[i].next ) &#123;<br><span class="hljs-type">int</span> v=eg[i].d;<br><span class="hljs-keyword">if</span>(v!=fa[u]) &#123;<br>dep[v]=dep[u]<span class="hljs-number">+1</span>;<br>fa[v]=u;<br><span class="hljs-built_in">dfs1</span>(v);<br>siz[u]+=siz[v];<span class="hljs-comment">//计算儿子节点个数</span><br><span class="hljs-keyword">if</span>(!son[u] || siz[v]&gt;siz[son[u]]) son[u]=v;<span class="hljs-comment">//记录重儿子结点编号</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> tp)</span> </span>&#123;<br>top[u]=tp;<br><span class="hljs-keyword">if</span>(son[u]) <span class="hljs-built_in">dfs2</span>(son[u],tp);<span class="hljs-comment">//拉重链</span><br><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=head[u]; i; i=eg[i].next ) &#123;<br><span class="hljs-type">int</span> v=eg[i].d;<br><span class="hljs-keyword">if</span>( v!=fa[u] &amp;&amp; v!=son[u] ) <span class="hljs-built_in">dfs2</span>(v,v);<span class="hljs-comment">//拉轻链</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(top[x]!=top[y])&#123;<br>       <span class="hljs-keyword">if</span>(dep[top[x]]&gt;=dep[top[y]])x=fa[top[x]];<br>       <span class="hljs-keyword">else</span> y=fa[top[y]];<br>&#125;<br><span class="hljs-keyword">return</span> dep[x]&lt;dep[y]? x : y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i) &#123;<br><span class="hljs-type">int</span> x,y; <br>x=<span class="hljs-built_in">Read</span>(), y=<span class="hljs-built_in">Read</span>();<br><span class="hljs-built_in">addEdge</span>(x,y,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">addEdge</span>(y,x,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">dfs1</span>(s);<br><span class="hljs-built_in">dfs2</span>(s,s);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) &#123;<br><span class="hljs-type">int</span> x,y; <br>x=<span class="hljs-built_in">Read</span>(), y=<span class="hljs-built_in">Read</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">lca</span>(x,y));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>离散化后只能知道数据之间的相对大小，但无法确定它们的真实值；</p><p>离散化的三个步骤：</p><p>1 sort排序</p><p>2 unique去重</p><p>3 lower_bound索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    b[i]=a[i];    <span class="hljs-comment">//b[]是a[]的副本</span><br>&#125;<br><span class="hljs-built_in">sort</span>(b<span class="hljs-number">+1</span>,b+n<span class="hljs-number">+1</span>);  <span class="hljs-comment">//排序</span><br><span class="hljs-type">int</span> sum=<span class="hljs-built_in">unique</span>(b<span class="hljs-number">+1</span>,b<span class="hljs-number">+1</span>+n)-b<span class="hljs-number">-1</span>;  <span class="hljs-comment">//去重</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    a[i]=<span class="hljs-built_in">lower_bound</span>(b<span class="hljs-number">+1</span>,b<span class="hljs-number">+1</span>+sum,a[i])-b;<span class="hljs-comment">//索引</span><br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> set[mx];<span class="hljs-comment">//集合</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> x==set[x]?x:set[x]=<span class="hljs-built_in">find</span>(set[x]);<span class="hljs-comment">//到顶就return，没有就继续往上递归</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionset</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//合并集合</span><br>    <span class="hljs-type">int</span> xx=<span class="hljs-built_in">find</span>(x),yy=<span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(xx!=yy)&#123;<br>        <span class="hljs-keyword">if</span>(xx&gt;yy)<span class="hljs-built_in">swap</span>(xx,yy);<br>        set[yy]=xx;<br>    &#125;<br>&#125;<br> <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)set[i]=i;<span class="hljs-comment">//在主函数中初始化（各为一个集合）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言代码集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针</title>
    <link href="/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/>
    <url>/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针也就是内存地址，指针变量是用来存放内存地址的变量</p><p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数</p><p><code>int *p=&amp;a</code>申明p指针，储存的是a的地址</p><p><code>p</code>引用地址，<code>*p</code>反引用，改变的是指针所指地址的值</p><p>C语言引用数组时，得到的数组第一个元素的地址</p><p>NULL 指针是一个定义在标准库中的值为零的常量</p><p>%p是打印地址（指针地址）的，是十六<a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">进制</a>的形式，但是会全部打完，即有多少位打印多少位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> b=<span class="hljs-number">13</span>;<br>   <span class="hljs-type">int</span> *ptr=&amp;b;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pointer:%d\n&quot;</span>,ptr);<span class="hljs-comment">//pointer:6487572</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value:%d\n&quot;</span>,*ptr);<span class="hljs-comment">//value:13</span><br></code></pre></td></tr></table></figure><p><strong>打代码时一定注意需要的是指针还是需要里面存储的东西</strong></p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol><li><code>int *p</code>; &#x2F;&#x2F;首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 </li><li><code>int *p[3]</code>; &#x2F;&#x2F;首先从P 处开始,先与[]结合,因为其优先级比<em>高,所以P 是一个数组,然后再与</em>结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 </li><li><code>int (*p)[3]</code>; &#x2F;&#x2F;首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与”()”这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 </li><li><code>int **p</code>; &#x2F;&#x2F;首先从P 开始,先与<em>结合,说是P 是一个指针,然后再与</em>结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. </li><li><code>int p(int)</code>; &#x2F;&#x2F;从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 </li><li><code>int (*p)(int)</code>; &#x2F;&#x2F;从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 </li><li><code>int *(*p(int))[3]</code>; &#x2F;&#x2F;可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的<em>结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与</em>结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a=<span class="hljs-number">20</span>;<span class="hljs-comment">//只读（不改变数值） </span><br><span class="hljs-type">int</span> *p=&amp;a;<br><span class="hljs-type">char</span> ch[<span class="hljs-number">5</span>]=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<span class="hljs-comment">// 可以修改 </span><br><span class="hljs-type">char</span> *c=<span class="hljs-string">&quot;abcsd&quot;</span>;<span class="hljs-comment">//放在常量区 不能修改 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p);<span class="hljs-comment">//a的地址 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,p+<span class="hljs-number">1</span>);<span class="hljs-comment">//a的地址+4（下一个整数，一个整数占十位）</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*p);<span class="hljs-comment">//p本身 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>));<span class="hljs-comment">//char占1位，int，long占4位，long long，double占8位 </span><br><span class="hljs-comment">//void指针（指向指针的指针） </span><br><span class="hljs-type">void</span> *pr=p;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,pr+<span class="hljs-number">1</span>);<span class="hljs-comment">//a的地址+4（下一个整数，一个整数占十位）</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*pr);<span class="hljs-comment">//p本身 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">20</span><br><span class="hljs-comment">000000000062FE14</span><br><span class="hljs-comment">6487572</span><br><span class="hljs-comment">000000000062FE14</span><br><span class="hljs-comment">20</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><p><strong>这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？</strong></p><p>指针的值是指针本身存储的数值，这个值将被编译器<strong>当作一个地址</strong>，而不是一个一般的数值。</p><p>在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念</p><p>指向多维数组的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> b[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>],i,j,k;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>b[i][j]=i+j;<br>&#125;<br><span class="hljs-type">int</span> (*pb)[<span class="hljs-number">3</span>]=b;<span class="hljs-comment">//指向二维数组的指针（数组套数组） </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,**pb);<span class="hljs-comment">//输出b[0][0] </span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(*pb+i)+j);<span class="hljs-comment">//最外面的*取消地址，内部+2是前面的第二位，外部+3是后面的第三位 printf(&quot;%d&quot;,*(*pb+i)+j);//最外面的*取消地址，内部+2是前面的第二位，外部+3是后面的第三位 </span><br>&#125;<br><span class="hljs-type">int</span> b2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=&#123;&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;&#125;,&#123;&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">1</span>&#125;&#125;,&#123;&#123;<span class="hljs-number">8</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">11</span>,<span class="hljs-number">13</span>&#125;&#125;&#125;,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> (*pb2)[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=b2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, b2,*b2,b2[<span class="hljs-number">0</span>],&amp;b2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//全部打印出地址（指针） </span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)&#123;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;k++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b2[i][j][k]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(pb2[i][j]+k));<span class="hljs-comment">//*(c[1]+1)得到c[1][1]首字母的指针 </span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h2><h3 id="程序内存空间的分配"><a href="#程序内存空间的分配" class="headerlink" title="程序内存空间的分配"></a>程序内存空间的分配</h3><p>内存中的每个空间都是可以寻址的</p><p>从大到小：</p><p>堆Heap（动态内存）：更自由，可自由分配大小</p><p>栈Stack： 存储函数执行时的信息 ，局部变量（程序启动时空间固定）</p><p>静态或全局变量： （不在函数里定义的就是全局变量），在任何地方都能访问修改</p><p>代码：存储程序的指令</p><h3 id="运行时的空间调用"><a href="#运行时的空间调用" class="headerlink" title="运行时的空间调用"></a>运行时的空间调用</h3><p>在栈中先执行main函数，给予栈帧，每当调用函数时，当前函数会在调用的那行暂停，机器转而去执行被调函数，被调函数被赋予新的栈帧，如果一个函数无限次调用另一个函数，就会造成栈溢出</p><h3 id="实参与形参"><a href="#实参与形参" class="headerlink" title="实参与形参"></a>实参与形参</h3><p>实参：主函数中调用其他函数，</p><p>形参：被调函数中的参数</p><h3 id="堆heap的使用"><a href="#堆heap的使用" class="headerlink" title="堆heap的使用"></a>堆heap的使用</h3><p>在堆里的内存只能被引用</p><p><strong>#include&lt;stdlib.h&gt;</strong></p><p>malloc：</p><p>在heap里找到内存然后返回地址 <code>int *p=(int*)malloc(n*·sizeof(int));</code></p><p>返回的是void指针，指向分配发给我们的内存块的第一个地址，需要将其转换为特定的指针</p><p>注意malloc括号内的数字是bytes数，一个int占4bytes</p><p>calloc ：</p><p>与mallloc相似，需要两个参数：返回特定类型的元素的数量，第二个参数是类型的大小</p><p><code>int *p=(int*)calloc(3,sizeof(int));</code></p><p>realloc ：</p><p>修改已经定义的内存</p><p><code>int *pr=(int*)calloc(p,sizeof(int));</code></p><p>free：<code>free(p)</code>释放队中的内存（不会自动释放）</p><p>C++</p><p> new delete</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">char</span> *pr,*pr2;<br>pr=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">15</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<span class="hljs-comment">//注意malloc和calloc关系</span><br><span class="hljs-built_in">strcpy</span>(pr,<span class="hljs-string">&quot;tht nb&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string pr is %s, address is %p\n&quot;</span>,pr,pr);<br>pr2=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">15</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br><span class="hljs-built_in">strcpy</span>(pr2,<span class="hljs-string">&quot;tht nbnb&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string pr2 is %s, address is %p\n&quot;</span>,pr2,pr2);<br>pr=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">realloc</span>(pr,<span class="hljs-number">20</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br><span class="hljs-built_in">strcat</span>(pr,<span class="hljs-string">&quot;nbnbnb&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string pr is %s, address is %p\n&quot;</span>,pr,pr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h2><p>一个指针ptrold 加(减)一个整数n 后，结果是一个<strong>新的指针</strong>ptrnew，ptrnew 的类型和ptrold 的类型相同，ptrnew 所指向的类型和ptrold所指向的类型也相同。ptrnew 的值将比ptrold 的值<strong>增加(减少)了n 乘sizeof(ptrold 所指向的类型)个字节</strong>。就是说，ptrnew 所指向的内存区将比ptrold 所指向的内存区向高(低)地址方向移动了n 乘sizeof(ptrold 所指向的类型)个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">20</span>]; <br>   <span class="hljs-type">int</span> *ptr=(<span class="hljs-type">int</span> *)a; <span class="hljs-comment">//强制类型转换并不会改变a 的类型 </span><br>   ptr++; <br></code></pre></td></tr></table></figure><p>指针ptr 的类型是int*,它指向的类型是int，它被初始化为指向整型变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因为在32 位程序中，int 占4 个字节。由于地址是用字节做单位的，故ptr 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于char 类型的长度是一个字节，所以，原来ptr 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字</p><h2 id="取值符与地址符"><a href="#取值符与地址符" class="headerlink" title="取值符与地址符"></a>取值符与地址符</h2><p><code>&amp;</code> 运算符 ：用于取一个对象的地址</p><p><code>* </code>运算符：作用于指针时表示访问指针所指向的对象</p><p>地址与数据的关系相当于x与y</p><ol><li>处于不同维度</li><li>一个数据可对应多个地址</li><li>一个地址有且只有一个数据</li></ol><h3 id="实参与形参-1"><a href="#实参与形参-1" class="headerlink" title="实参与形参"></a>实参与形参</h3><p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p><h4 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h4><p>函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用</p><ul><li>必须有确定的值s</li></ul><h4 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h4><p>在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据</p><ul><li>只在函数内部有效（只有在函数被调用时才会分配内存，调用结束后，立刻释放内存</li><li>函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参</li></ul><h3 id="函数与调用指针"><a href="#函数与调用指针" class="headerlink" title="函数与调用指针"></a>函数与调用指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">swaps</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> *b)</span>&#123; <span class="hljs-comment">//本质是交换地址 </span><br>    <span class="hljs-type">int</span> c=*b;<br>    *b=*a;<span class="hljs-comment">//b的地址赋值为a的地址 </span><br>    *a=c; <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SwapStringArray</span><span class="hljs-params">(<span class="hljs-type">char</span> *str1, <span class="hljs-type">char</span> *str2)</span>&#123;<span class="hljs-comment">//交换数组</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(str1[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; str2[j]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        Swap(&amp;str1[i],&amp;str2[j]);<br>        i++;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(str1[i] != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; str2[j] == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">while</span>(str1[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>            Swap(&amp;str1[i],&amp;str2[i]);<br>            i++;<br>        &#125;<br>        str1[j] =<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        str2[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str1[i] == <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; str2[j] != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">while</span>(str2[j] !=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>            Swap(&amp;str1[j],&amp;str2[j]);<br>            j++;<br>        &#125;<br>        str1[j]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        str2[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sorrt</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b)</span>&#123;<br>    a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>swaps(&amp;a,&amp;b);<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">20</span>],b;<br>    sorrt(a,b);<span class="hljs-comment">//shu&#x27;zu</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的调用其实就是将执行程序的地址跳转到函数的第一条指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">adds</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123; <span class="hljs-comment">//本质是交换地址 </span><br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">abc</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sb&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-type">void</span> (*ptr)())</span>&#123;<br>    ptr();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> (*pf)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);<br>pf=&amp;adds;<br><span class="hljs-type">int</span> x=<span class="hljs-number">2</span>,y=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> xpy;<br>xpy=(*pf)(x,y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,xpy);<br><span class="hljs-comment">//void (*pv)()=&amp;abc;</span><br><span class="hljs-comment">//b(pv);</span><br>b(abc);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p><strong>NULL</strong> is the constant that is defined by the standard </p><p>library</p><p>• It is equivalent to zero for a pointer</p><p>• It guarantees that the pointer does not point to any location in the memory and prevents accidental overwriting of a memory</p><p>• You need to add #include directive for <strong>stddef.h</strong> to your source fileNever dereference an uninitialized pointer</p><p>int * pt; &#x2F;&#x2F; uninitialized pointer</p><p>*pt &#x3D; 5; &#x2F;&#x2F; store the value 5 to a location where pt points</p><p>Problem : pt has a random value and there is no knowing where pt will be placed</p><ol><li><p>It might go somewhere harmless, it might overwrite data or code, or might cause the program to crash</p></li><li><p>Creating a pointer only allocated memory to store the pointer itself and it does not allocate memory to store the data itself.</p></li></ol><h2 id="pointers-to-arrays"><a href="#pointers-to-arrays" class="headerlink" title="pointers to arrays"></a>pointers to arrays</h2><p><strong>Remember:</strong> <em>array names are themselves pointers and</em> </p><p><em>therefore you do not use</em> <strong>&amp;</strong> <em>operator when pointing towards</em> </p><p><em>an arrayname</em></p><p>• <strong>valuesPtr &#x3D; values;</strong></p><p>When specifying the array name without a subscript, this </p><p>has an effect of producing a pointer to the first element of </p><p>the <strong>values or</strong></p><p>• valuesPtr &#x3D; &amp;values[0];</p><p>To reference values[3] via pointer, you can simply add 3 to values Ptr such as *(valuesPtr+3)</p><p>To set the valuesPtr to point the second element of  the array, you do the following</p><p>valuesPtr &#x3D; &amp;values[1];</p><p><strong>Or</strong></p><p>valuesPtr +&#x3D;1;</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C速转Python</title>
    <link href="/Blogs/2025/08/28/C%E9%80%9F%E8%BD%ACPython/"/>
    <url>/Blogs/2025/08/28/C%E9%80%9F%E8%BD%ACPython/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-C-速转Pythondate-2020-07-12-12-02-38tags-Pythoncategories-技术"><a href="#title-C-速转Pythondate-2020-07-12-12-02-38tags-Pythoncategories-技术" class="headerlink" title="title: C++速转Pythondate: 2020-07-12 12:02:38tags:- Pythoncategories: 技术"></a>title: C++速转Python<br>date: 2020-07-12 12:02:38<br>tags:<br>- Python<br>categories: 技术</h2><h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>C++：库是他们的，我什么也没有。。。</p><p>Python的库太香了，而且最近要搞基于Python的AI竞赛</p><p>就当是复习了吧</p><span id="more"></span><p>速成直接看<strong>这个例子</strong></p><p>C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string a[<span class="hljs-number">3</span>]=&#123;<span class="hljs-string">&quot;It&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;Mavericreate&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,&amp;a[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,&amp;a[i]);<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将if 与 while的()改为” “,并在结尾加上:</p><p>将;去掉</p><p>函数名从printf改为print</p><p>数组把[]去掉</p><p>去掉{}</p><p><strong>行的格式正确（语句内的代码要空格）</strong></p><p>然后。。。</p><p>就差不多了（入门级的代码改变不需要import之类</p><p>Python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-string">&quot;It&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;Mavericreate&quot;</span>]<br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s &quot;</span>%(a[i]),end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">#i+=1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>i=<span class="hljs-number">2</span><br><span class="hljs-keyword">while</span> i&gt;=<span class="hljs-number">0</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s &quot;</span>%(a[i]),end=<span class="hljs-string">&quot;&quot;</span>)<br>i-=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>想系统一点的话就看下面一堆东东</p><p>可以了解一下，遇到函数不会的话可以直接查表</p><h1 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量(Variable)"></a>变量(Variable)</h1><h2 id="赋值方法"><a href="#赋值方法" class="headerlink" title="赋值方法"></a>赋值方法</h2><ul><li>Python中变量不用声明</li><li>变量使用前必须赋值</li><li>方法： 变量名&#x3D;变量值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python注释符为‘#’</span><br><span class="hljs-comment">#一般赋值</span><br>a=<span class="hljs-number">3</span><br><span class="hljs-comment">#多变量赋值(注意变量名不能相同，这里只是为了演示)</span><br>a=b=c=<span class="hljs-number">3</span><br><span class="hljs-comment">#为多个对象指定多个变量</span><br>a,b,c=<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-literal">True</span><span class="hljs-comment">#注意True大写</span><br><span class="hljs-comment">#链式赋值</span><br>a=b=b+<span class="hljs-number">1</span><br><span class="hljs-comment">#增量赋值（和C一样</span><br>a=a+<span class="hljs-number">1</span><br>a+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="变量的规范"><a href="#变量的规范" class="headerlink" title="变量的规范"></a>变量的规范</h2><ul><li><strong>只能</strong>字母或下划线开头</li><li>大小写敏感</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#可以使用type(variable)来获得类型（返回string</span><br>a=<span class="hljs-number">1</span><br><span class="hljs-built_in">type</span>(a)<br></code></pre></td></tr></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>Python支持四种数值类型</p><table><thead><tr><th align="center">int</th><th align="center">与C一样，但是在python3里无高精度（自动高精度）</th><th>1，2，0x6f(16进制)</th></tr></thead><tbody><tr><td align="center">float(浮点数)</td><td align="center">等于C的double类型</td><td>1.0，-0.1，1.2e-4</td></tr><tr><td align="center">complex(复数)</td><td align="center">a+bj,或者complex(a,b)。a为实部，b为虚部。.real取出实部，.imag取出虚部</td><td>1+2j,complex(1,2)</td></tr><tr><td align="center">bool(布尔)</td><td align="center">True(对应1)&#x2F;False(对应0)</td><td>True,False</td></tr></tbody></table><h4 id="数值tips"><a href="#数值tips" class="headerlink" title="数值tips:"></a>数值tips:</h4><p>type()查看类型</p><p>del()删除引用</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>与C一样</p><p>但是有 **操作，a**b表示a的b次方</p><p>还有地板除</p><p>-11&#x2F;&#x2F;4&#x3D;-3</p><p>如果其中一个操作数为负数，则结果将被保留，即从0向负无穷大舍去</p><h4 id="数值运算符"><a href="#数值运算符" class="headerlink" title="数值运算符"></a>数值运算符</h4><p>与C一样</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>设a&#x3D;True，b&#x3D;False</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">“且”，两边同时为真才为真</td><td align="center">（a and b）结果为False</td></tr><tr><td align="center">or</td><td align="center">“或”，有一个是对的就对</td><td align="center">（a or b）结果为False</td></tr><tr><td align="center">not</td><td align="center">“非”，状态取反</td><td align="center">not(a and b)结果为True</td></tr></tbody></table><h4 id="数字内置函数"><a href="#数字内置函数" class="headerlink" title="数字内置函数"></a>数字内置函数</h4><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">str(x)</td><td align="center">数值x转换为字符串类型</td></tr><tr><td align="center">int(x)</td><td align="center">x转换整数，（不四舍五入，直接取整数部分</td></tr><tr><td align="center">float(x)</td><td align="center">将x转为浮点数</td></tr><tr><td align="center">complex(x,y)</td><td align="center">转负数</td></tr><tr><td align="center">bin(x)</td><td align="center">转2进制</td></tr><tr><td align="center">hex(x)</td><td align="center">转16进制</td></tr></tbody></table><h4 id="数值内置函数"><a href="#数值内置函数" class="headerlink" title="数值内置函数"></a>数值内置函数</h4><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td align="center">取x的决定值</td></tr><tr><td align="center">min(x1,x2,x3)</td><td align="center">取最小值</td></tr><tr><td align="center">max(x1,x2,x3)</td><td align="center">取最大值</td></tr><tr><td align="center">pow(x,y)</td><td align="center">计算x的y次方，&#x3D;x**y</td></tr><tr><td align="center">round(x)</td><td align="center">四舍五入x到个位</td></tr><tr><td align="center">round(x,n)</td><td align="center">四舍五入x到小数点后n位</td></tr></tbody></table><h4 id="处理数值对象的模块"><a href="#处理数值对象的模块" class="headerlink" title="处理数值对象的模块"></a>处理数值对象的模块</h4><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math&#x2F;cmath</td><td align="center">标准C库数学运算函数，常规在cmath，复数运算cmath</td></tr><tr><td align="center">random</td><td align="center">多种伪随机数生成器</td></tr><tr><td align="center">decimal</td><td align="center">十进制浮点运算类</td></tr><tr><td align="center">array</td><td align="center">高效数值数组</td></tr><tr><td align="center">operator</td><td align="center">数字运算符的函数实现</td></tr></tbody></table><h4 id="导入数学模块"><a href="#导入数学模块" class="headerlink" title="导入数学模块"></a>导入数学模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> XXX<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> math<br><span class="hljs-comment">#任意皆可</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">pi</td><td align="center">圆周率</td></tr><tr><td align="center">e</td><td align="center">自然常数</td></tr><tr><td align="center">sqrt(x)</td><td align="center">x的平方根</td></tr><tr><td align="center">sin(x),cos(x),cos(x),tan(x)</td><td align="center">x为弧度制</td></tr><tr><td align="center">exp(x)</td><td align="center">e的x次方</td></tr><tr><td align="center">log(x)  相当于ln,log(x,n) n为底数，x为对数,log10(x) 10为底数</td><td align="center">log函数</td></tr></tbody></table><h4 id="导入随机模块"><a href="#导入随机模块" class="headerlink" title="导入随机模块"></a>导入随机模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> XXX<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><span class="hljs-comment">#任意皆可</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">choice(seq)</td><td align="center">来自列表，元组，或字符串的随机项目</td></tr><tr><td align="center">randrange([start],stop,[step])</td><td align="center">从（start，stop，step）中选择元素</td></tr><tr><td align="center">random()</td><td align="center">返回随机浮点数（0&lt;&#x3D;r&lt;1）</td></tr><tr><td align="center">seed([x])</td><td align="center">设置生成随机数的整数起始值</td></tr><tr><td align="center">shuffle(lst)</td><td align="center">将列表的项目随机化到位置</td></tr><tr><td align="center">uniform(x,y)</td><td align="center">返回随机浮点数r（x&lt;&#x3D;r&lt;y）</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>单引号双引号都可以用</li><li>长字符串可以用’ ‘ ‘</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>注意函数和方法不一样</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">find()</td><td align="center">查找字符串中，若有就返回索引值，没有则返回-1</td></tr><tr><td align="center">index()</td><td align="center">查找字符串中，若有就返回索引值，没有则引发异常</td></tr><tr><td align="center">replace(old,new)</td><td align="center">使用新的字符串替代原字符串中替代特定的字符串</td></tr><tr><td align="center">split(str)</td><td align="center">根据分隔符str拆分字符串，默认以空格拆分</td></tr><tr><td align="center">lstrip()</td><td align="center">删除字符串中的所有前导空格</td></tr><tr><td align="center">rstrip()</td><td align="center">删除字符串中的所有尾随空格</td></tr><tr><td align="center">strip()</td><td align="center">对字符串lstrip()和rstrip()</td></tr></tbody></table><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">capitalize()</td><td align="center">把字符串的第一个字母转为大写</td></tr><tr><td align="center">islower()</td><td align="center">若字符串至少包含1个字母，且所有字符均为小写，则返回True，否则返回False</td></tr><tr><td align="center">isupper()</td><td align="center">若字符串至少包含1个可变大小写字母，且所有可变大小写字符均为大写，则返回True，否则返回False</td></tr><tr><td align="center">lower()</td><td align="center">所有大写字母转小写</td></tr><tr><td align="center">upper()</td><td align="center">所有小写字母转大写</td></tr><tr><td align="center">join(seq)</td><td align="center">将序列seq中的元素以字符串合并到具有分隔符字符串的字符串中</td></tr></tbody></table><h4 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h4><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\\</td><td align="center">反斜线</td><td align="center">\v</td><td align="center">纵向制表符</td></tr><tr><td align="center">\‘</td><td align="center">单引号</td><td align="center">\r</td><td align="center">回车符</td></tr><tr><td align="center">\“</td><td align="center">双引号</td><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\a</td><td align="center">发出系统响铃声</td><td align="center">\o</td><td align="center">八进制数代表的字符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td><td align="center">\x</td><td align="center">十六进制数代表的字符</td></tr><tr><td align="center">\b</td><td align="center">退格符</td><td align="center">\000</td><td align="center">终止符，后面字符串全部省略</td></tr><tr><td align="center">\t</td><td align="center">横向制表符</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>不想让转义生效时，就用r与R来定义原始字符串：</p><p>print(r”\t\r”)</p><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="center">符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%c</td><td align="center">格式化字符及其ASCIL码</td><td align="center">%f</td><td align="center">格式化浮点数字，可指定小数点后精度</td></tr><tr><td align="center">%s</td><td align="center">格式化字符串</td><td align="center">%e</td><td align="center">科学技术法格式化浮点数</td></tr><tr><td align="center">%d</td><td align="center">格式化整数</td><td align="center">%E</td><td align="center">科学技术法格式化浮点数</td></tr><tr><td align="center">%u</td><td align="center">格式化无符号整数</td><td align="center">%g</td><td align="center">根据值的大小决定使用%f或%e</td></tr><tr><td align="center">%o</td><td align="center">格式化无符号八进制数</td><td align="center">%G</td><td align="center">根据值的大小决定使用%f或%e</td></tr><tr><td align="center">%x</td><td align="center">格式化无符号十六进制数</td><td align="center">%p</td><td align="center">用16进制格式化变量地址</td></tr><tr><td align="center">%X</td><td align="center">格式化无符号十六进制数（大写</td><td align="center">%%</td><td align="center">输出%</td></tr></tbody></table><ul><li>列表: [1,2,3,4,5]</li></ul><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><ul><li>格式：list&#x3D;[a,b,c]</li><li>特殊方法:list2&#x3D;[1,’b’,c,[‘d’,e]]</li><li>访问方法与C一样list[n]（访问第一个元素</li><li>注意如果n&#x3D;-2时则会访问倒数第二个元素</li><li>list[1:3]会取到第一个还有第二个元素</li></ul><h4 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h4><table><thead><tr><th align="center">函数</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">s.append(x)</td><td align="center">末尾添加x（元素）</td></tr><tr><td align="center">s.count(x)</td><td align="center">返回x出现的次数</td></tr><tr><td align="center">s.extend(iter)</td><td align="center">将iter的所有元素添加到</td></tr><tr><td align="center">s.index(x)</td><td align="center">返回第x个元素的索引</td></tr><tr><td align="center">s.insert(i,x)</td><td align="center">将元素x插入到索引i指定的元素前面，结果是s[i]&#x3D;x</td></tr><tr><td align="center">s.pop(i)</td><td align="center">删除并返回x中索引为i的元素</td></tr><tr><td align="center">s.remove(x)</td><td align="center">删除x中第一个x元素</td></tr><tr><td align="center">s.reverse()</td><td align="center">反转排列顺序，（alist[::-1]在输出的时候会反过来，但实际不会</td></tr><tr><td align="center">s.sort()</td><td align="center">升序排列s中元素</td></tr></tbody></table><p>观察下面的程序，看看有什么发现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>c=(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)<br>a.append(b)<br><span class="hljs-built_in">print</span>(a)<br>a.extend(b)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#a+c失败，因为列表不能与元组相加</span><br>a.append(c)<br><span class="hljs-built_in">print</span>(a)<br>a.extend(c)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h3 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h3><ul><li>不可变序列（不能进行添加删除</li><li>由不同元素组成</li><li>元组代表一行数据，其中元素代表不同数据项</li></ul><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th align="center">函数</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">x in tuple1</td><td align="center">若x是tuple1中的一个元素，则返回True，否则False</td></tr><tr><td align="center">len(tuple1)</td><td align="center">tuple1所包含的元素数</td></tr><tr><td align="center">tuple1.count(x)</td><td align="center">元素x在元组中出现的次数</td></tr><tr><td align="center">tuple1.index(x)</td><td align="center">元组tuple1中第一个元素x的索引，若x不在，则引发异常</td></tr></tbody></table><h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><ul><li>用{ }扩起来，每对键值用:分开</li><li>字典中的键必须唯一</li><li>Python3.6的字典会保持插入后的值</li><li>支持多级结构，既值可以为列表，字典</li><li>字典通过key可以获取相应的value值</li><li>多维字典访问dict[key] [索引下标]</li><li>使用字典中不存在的键访问会报错</li></ul><h4 id="字典添加与删除方法"><a href="#字典添加与删除方法" class="headerlink" title="字典添加与删除方法"></a>字典添加与删除方法</h4><p>如果存在key，则更新value，不存在，就追加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;work&#x27;</span>]=<span class="hljs-string">&#x27;teacher&#x27;</span> <br><span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;age&#x27;</span>]=<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>使用del语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> <span class="hljs-built_in">dict</span>[<span class="hljs-string">&#x27;work&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th align="center">函数</th><th align="center">描述与用法</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">d.items(),d.keys(),d.value()</td><td align="center">返回键值对&#x2F;键&#x2F;值 的视图</td><td align="center"></td></tr><tr><td align="center">d.get(key)</td><td align="center">返回与key相关联的值</td><td align="center"></td></tr><tr><td align="center">d.pop(key)</td><td align="center">删除键key，并返回与之相关的值</td><td align="center">dict.pop(‘age’)</td></tr><tr><td align="center">d.popitem()</td><td align="center">随机删除字典d中的某键值对，并返回相应的键值对</td><td align="center"></td></tr><tr><td align="center">d.clear()</td><td align="center">删除d中的所有元素</td><td align="center"></td></tr><tr><td align="center">d.fromkeys(s,t)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">d.update(e)</td><td align="center">将e中的键值队添加到字典中，e可能是字典，也可以是<strong>键值队序列</strong></td><td align="center">dict.update({‘married’:’yes’})</td></tr><tr><td align="center">d.setdefault(key,v)</td><td align="center">如key包含在字典key中，则返回d中key对应的value，否则，将key，v添加到字典</td><td align="center">Dict.setdefault(age,30)</td></tr></tbody></table><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>不重复元素，无列表与字典应用广泛</li><li>set()或{}创建（创空集时不能用{}</li><li>作用：消除重复元素</li><li>特性：union, intersection, difference, sysmmetric difference</li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>英文博客写过，这里不再赘述</p><h1 id="语句，关键字"><a href="#语句，关键字" class="headerlink" title="语句，关键字"></a>语句，关键字</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>以C++为对比</p><p>去掉“;”,”()”</p><p>在if尾部加上”:”</p><p>注意对齐，python没有分号但是对齐很重要</p><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">20</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a&lt;20&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">20</span> &amp;&amp; a&lt;<span class="hljs-number">80</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;20&lt;=a&lt;80&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,a&gt;80&quot;</span>,a);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">100</span><br><span class="hljs-keyword">if</span> a&lt;<span class="hljs-number">20</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&lt;20&quot;</span>)<br><span class="hljs-keyword">elif</span> a&gt;=<span class="hljs-number">20</span> <span class="hljs-keyword">and</span> a&lt;<span class="hljs-number">80</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;20&lt;=a&lt;80&quot;</span>)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a= %d,a&gt;80&quot;</span> %(a))<br></code></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string a[<span class="hljs-number">3</span>]=&#123;<span class="hljs-string">&quot;It&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;Mavericreate&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,&amp;a[i]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,&amp;a[i]);<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//Result:</span><br><span class="hljs-comment">//It is Mavericreate </span><br><span class="hljs-comment">//It is Mavericreate </span><br></code></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">a=[<span class="hljs-string">&quot;It&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;Mavericreate&quot;</span>]<br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s &quot;</span>%(a[i]),end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>i=<span class="hljs-number">2</span><br><span class="hljs-keyword">while</span> i&gt;=<span class="hljs-number">0</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s &quot;</span>%(a[i]),end=<span class="hljs-string">&quot;&quot;</span>)<br>i-=<span class="hljs-number">1</span><br><span class="hljs-comment">#result:</span><br><span class="hljs-comment">#It is Mavericreate </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#Mavericreate is It </span><br></code></pre></td></tr></table></figure><h4 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h4><ul><li>range()函数生成一个序列，返回一个range对象</li><li>默认起始值为0，如 range(10)</li><li>有反向range的打法，如 range(10,0,-1)</li><li>上面最后的-1表示每次递增的量，为-的话就递减</li></ul><h4 id="Enumerate遍历方法"><a href="#Enumerate遍历方法" class="headerlink" title="Enumerate遍历方法"></a>Enumerate遍历方法</h4><p>enumerate()函数用于遍历序列中的元素与下标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-string">&#x27;abc&#x27;</span>):<br> <span class="hljs-built_in">print</span>(i,j)<br><span class="hljs-comment">#Result:</span><br><span class="hljs-comment">#1 b</span><br><span class="hljs-comment">#2 c</span><br><br></code></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字为特殊的标识符 （Python内部已有的标识符</p><p>查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> keyword<br><span class="hljs-built_in">print</span>(keyword.kwlist);<br>[<span class="hljs-string">&#x27;False&#x27;</span>, <span class="hljs-string">&#x27;None&#x27;</span>, <span class="hljs-string">&#x27;True&#x27;</span>, <span class="hljs-string">&#x27;and&#x27;</span>, <span class="hljs-string">&#x27;as&#x27;</span>, <span class="hljs-string">&#x27;assert&#x27;</span>, <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-string">&#x27;await&#x27;</span>, <span class="hljs-string">&#x27;break&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;continue&#x27;</span>, <span class="hljs-string">&#x27;def&#x27;</span>, <span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-string">&#x27;elif&#x27;</span>, <span class="hljs-string">&#x27;else&#x27;</span>, <span class="hljs-string">&#x27;except&#x27;</span>, <span class="hljs-string">&#x27;finally&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;global&#x27;</span>, <span class="hljs-string">&#x27;if&#x27;</span>, <span class="hljs-string">&#x27;import&#x27;</span>, <span class="hljs-string">&#x27;in&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;lambda&#x27;</span>, <span class="hljs-string">&#x27;nonlocal&#x27;</span>, <span class="hljs-string">&#x27;not&#x27;</span>, <span class="hljs-string">&#x27;or&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>, <span class="hljs-string">&#x27;raise&#x27;</span>, <span class="hljs-string">&#x27;return&#x27;</span>, <span class="hljs-string">&#x27;try&#x27;</span>, <span class="hljs-string">&#x27;while&#x27;</span>, <span class="hljs-string">&#x27;with&#x27;</span>, <span class="hljs-string">&#x27;yield&#x27;</span>]<br></code></pre></td></tr></table></figure><p>大部分关键字与C++相同</p><p>这里提一些没有的（我没在C++里看到的</p><table><thead><tr><th align="center">关键字</th><th align="center">含义</th><th>示例</th><th align="center">关键字</th><th align="center">含义</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">def</td><td align="center">定义函数或方法</td><td></td><td align="center">raise</td><td align="center">异常抛出操作</td><td align="center"></td></tr><tr><td align="center">except, try, finally</td><td align="center">捕捉异常</td><td></td><td align="center">with</td><td align="center">简化语句</td><td align="center">with open(file) as fp</td></tr><tr><td align="center">global</td><td align="center">全局变量定义</td><td></td><td align="center">yield</td><td align="center">从函数依次返回值</td><td align="center"></td></tr><tr><td align="center">in</td><td align="center">判断是否在序列中</td><td></td><td align="center">assert</td><td align="center">判断变量或表达式的值是否为真</td><td align="center"></td></tr><tr><td align="center">class</td><td align="center">用于定义类</td><td></td><td align="center">is</td><td align="center">判断变量是否为某个类</td><td align="center"></td></tr><tr><td align="center">as</td><td align="center">类型转换</td><td>import keyword as ke</td><td align="center">lamdba</td><td align="center">定义匿名变量</td><td align="center"></td></tr><tr><td align="center"><strong>and, or, not</strong></td><td align="center">逻辑与,或，非操作</td><td>if a and b:</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在Python内，一切（数据结构）都是对象，对象就是申请的一块内存，一个对象一旦被创建，在内存中的大小就是不变的。</p><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))<br><br><span class="hljs-comment">#result:</span><br><span class="hljs-comment">#4334942864</span><br><span class="hljs-comment">#表示这个为内存地址（每次地址可能都不一样</span><br></code></pre></td></tr></table></figure><p>对于数字，字符串，None，即使是赋值，也只是创造了新的引用，而不是对象本身。</p><h3 id="关键字if：判断指向的对象是否相同"><a href="#关键字if：判断指向的对象是否相同" class="headerlink" title="关键字if：判断指向的对象是否相同"></a>关键字if：判断指向的对象是否相同</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">a,b=<span class="hljs-number">1</span>,<span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment">#False</span><br><br>a,b=<span class="hljs-number">1</span>,<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment">#True</span><br><br>a,b=<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment">#True</span><br><br>a,b=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment">#True</span><br><br>a,b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment">#False</span><br><br>a,b=<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span><br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br><span class="hljs-comment">#True</span><br></code></pre></td></tr></table></figure><h3 id="引用次数"><a href="#引用次数" class="headerlink" title="引用次数"></a>引用次数</h3><p>在Python中，每个对象都存有指向该对象的引用总数，即引用次数（reference count）</p><p>使用sys包中的gatrefcount(),来查看引用次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> getrefcount<br>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(getrefcount(a))<br>b=a<br><span class="hljs-built_in">print</span>(getrefcount(b))<br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)<br>c=[a,a]<br><span class="hljs-built_in">print</span>(getrefcount(a))<br><span class="hljs-built_in">print</span>(c <span class="hljs-keyword">is</span> a)<br><span class="hljs-comment">#Result:</span><br><span class="hljs-comment">#2</span><br><span class="hljs-comment">#3</span><br><span class="hljs-comment">#True</span><br><span class="hljs-comment">#5</span><br><span class="hljs-comment">#False</span><br></code></pre></td></tr></table></figure><h3 id="引用环"><a href="#引用环" class="headerlink" title="引用环"></a>引用环</h3><p>两个对象可能互相引用，从而构成引用环（Reference cycle）</p><p>即使是一个对象，只需要自己引用自己，也能构成引用环</p><p>对回收内存带来麻烦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> getrefcount<br>a=[]<br>b=[a]<br>a.append(b)<br><span class="hljs-built_in">print</span>(getrefcount(a),getrefcount(b))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a),<span class="hljs-built_in">id</span>(b))<br><span class="hljs-comment">#Result:</span><br><span class="hljs-comment">#3 3</span><br><span class="hljs-comment">#4319390848 4319390784</span><br></code></pre></td></tr></table></figure><p>回收内存</p><p>对象越多，内存越大，使用del(a)清楚没用的对象</p><p>垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>Python程序由包，模块，函数组成</p></li><li><p>包是模块组成的集合</p></li><li><p>模块是处理一类问题的函数与类的集合</p></li><li><p>函数是可以重复使用，用来实现单一，或相关联功能的代码块</p></li><li><p>函数能提高应用的模块性以及代码的重复利用率</p></li></ul><h2 id="示范"><a href="#示范" class="headerlink" title="示范"></a>示范</h2><p>函数以def开头，加上名字还有括号内需要传递的变量</p><p>与if一样用:</p><p>也是用return 返回值 结束，没有则返回None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Showname</span>(<span class="hljs-params">name</span>):<br><span class="hljs-string">&#x27;&#x27;&#x27;this function is to show name&#x27;&#x27;&#x27;</span><span class="hljs-comment">#文档字符串存放函数说明</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am %s&#x27;</span> %(name))<br>Showname(<span class="hljs-string">&#x27;Maverick&#x27;</span>)<br><span class="hljs-comment">#Result:</span><br><span class="hljs-comment">#I am Maverick</span><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>形参：</p><p><strong>形式参数</strong>，不占内存，只有在调用时才分配内存单元，目的是函数调用时接受实参</p><p>实参：</p><p><strong>实际参数</strong>，调用函数时传给函数的参数，可以是常量，变量，表达式，函数，传给形参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">a</span>):<br>a=<span class="hljs-number">2</span><br>b=<span class="hljs-number">1</span><br>charge(b)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment">#Result:</span><br><span class="hljs-comment">#1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">charge</span>(<span class="hljs-params">a</span>):<br>a.append(<span class="hljs-number">2</span>)<br>b=[<span class="hljs-number">1</span>]<br>charge(b)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment">#Result:</span><br><span class="hljs-comment">#[1, 2]</span><br></code></pre></td></tr></table></figure><p>如果参数应用的对象本身是<strong>不可变</strong>的，如数值，字符串，元组，则在函数中对形参的修改<strong>不会影响</strong>到实参</p><p>如果参数应用的对象本身是<strong>可变</strong>的，如列表，字典 则在函数中对形参的修改<strong>会影响</strong>到实参</p><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><table><thead><tr><th align="center">参数类型</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">位置</td><td align="center">调用时根据函数定义的参数位置来传递</td></tr><tr><td align="center">默认</td><td align="center">用于定义参数，提供默认值</td></tr><tr><td align="center">可变</td><td align="center">传入参数个数可变</td></tr><tr><td align="center">关键字</td><td align="center">用于函数调用，通过键值形式加以指定，可以让函数更清晰，容易使用，同时清除参数的顺序要求</td></tr><tr><td align="center">命名关键字</td><td align="center">在*之后的参数只能通过关键字参数传递</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#位置参数</span><br><span class="hljs-comment">#位置固定。参数个数确认后，传入参数需要与之相同</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">word</span>(<span class="hljs-params">greeting,name</span>):<br><span class="hljs-built_in">print</span>(greeting, name+<span class="hljs-string">&#x27;!&#x27;</span>)<br>word(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>)<br><span class="hljs-comment">#Result</span><br><span class="hljs-comment">#Hello Jack!</span><br><br><span class="hljs-comment">#默认参数</span><br><span class="hljs-comment">#当参数没有实际传递的值时，函数将使用默认参数计算</span><br><span class="hljs-comment">#带默认值的参数需在无默认值的后面</span><br><span class="hljs-comment">#默认参数最好指向不变对象</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">word</span>(<span class="hljs-params">name, greeting=<span class="hljs-string">&#x27;hi&#x27;</span></span>):<br><span class="hljs-built_in">print</span>(greeting, name+<span class="hljs-string">&#x27;!&#x27;</span>)<br>word(<span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><span class="hljs-comment">#Result</span><br><span class="hljs-comment">#Hello Jack!</span><br><br><span class="hljs-comment">#默认参数#2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">word</span>(<span class="hljs-params">name, greeting=[]</span>):<br>greeting.append(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-built_in">print</span>(greeting, name+<span class="hljs-string">&#x27;!&#x27;</span>)<br>word(<span class="hljs-string">&#x27;Jack&#x27;</span>)<br>word(<span class="hljs-string">&#x27;rose&#x27;</span>,[<span class="hljs-string">&#x27;hi&#x27;</span>])<br>word(<span class="hljs-string">&#x27;mary&#x27;</span>)<br><span class="hljs-comment">#Result</span><br><span class="hljs-comment">#[&#x27;hello&#x27;] Jack!</span><br><span class="hljs-comment">#[&#x27;hi&#x27;, &#x27;hello&#x27;] rose!</span><br><span class="hljs-comment">#[&#x27;hello&#x27;, &#x27;hello&#x27;] mary!</span><br><br><span class="hljs-comment">#可变参数</span><br><span class="hljs-comment">#处理比声名多的参数</span><br><span class="hljs-comment">#*表示元组类型参数，**表示字典类型参数</span><br><span class="hljs-comment">#字典类型参数在元组类型后</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">word</span>(<span class="hljs-params">name, *greeting,**name1</span>):<br><span class="hljs-built_in">print</span>(greeting, name+<span class="hljs-string">&#x27;!&#x27;</span>,name1)<br>word(<span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-string">&#x27;Hi&#x27;</span>,<span class="hljs-string">&#x27;Nice to meet u&#x27;</span>)<br><span class="hljs-comment">#Result</span><br><span class="hljs-comment">#(&#x27;Hi&#x27;, &#x27;Nice to meet u&#x27;) Jack! &#123;&#125;</span><br><br><span class="hljs-comment">#关键字参数</span><br><span class="hljs-comment">#调用参数时，使用param=value的方式传递参数</span><br><span class="hljs-comment">#清晰指出参数值，提高程序可读性</span><br><span class="hljs-comment">#参数顺序不重要</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">word</span>(<span class="hljs-params">name, greeting,name1</span>):<br><span class="hljs-built_in">print</span>(greeting, name+<span class="hljs-string">&#x27;!&#x27;</span>,name1)<br>word(greeting=<span class="hljs-string">&#x27;Jack&#x27;</span>,name=<span class="hljs-string">&#x27;hello&#x27;</span>,name1=<span class="hljs-string">&#x27;rose&#x27;</span>)<br><span class="hljs-comment">#Result</span><br><span class="hljs-comment">#Jack hello! rose</span><br><br><span class="hljs-comment">#命名关键字参数</span><br><span class="hljs-comment">#必须传入参数名（不传报错</span><br><span class="hljs-comment">#若已有一个可变参数，则后面命名关键字参数不需要分隔符*</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">word</span>(<span class="hljs-params">name,*, greet=<span class="hljs-string">&#x27;hi&#x27;</span>,word</span>):<br><span class="hljs-built_in">print</span>(greet, name,word)<br>word(<span class="hljs-string">&#x27;TOM&#x27;</span>,greet=<span class="hljs-string">&#x27;hello&#x27;</span>,word=<span class="hljs-string">&#x27;how are you&#x27;</span>)<br>word(<span class="hljs-string">&#x27;TOM&#x27;</span>,word=<span class="hljs-string">&#x27;how are you&#x27;</span>)<br><span class="hljs-comment">#Result</span><br><span class="hljs-comment">#hello TOM how are you</span><br><span class="hljs-comment">#hi TOM how are you</span><br></code></pre></td></tr></table></figure><p>在Python中，参数定义顺序必须是：</p><p>位置参数，默认参数，可变参数，命名关键字参数，关键字参数</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在python中创建，改变，查找变量名时，都在一个保存变量名的空间中进行，我们称为命名空间，也叫<strong>作用域</strong></p><p>。。。</p><p>先写这么多</p><p>夏令营回来后补上吧</p><p>看看有没有心情写写算法</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C速转Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/Blogs/2025/08/28/Docker/"/>
    <url>/Blogs/2025/08/28/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-简介和安装"><a href="#Docker-简介和安装" class="headerlink" title="Docker 简介和安装"></a>Docker 简介和安装</h1><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1">视频教程</a></p></blockquote><h3 id="跟普通虚拟机的对比"><a href="#跟普通虚拟机的对比" class="headerlink" title="跟普通虚拟机的对比"></a>跟普通虚拟机的对比</h3><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h3><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包<br><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装<br><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。<br><img src="https://cos.easydoc.net/46901064/files/kv7rlicu.png" alt="image.png"></p><h3 id="Docker-部署的优势"><a href="#Docker-部署的优势" class="headerlink" title="Docker 部署的优势"></a>Docker 部署的优势</h3><p>常规应用开发部署方式：自己在 Windows 上开发、测试 –&gt; 到 Linux 服务器配置运行环境部署。</p><blockquote><p>问题：我机器上跑都没问题，怎么到服务器就各种问题了</p></blockquote><p>用 Docker 开发部署流程：自己在 Windows 上开发、测试 –&gt; 打包为 Docker 镜像（可以理解为软件安装包） –&gt; 各种服务器上只需要一个命令部署好</p><blockquote><p>优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。</p></blockquote><p>例如 <a href="https://easydoc.net/">易文档</a>，<a href="https://svnbucket.com/">SVNBucket</a> 的私有化部署就是用 Docker，轻松应对客户的各种服务器。</p><h3 id="Docker-通常用来做什么"><a href="#Docker-通常用来做什么" class="headerlink" title="Docker 通常用来做什么"></a>Docker 通常用来做什么</h3><ul><li>应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用</li><li>快速安装测试&#x2F;学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis &#x2F; MongoDB &#x2F; ElasticSearch &#x2F; ELK</li><li>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</li><li>Windows 上体验&#x2F;学习各种 Linux 系统</li></ul><h3 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h3><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>桌面版：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a><br>服务器版：<a href="https://docs.docker.com/engine/install/#server">https://docs.docker.com/engine/install/#server</a></p><h3 id="启动报错解决"><a href="#启动报错解决" class="headerlink" title="启动报错解决"></a>启动报错解决</h3><p>报错截图<br><img src="https://cos.easydoc.net/46901064/files/kvacsk82.png" alt="image.png"></p><p><strong>解决方法</strong>：<br>控制面板-&gt;程序-&gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)<br><img src="https://cos.easydoc.net/46901064/files/kvactn57.png" alt="image.png"></p><p><strong>命令行安装 Linux 内核</strong><br><code>wsl.exe --install -d Ubuntu</code></p><blockquote><p>你也可以打开微软商店 Microsoft Store 搜索 Linux 进行安装，选择一个最新版本的 Ubuntu 或者 Debian 都可以</p></blockquote><blockquote><p>上面命令很可能你安装不了，微软商店你也可能打不开，如果遇到这个问题，参考：<a href="https://blog.csdn.net/qq_42220935/article/details/104714114">https://blog.csdn.net/qq_42220935/article/details/104714114</a></p></blockquote><p><strong>设置开机启动 Hypervisor</strong><br><code>bcdedit /set hypervisorlaunchtype auto</code></p><blockquote><p>注意要用管理员权限打开 PowerShell</p></blockquote><p><strong>设置默认使用版本2</strong><br><code>wsl.exe --set-default-version 2</code></p><p><strong>查看 WSL 是否安装正确</strong><br><code>wsl.exe --list --verbose</code><br>应该如下图，可以看到一个 Linux 系统，名字你的不一定跟我的一样，看你安装的是什么版本。<br>并且 VERSION 是 2<br><img src="https://cos.easydoc.net/46901064/files/ldxvkks2.png" alt="image.png"></p><p><strong>确保 BIOS 已开启虚拟化，下图检查是否已开启好</strong></p><blockquote><p>如果是已禁用，请在开机时按 F2 进入 BIOS 开启一下，不会设置的可以网上搜索下自己主板的设置方法，Intel 和 AMD 的设置可能稍有不同</p></blockquote><p><img src="https://cos.easydoc.net/46901064/files/kvaf7ody.png" alt="image.png"></p><p><strong>出现下图错误，点击链接安装最新版本的 WSL2</strong><br><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a><br><img src="https://cos.easydoc.net/46901064/files/kvajwvuw.png" alt="image.png"></p><h3 id="镜像加速源"><a href="#镜像加速源" class="headerlink" title="镜像加速源"></a>镜像加速源</h3><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td><a href="https://ud6340vz.mirror.aliyuncs.com/">https://ud6340vz.mirror.aliyuncs.com</a></td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]<br></code></pre></td></tr></table></figure><p><img src="https://cos.easydoc.net/46901064/files/l25jdwrn.png" alt="1.png"></p><blockquote><p>觉得老师讲得不错的话，记得点赞、关注、分享，鼓励下老师<br>你们的鼓励会让老师更加有动力继续创造更多更好的内容</p></blockquote><p>你可以到 <a href="https://github.com/gzyunke/test-docker/issues">Github issue</a> 给我提问或反馈遇到的问题。</p><p>[[1使用说明]]</p><p>[[2Docker构建镜像]]</p><p>[[3目录挂载]]</p><p>[[4多容器通信]]</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker构建镜像</title>
    <link href="/Blogs/2025/08/28/Docker%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <url>/Blogs/2025/08/28/Docker%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="为自己的-Web-项目构建镜像"><a href="#为自己的-Web-项目构建镜像" class="headerlink" title="为自己的 Web 项目构建镜像"></a>为自己的 Web 项目构建镜像</h3><p>示例项目代码：<a href="https://github.com/gzyunke/test-docker">https://github.com/gzyunke/test-docker</a><br>这是一个 Nodejs + Koa2 写的 Web 项目，提供了简单的两个演示页面。<br>软件依赖：<a href="https://nodejs.org/zh-cn/">nodejs</a><br>项目依赖库：koa、log4js、koa-router</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=3">视频教程</a></p></blockquote><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写 Dockerfile"></a>编写 Dockerfile</h3><p><code>FROM node:11 MAINTAINER easydoc.net  # 复制代码 ADD . /app  # 设置容器启动后的默认运行目录 WORKDIR /app  # 运行命令，安装依赖 # RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。 # 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs RUN npm install --registry=https://registry.npm.taobao.org  # CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。 # 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。 # 例如 CMD cd /app &amp;&amp; ./start.sh CMD node app.js</code></p><p><a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile文档</a></p><blockquote><p>实用技巧：<br>如果你写 Dockerfile 时经常遇到一些运行错误，依赖错误等，你可以直接运行一个依赖的底，然后进入终端进行配置环境，成功后再把做过的步骤命令写道 Dockerfile 文件中，这样编写调试会快很多。<br>例如上面的底是<code>node:11</code>，我们可以运行<code>docker run -it -d node:11 bash</code>，跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了。<br>掌握好这个技巧，你的 Dockerfile 文件编写起来就非常的得心应手了。</p></blockquote><h3 id="Build-为镜像（安装包）和运行"><a href="#Build-为镜像（安装包）和运行" class="headerlink" title="Build 为镜像（安装包）和运行"></a>Build 为镜像（安装包）和运行</h3><p>编译 <code>docker build -t test:v1 .</code></p><blockquote><p><code>-t</code> 设置镜像名字和版本号<br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p></blockquote><p>运行 <code>docker run -p 8080:8080 --name test-hello test:v1</code></p><blockquote><p><code>-p</code> 映射容器内端口到宿主机<br><code>--name</code> 容器名字<br><code>-d</code> 后台运行<br>命令参考文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p></blockquote><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker构建镜像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Embedded System</title>
    <link href="/Blogs/2025/08/28/Embedded%20System/"/>
    <url>/Blogs/2025/08/28/Embedded%20System/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>An embedded system is a microprocessor-based computer hardware system with software that is designed to perform a dedicated function, either as an independent system or as a part of a large system. At the core is an integrated circuit designed to carry out computation for real-time operations.</p><h1 id="Basic-structure-of-an-embedded-system"><a href="#Basic-structure-of-an-embedded-system" class="headerlink" title="Basic structure of an embedded system"></a>Basic structure of an embedded system</h1><h2 id="Sensor"><a href="#Sensor" class="headerlink" title="Sensor"></a>Sensor</h2><p>The sensor measures and converts the physical quantity to an electrical signal, which can then be read by an embedded systems engineer or any electronic instrument. A sensor stores the measured quantity to the memory.</p><h2 id="A-D-Converter-D-A-Converter"><a href="#A-D-Converter-D-A-Converter" class="headerlink" title="A-D Converter&#x2F;D-A Converter"></a>A-D Converter&#x2F;D-A Converter</h2><p>An analog-to-digital converter converts the analog signal sent by the sensor into a digital signal.<br>A digital-to-analog converter changes the digital data fed by the processor to analog data</p><h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><p>An actuator compares the output given by the D-A Converter to the actual output stored and stores the approved output.</p><h2 id="Processor-MCU"><a href="#Processor-MCU" class="headerlink" title="Processor (MCU)"></a>Processor (MCU)</h2><p>Processors assess the data to measure the output and store it to the memory.</p><ul><li>Clock - keeps everything synchronised - 80 MHzfor our mbed</li><li>CPU – the heart of the microcontroller – the ARM Cortex-M4is core in the mbed</li><li>Instruction decoder – controlsthe chip, carries out actions for</li><li>Input&#x2F;output ports – serial, parallel, digital, analogue, Pulse Width Modulation (PWM) etc</li><li>Memory – program and data</li></ul><h2 id="不同种类的处理器"><a href="#不同种类的处理器" class="headerlink" title="不同种类的处理器"></a>不同种类的处理器</h2><h3 id="CPU（Central-Processing-Unit）"><a href="#CPU（Central-Processing-Unit）" class="headerlink" title="CPU（Central Processing Unit）"></a>CPU（Central Processing Unit）</h3><p>中央处理器，内部分成了控制器CU和运算器ALU (Arithmetic logic unit)，数据来了，会先放到内存，控制器会从内存拿相应数据给到运算器进行运算，并会将结果返回到内存。当然，这只是简化的解释，实际会有取指令阶段、指令译码阶段、执行指令阶段、访存取数和结果写回等步骤</p><h3 id="GPU-Graphics-Processing-Unit"><a href="#GPU-Graphics-Processing-Unit" class="headerlink" title="GPU (Graphics Processing Unit)"></a>GPU (Graphics Processing Unit)</h3><p>图形处理，主要擅长做类似图像处理这样的，计算密度大，数据间相关性小的并行计算。这是因为GPU在设计时，不像CPU将大部分区域用于数据存储和控制，而是给计算单元分配了更多区域。这样可以为并行计算的每个数据单元执行相同程序，不需要繁琐的流程控制而提高计算能力。</p><h3 id="MCU-Moderate"><a href="#MCU-Moderate" class="headerlink" title="MCU (Moderate)"></a>MCU (Moderate)</h3><p>An MCU is an intelligent semiconductor IC that consists of a processor unit, memory modules, communication interfaces and peripherals.</p><h3 id="ASIC（专用集成电路）-Specific"><a href="#ASIC（专用集成电路）-Specific" class="headerlink" title="ASIC（专用集成电路）(Specific)"></a>ASIC（专用集成电路）(Specific)</h3><p>An application-specific integrated circuit, or ASIC for short, is a chip created for a particular use or application, rather than for general-purpose use. They are usually made using silicon technology. Because of their uniqueness, they come in a many flavors and types.</p><h3 id="FPGA-现场可编程门阵列-General"><a href="#FPGA-现场可编程门阵列-General" class="headerlink" title="FPGA (现场可编程门阵列)(General)"></a>FPGA (现场可编程门阵列)(General)</h3><p>field programmable gate arrays<br>是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。</p><h1 id="The-instruction-set"><a href="#The-instruction-set" class="headerlink" title="The instruction set"></a>The instruction set</h1><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><h3 id="CSIC-复杂指令集"><a href="#CSIC-复杂指令集" class="headerlink" title="CSIC (复杂指令集)"></a>CSIC (复杂指令集)</h3><p>– Complex all encompassing instruction set</p><p>– Many microprocessors</p><p>– Some instructions are single clock cycle, more complex ones are several cycles (power vs. speed)</p><h3 id="RISC（精简指令集）"><a href="#RISC（精简指令集）" class="headerlink" title="RISC（精简指令集）"></a>RISC（精简指令集）</h3><p>– Reduced instruction set of more simple commands</p><p>– Many microcontrollers</p><p>– Most commands operate in fewer clock cycles</p><p>– Pipelined architecture common</p><h2 id="The-instructions-for-the-CPU"><a href="#The-instructions-for-the-CPU" class="headerlink" title="The instructions for the CPU"></a>The instructions for the CPU</h2><h3 id="Machine-language"><a href="#Machine-language" class="headerlink" title="Machine language"></a>Machine language</h3><p>– Fundamental basic instructions (instruction code)</p><p>– 10000000 : Or 0x80 : Add register B to accumulator</p><p>– Very easy to make mistakes, can be made optimum</p><h3 id="Assembly-language（汇编语言）"><a href="#Assembly-language（汇编语言）" class="headerlink" title="Assembly language（汇编语言）"></a>Assembly language（汇编语言）</h3><p>– Mnenomics : ADD B</p><p>– Machine specific instructions</p><h3 id="Programming-language"><a href="#Programming-language" class="headerlink" title="Programming language"></a>Programming language</h3><p>– + : but this also contains a fetch from memory, load into register</p><p>B, fetch from memory and load into accumulator, add and then</p><p>output accumulator to memory instructions</p><p>– General, ‘easy’ to write, inefficient</p><p>Microcontroller: Everything (CPU, RAM, ROM, I&#x2F;O, and clock) on one chip. The memory (RAM&#x2F;ROM) is fixed and mounted on the chip</p><p>Microprocessor: CPU is stand-alone and RAM, ROM, I&#x2F;O, Clock are separate. Flexible in the amount of RAM&#x2F;ROM amount</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADCDAC</title>
    <link href="/Blogs/2025/08/28/ADCDAC/"/>
    <url>/Blogs/2025/08/28/ADCDAC/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟电路Analogue与数字电路Digital"><a href="#模拟电路Analogue与数字电路Digital" class="headerlink" title="模拟电路Analogue与数字电路Digital"></a>模拟电路Analogue与数字电路Digital</h1><p>[[模拟电路]]与[[数字电路]]</p><p>在现实世界中，常见的信号大都是模拟量，像温度、声音、气压等，但在信号的处理与传输中，为了减少噪声的干扰，较多使用的是数字量。因此我们经常会将现实中的模拟信号，通过 ADC 转换为数字信号进行运算、传输、储存，再通过 DAC 转换为模拟信号，呈现出来。</p><h2 id="数字电路与模拟电路"><a href="#数字电路与模拟电路" class="headerlink" title="数字电路与模拟电路"></a>数字电路与模拟电路</h2><h3 id="数字电路"><a href="#数字电路" class="headerlink" title="数字电路"></a>数字电路</h3><ul><li>用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。存储器是用来存储二进值数据的数字电路。</li><li>电路结构简单，稳定可靠。数字电路只要能区分高电平和低电平即可， 对元件的精度要求不高，因此有利于实现数字电路集成化。</li><li>数字信号在传递时采用高、低电平两个值，因此数字电路抗干扰能力强，不易受外界干扰。数字电路不仅能完成数值运算，还可以进行逻辑运算和判断，因此数字电路又称为数字逻辑电路。</li><li>数字电路中元件处于开关状态，功耗较少。<br>由于数字电路具有以上特点，故发展十分迅速，在计算机、数字通信、数字仪器及家用电器等技术领域中得到广泛的应用。</li></ul><h3 id="模拟电路"><a href="#模拟电路" class="headerlink" title="模拟电路"></a>模拟电路</h3><ul><li>模拟电路是处理模拟信号的电路；数字电路是处理数字信号的电路。模拟信号是关于时间的函数，是一个连续变化的量。数字信号则是离散的量。</li></ul><h1 id="ADC-Analogue-to-digital-converters"><a href="#ADC-Analogue-to-digital-converters" class="headerlink" title="ADC(Analogue to digital converters)"></a>ADC(Analogue to digital converters)</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>采样～保持～量化～编码</p><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>输入的模拟信号是连续的，而将要输出的数字信号是离散的，所以只能进行瞬时采样，再将采样值转换为输出的数字量，再重新开始下一轮的采样。</p><p>为了能准确无误用信号 v_svs 表示出模拟输入信号 v_1v1，至少需要满足采样定理（Nyquist-Shannon theorem），即采样频率 f_sfs 在模拟输入信号最高频率分量fi(max) 的 2 倍以上(通常会取 3~5 倍，但太高的频率需要更快的工作速度，需要综合成本考虑)</p><p>The number of samples per second is called sample rate.</p><p>Basically, the sampler converts the continuous-time-continuous amplitude signal into a continuous amplitude- discrete time signal.</p><h2 id="保持"><a href="#保持" class="headerlink" title="保持"></a>保持</h2><p>保持电路能够采样结束后，让信号保持一段时间，使 ADC 有充分时间进行转换。一般采样脉冲频率越高、采样越密，采样值就越多，采样保持电路的输出信号就越接近输入信号的波形。</p><p>It holds the first sample until the next sample comes from the sampler.</p><p>Once the new sample comes from the sampler to the holding circuit it releases the old sample to its next block.</p><h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p>采样得到的数字量，必须为某个规定的最小数值单位的整数倍，这个转换过程称为量化，所取的最小数量单位称为量化单位 Δ。数字信号最低有效位 LSB 的 1 所代表的数量大小就等于 Δ。</p><p>因为模拟电压是连续的，不一定能被 Δ 整除，因此会出现量化误差。量化级越细，量化误差就越小，所用二进制代码的位数就越多，电路也越复杂。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li>将量化的结果用二进制(或其他进制)表示出来，称为编码。</li><li>The output from the encoder is fed to the next circuitry. Here, is the end of the analog to a digital circuit.For n bit ADC, the number of 2^n divisions are available.</li><li>If “Vref” the reference input voltage, then an analog division (level) for Va can be obtained by D(out)&#x3D;2^n*Va&#x2F;Vref （n是bit位，Va是输出</li></ul><h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><p>Bit depth (resolution) is how much accuracy can an analog to digital converter can convert the signal from analog to digital.</p><p>The sample rate of an ADC is how fast an ADC can convert the signal from analog to digital.</p><p>5种ADC packages</p><ul><li>Sigma-delta</li><li>Succesive approximation（SAR）</li><li>Pipelined</li><li>Dual-slope</li><li>Flash</li></ul><h1 id="DAC-Digital-to-Analog-Converter"><a href="#DAC-Digital-to-Analog-Converter" class="headerlink" title="DAC(Digital to Analog Converter)"></a>DAC(<strong>Digital to Analog Converter</strong>)</h1><p>DAC is used to change digital signals to continuous analogue signals that are then used by the peripherals attached to the microcontroller&#x2F;microprocessor. </p><p>Digital signal is discrete in time and amplitude or mostly available in the form of binary such as 0 or 1. A DAC converts usually a fixed-point binary number into a physical quantity (e.g., a voltage). In particular, DACs are often used to convert discrete time series data to a continually varying physical signal.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>Generally, the digital to analog converter or DAC allows <strong>multiple inputs</strong> and <strong>a single output</strong>.</li><li>converts the <strong>discrete time-discrete amplitude signal</strong> into a <strong>continuous time-continuous amplitude signal</strong>.</li><li>In the analog to digital conversion (ADC) process <strong>signal cutting or power removal happens</strong> whereas in the digital to analog conversion (DAC) <strong>signal or power addition happens</strong>.</li></ul><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>二进制信号（以八位为例）</p><p>00001010&#x3D;2^3+2^1</p><h3 id="Weighted-Resistors-Method"><a href="#Weighted-Resistors-Method" class="headerlink" title="Weighted Resistors Method"></a><strong>Weighted Resistors Method</strong></h3><h3 id="R-2RMethod"><a href="#R-2RMethod" class="headerlink" title="R_2RMethod"></a>R_2RMethod</h3><p>特点是简单粗暴，从低位到高位用电阻让电流呈2的幂数改变。但是这个电路很难做到高的位数，若是一个8位的dac，最大的电阻达到了最小电阻的128倍，如果最小的电阻有10k，最大就有1MΩ多，这个电阻可不好做准确，而且尽管只用几个电阻，但是每个电阻阻值都不一样，在使用这种方法的时候有一种叫做双权电阻的方法，减少了电阻种类和大电阻，但是仍然无法避免最大电阻的需求。</p><p><img src="https://pic2.zhimg.com/80/v2-2241f4d952185bcf5e5e9a613972528d_1440w.webp" alt="img"></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul><li>Input Circuit</li><li>Voltage Switching Circuit </li><li>Resistive Network</li><li>Amplifier</li></ul><h2 id="input-Circuit（输入电路）"><a href="#input-Circuit（输入电路）" class="headerlink" title="input Circuit（输入电路）"></a>input Circuit（输入电路）</h2><p>It receives the binary digital inputs safely and does some filtration if required. It does not have any vital role in the whole circuit.</p><h2 id="Voltage-Switching-Circuit-电压切换电路"><a href="#Voltage-Switching-Circuit-电压切换电路" class="headerlink" title="Voltage Switching Circuit(电压切换电路)"></a>Voltage Switching Circuit(电压切换电路)</h2><p>It switches voltages between input digital signals and reference voltage sources and passes to the main resistive circuit. It also makes connection or isolation with the ground.</p><h2 id="Resistive-Network（电阻网络）"><a href="#Resistive-Network（电阻网络）" class="headerlink" title="Resistive Network（电阻网络）"></a>Resistive Network（电阻网络）</h2><p>It is the main part of the DAC circuit.</p><p>It basically helps to multiple digital input processing before the amplifier circuit. There are two types of DAC available according to the resistive network</p><ul><li>weighted resistor network</li><li>R-2R network.</li></ul><h2 id="Amplifier（放大器）"><a href="#Amplifier（放大器）" class="headerlink" title="Amplifier（放大器）"></a>Amplifier（放大器）</h2><p>Generally, a differential or operational amplifier is used in the DAC system. That not only amplifies the signal even it process signal such as summation.</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADCDAC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I2C</title>
    <link href="/Blogs/2025/08/28/I2C/"/>
    <url>/Blogs/2025/08/28/I2C/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>I2C（内部集成电路）是一种串行通信协议，允许将多个设备连接到一条总线上</p><h2 id="I2C物理层"><a href="#I2C物理层" class="headerlink" title="I2C物理层"></a><strong>I2C物理层</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-13f2e9e79052fab366696994d2cf85d9_1440w.jpg"></p><p>·它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个I2C通讯总线中，可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机。</p><p>·一个I2C总线只使用两条总线线路，一条双向串行数据线(SDA)，一条串行时钟线(SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p><p>·每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p><p>·总线通过上拉电阻接到电源。当I2C设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p><p>·多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p><p>·具有三种传输模式：标准模式传输速率为100kbit&#x2F;s，快速模式为400kbit&#x2F;s，高速模下可达3.4Mbit&#x2F;s，但目前大多I2C设备尚不支持高速模式。</p><h2 id="I2C协议层"><a href="#I2C协议层" class="headerlink" title="I2C协议层"></a><strong>I2C协议层</strong></h2><p>以主机向从机写数据为例，其基本结构如图所示，依次为：<br><strong>起始信号——从机地址——读写信号——数据位——应答位——… … ——停止位</strong></p><p><img src="https://pic2.zhimg.com/80/v2-1731c80f7c957ba510ac073e50483705_1440w.webp"></p><p>起始信号(S)：当 SCL 线是高电平时，SDA 线从高电平向低电平切换；停止信号(P)：当 SCL 是高电平时，SDA 线由低电平向高电平切换。</p><p><img src="https://pic3.zhimg.com/80/v2-2e7da749509983984c037ea57c151222_1440w.webp"></p><p>帧地址：I2C总线上的每个设备都有自己的独立地址，主机发起通讯时，通过SDA信号线发送设备地址(SLAVE_ADDRESS)来查找从机。I2C协议规定设备地址可以是7位或10位，实际中7位的地址应用比较广泛。</p><p>I2C使用SDA信号线来传输数据，使用SCL信号线进行数据同步。SDA数据线在SCL的每个时钟周期传输一位数据。传输时，SCL为高电平的时候SDA表示的数据有效，即此时的SDA为高电平时表示数据“1”，为低电平时表示数据“0”。当SCL为低电平时，SDA的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做好准备。</p><p>I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。</p><p>作为数据接收端时，当设备(无论主从机)接收到I2C传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输。</p><h2 id="I2C功能框图剖析"><a href="#I2C功能框图剖析" class="headerlink" title="I2C功能框图剖析"></a><strong>I2C功能框图剖析</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-81bbae342cab337627cf272b44db67b5_1440w.webp"></p><p><strong>时钟控制逻辑：</strong></p><p>SCL线的时钟信号，由I2C接口根据时钟控制寄存器(CCR)控制，控制的参数主要为时钟频率。配置I2C的CCR寄存器可修改通讯速率相关的参数。</p><p>可选择I2C通讯的“标准&#x2F;快速”模式，这两个模式分别I2C对应100&#x2F;400Kbit&#x2F;s的通讯速率。</p><p>在快速模式下可选择SCL时钟的占空比，可选Tlow&#x2F;Thigh&#x3D;2或Tlow&#x2F;Thigh&#x3D;16&#x2F;9模式，我们知道I2C协议在SCL高电平时对SDA信号采样，SCL低电平时SDA准备下一个数据，修改SCL 的高低电平比会影响数据采样，但其实这两个模式的比例差别并不大，若不是要求非常严格，随便选就可以了。</p><p>CCR寄存器中还有一个12位的配置因子CCR，它与I2C外设的输入时钟源共同作用，产生SCL时钟，STM32的I2C外设都挂载在APB1总线上，使用APB1的时钟源PCLK1，SCL信号线的输出时钟公式如下：</p><p><img src="https://pic1.zhimg.com/80/v2-824476a9d0304a01ac3f4b15190abd08_1440w.webp"></p><p>例如，我们的PCLK1&#x3D;36MHz，想要配置400Kbit&#x2F;s的速率，计算方式如下：</p><p>PCLK时钟周期：TPCLK1 &#x3D; 1&#x2F;36000000</p><p>目标SCL时钟周期：TSCL &#x3D; 1&#x2F;400000</p><p>SCL时钟周期内的高电平时间：THIGH &#x3D; TSCL&#x2F;3</p><p>SCL时钟周期内的低电平时间：TLOW &#x3D; 2*TSCL&#x2F;3</p><p>计算CCR的值：CCR &#x3D; THIGH&#x2F;TPCLK1 &#x3D; 30</p><p>计算结果得出CCR为30，向该寄存器位写入此值则可以控制IIC的通讯速率为400KHz，其实即使配置出来的SCL时钟不完全等于标准的400KHz，IIC通讯的正确性也不会受到影响，因为所有数据通讯都是由SCL协调的，只要它的时钟频率不远高于标准即可。</p><p><strong>数据控制逻辑：</strong></p><p>I2C的SDA信号主要连到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线。当向外发送数据的时候，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过SDA信号线发送出去；当从外部接收数据的时候，数据移位寄存器把SDA信号线采样到的数据一位位地存储到“数据寄存器”中。若使能了数据校验，接收到的数据会经过PCE计算器运算，运算结果存储在“PEC 寄存器”中。当STM32的I2C工作在从机模式的时候，接收到设备地址信号时，数据移位寄存器会把接收到的地址与STM32的自身的“I2C地址寄存器”的值作比较，以便响应主机的寻址。STM32的自身I2C地址可通过修改“自身地址寄存器”修改，支持同时使用两个I2C设备地址，两个地址分别存储在OAR1和OAR2中。</p><p><strong>整体控制逻辑：</strong></p><p>整体控制逻辑负责协调整个I2C外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1&#x2F;CR2)”的参数而改变。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR1和SR2)”，我们只要读取这些寄存器相关的寄存器位，就可以了解I2C的工作状态。除此之外，控制逻辑还根据要求，负责控制产生I2C中断信号、DMA请求及各种I2C的通讯信号(起始、停止、响应信号等)。</p><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a><strong>通讯过程</strong></h2><p>使用I2C外设通讯时，在通讯的不同阶段它会对“状态寄存器(SR1及SR2)”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。</p><p><strong>从发送模式：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-933083b14613c8db15b7a9801e7bbf97_1440w.webp"></p><p><strong>从接收模式：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-cf186fae58138d2b2267c804ae49cfb3_1440w.webp"></p><h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>IC (Inter-Integrated Circuit) is a</p><ul><li><p>﻿﻿Synchronous</p></li><li><p>﻿﻿multi-master</p></li><li><p>﻿﻿multi-slave</p></li><li><p>﻿﻿packet switched</p></li><li><p>﻿﻿single-ended</p></li></ul><p>serial computer bus invented in 1982 by Philips Semiconductor</p><p>It is widely used for attaching <strong>lower-speed peripheral</strong> Is to processors and microcontrollers in <strong>short-distance, intra-board communication</strong>.</p><p>Inter-Integrated Circuit, or I2C</p><ul><li>﻿﻿I2C combines <strong>the best features of SPI and UART</strong>.</li><li>﻿﻿With I2C, we can <strong>connect multiple slaves to a single master</strong> (like SPI) and we can have multiple masters controlling single, or multiple slaves.</li><li>﻿﻿I2C is really useful when you want to have more than one microcontroller logging data to a single memory card or displaying text to a single LCD</li><li>Like UART communication, I2C only <strong>uses two wires</strong> to transmit data between devices</li></ul><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><ul><li>Half-duplex, synchronous, multi-master bus  </li><li>No chip select or arbitration logic required</li><li>Serial data (SDA) and Serial clock (SCL)</li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li>Each peripheral is known as a “node” and can act as either a <strong>master or a slave</strong></li><li>The master <strong>controls the data transfer</strong> and <strong>generates the clock signal</strong></li><li>The slave is any device addressed by the master</li><li><strong>More than one</strong> microcontroller can be connected to the bus, and they <strong>can claim the master role at different times</strong>.</li><li>The protocol uses the <strong>serial data line (SDA)</strong> and <strong>serial clock line (SCL) signals</strong> to support serial communication of 8-bit data bytes, 7- bit device addresses as well as control information</li><li>All data is <strong>transferred in blocks of 8 bits (a byte)</strong>, with no limit on the number of bytes that can be transferred in a message</li><li>Each byte is followed by a <strong>1 bit acknowledgement</strong> from the receiver.</li></ul><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>Master – the device that <strong>initiates communication and controls the clock</strong>.</p><ul><li><strong>Multiple masters</strong> are also supported on an I2C bus.</li></ul><p>Slave – <strong>a device on the bus that is read or written to</strong>, but does not initiate transmission or provide a clock.</p><p>Slave address – a unique and predetermined address for each slave on the bus.</p><ul><li>This address is used by the master to indicate which slave it wants to communicate with.</li></ul><p><strong>SDA (Serial Data)</strong> – The line for the master and slave to <strong>send and receive data</strong>.</p><p><strong>SCL (Serial Clock)</strong> – The line that <strong>carries the clock signal</strong>.</p><ul><li><p>I2C is a <strong>serial</strong> communication protocol, so data is transferred <strong>bit by bit</strong> along a single wire (the SDA line).</p></li><li><p>Like SPI, I2C is <strong>synchronous</strong>（同步的）, so the output of bits is synchronized to the sampling of bits by a clock signal shared between the master and the slave.</p></li><li><p>The clock signal is always <strong>controlled by the master</strong>.</p></li></ul><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p>The I2C standard is a serial interface implement with a two- wire link that can <strong>support multiple masters and multiple slaves</strong></p><p>I2C uses two bi directional open collector BJT or open drain of MOSFET lines</p><p>It behave like a switch and can have possibly two states- ON or OFF</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用I2C时，数据被转换成messages，messages则被分解为数据帧。每条messages都有一个地址帧，其中包含从站的二进制地址，以及一个或多个包含正在传输的数据的数据帧。该消息还包括每个数据帧之间的启动和停止条件，读&#x2F;写位和ACK &#x2F; NACK位：</p><p><img src="https://pic3.zhimg.com/80/v2-14fd1d6dd21de804e75ad773003a1216_720w.webp" alt="img"></p><p>启动条件：在SCL线路从高电平切换到低电平之前，SDA线路从高电平切换到低电平。</p><p>停止条件：SCL线路从低电平切换到高电平后，SDA线路从低电平切换到高电平。</p><p>地址帧：每个从站唯一的7或10位序列，用于在主站想与之通信时识别从站。</p><p>读&#x2F;写位：单个位，指定主器件是向从器件发送数据(低电压电平)还是从器件请求数据(高电压电平)。</p><p>ACK &#x2F; NACK位：消息中的每个帧后跟一个应答&#x2F;不应答位。<strong>如果成功接收到地址帧或数据帧，则从接收设备向发送方返回ACK位</strong>。</p><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a><strong>地址</strong></h4><p>I2C没有像SPI这样的从选择线，因此它需要另一种方法让从器件知道数据正在发送给它，而不是另一个从器件。它通过地址来做到这一点。地址帧始终是新消息中起始位之后的第一帧。</p><p>主设备将与其通信的从设备的地址发送给与其连接的每个从设备。然后，每个从设备将从主设备发送的地址与其自己的地址进行比较。如果地址匹配，则将低电压ACK位发送回主机。如果地址不匹配，则从器件不执行任何操作，SDA线保持高电平。</p><p>The LSB of the address byte is the direction control bit ◦ </p><ul><li>High &#x3D; read</li><li><em>Low &#x3D; write</em></li></ul><h4 id="读-写位"><a href="#读-写位" class="headerlink" title="读&#x2F;写位"></a><strong>读&#x2F;写位</strong></h4><p>地址帧在末尾包括一个位，用于通知从设备，主设备是想要向其写入数据还是从主设备接收数据。如果<strong>主设备想要向从设备发送数据，则读&#x2F;写位是低电平</strong>。如果主设备向从设备<strong>请求数据，则该位是高电平</strong>。</p><ul><li>When the master is <strong>writing</strong> to a slave, the master sends the 8-bits of data and the slave produces the ACK&#x2F;NACK signal.</li><li>When the master is <strong>reading</strong> from a slave, the slave sends the 8-bits of data and the master produces the ACK&#x2F;NACK</li></ul><p>signal.</p><h4 id="数据框架"><a href="#数据框架" class="headerlink" title="数据框架"></a><strong>数据框架</strong></h4><p>在主设备检测到来自从设备的ACK位之后，准备好发送第一个数据帧。</p><p>数据帧始终为8位长，并以最高有效位先发送。紧接着每个数据帧的ACK &#x2F; NACK位以验证帧已被成功接收。在发送下一个数据帧之前，主机或从机必须接收ACK位(取决于发送数据的人)。</p><p>在发送了所有数据帧之后，主设备可以向从设备发送停止条件以停止传输。<strong>停止条件是SCL线上从低电平到高电平转换后，SDA线上从低电平变为高电平，SCL线保持高电平</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h4><p>由于I2C使用寻址，因此可以从单个主设备控制多个从设备。<strong>使用7位地址，可以使用128(27)个唯一地址</strong>。使用10位地址并不常见，但提供1,024(210)个唯一地址。要将多个从器件连接到单个主器件，请像这样连接它们，使用4.7K欧姆上拉电阻将SDA和SCL线连接到Vcc</p><h4 id="多主多从"><a href="#多主多从" class="headerlink" title="多主多从"></a>多主多从</h4><p>多个主设备可以连接到单个从设备或多个从设备。当两个主设备尝试通过SDA线同时发送或接收数据时，同一系统中出现多个主设备的问题。为了解决这个问题，<strong>每个主设备需要在发送消息之前检测SDA线路是低还是高</strong>。如果SDA线为低电平，则表示另一个主控制器已控制总线，主控制器应等待发送消息。如果SDA线路很高，那么传输信息是安全的。要将多个主设备连接到多个从设备，请使用下图，使用4.7K欧姆上拉电阻将SDA和SCL线路连接到Vcc</p><h3 id="Clock-Stretching"><a href="#Clock-Stretching" class="headerlink" title="Clock Stretching"></a>Clock Stretching</h3><p>12C devices can <strong>slow down communication by stretching SCL</strong></p><ul><li>﻿﻿kind of flow control</li><li>﻿﻿If an addressed slave device is not ready to process more data it will stretch the clock</li></ul><p>﻿﻿The master will not be able to raise the clock line</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ol><li>主机向每一个连接的从设备发送数据，然后<strong>将SDA信号从高切换到低，之后在将SCL从高切换到低电平</strong>。</li></ol><p><img src="https://pic3.zhimg.com/80/v2-5d68fa57d49c5f936f35c9ff6960666a_720w.webp" alt="img"></p><ol start="2"><li>主设备向每个从设备发送它想要与之通信的从设备的7或10位<strong>地址，以及读&#x2F;写位</strong>：</li></ol><p><img src="https://pic4.zhimg.com/80/v2-b27296911924ff1f8cc4a45ca13604d7_720w.webp" alt="img"></p><ol start="3"><li>每个从设备将主设备发送的地址与其自己的地址进行比较。<strong>如果地址匹配，则从器件通过将SDA线拉低一位来返回ACK位</strong>。如果主设备的地址与从设备的地址<strong>不匹配，则从设备将SDA线保持为高电平</strong>。</li></ol><p><img src="https://pic2.zhimg.com/80/v2-a7609f6f52ffc96d92b806d106d40a19_720w.webp" alt="img"></p><ol start="4"><li>主设备<strong>发送或接收数据帧</strong>：</li></ol><p><img src="https://pic4.zhimg.com/80/v2-b5050de35cc69f96b49c1f0904f277b7_720w.webp" alt="img"></p><ol start="5"><li>在传输了每个数据帧之后，接收设备将另一个ACK位<strong>返回给发送方以确认成功接收到该帧</strong>：</li></ol><p><img src="https://pic2.zhimg.com/80/v2-d1158c854bfe5a8cdd2ae0313543d4f9_720w.webp" alt="img"></p><ol start="6"><li>要停止数据传输，主机通过在<strong>将SDA切换为高电平之前切换SCL为高电平来向从机发送停止条件</strong>：</li></ol><p><img src="https://pic1.zhimg.com/80/v2-c62ae09d5c6d58c6893ab249b36ae740_720w.webp" alt="img"></p><p>To stop the data transmission, the master sends a stop condition to the slave by <strong>switching SCL high  before switching SDA high</strong> </p><p><strong>Idle</strong> <strong>–</strong> when both SDA and SCL are held high by the pull-up resistors and no I2C device is attempting to communicate.</p><p><strong>Busy –</strong> when devices are driving the bus.</p><p><strong>Messages –</strong> how I2C information is transferred.</p><h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul><li><p>只使用两根电线</p></li><li><p>支持多个主服务器和多个从服务器</p></li><li><p>ACK &#x2F; NACK位确认每个帧都已成功传输</p></li><li><p>硬件没有UART那么复杂</p></li><li><p>众所周知且广泛使用的协议</p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul><li><p>数据传输速率比SPI慢</p></li><li><p>数据帧的大小限制为8位</p></li><li><p>实现比SPI更复杂的硬件</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/83941898">https://zhuanlan.zhihu.com/p/83941898</a></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I2C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVL和KCL分析</title>
    <link href="/Blogs/2025/08/28/KVL%E5%92%8CKCL%E5%88%86%E6%9E%90/"/>
    <url>/Blogs/2025/08/28/KVL%E5%92%8CKCL%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>1.<strong>基本定律​</strong>​<br>    <br>    - ​<strong>​KCL​</strong>​：节点电流代数和为零<br>    - ​<strong>​KVL​</strong>​：回路电压代数和为零<br><br>2. <strong>矩阵分析法​</strong>​<br>    <br>    |方法|适用场景|关键步骤|<br>    |—|—|—|<br>    |节点分析法|多节点电路|选参考点 → 列KCL方程 → 矩阵求解|<br>    |网孔分析法|多网孔电路|设网孔电流 → 列KVL方程 → 矩阵求解|<br>    |​<strong>​超节点​</strong>​|跨接电压源的节点|合并节点 → 添加约束方程 V1​−V2​&#x3D;Vs​|<br>    |​<strong>​超网孔​</strong>​|跨接电流源的网孔|绕过电流源 → 添加约束方程 I1​−I2​&#x3D;Is​||</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KVL和KCL分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言函数</title>
    <link href="/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/"/>
    <url>/Blogs/2025/08/28/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的使用可以使程序更加模块化，便于组织，而且可重复利用</p><h2 id="recusion"><a href="#recusion" class="headerlink" title="recusion"></a>recusion</h2><p>The process in which a function calls itself directly or indirectly is called recursion</p><h2 id="Function-Definition"><a href="#Function-Definition" class="headerlink" title="Function Definition"></a>Function Definition</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">return_type <span class="hljs-title function_">function_name</span> <span class="hljs-params">(parameters)</span> <br>&#123;<br>    <span class="hljs-comment">//body of the function</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Function-Declarations"><a href="#Function-Declarations" class="headerlink" title="Function Declarations"></a>Function Declarations</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">return_type <span class="hljs-title function_">name_of_the_function</span> <span class="hljs-params">(parameters)</span>; <br>return_type <span class="hljs-title function_">name_of_the_function</span> <span class="hljs-params">(<span class="hljs-type">int</span>[],<span class="hljs-type">int</span>)</span>; <br><span class="hljs-type">int</span> <span class="hljs-title function_">mystery</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> p)</span> ; <span class="hljs-comment">/* function prototype */</span><br></code></pre></td></tr></table></figure><h1 id="Define-Typedef"><a href="#Define-Typedef" class="headerlink" title="Define &amp; Typedef"></a>Define &amp; Typedef</h1><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><h3 id="两种定义方式"><a href="#两种定义方式" class="headerlink" title="两种定义方式"></a>两种定义方式</h3><ul><li>#define &lt;宏名&#x2F;标识符&gt; &lt;字符串&gt;</li><li>#define &lt;宏名&gt;(&lt;参数表&gt;) &lt;字符串&gt;</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> S(a,b) a*b</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX（a,b） （（a）&gt;（b）？（a）：（b））<span class="hljs-comment">//一定注意括号</span></span><br><br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>宏名一般用大写</li><li>宏定义末尾不加分号</li><li>可以用#undef命令终止宏定义的作用域</li><li>宏定义可以嵌套</li><li>字符串“ ”中永远不包含宏</li><li>宏替换在编译前进行，不分配内存，变量定义分配内存，函数调用在编译后程序运行时进行，并且分配内存</li><li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查</li><li>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义</li></ul><h3 id="冷门偏门"><a href="#冷门偏门" class="headerlink" title="冷门偏门"></a>冷门偏门</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Conn(x,y) x##y<span class="hljs-comment">//##的意思是连接</span></span><br><span class="hljs-type">int</span> n = Conn(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>); <span class="hljs-comment">//结果就是n=123456;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ToChar(x) #@x<span class="hljs-comment">//其实就是给x加上单引号，结果返回是一个constchar。</span></span><br><span class="hljs-type">char</span> a = ToChar(<span class="hljs-number">1</span>);<span class="hljs-comment">//结果就是a=&#x27;1&#x27;;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ToString(x) #x <span class="hljs-comment">//#x是给x加双引号</span></span><br><span class="hljs-type">char</span>* str = ToString(<span class="hljs-number">123132</span>);<span class="hljs-comment">//就成了str=&quot;123132&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C 语言提供了 <strong>typedef</strong> 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 <strong>BYTE</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BYTE;<br></code></pre></td></tr></table></figure><p>在这个类型定义之后，标识符 BYTE 可作为类型 <strong>unsigned char</strong> 的缩写，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BYTE  b1, b2;<br></code></pre></td></tr></table></figure><p>也可以对结构体使用(注意是<strong>最后</strong>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Books</span> &#123;   <span class="hljs-type">char</span>  title[<span class="hljs-number">50</span>];   <span class="hljs-type">char</span>  author[<span class="hljs-number">50</span>];   <span class="hljs-type">char</span>  subject[<span class="hljs-number">100</span>];   <span class="hljs-type">int</span>   book_id; &#125; Book;<br>Book b;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MOSFET</title>
    <link href="/Blogs/2025/08/28/MOSFET/"/>
    <url>/Blogs/2025/08/28/MOSFET/</url>
    
    <content type="html"><![CDATA[<p>​<strong>​MOS电容工作模式​</strong>​：</p><pre><code class="hljs">|偏压类型|P型衬底响应||---|---||VG​&lt;0|积累（空穴堆积）||VG​&gt;0|耗尽 → 反型（VG​=VT​ 时反型层形成）|</code></pre><ul><li>​<strong>​阈值电压 VT​​</strong>​：<br>  VT​&#x3D;Φms​+2∣ϕF​∣+Cox​4ϵs​eNA​∣ϕF​∣​​</li></ul>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
      <category>电子器件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOSFET</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdownguide</title>
    <link href="/Blogs/2025/08/28/Markdownguide/"/>
    <url>/Blogs/2025/08/28/Markdownguide/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-Markdown-guidedate-2020-03-25-21-42-34tags-小工具categories-技术"><a href="#title-Markdown-guidedate-2020-03-25-21-42-34tags-小工具categories-技术" class="headerlink" title="title: Markdown guidedate: 2020-03-25 21:42:34tags:- 小工具categories: 技术"></a>title: Markdown guide<br>date: 2020-03-25 21:42:34<br>tags:<br>- 小工具<br>categories: 技术</h2><p>转载自<a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html">siriusq</a></p><p>编写博客需要使用Markdown，因此需要熟记语法规则，虽然Markdown语法比较少，但是一个一个查起来也是很蛋疼的</p><span id="more"></span><p><strong>常用的Markdown语法规则有：</strong></p><ul><li><p>标题（我把标题扔到网页最后面了，目录被打乱了。。。）</p></li><li><p>字体加粗倾斜</p></li><li><p>引用</p></li><li><p>分割线</p></li><li><p>图片</p></li><li><p>超链接</p></li><li><p>列表</p></li><li><p>表格</p></li><li><p>代码</p></li><li><p>小文本</p></li><li><p>特殊字符转义</p></li><li><p>字体颜色大小</p></li><li><p>文本居中</p></li><li><p>勾选框</p></li><li><p>首行缩进</p></li><li><p>链接到其他文章</p></li><li><p>文字背景色</p></li><li><p>标签</p></li><li><p>选项卡</p></li><li><p>按钮</p></li></ul><h1 id="字体加粗倾斜"><a href="#字体加粗倾斜" class="headerlink" title="字体加粗倾斜"></a>字体加粗倾斜</h1><p>字体倾斜需要在文本两端各加一个<code>*</code>号<br>字体加粗需要在文本两端各加两个<code>*</code>号<br>字体同时倾斜加粗需要在文本两端各加三个<code>*</code>号<br>字体加入删除线需要在文本两端各加两个<code>~~</code></p><p><strong>示例</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*倾斜的文字*</span><br><span class="hljs-strong">**加粗的文字**</span><br><span class="hljs-strong">**<span class="hljs-emphasis">*倾斜加粗的文字*</span>**</span><br>~~加删除线的文字~~<br>++加下划线的文字++<br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><p><em>倾斜的文字</em><br><strong>加粗的文字</strong><br>*<strong>倾斜加粗的文字*</strong><br><del>加删除线的文字</del><br>++加下划线的文字++</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用需要在文本前加一个<code>&gt;</code>,引用可以嵌套，比如两个<code>&gt;&gt;</code>或三个<code>&gt;&gt;&gt;</code></p><p><strong>示例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">引用的文本</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; 嵌套的引用文本</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 再次嵌套的文本</span><br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><blockquote><p>引用的文本</p><blockquote><p>嵌套的引用文本</p><blockquote><p>再次嵌套的文本</p></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>分割线使用连续三个及以上的<code>*</code>或<code>-</code>实现，前后都有段落时各空出一行</p><p><strong>示例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">***</span><br><br><span class="hljs-string">*****</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">-----</span><br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><hr><hr><hr><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>使用链接形式插入图片</p><p><strong>语法</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[图片alt]</span>(图片url 图片title)<br></code></pre></td></tr></table></figure><p>其中<code>图片alt</code>为图片下面的文字，相当于注释，<code>图片url</code>为图片的地址，<code>图片title</code>为鼠标悬浮到图片上显示的内容，此项选填</p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>超链接形式和图片类似，删掉前面的<code>!</code>即可</p><h2 id="普通链接方法"><a href="#普通链接方法" class="headerlink" title="普通链接方法"></a>普通链接方法</h2><p><strong>语法</strong></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-name">超链接名称</span>](<span class="hljs-name">超链接地址</span> 超链接title)<br></code></pre></td></tr></table></figure><p><code>超链接title</code>选填，鼠标悬浮时显示</p><p><strong>示例</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[Github]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com github)</span><br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><p><a href="%5Bhttps://github.com%5D(https://github.com/">Github</a> Github)</p><h2 id="高级链接方法"><a href="#高级链接方法" class="headerlink" title="高级链接方法"></a>高级链接方法</h2><p><strong>示例</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">使用<span class="hljs-number">1</span>作为变量 [<span class="hljs-title class_">Github</span>][<span class="hljs-number">1</span>]<br>在末尾为<span class="hljs-number">1</span>赋值<br>[<span class="hljs-number">1</span>]<span class="hljs-symbol">:https</span><span class="hljs-symbol">://github</span>.com github<br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><p>使用1作为变量 <a href="https://github.com(https//github.com/)">Github</a><br>在末尾为1赋值</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表分为有序列表和无序列表,都可以嵌套，嵌套时在下一个列表前加<code>Tab</code>或加三个空格<br>其中有序列表使用符号<code>*</code>或<code>+</code>或<code>-</code>即可</p><p><strong>示例</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> C<br><span class="hljs-bullet">+</span> C++<br><span class="hljs-bullet">*</span> Java<br><br><span class="hljs-bullet">-</span> 嵌套1<br><span class="hljs-bullet">-</span> 嵌套2<br><span class="hljs-bullet">-</span> 嵌套3<br><br><span class="hljs-bullet">1.</span> C<br><span class="hljs-bullet">2.</span> C++<br><span class="hljs-bullet">3.</span> Java<br><br><span class="hljs-bullet">1.</span> 嵌套1<br><span class="hljs-bullet">1.</span> 嵌套2<br><span class="hljs-bullet">2.</span> 嵌套2（1）<br><span class="hljs-bullet">3.</span> 嵌套2（2）<br><span class="hljs-bullet">1.</span> 嵌套3<br><span class="hljs-bullet">2.</span> 嵌套3（1）<br><span class="hljs-bullet">2.</span> 嵌套2（3）<br><span class="hljs-bullet">2.</span> 嵌套1（1）<br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><ul><li><p>C</p></li><li><p>C++</p></li><li><p>Java</p></li><li><p>嵌套1</p><ul><li>嵌套1<ul><li>嵌套3</li></ul></li></ul></li></ul><ol><li><p>C</p></li><li><p>C++</p></li><li><p>Java</p></li><li><p>嵌套1</p><ol><li>嵌套2</li><li>嵌套2（1）</li><li>嵌套2（2）<ol><li>嵌套3</li><li>嵌套3（1）</li></ol></li><li>嵌套2（3）</li></ol></li><li><p>嵌套1（1）</p></li></ol><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><strong>示例</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">表头|<span class="hljs-string">表头</span>|<span class="hljs-string">表头</span><br><span class="hljs-string">-</span>|<span class="hljs-string">:-:</span>|<span class="hljs-string">-:</span><br><span class="hljs-string">内容</span>|<span class="hljs-string">内容</span>|<span class="hljs-string">内容</span><br><span class="hljs-string">内容</span>|<span class="hljs-string">内容</span>|<span class="hljs-string">内容</span><br></code></pre></td></tr></table></figure><p>其中第二行表示对齐方式</p><ul><li>默认为左对齐，只写<code>-</code></li><li>居中为<code>:-:</code></li><li>右对齐为<code>-:</code></li></ul><p><strong>预览效果</strong></p><table><thead><tr><th align="left">表头</th><th align="left">表头</th><th align="left">表头</th></tr></thead><tbody><tr><td align="left">内容</td><td align="left">内容</td><td align="left">内容</td></tr><tr><td align="left">内容</td><td align="left">内容</td><td align="left">内容</td></tr></tbody></table><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码使用反引号 <code> 表示，反引号是键盘左上角的</code>~&#96;键输入，而不是键盘右边的引号<br>连续三个反引号可以生成代码块，代码块后面的字符表示不同的语言类型，示例中多打了括号</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">`Hello World！`<br>(```cpp)<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    (```)<br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Hello World!<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码块语言说明"><a href="#代码块语言说明" class="headerlink" title="代码块语言说明"></a>代码块语言说明</h2><p>三个反引号后面的语言格式说明</p><table><thead><tr><th align="left">语言</th><th align="left">格式</th></tr></thead><tbody><tr><td align="left">Bash</td><td align="left">bash</td></tr><tr><td align="left">C#</td><td align="left">cs</td></tr><tr><td align="left">C语言</td><td align="left">cpp</td></tr><tr><td align="left">CSS</td><td align="left">css</td></tr><tr><td align="left">DOS</td><td align="left">dos</td></tr><tr><td align="left">Go</td><td align="left">go</td></tr><tr><td align="left">HTML</td><td align="left">xml</td></tr><tr><td align="left">ini</td><td align="left">ini</td></tr><tr><td align="left">Matlab</td><td align="left">matlab</td></tr><tr><td align="left">Markdown</td><td align="left">markdown</td></tr><tr><td align="left">makefile</td><td align="left">makefile</td></tr><tr><td align="left">Json</td><td align="left">json</td></tr><tr><td align="left">Java</td><td align="left">java</td></tr><tr><td align="left">JavaScript</td><td align="left">js &#x2F; javascript</td></tr><tr><td align="left">Objective-C</td><td align="left">objectivec</td></tr><tr><td align="left">PHP</td><td align="left">php</td></tr><tr><td align="left">PowerShell</td><td align="left">powershell</td></tr><tr><td align="left">Processing</td><td align="left">processing</td></tr><tr><td align="left">Python</td><td align="left">python</td></tr><tr><td align="left">R</td><td align="left">r</td></tr><tr><td align="left">Ruby</td><td align="left">ruby</td></tr><tr><td align="left">SQL</td><td align="left">sql</td></tr><tr><td align="left">Swift</td><td align="left">swift</td></tr><tr><td align="left">TeX</td><td align="left">tex</td></tr><tr><td align="left">VBScript</td><td align="left">vbscript</td></tr><tr><td align="left">VB.Net</td><td align="left">vbnet</td></tr><tr><td align="left">Vim Script</td><td align="left">vim</td></tr></tbody></table><h1 id="小文本"><a href="#小文本" class="headerlink" title="小文本"></a>小文本</h1><p>在文本两端分别加入<code>和</code>即可生成小文本</p><p><strong>示例</strong><br><code>小文本</code></p><p><strong>预览效果</strong></p><p>小文本</p><h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>在使用一些特殊符号(如<code>#</code>)时需要在符号前加<code>\</code>进行转义，否则符号不会正确显示</p><p><strong>示例</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\#</span><br><span class="hljs-string">\*</span><br><span class="hljs-string">\!</span><br><span class="hljs-string">\+</span><br><span class="hljs-string">\-</span><br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><p>#<br>*<br>!<br>+<br>-</p><h2 id="特殊转义"><a href="#特殊转义" class="headerlink" title="特殊转义"></a>特殊转义</h2><p>部分特殊字符需要使用字符串转义</p><table><thead><tr><th align="left">特殊字符</th><th align="left">转义符号</th><th align="left">中文名称</th><th align="left">英文名称</th></tr></thead><tbody><tr><td align="left">!</td><td align="left"><code>!</code></td><td align="left">感叹号</td><td align="left">Exclamation mark</td></tr><tr><td align="left">“</td><td align="left"><code>&quot;</code> <code>&quot;</code></td><td align="left">双引号</td><td align="left">Quotation mark</td></tr><tr><td align="left">#</td><td align="left"><code>#</code></td><td align="left">数字标志</td><td align="left">Number sign</td></tr><tr><td align="left">$</td><td align="left"><code>$</code></td><td align="left">美元标志</td><td align="left">Dollar sign</td></tr><tr><td align="left">%</td><td align="left"><code>%</code></td><td align="left">百分号</td><td align="left">Percent sign</td></tr><tr><td align="left">&amp;</td><td align="left"><code>&amp;</code> <code>&amp;</code></td><td align="left">与</td><td align="left">Ampersand</td></tr><tr><td align="left">‘</td><td align="left"><code>&#39;</code></td><td align="left">单引号</td><td align="left">Apostrophe</td></tr><tr><td align="left">(</td><td align="left"><code>(</code></td><td align="left">小括号左边部分</td><td align="left">Left parenthesis</td></tr><tr><td align="left">)</td><td align="left"><code>)</code></td><td align="left">小括号右边部分</td><td align="left">Right parenthesis</td></tr><tr><td align="left">*</td><td align="left"><code>*</code></td><td align="left">星号</td><td align="left">Asterisk</td></tr><tr><td align="left">+</td><td align="left"><code>+</code></td><td align="left">加号</td><td align="left">Plus sign</td></tr><tr><td align="left">&lt;</td><td align="left"><code>&lt;</code> <code>&lt;</code></td><td align="left">小于号</td><td align="left">Less than</td></tr><tr><td align="left">&#x3D;</td><td align="left"><code>=</code></td><td align="left">等于符号</td><td align="left">Equals sign</td></tr><tr><td align="left">-</td><td align="left"><code>-</code> <code>−</code></td><td align="left">减号</td><td align="left">Minus</td></tr><tr><td align="left">&gt;</td><td align="left"><code>&gt;</code> <code>&gt;</code></td><td align="left">大于号</td><td align="left">Greater than</td></tr><tr><td align="left">?</td><td align="left"><code>?</code></td><td align="left">问号</td><td align="left">Question mark</td></tr><tr><td align="left">@</td><td align="left"><code>@</code></td><td align="left">艾特</td><td align="left">Commercial at</td></tr><tr><td align="left">[</td><td align="left"><code>[</code></td><td align="left">中括号左边部分</td><td align="left">Left square bracket</td></tr><tr><td align="left">\</td><td align="left"><code>\</code></td><td align="left">反斜杠</td><td align="left">Reverse solidus (backslash)</td></tr><tr><td align="left">]</td><td align="left"><code>]</code></td><td align="left">— 中括号右边部分</td><td align="left">Right square bracket</td></tr><tr><td align="left">{</td><td align="left"><code>&#123;</code></td><td align="left">大括号左边部分</td><td align="left">Left curly brace</td></tr><tr><td align="left">|</td><td align="left">&#96;</td><td align="left">&#96;</td><td align="left">竖线</td></tr><tr><td align="left">}</td><td align="left"><code>&#125;</code></td><td align="left">大括号右边部分</td><td align="left">Right curly brace</td></tr><tr><td align="left"></td><td align="left"><code> </code></td><td align="left">空格</td><td align="left">Space</td></tr></tbody></table><h1 id="字体颜色大小"><a href="#字体颜色大小" class="headerlink" title="字体颜色大小"></a>字体颜色大小</h1><ul><li>Hexo只支持黑色字体，可以使用Html语言调整颜色，使用<code>和</code>包裹需要变色的字体，<code>ff0000</code>可以替换为其他颜色代码。</li><li>字号同样使用Html语言调整，使用<code>和</code>包裹需要改变大小的字体，<code>font size=</code>后是调整的字号。</li><li>字体同样使用Html语言调整，使用<code>和</code>包裹需要改变的字体，<code>font face=</code>后是调整的字体名称。</li><li>颜色字号字体三者可以叠加使用</li></ul><p><strong>示例</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;font <span class="hljs-attribute">color</span>=<span class="hljs-string">&quot;ff0000&quot;</span>&gt;这是红色字&lt;/font&gt;<br>&lt;font <span class="hljs-attribute">size</span>=2&gt;这是2号字&lt;/font&gt;<br>&lt;font <span class="hljs-attribute">face</span>=<span class="hljs-string">&quot;华文彩云&quot;</span>&gt;这是华文彩云字&lt;/font&gt;<br>&lt;font <span class="hljs-attribute">face</span>=<span class="hljs-string">&quot;华文彩云&quot;</span> <span class="hljs-attribute">size</span>=2 <span class="hljs-attribute">color</span>=<span class="hljs-string">&quot;ff0000&quot;</span>&gt;这是2号红色华文彩云字&lt;/font&gt;<br></code></pre></td></tr></table></figure><p><strong>预览</strong><br>这是红色字<br>这是2号字<br>这是华文彩云字<br>这是2号红色华文彩云字</p><h1 id="字体居中"><a href="#字体居中" class="headerlink" title="字体居中"></a>字体居中</h1><p>字体居中同样使用Html语言包裹，有三种格式<br><strong>示例</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">centerquote</span> %&#125;</span><span class="language-xml">这是居中字体</span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endcenterquote</span> %&#125;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blockquote-center&quot;</span>&gt;</span>这是居中字体<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">cq</span> %&#125;</span><span class="language-xml">这是居中字体</span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endcq</span> %&#125;</span><br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><blockquote><p>这是居中字体</p></blockquote><blockquote><p>这是居中字体</p></blockquote><blockquote><p>这是居中字体</p></blockquote><h1 id="勾选框"><a href="#勾选框" class="headerlink" title="勾选框"></a>勾选框</h1><p>一种类似todo list的东西<br><strong>示例</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[ ]这是勾选框<br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><ul><li>[ ]这是勾选框</li></ul><h1 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h1><p>Hexo会把缩进的空格忽略掉，所以需要使用转义来进行首行缩进<br><strong>示例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;emsp;</span><span class="hljs-symbol">&amp;emsp;</span>这是首行缩进的文本<br></code></pre></td></tr></table></figure><p><strong>预览</strong><br>  这是首行缩进的文本</p><h1 id="链接到其他文章"><a href="#链接到其他文章" class="headerlink" title="链接到其他文章"></a>链接到其他文章</h1><p>Hexo支持引入其他文章链接，语法为<code>和</code>,其中<code>slug</code>是要引用markdown的文件名，title是引用文章的标题</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> Hexo博客踩坑指北 [Hexo博客指北] %&#125;</span><br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><p>[<a href="https://siriusq.top/Hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97.html">Hexo博客指北]</a></p><h1 id="文字背景色"><a href="#文字背景色" class="headerlink" title="文字背景色"></a>文字背景色</h1><p>文字背景色需要使用Html表格设置，在<code>bgcolor</code>后设置文字背景色，使用颜色英文名<br><strong>预览</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">lightblue</span>&gt;</span>背景色yellow<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><p>亮蓝色背景色</p><h1 id="Note标签"><a href="#Note标签" class="headerlink" title="Note标签"></a>Note标签</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>需要在Next主题配置文件中选择样式，打开<code>_config.yml</code>并搜索<code>Note tag (bs-callout)</code>,下面是我的配置,<code>style</code>共有五种，预览可以在<a href="https://github.com/iissnan/hexo-theme-next/pull/1697">这里</a>查看，<code>icon</code>用于设置是否显示图标</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Note tag (bs-callout)</span><br><span class="hljs-attr">note:</span><br>  <span class="hljs-comment"># Note tag style values:</span><br>  <span class="hljs-comment">#  - simple    bs-callout old alert style. Default.</span><br>  <span class="hljs-comment">#  - modern    bs-callout new (v2-v3) alert style.</span><br>  <span class="hljs-comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br>  <span class="hljs-comment">#  - disabled  disable all CSS styles import of note tag.</span><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">flat</span><br>  <span class="hljs-attr">icons:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">border_radius:</span> <span class="hljs-number">3</span><br>  <span class="hljs-comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br>  <span class="hljs-comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span><br>  <span class="hljs-attr">light_bg_offset:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用&#96;&#96;包裹需要显示的内容，<code>class</code>后面显示note的风格，加上<code>no-icon</code>可以隐藏图标<br><strong>示例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note default&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note primary&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>primary<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note success&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>success<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note info&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note warning&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>warning<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note danger&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>danger<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note default no-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>danger no-icon<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><p>default</p><p>primary</p><p>success</p><p>info</p><p>warning</p><p>danger</p><p>danger no-icon</p><h1 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h1><p>在<code>@</code>前调整label的风格，<code>@</code>后输入显示的内容<br><strong>示例</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">&#123;% label <span class="hljs-keyword">default</span>@这是<span class="hljs-keyword">default</span> %&#125;<br>&#123;% label primary@这是primary %&#125;<br>&#123;% label success@这是success %&#125;<br>&#123;% label info@这是info %&#125;<br>&#123;% label <span class="hljs-keyword">warning</span>@这是<span class="hljs-keyword">warning</span> %&#125;<br>&#123;% label danger@这是danger %&#125;<br></code></pre></td></tr></table></figure><p>**预览</p><p>这是default 这是primary 这是success 这是info 这是warning 这是danger</p><h1 id="Tab-tag选项卡"><a href="#Tab-tag选项卡" class="headerlink" title="Tab tag选项卡"></a>Tab tag选项卡</h1><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>在Next主题文件中搜索<code>Tabs tag</code>，然后将<code>enable</code>设置为<code>true</code>，下面是我的配置</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># Tabs tag</span><br><span class="hljs-params">tabs:</span><br>  <span class="hljs-params">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">transition:</span><br>    <span class="hljs-params">tabs:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-params">labels:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">border_radius:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>自定义的选项较多<br><strong>示例</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">tabs</span> First unique name %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab --&gt;</span></span><br><span class="language-xml">**This is Tab 1.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab --&gt;</span></span><br><span class="language-xml">**This is Tab 2.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab --&gt;</span></span><br><span class="language-xml">**This is Tab 3.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endtabs</span> %&#125;</span><br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><ul><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#first-unique-name-1">First unique name 1</a></li><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#first-unique-name-2">First unique name 2</a></li><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#first-unique-name-3">First unique name 3</a></li></ul><p><strong>This is Tab 1.</strong></p><p><strong>示例</strong><br>第一行的数字3表示默认显示的Tabs,设置为-1时表示不显示默认Tabs</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">tabs</span> Second unique name, 3 %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab --&gt;</span></span><br><span class="language-xml">**This is Tab 1.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab --&gt;</span></span><br><span class="language-xml">**This is Tab 2.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab --&gt;</span></span><br><span class="language-xml">**This is Tab 3.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endtabs</span> %&#125;</span><br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><ul><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#second-unique-name-1">Second unique name 1</a></li><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#second-unique-name-2">Second unique name 2</a></li><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#second-unique-name-3">Second unique name 3</a></li></ul><p><strong>This is Tab 3.</strong></p><p><strong>示例</strong><br>选项的名称和图标可以自定义，在&#96;&#96;中调整</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">tabs</span> Third unique name %&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab Solution 1@text-width --&gt;</span></span><br><span class="language-xml">**This is Tab 1.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab Solution 2@amazon --&gt;</span></span><br><span class="language-xml">**This is Tab 2.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- tab Solution 3@bold --&gt;</span></span><br><span class="language-xml">**This is Tab 3.**</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- endtab --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endtabs</span> %&#125;</span><br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><ul><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#third-unique-name-1">Solution 1</a></li><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#third-unique-name-2">Solution 2</a></li><li><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#third-unique-name-3">Solution 3</a></li></ul><p><strong>This is Tab 1.</strong></p><h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><p><strong>示例</strong><br>使用<code>button</code>或者<code>btn</code>，在两者后面加入要跳转的链接，不加链接的话默认跳转到当前页面</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="language-xml">//只显示文字，Text是文字内容</span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">button</span> https://siriusq.top/, 主页 %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">//多个按钮并列</span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> https://siriusq.top/, 主页 %&#125;</span><span class="language-xml"> </span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #, Text &amp; Title,, Title %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">//只显示图标</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> https://siriusq.top/,, home fa-5x %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #,, home fa-4x %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #,, home fa-3x %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #,, home fa-2x %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #,, home fa-lg %&#125;</span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #,, home %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">//显示文字和图标</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #, Text &amp; Icon (buggy), home %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">btn</span> #, Text &amp; Icon (fixed width), home fa-fw %&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>预览</strong><br>只显示文字</p><p><a href="https://siriusq.top/">主页</a></p><p>多个按钮并列</p><p><a href="https://siriusq.top/">主页</a> <a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#">Text &amp; Title</a></p><p>只显示图标</p><p>显示文字和图标</p><p><a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#">Text &amp; Icon (buggy)</a> <a href="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95.html#">Text &amp; Icon (fixed width)</a></p><h1 id="插入音乐-视频"><a href="#插入音乐-视频" class="headerlink" title="插入音乐&#x2F;视频"></a>插入音乐&#x2F;视频</h1><p>因为Github Page提供的空间有限，音乐和视频建议上传到B站或Youtube等平台，通过Html语言嵌入，直接复制网页提供的分享链接即可，使用<code>width</code>设置宽度，<code>height</code>设置高度</p><h2 id="标签"><a href="#标签" class="headerlink" title="&#96;&#96;标签"></a>&#96;&#96;标签</h2><p>使用<code>source src</code>设置视频路径<br><strong>示例</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">video</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;480&quot;</span> height=<span class="hljs-string">&quot;320&quot;</span> controls&gt;<br>&lt;<span class="hljs-selector-tag">source</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span>&gt;<br>&lt;/video&gt;<br></code></pre></td></tr></table></figure><p><strong>预览（并没有视频）</strong></p><h2 id="标签-1"><a href="#标签-1" class="headerlink" title="&#96;&#96;标签"></a>&#96;&#96;标签</h2><p><strong>示例</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;embed <span class="hljs-attribute">src</span>=<span class="hljs-string">&#x27;http://player.youku.com/player.php/sid/XMzUzNjg1OTQzNg==/v.swf&#x27;</span> <span class="hljs-attribute">allowFullScreen</span>=<span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-attribute">quality</span>=<span class="hljs-string">&#x27;high&#x27;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&#x27;480&#x27;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&#x27;400&#x27;</span> <span class="hljs-attribute">align</span>=<span class="hljs-string">&#x27;middle&#x27;</span> <span class="hljs-attribute">allowScriptAccess</span>=<span class="hljs-string">&#x27;always&#x27;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&#x27;application/x-shockwave-flash&#x27;</span>&gt;&lt;/embed&gt;<br></code></pre></td></tr></table></figure><p><strong>预览（随便放的）</strong></p><h2 id="标签-2"><a href="#标签-2" class="headerlink" title="&#96;&#96;标签"></a>&#96;&#96;标签</h2><p><strong>示例</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;iframe height<span class="hljs-operator">=</span><span class="hljs-number">400</span> width<span class="hljs-operator">=</span><span class="hljs-number">600</span> src<span class="hljs-operator">=</span><span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=14176961&amp;cid=23141262&amp;page=1&quot;</span> scrolling<span class="hljs-operator">=</span><span class="hljs-string">&quot;no&quot;</span> border<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> frameborder<span class="hljs-operator">=</span><span class="hljs-string">&quot;no&quot;</span> framespacing<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> allowfullscreen<span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span>&gt; &lt;/iframe&gt;<br></code></pre></td></tr></table></figure><p><strong>预览（自己的B站软广）</strong></p><iframe height="400" width="600" src="https://www.bilibili.com/video/BV1ni4y1F79U" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="display: block; margin: 0px; max-width: 100%; height: 498.65625px; left: 0px; position: absolute; top: 0px; width: 748px;"></iframe><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><h2 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h2><ul><li><p>安装图片插件</p><ul><li>在博客根目录中运行Git bash</li><li>输入命令<code>npm install hexo-asset-image</code>等待安装完成</li></ul></li><li><p>修改配置文件</p><ul><li>打开博客根目录的<code>_config.yml</code></li><li>搜索<code>psot_asset_folder</code>并将其设置为<code>true</code></li></ul></li><li><p>使用方法</p><ul><li><p>使用命令<code>hexo new &quot;title&quot;</code>创建新博文时会生成一个同名文件夹</p></li><li><p>将要插入的图片放入同名文件夹中</p></li><li><p>使用markdown格式引入图片，下面三种都可以,最后一种可以通过后面的数字控制大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-attr">[替代文字]</span>(博客标题/图片名<span class="hljs-selector-class">.JPG</span>)<br>!<span class="hljs-selector-attr">[替代文字]</span>(/博客标题/图片名<span class="hljs-selector-class">.JPG</span>)<br>&#123;% <span class="hljs-selector-tag">img</span> full-<span class="hljs-selector-tag">image</span> /博客标题/图片名<span class="hljs-selector-class">.JPG</span> <span class="hljs-number">180</span> <span class="hljs-number">180</span> 图片名 %&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行<code>hexo s</code>即可本地查看效果</p></li></ul></li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><strong>示例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">!<span class="hljs-selector-attr">[替代文字]</span>(Markdown写作语法/<span class="hljs-number">201904133</span><span class="hljs-selector-class">.JPG</span>)<br>!<span class="hljs-selector-attr">[替代文字]</span>(/Markdown写作语法/<span class="hljs-number">201904133</span><span class="hljs-selector-class">.JPG</span>)<br>&#123;% <span class="hljs-selector-tag">img</span> full-<span class="hljs-selector-tag">image</span> /Markdown写作语法/<span class="hljs-number">201904133</span><span class="hljs-selector-class">.JPG</span> <span class="hljs-number">180</span> <span class="hljs-number">180</span> 图片名 %&#125;<br></code></pre></td></tr></table></figure><p><strong>预览</strong></p><p><img src="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/201904133.JPG" alt="替代文字"><br><img src="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/201904133.JPG" alt="替代文字"></p><p><img src="https://siriusq.top/Markdown%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/201904133.JPG" alt="图片名"></p><h2 id="一点微小的工作"><a href="#一点微小的工作" class="headerlink" title="一点微小的工作"></a>一点微小的工作</h2><p>Next主题默认会在图片四周生成一圈灰色边框影响美观，对此需要修改<code>博客目录\themes\next\source\css\_common\components\post</code>中的<code>post-expand.styl</code>文件。<br>在文件中搜索<code>img</code>，并将其修改为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto <span class="hljs-number">25px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">3px</span>;<br>    <span class="hljs-attribute">border</span>: none;<br>  &#125;<br></code></pre></td></tr></table></figure><p>重新部署后灰色边框就会消失</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>图片后缀大小写要匹配</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>在文字前加<code>#</code>和空格，支持六级标题和大小标题，一定不要漏了 <strong>空格</strong>，空格漏掉的话会和普通字符一样显示</p><p><strong>示例</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br><br>大标题<br>===<br><br>小标题<br>---<br></code></pre></td></tr></table></figure><p><strong>预览效果</strong></p><p>就不预览了，太难看了qaq</p><h1 id="数学公式使用"><a href="#数学公式使用" class="headerlink" title="数学公式使用"></a>数学公式使用</h1><p>转载自<a href="https://jzqt.github.io/2015/06/30/Markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">剑紫青天</a></p><p>一些扩展的<code>Markdown</code>语法支持采用<code>LaTex</code>语法写数学公式，而在网页中使用<code>Mathjax</code>插件来显示数学公式。</p><p>本教程介绍<strong>如何在Markdown中书写数学公式</strong>。</p><h2 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h2><p>在Markdown中插入数学公式的语法是<code>$数学公式$</code>和<code>$$数学公式$$</code>。</p><p><strong>行内公式</strong>是可以让公式在文中与文字或其他东西混编，不独占一行。</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">质能方程<span class="hljs-symbol">$</span>E = mc^<span class="hljs-number">2</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>质能方程$E &#x3D; mc^2$</p></blockquote></li></ul><p><strong>独立公式</strong>使公式单独占一行，不与文中其他文字等混编。</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">质能方程<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>E = mc^<span class="hljs-number">2</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>质能方程$$E &#x3D; mc^2$$</p></blockquote></li></ul><h2 id="普通公式"><a href="#普通公式" class="headerlink" title="普通公式"></a>普通公式</h2><p>普通的加减乘除数学公式的输入方法与平常的书写一样。</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>x = <span class="hljs-number">100</span> * y + z - <span class="hljs-number">10</span> / <span class="hljs-number">33</span> + <span class="hljs-number">10</span> % <span class="hljs-number">3</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>$$x &#x3D; 100 * y + z - 10 &#x2F; 33 + 10 % 3$$</p></blockquote></li></ul><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>使用<code>^</code>来表示上标，<code>_</code>来表示下标，同时如果上下标的内容多于一个字符，可以使用<code>&#123;&#125;</code>来将这些内容括起来当做一个整体。<br>与此同时，上下标是可以嵌套的。</p><ul><li><p><strong>示例</strong></p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-built_in">$$x</span> = a_&#123;<span class="hljs-number">1</span>&#125;<span class="hljs-symbol">^n</span> + a_&#123;<span class="hljs-number">2</span>&#125;<span class="hljs-symbol">^n</span> + a_&#123;<span class="hljs-number">3</span>&#125;<span class="hljs-symbol">^n</span>$$<br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>$$x &#x3D; a_{1}^n + a_{2}^n + a_{3}^n$$</p></blockquote></li></ul><p>如果希望左右两边都能有上下标，可以使用<code>\sideset</code>语法</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\sideset&#123;^<span class="hljs-number">1</span>_2&#125;&#123;^<span class="hljs-number">3</span>_4&#125;A<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>$$\sideset{^1_2}{^3_4}A$$</p></blockquote></li></ul><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p><code>()</code>，<code>[]</code>和<code>|</code>都表示它们自己，但是<code>&#123;&#125;</code>因为有特殊作用因此当需要显示大括号时一般使用<code>\lbrace \rbrace</code>来表示。</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>f(x, y) = <span class="hljs-number">100</span> * \lbrace[(x + y) * <span class="hljs-number">3</span>] - <span class="hljs-number">5</span>\rbrace<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>$$f(x, y) &#x3D; 100 * \lbrace[(x + y) * 3] - 5\rbrace$$</p></blockquote></li></ul><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>分数使用<code>\frac&#123;分母&#125;&#123;分子&#125;</code>这样的语法，不过推荐使用<code>\cfrac</code>来代替<code>\frac</code>，显示公式不会太挤。</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">3</span>&#125; 与 \cfrac&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">3</span>&#125;<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>$$\frac{1}{3} 与 \cfrac{1}{3}$$</p></blockquote></li></ul><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>开方使用<code>\sqrt[次数]&#123;被开方数&#125;</code>这样的语法</p><ul><li><p><strong>示例</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\<span class="hljs-built_in">sqrt</span>[<span class="hljs-number">3</span>]&#123;X&#125;<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\<span class="hljs-built_in">sqrt</span>&#123;<span class="hljs-number">5</span> - x&#125;<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示</strong></p><blockquote><p>$$\sqrt[3]{X}$$<br>$$\sqrt{5 - x}$$</p></blockquote></li></ul><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>见下表</p><table><thead><tr><th align="center">代码</th><th align="center">大写</th><th align="center">代码</th><th align="center">小写</th></tr></thead><tbody><tr><td align="center"><code>A</code></td><td align="center">$A$</td><td align="center"><code>\alpha</code></td><td align="center">$\alpha$</td></tr><tr><td align="center"><code>B</code></td><td align="center">$B$</td><td align="center"><code>\beta</code></td><td align="center">$\beta$</td></tr><tr><td align="center"><code>\Gamma</code></td><td align="center">$\Gamma$</td><td align="center"><code>\gamma</code></td><td align="center">$\gamma$</td></tr><tr><td align="center"><code>\Delta</code></td><td align="center">$\Delta$</td><td align="center"><code>\delta</code></td><td align="center">$\delta$</td></tr><tr><td align="center"><code>E</code></td><td align="center">$E$</td><td align="center"><code>\epsilon</code></td><td align="center">$\epsilon$</td></tr><tr><td align="center"><code>Z</code></td><td align="center">$Z$</td><td align="center"><code>\zeta</code></td><td align="center">$\zeta$</td></tr><tr><td align="center"><code>H</code></td><td align="center">$H$</td><td align="center"><code>\eta</code></td><td align="center">$\eta$</td></tr><tr><td align="center"><code>\Theta</code></td><td align="center">$\Theta$</td><td align="center"><code>\theta</code></td><td align="center">$\theta$</td></tr><tr><td align="center"><code>I</code></td><td align="center">$I$</td><td align="center"><code>\iota</code></td><td align="center">$\iota$</td></tr><tr><td align="center"><code>K</code></td><td align="center">$K$</td><td align="center"><code>\kappa</code></td><td align="center">$\kappa$</td></tr><tr><td align="center"><code>\Lambda</code></td><td align="center">$\Lambda$</td><td align="center"><code>\lambda</code></td><td align="center">$\lambda$</td></tr><tr><td align="center"><code>M</code></td><td align="center">$M$</td><td align="center"><code>\mu</code></td><td align="center">$\mu$</td></tr><tr><td align="center"><code>N</code></td><td align="center">$N$</td><td align="center"><code>\nu</code></td><td align="center">$\nu$</td></tr><tr><td align="center"><code>\Xi</code></td><td align="center">$\Xi$</td><td align="center"><code>\xi</code></td><td align="center">$\xi$</td></tr><tr><td align="center"><code>O</code></td><td align="center">$O$</td><td align="center"><code>\omicron</code></td><td align="center">$\omicron$</td></tr><tr><td align="center"><code>\Pi</code></td><td align="center">$\Pi$</td><td align="center"><code>\pi</code></td><td align="center">$\pi$</td></tr><tr><td align="center"><code>P</code></td><td align="center">$P$</td><td align="center"><code>\rho</code></td><td align="center">$\rho$</td></tr><tr><td align="center"><code>\Sigma</code></td><td align="center">$\Sigma$</td><td align="center"><code>\sigma</code></td><td align="center">$\sigma$</td></tr><tr><td align="center"><code>T</code></td><td align="center">$T$</td><td align="center"><code>\tau</code></td><td align="center">$\tau$</td></tr><tr><td align="center"><code>\Upsilon</code></td><td align="center">$\Upsilon$</td><td align="center"><code>\upsilon</code></td><td align="center">$\upsilon$</td></tr><tr><td align="center"><code>\Phi</code></td><td align="center">$\Phi$</td><td align="center"><code>\phi</code></td><td align="center">$\phi$</td></tr><tr><td align="center"><code>X</code></td><td align="center">$X$</td><td align="center"><code>\chi</code></td><td align="center">$\chi$</td></tr><tr><td align="center"><code>\Psi</code></td><td align="center">$\Psi$</td><td align="center"><code>\psi</code></td><td align="center">$\psi$</td></tr><tr><td align="center"><code>\Omega</code></td><td align="center">$\Omega$</td><td align="center"><code>\omega</code></td><td align="center">$\omega$</td></tr></tbody></table><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="center">符号</th><th align="left">代码</th></tr></thead><tbody><tr><td align="center">$\pm$</td><td align="left"><code>\pm</code></td></tr><tr><td align="center">$\times$</td><td align="left"><code>\times</code></td></tr><tr><td align="center">$\div$</td><td align="left"><code>\div</code></td></tr><tr><td align="center">$\mid$</td><td align="left"><code>\mid</code></td></tr><tr><td align="center">$\nmid$</td><td align="left"><code>\nmid</code></td></tr><tr><td align="center">$\cdot$</td><td align="left"><code>\cdot</code></td></tr><tr><td align="center">$\circ$</td><td align="left"><code>\circ</code></td></tr><tr><td align="center">$\ast$</td><td align="left"><code>\ast</code></td></tr><tr><td align="center">$\bigodot$</td><td align="left"><code>\bigodot</code></td></tr><tr><td align="center">$\bigotimes$</td><td align="left"><code>\bigotimes</code></td></tr><tr><td align="center">$\bigoplus$</td><td align="left"><code>\bigoplus</code></td></tr><tr><td align="center">$\leq$</td><td align="left"><code>\leq</code></td></tr><tr><td align="center">$\geq$</td><td align="left"><code>\geq</code></td></tr><tr><td align="center">$\neq$</td><td align="left"><code>\neq</code></td></tr><tr><td align="center">$\approx$</td><td align="left"><code>\approx</code></td></tr><tr><td align="center">$\equiv$</td><td align="left"><code>\equiv</code></td></tr><tr><td align="center">$\sum$</td><td align="left"><code>\sum</code></td></tr><tr><td align="center">$\prod$</td><td align="left"><code>\prod</code></td></tr><tr><td align="center">$\coprod$</td><td align="left"><code>\coprod</code></td></tr></tbody></table><h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><table><thead><tr><th align="center">符号</th><th align="left">代码</th></tr></thead><tbody><tr><td align="center">$\emptyset$</td><td align="left"><code>\emptyset</code></td></tr><tr><td align="center">$\in$</td><td align="left"><code>\in</code></td></tr><tr><td align="center">$\notin$</td><td align="left"><code>\notin</code></td></tr><tr><td align="center">$\subset$</td><td align="left"><code>\subset</code></td></tr><tr><td align="center">$\supset$</td><td align="left"><code>\supset</code></td></tr><tr><td align="center">$\subseteq$</td><td align="left"><code>\subseteq</code></td></tr><tr><td align="center">$\supseteq$</td><td align="left"><code>\supseteq</code></td></tr><tr><td align="center">$\bigcap$</td><td align="left"><code>\bigcap</code></td></tr><tr><td align="center">$\bigcup$</td><td align="left"><code>\bigcup</code></td></tr><tr><td align="center">$\bigvee$</td><td align="left"><code>\bigvee</code></td></tr><tr><td align="center">$\bigwedge$</td><td align="left"><code>\bigwedge</code></td></tr><tr><td align="center">$\biguplus$</td><td align="left"><code>\biguplus</code></td></tr><tr><td align="center">$\bigsqcup$</td><td align="left"><code>\bigsqcup</code></td></tr></tbody></table><h3 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h3><table><thead><tr><th align="center">符号</th><th align="left">代码</th></tr></thead><tbody><tr><td align="center">$\log$</td><td align="left"><code>\log</code></td></tr><tr><td align="center">$\lg$</td><td align="left"><code>\lg</code></td></tr><tr><td align="center">$\ln$</td><td align="left"><code>\ln</code></td></tr></tbody></table><h3 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h3><table><thead><tr><th align="center">符号</th><th align="left">代码</th></tr></thead><tbody><tr><td align="center">$\bot$</td><td align="left"><code>\bot</code></td></tr><tr><td align="center">$\angle$</td><td align="left"><code>\angle</code></td></tr><tr><td align="center">$\sin$</td><td align="left"><code>\sin</code></td></tr><tr><td align="center">$\cos$</td><td align="left"><code>\cos</code></td></tr><tr><td align="center">$\tan$</td><td align="left"><code>\tan</code></td></tr><tr><td align="center">$\cot$</td><td align="left"><code>\cot</code></td></tr><tr><td align="center">$\sec$</td><td align="left"><code>\sec</code></td></tr><tr><td align="center">$\csc$</td><td align="left"><code>\csc</code></td></tr></tbody></table><h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><table><thead><tr><th align="center">符号</th><th align="left">代码</th></tr></thead><tbody><tr><td align="center">$\prime$</td><td align="left"><code>\prime</code></td></tr><tr><td align="center">$\int$</td><td align="left"><code>\int</code></td></tr><tr><td align="center">$\iint$</td><td align="left"><code>\iint</code></td></tr><tr><td align="center">$\iiint$</td><td align="left"><code>\iiint</code></td></tr><tr><td align="center">$\iiiint$</td><td align="left"><code>\iiiint</code></td></tr><tr><td align="center">$\oint$</td><td align="left"><code>\oint</code></td></tr><tr><td align="center">$\lim$</td><td align="left"><code>\lim</code></td></tr><tr><td align="center">$\infty$</td><td align="left"><code>\infty</code></td></tr><tr><td align="center">$\nabla$</td><td align="left"><code>\nabla</code></td></tr><tr><td align="center">$\mathrm{d}$</td><td align="left"><code>\mathrm&#123;d&#125;</code></td></tr></tbody></table><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感觉还是挂在自己博客上比较好看（手动狗头），还是建议大家去看原帖，侵权删除。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdownguide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latexit使用方法</title>
    <link href="/Blogs/2025/08/28/Latexit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/Blogs/2025/08/28/Latexit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[[Latex语法]]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LaTeXiT 是一个“简洁版”的 LaTeX 图形交互界面。<br>一般被用于检查写的数学公式。因为小巧方便快捷，可以很快速地看到输出的公式的样子</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入以下内容：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\[</span><br><span class="hljs-keyword">\lim</span><span class="hljs-built_in">_</span>&#123;n <span class="hljs-keyword">\to</span> <span class="hljs-keyword">\infty</span>&#125;<br><span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;k=1&#125;<span class="hljs-built_in">^</span>n <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;k<span class="hljs-built_in">^</span>2&#125;<br>= <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\pi</span><span class="hljs-built_in">^</span>2&#125;&#123;6&#125;<br><span class="hljs-keyword">\]</span><br></code></pre></td></tr></table></figure><p>这是因为模式选择不对。</p><p>这一行表示的是当前内容以什么模式运行。也可以直接选最左端的“Auto”模式来让软件自动选择。<br><img src="https://img-blog.csdnimg.cn/e34142a52af6476eaf98408b84c34ac2.png" alt="请添加图片描述"></p><p>这里我们选“TeXt”或者“Auto”模式。运行效果就像之前一样了。</p><p>如果你仔细观察的话，那么就可以发现：行的编号是从 7 开始的，这是因为为了简洁，这里隐藏了开头的部分，因为大概率不需要修改这部分内容。<br>拖拽下图的这个小灰点可以显示隐藏的部分：</p><h2 id="导出保存"><a href="#导出保存" class="headerlink" title="导出保存"></a>导出保存</h2><p>接下来，以 PNG 的格式来导出这个公式。</p><p>Command + E 或者点击 “File” - “Export image…”</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>latex学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Latexit使用方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex语法</title>
    <link href="/Blogs/2025/08/28/Latex%E8%AF%AD%E6%B3%95/"/>
    <url>/Blogs/2025/08/28/Latex%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="Preamble"><a href="#Preamble" class="headerlink" title="Preamble"></a>Preamble</h2><p>主要是对文章内容与包的基本设置</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[10pt]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>[usenames]&#123;color&#125; <span class="hljs-comment">%used for font color</span><br><span class="hljs-keyword">\usepackage</span>&#123;amssymb&#125; <span class="hljs-comment">%maths</span><br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125; <span class="hljs-comment">%maths</span><br><span class="hljs-keyword">\usepackage</span>[utf8]&#123;inputenc&#125; <span class="hljs-comment">%useful to type directly diacritic characters</span><br></code></pre></td></tr></table></figure><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>文章展示的内容</p><p><code>\begin&#123;document&#125;</code> 和 <code>\end&#123;document&#125;</code> 命令将你的文本内容包裹起来。任何在 <code>\begin&#123;documnet&#125;</code> 之前的文本都被视为前导命令，会影响整个文档。任何在 <code>\end&#123;document&#125;</code> 之后的文本都会被忽视。</p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>看了看latex在写作上的优势之后，发现真没markdown方便，不如取其长，只关注公式的部分好了</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="识别符"><a href="#识别符" class="headerlink" title="识别符"></a>识别符</h3><p>你可以使用一对 <code>$</code> 来启用数学模式，这可以用于撰写行内数学公式。</p><p>如果你想要行间的公式，可以使用 <code>$$...$$</code>（现在我们推荐使用 <code>\[...\]</code>，因为前者可能产生不良间距。</p><h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p>如果是生成带标号的公式，可以使用 <code>\begin&#123;equation&#125;...\end&#123;equation&#125;</code>。</p><p>要撰写不标号的公式就在环境标志的后面添加 <code>*</code> 字符，如 <code>&#123;equation*&#125;</code>，<code>&#123;eqnarray*&#125;</code>。</p><h2 id="基础符号"><a href="#基础符号" class="headerlink" title="基础符号"></a>基础符号</h2><h4 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h4><p>上标（Powers）使用 <code>^</code> 来表示，比如 <code>$n^2$</code> 生成的效果为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="n^2">。</p><p>下标（Indices）使用 <code>_</code> 表示，比如 <code>$2_a$</code> 生成的效果为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="2_a">。</p><p>如果上标或下标的内容包含多个字符，请使用花括号包裹起来。比如 <code>$b_&#123;a-2&#125;$</code> 的效果为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="b_{a-2}">。</p><h4 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h4><p>分数使用 <code>\frac&#123;numerator&#125;&#123;denominator&#125;</code> 命令插入。比如 <code>$$\frac&#123;a&#125;&#123;3&#125;$$</code> 的生成效果为</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" \frac{a}{3} "></p><p>分数可以嵌套。比如 <code>$$\frac&#123;y&#125;&#123;\frac&#123;3&#125;&#123;x&#125;+b&#125;$$</code> 的生成效果为</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" \frac{y}{\frac{3}{x}+b} "></p><h4 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h4><p>我们使用 <code>\sqrt&#123;...&#125;</code> 命令插入根号。省略号的内容由被开根的内容替代。如果需要添加开根的次数，使用方括号括起来即可。</p><p>例如 <code>$$\sqrt&#123;y^2&#125;$$</code> 的生成效果为</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" \sqrt{y^2} "></p><p>而 <code>$$\sqrt[x]&#123;y^2&#125;$$</code> 的生成效果为</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" \sqrt[x]{y^2} "></p><h2 id="微积分与线代"><a href="#微积分与线代" class="headerlink" title="微积分与线代"></a>微积分与线代</h2><h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><p>使用 <code>\sum</code> 和 <code>\int</code> 来插入求和式与积分式。对于两种符号，上限使用 <code>^</code> 来表示，而下限使用 <code>_</code> 表示。</p><p><code>$$\sum_&#123;x=1&#125;^5 y^z$$</code> 的生成效果为</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" \sum_{x=1}^5y^z "></p><p>而 <code>$$\int_a^b f(x)$$</code> 的生成效果为</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" \int_a^b f(x) "></p><h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><p>我们可以使用反斜杠加希腊字母的名称来表示一个希腊字母。名称的首字母的大小写决定希腊字母的形态。例如</p><ul><li><code>$\alpha$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\alpha"></li><li><code>$\beta$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\beta"></li><li><code>$\delta, \Delta$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\delta, \Delta"></li><li><code>$\pi, \Pi$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\pi, \Pi"></li><li><code>$\sigma, \Sigma$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\sigma, \Sigma"></li><li><code>$\phi, \Phi, \varphi$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\phi, \Phi, \varphi"></li><li><code>$\psi, \Psi$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\psi, \Psi"></li><li><code>$\omega, \Omega$</code>&#x3D;<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\omega, \Omega"></li></ul><h2 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h2><p>拉丁字母、阿拉伯数字和 +-*&#x2F;&#x3D; 运算符均可以直接输入获得，命令\cdot表示乘法的圆点，命令\neq表示不等号，命令\equiv表示恒等于，命令\bmod表示取模</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$ x+2-3*4/6=4/y + x\cdot y $$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$ 0 \neq 1 \quad x \equiv x \quad 1 = 9 \bmod 2 $$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>语法_表示下标、^表示上标，但上下标内容不止一个字符时，需用大括号括起来。单引号’表示求导</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$ a_&#123;ij&#125;^&#123;2&#125; + b^3_&#123;2&#125;=x^&#123;t&#125; + y&#x27; + x&#x27;&#x27;_&#123;12&#125; $$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><h2 id="根号、分式"><a href="#根号、分式" class="headerlink" title="根号、分式"></a>根号、分式</h2><p>命令：\sqrt表示平方根，\sqrt[n]表示n次方根，\frac表示分式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\sqrt&#123;x&#125; + \sqrt&#123;x^&#123;2&#125;+\sqrt&#123;y&#125;&#125; = \sqrt[3]&#123;k_&#123;i&#125;&#125; - \frac&#123;x&#125;&#123;m&#125;$$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><h2 id="上下标记"><a href="#上下标记" class="headerlink" title="上下标记"></a>上下标记</h2><p>命令：\overline, \underline 分别在表达式上、下方画出水平线</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\overline&#123;x+y&#125; \qquad \underline&#123;a+b&#125;$$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><p>命令：\overbrace, \underbrace 分别在表达式上、下方给出一个水平的大括号</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\overbrace&#123;1+2+\cdots+n&#125;^&#123;n个&#125; \qquad \underbrace&#123;a+b+\cdots+z&#125;_&#123;26&#125;$$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><p>个</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>命令：\vec表示向量，\overrightarrow表示箭头向右的向量，\overleftarrow表示箭头向左的向量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\vec&#123;a&#125; + \overrightarrow&#123;AB&#125; + \overleftarrow&#123;DE&#125;$$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;</p><h2 id="积分、极限、求和、乘积"><a href="#积分、极限、求和、乘积" class="headerlink" title="积分、极限、求和、乘积"></a>积分、极限、求和、乘积</h2><p>命令：\int表示积分，\lim表示极限， \sum表示求和，\prod表示乘积，^、_表示上、下限</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$  \lim_&#123;x \to \infty&#125; x^2_&#123;22&#125; - \int_&#123;1&#125;^&#123;5&#125;x\mathrm&#123;d&#125;x + \sum_&#123;n=1&#125;^&#123;20&#125; n^&#123;2&#125; = \prod_&#123;j=1&#125;^&#123;3&#125; y_&#123;j&#125;  + \lim_&#123;x \to -2&#125; \frac&#123;x-2&#125;&#123;x&#125; $$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><h2 id="三圆点"><a href="#三圆点" class="headerlink" title="三圆点"></a>三圆点</h2><p>命令：\ldots点位于基线上，\cdots点设置为居中，\vdots使其垂直，\ddots对角线排列</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$ x_&#123;1&#125;,x_&#123;2&#125;,\ldots,x_&#123;5&#125;  \quad x_&#123;1&#125; + x_&#123;2&#125; + \cdots + x_&#123;n&#125; $$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><h2 id="重音符号"><a href="#重音符号" class="headerlink" title="重音符号"></a>重音符号</h2><p>常用命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ \hat&#123;x&#125; $<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ \bar&#123;x&#125; $<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ \tilde&#123;x&#125; $<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; </p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>其采用矩阵环境实现矩阵排列，常用的矩阵环境有matrix、bmatrix、vmatrix、pmatrix，其区别为在于外面的括号不同：</p><p><img src="https://pic1.zhimg.com/80/v2-684e48900e810dff360c23b4ffe99680_1440w.webp" alt="img"></p><p>下列代码中，&amp;用于分隔列，\用于分隔行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">$$\begin&#123;bmatrix&#125;<br>1 &amp; 2 &amp; \cdots \\<br>67 &amp; 95 &amp; \cdots \\<br>\vdots  &amp; \vdots &amp; \ddots \\<br>\end&#123;bmatrix&#125;$$<br></code></pre></td></tr></table></figure><p> &#x3D;&#x3D;&#x3D;&gt;&gt;&gt;</p><h2 id="希腊字母-1"><a href="#希腊字母-1" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>希腊字母无法直接通过美式键盘输入获得。在LaTeX中通过反斜杠\加上其字母读音实现，将读音首字母大写即可输入其大写形式，详见下表</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$$ \alpha^&#123;2&#125; + \beta = \Theta  $$<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;</p><p><img src="https://pic1.zhimg.com/80/v2-da3e717cf670582fbfbdddee33073524_1440w.webp" alt="img"></p><h1 id="Preamble-1"><a href="#Preamble-1" class="headerlink" title="Preamble"></a>Preamble</h1><h2 id="documentclass"><a href="#documentclass" class="headerlink" title="\documentclass"></a><code>\documentclass</code></h2><p>命令必须出现在每个 LaTeX 文档的开头。花括号内的文本指定了文档的类型。<strong>article</strong> 文档类型适合较短的文章，比如期刊文章和短篇报告。其他文档类型包括 <strong>report</strong>（适用于更长的多章节的文档，比如博士生论文），<strong>proc</strong>（会议论文集），<strong>book</strong> 和 <strong>beamer</strong>。方括号内的文本指定了一些选项——示例中它设置纸张大小为 A4，主要文字大小为 12pt。</p><h2 id="包设置"><a href="#包设置" class="headerlink" title="包设置"></a>包设置</h2><p>你可以引用很多包来增强 LaTeX 的排版效果。包引用的命令放置在文档的前导命令的位置（即放在 <code>\begin&#123;document&#125;</code> 命令之前）。使用 <code>\usepackage[options]&#123;package&#125;</code> 来引用包。其中 <strong>package</strong> 是包的名称，而 <strong>options</strong> 是指定包的特征的一些参数。</p><h3 id="中文字体支持"><a href="#中文字体支持" class="headerlink" title="中文字体支持"></a>中文字体支持</h3><p>事实上，让 LaTeX 支持中文字体有许多方法。在此我们仅给出最 <strong>简洁</strong> 的解决方案：使用 CTeX 宏包。只需要在文档的前导命令部分添加：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>[UTF8]&#123;ctex&#125; <br></code></pre></td></tr></table></figure><p>就可以了。在编译文档的时侯使用 <code>xelatex</code> 命令，因为它是支持中文字体的。</p><h3 id="彩色字体"><a href="#彩色字体" class="headerlink" title="彩色字体"></a>彩色字体</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;color&#125;<br></code></pre></td></tr></table></figure><h1 id="展示内容"><a href="#展示内容" class="headerlink" title="展示内容"></a>展示内容</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\rightarrow"> 在 <code>\begin&#123;document&#125;</code> 和 命令后紧跟着输入以下文本：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\title</span>&#123;My First Document&#125; <br><span class="hljs-keyword">\author</span>&#123;My Name&#125; <br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125; <br><span class="hljs-keyword">\maketitle</span> <br></code></pre></td></tr></table></figure><ul><li><code>\today</code> 是插入当前时间的命令。你也可以输入一个不同的时间，比如 <code>\date&#123;November 2013&#125;</code>。</li><li><strong>article</strong> 文档的正文会紧跟着标题之后在同一页上排版。<strong>report</strong> 会将标题置为单独的一页。</li></ul><h3 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h3><p>下列分节命令适用于 <strong>article</strong> 类型的文档：</p><ul><li><code>\section&#123;...&#125;</code></li><li><code>\subsection&#123;...&#125;</code></li><li><code>\subsubsection&#123;...&#125;</code></li><li><code>\paragraph&#123;...&#125;</code></li><li><code>\subparagraph&#123;...&#125;</code></li></ul><p>花括号内的文本表示章节的标题。对于 <strong>report</strong> 和 <strong>book</strong> 类型的文档我们还支持 <code>\chapter&#123;...&#125;</code>的命令。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\section</span>&#123;Introduction&#125; <br>This is the introduction. <br><span class="hljs-keyword">\section</span>&#123;Methods&#125; <br><span class="hljs-keyword">\subsection</span>&#123;Stage 1&#125; <br>The first part of the methods. <br><span class="hljs-keyword">\subsection</span>&#123;Stage 2&#125; <br>The second part of the methods. <br><span class="hljs-keyword">\section</span>&#123;Results&#125; <br>Here are my results. <br></code></pre></td></tr></table></figure><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>可以对任意章节命令创建标签，这样他们可以在文档的其他部分被引用。使用 <code>\label&#123;labelname&#125;</code> 对章节创建标签。然后输入 <code>\ref&#123;labelname&#125;</code> 或者 <code>\pageref&#123;labelname&#125;</code> 来引用对应的章节。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">Referring to section <span class="hljs-keyword">\ref</span>&#123;sec1&#125; on page <span class="hljs-keyword">\pageref</span>&#123;sec1&#125;<br></code></pre></td></tr></table></figure><h3 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h3><p>如果你使用分节命令，那么可以容易地生成一个目录。使用 <code>\tableofcontents</code> 在文档中创建目录。通常我们会在标题的后面建立目录。</p><p>你可能也想也想更改页码为罗马数字（i,ii,iii）。这会确保文档的正文从第 1 页开始。页码可以使用 <code>\pagenumbering&#123;...&#125;</code> 在阿拉伯数字和罗马数字见切换。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\rightarrow"> 在 <code>\maketitle</code> 之后输入以下内容：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\pagenumbering</span>&#123;roman&#125; <br><span class="hljs-keyword">\tableofcontents</span> <br><span class="hljs-keyword">\newpage</span> <span class="hljs-comment">%\newpage 命令会另起一个页面</span><br><span class="hljs-keyword">\pagenumbering</span>&#123;arabic&#125;<br></code></pre></td></tr></table></figure><h2 id="文字处理"><a href="#文字处理" class="headerlink" title="文字处理"></a>文字处理</h2><h3 id="字体效果"><a href="#字体效果" class="headerlink" title="字体效果"></a>字体效果</h3><p>LaTeX 有多种不同的字体效果，在此列举一部分：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textit</span>&#123;words in italics&#125; <br><span class="hljs-keyword">\textsl</span>&#123;words slanted&#125; <br><span class="hljs-keyword">\textsc</span>&#123;words in smallcaps&#125; <br><span class="hljs-keyword">\textbf</span>&#123;words in bold&#125; <br><span class="hljs-keyword">\texttt</span>&#123;words in teletype&#125; <br><span class="hljs-keyword">\textsf</span>&#123;sans serif words&#125; <br><span class="hljs-keyword">\textrm</span>&#123;roman words&#125; <br><span class="hljs-keyword">\underline</span>&#123;underlined words&#125; <br></code></pre></td></tr></table></figure><h3 id="彩色字体-1"><a href="#彩色字体-1" class="headerlink" title="彩色字体"></a>彩色字体</h3><p>使用彩色字体的代码为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;\<span class="hljs-attribute">color</span>&#123;colorname&#125;<span class="hljs-selector-tag">text</span>&#125; <br></code></pre></td></tr></table></figure><p>其中 <strong>colorname</strong> 是你想要的颜色的名字，<strong>text</strong> 是你的彩色文本内容。注意到示例效果中的黄色与白色是有文字背景色的，这个我们同样可以使用 Color 包中的 <code>\colorbox</code> 命令来达到。用法如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">\colorbox</span><span class="hljs-template-variable">&#123;colorname&#125;</span><span class="hljs-template-variable">&#123;text&#125;</span><span class="language-xml"> </span><br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\rightarrow"> 在 <code>\begin&#123;document&#125;</code> 前输入 <code>\usepackage&#123;color&#125;</code>。<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\rightarrow"> 在文档内容中输入 <code>&#123;\color&#123;red&#125;fire&#125;</code>。<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\rightarrow"> 编译并核对 PDF 文档内容。</p><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>列举一些 LaTeX 的字体大小设定命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">normal size words <br>&#123;<span class="hljs-keyword">\tiny</span> tiny words&#125; &#123;<span class="hljs-keyword">\scriptsize</span> scriptsize words&#125; <br>&#123;<span class="hljs-keyword">\footnotesize</span> footnotesize words&#125; <br>&#123;<span class="hljs-keyword">\small</span> small words&#125; <br>&#123;<span class="hljs-keyword">\large</span> large words&#125; <br>&#123;<span class="hljs-keyword">\Large</span> Large words&#125; <br>&#123;<span class="hljs-keyword">\LARGE</span> LARGE words&#125; <br>&#123;<span class="hljs-keyword">\huge</span> huge words&#125; <br></code></pre></td></tr></table></figure><h3 id="段落缩进"><a href="#段落缩进" class="headerlink" title="段落缩进"></a>段落缩进</h3><p>LaTeX 默认每个章节第一段首行顶格，之后的段落首行缩进。如果想要段落顶格，在要顶格的段落前加 <code>\noindent</code> 命令即可。如果希望全局所有段落都顶格，在文档的某一位置使用 <code>\setlength&#123;\parindent&#125;&#123;0pt&#125;</code> 命令，之后的所有段落都会顶格。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>LaTeX 支持两种类型的列表：有序列表（enumerate）和无序列表（itemize）。列表中的元素定义为 <code>\item</code>。列表可以有子列表。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\rightarrow"> 输入下面的内容来生成一个有序列表套无序列表：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;enumerate&#125; <br><span class="hljs-keyword">\item</span> First thing <br><span class="hljs-keyword">\item</span> Second thing <br><span class="hljs-keyword">\begin</span>&#123;itemize&#125; <br><span class="hljs-keyword">\item</span> A sub-thing <br><span class="hljs-keyword">\item</span> Another sub-thing <br><span class="hljs-keyword">\end</span>&#123;itemize&#125; <br><span class="hljs-keyword">\item</span> Third thing <br><span class="hljs-keyword">\end</span>&#123;enumerate&#125; <br></code></pre></td></tr></table></figure><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>下列字符在 LaTeX 中属于特殊字符：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"># <span class="hljs-string">$ </span><span class="hljs-comment">% ^ &amp; _ &#123; &#125; ~ \ </span><br></code></pre></td></tr></table></figure><p>为了使用这些字符，我们需要在他们前面添加反斜杠进行转义：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\#</span> <span class="hljs-string">\$</span> <span class="hljs-string">\%</span> <span class="hljs-string">\^&#123;&#125;</span> <span class="hljs-string">\&amp;</span> <span class="hljs-string">\_</span> <span class="hljs-string">\&#123;</span> <span class="hljs-string">\&#125;</span> <span class="hljs-string">\~&#123;&#125;</span> <br></code></pre></td></tr></table></figure><p>注意在使用 <code>^</code> 和 <code>~</code> 字符的时侯需要在后面紧跟一对闭合的花括号，否则他们就会被解释为字母的上标，就像 <code>\^ e</code> 会变成 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="\mathrm {\hat{e}}">。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>latex学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Latex语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GEB</title>
    <link href="/Blogs/2025/08/28/GEB/"/>
    <url>/Blogs/2025/08/28/GEB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>从哥德尔不完全性定理引申到对人脑结构和心智本质的探讨再深入到计算机程序和人工智能</strong>，<strong>介绍了一个同时存在于数理逻辑，分子生物学缠结层次系统，这些内容在巴赫和埃舍尔的作品里有类似的对应物</strong></p></blockquote><h1 id="哥德尔不完备定理"><a href="#哥德尔不完备定理" class="headerlink" title="哥德尔不完备定理"></a>哥德尔不完备定理</h1><blockquote><p><strong>哥德尔第一不完备性定理</strong>：任意一个包含一阶谓词逻辑与初等数论的形式系统，都存在一个命题，它在这个系统中既不能被证明也不能被否定</p></blockquote><p>[[哥德尔不完备定理]]</p><p>本片源于：<a href="https://zhuanlan.zhihu.com/p/28386154">https://zhuanlan.zhihu.com/p/28386154</a></p><p>我的理解：说谎者悖论（A说我不是对的）</p><p>说谎者悖论的核心在于其自指星：<br>自指的存在让所有系统都具有不可避免缺陷，<strong>任何系统只要有谈论自身的能力，内部就存在不可消除的矛盾，不完全性成了所有系统的固有性质。</strong>这就告诉我们，不能指望有系统可以解决所有的问题，鉴别所有句子的真假，因为他们都是不完全的漏洞系统。因此在物理学，社会学，哲学或者任何领域，所有构建大一统理论体系的努力是注定要失败的  </p><h2 id="一、同构和层次"><a href="#一、同构和层次" class="headerlink" title="一、同构和层次"></a>一、同构和层次</h2><p>[[同构与层次]]</p><p>理解本书需要的最基础的一个单元，就是<strong>同构</strong>。同构的含义是<strong>保留信息的变换</strong>，也就是说，两个结构可以相互映射，并且每个结构的每个部分都在另一个结构中有且只有一个相应的部分。说得再明白一些，就是广义的「翻译」。</p><p>通过<strong>同构</strong>和对同构固定的<strong>解释</strong>，我们就可以创造出一个能够与现实世界的很具体的一部分产生映射的同构，并且通过使用这些发明出来的符号之间的推导，来推断现实世界未知的一些因素。基础算术就是一个很好的相对简单的例子，而在书中使用的更复杂的真正实现，是一种叫做<strong>TNT</strong>的数论系统。这个系统可以根据它本身的规则去有效地从已知公理和推导规则，去推理出系统内新的定理来。</p><h2 id="二、递归和自指"><a href="#二、递归和自指" class="headerlink" title="二、递归和自指"></a>二、递归和自指</h2><p>[[自指和怪圈]]</p><p><strong>递归</strong>从狭义上来讲，指的是计算机科学中（也就是像各位程序猿都熟悉的那样），指的是一个模块的程序在其内部调用自身的技巧</p><p>迭代的产生，来源于<strong>自指</strong>，即自己的部分指向自己本身。自指给了迭代以超出其范畴的表达能力，我们马上也会看到，自指也同样成为哥德尔的一把尖端武器，给了以希尔伯特为首的一帮子想要证明基础算术系统无矛盾的科学家们致命一击。</p><p>[[0大脑和思维]]</p><p>[[0大脑与自我]]</p><p>[[分子生物学与数理逻辑]]</p><p>[[巴赫与埃舍尔]]</p><h1 id="上篇-集异璧-GEB"><a href="#上篇-集异璧-GEB" class="headerlink" title="上篇 集异璧 GEB"></a>上篇 集异璧 GEB</h1><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><ul><li>巴赫<ul><li>巴赫以国王主题为题即兴创作「音乐的奉献」给普鲁士国王腓德烈大帝</li><li>卡农和赋格<ul><li>卡农：一个单一的主题与它自己相伴而奏</li><li>赋格：单独一个声部唱出主题，唱完后第二个声部或移高五度或降低四度进入</li></ul></li><li>无穷升高的卡农——Canon per Tonos<ul><li>引出怪圈的概念：向某一方向穿过某种层次系统中的一些层次时，正好回到了开始的地方</li></ul></li></ul></li><li>艾舍尔——怪圈的艺术<ul><li>「瀑布」，「上升与下降」、「画手」、「画廊」</li></ul></li><li>哥德尔<ul><li>「艾皮曼尼蒂斯悖论」或「说谎者悖论」：这句子是假的。</li><li>哥德尔不完备性定理<ul><li>数论的所有一致的公理化形式系统都包含有不可判定的命题</li><li>无论涉及到什么公理系统，可证性总是比真理性弱</li></ul></li></ul></li><li>数理逻辑提要<ul><li>十九世纪晚期，整理出严格的演绎推理模式，成书「思维的法则」</li><li>十九世纪八十年代，集合论<ul><li>集合论的悖论——怪圈仍然存在<ul><li>罗素悖论</li><li>格瑞林悖论</li></ul></li></ul></li><li>消除怪圈<ul><li>罗素和怀特海的「数学原理」：将所有集合分级，只有高一级的才可以包含该层，也就没有了怪圈<ul><li>分层法：将语言分层来禁止循环，从最底层的对象语言、元语言、元元语言等等</li><li>这种方法完全不能用在日常语言中</li></ul></li></ul></li><li>一致性、完全性和希尔伯特方案<ul><li>利用数学的一小部分来证明整个数学方法是正确的（相当于用手拽着鞋来确实地让脚离地，相对于抓自己的头发不能让自己升高）</li><li>哥德尔不完备性定理彻底否决了所有尝试</li></ul></li><li>巴比奇、计算机、人工智能……和巴赫<ul><li>查尔斯·巴比奇（1792-1871）构想出计算机的存储和加工装置</li><li>计算机和人工智能<ul><li>利用不同层次的规则（上层管理控制下层）来模拟智能</li></ul></li><li>巴赫代表音乐，有神学家认为人工智能永远无法理解音乐，那是灵魂的领域</li></ul></li></ul></li><li>哥德尔、艾舍尔、巴赫为三块异璧</li></ul><p> 三部创意曲</p><ul><li>芝诺与其为说明「芝诺定理」而创作的人物阿基里斯和乌龟</li><li>没啥内容，只作为起始介绍一下芝诺悖论和后面的出场两位虚拟人物</li></ul><h2 id="第一章-WU谜题"><a href="#第一章-WU谜题" class="headerlink" title="第一章 WU谜题"></a>第一章 WU谜题</h2><ul><li>形式系统</li><li>WU谜题：只使用WUJ三个字母和4条已有规则，把WJ变换为WU</li><li>定理、公理和规则<ul><li>定理：在形式系统中按照一定的规则产生出来的</li><li>公理：无偿提供的定理</li><li>规则：符号变换规则，生成规则，推导规则</li><li>推导：按照形式系统中的规则逐行生成该定理的明显论证</li></ul></li><li>系统内外<ul><li>机器有可能在做某件事的时不去观察，而人不可能不去观察。机器可以不知抱怨地重复做一样的事情而不意识到模式上根本就不会有结果。</li></ul></li><li>跳出系统<ul><li>如果系统的定义是按照规律做一些事情，那么计算机有能力跳出系统</li><li>如果系统的定义是计算机按照程序做所作的一切，那计算机很显然无法跳出系统</li><li>人在做一件事情重复失败的时候，会跳出系统观察总结反思</li></ul></li><li>W方式、J方式和U方式<ul><li>W方式：像有思维的人一样工作</li><li>J方式：像机器一样工作</li><li>U方式：禅宗的处世态度</li></ul></li><li>判定过程：WU真的可以出现吗？<ul><li>如果有一个检验定理的测试，一个总是在有限长的时间内终结的测试，那么，这个测试就叫做给定形式系统的判定过程。</li><li>公理有判定过程，定理则可以没有</li></ul></li></ul><p>二部创意曲</p><ul><li>无论是何种的推理，哪怕是最简单的三段论推理，仍然可以引入无穷多的前提，也就是说，永远无法完整无矛盾地证明</li></ul><h2 id="第二章-数学中的意义与形式"><a href="#第二章-数学中的意义与形式" class="headerlink" title="第二章 数学中的意义与形式"></a>第二章 数学中的意义与形式</h2><ul><li>以pq形式系统来模仿现实中的加减法<ul><li>公理定义、定理和定理生成规则</li><li>良构：构型良好的字符串，从形式上无法排除无法否认的符号串</li><li>自顶而下和自底而上<ul><li>自顶而下：拿到一条符号串，检测是不是公理，如果不是公理，将其分解成多个更短些的字符串，再次检查公理，一直分解下去，直到遇到公理或者不能再分解缩短为止（注：类似反证法，先假设要证明的是正确的，以此为条件来反推）</li><li>自底而上：拿到一个符号串，将所有的公理和它能产生的定理，以及定理产生的定理等等一一列出，直到出现符合该符号串规则的为止（注：常见的正顺序证明方法）</li></ul></li><li>同构产生意义<ul><li>同构：保存信息的变换。两个复杂结果可以互相映射，并且每一个结构的每一部分在另一个结构中都有一个相应的部分。</li><li>同构具有模糊性</li><li>「解释」：符号和词语之间的同构关系</li><li>有意义和无意义的解释——真理和定理相互对应的解释为有意义的</li><li>主动意义之于被动意义<ul><li>主动意义：所得到的新的意义，创造定理的规则也同时增加了，意义变成了规则</li><li>被动意义：在形式系统中，意义一定是被动的。我们没有权利根据新的意义来创造出新的定理。</li></ul></li><li>双重意义：行驶系统中的符号不一定只有一个确定意义，也有可能在其他的解释下，定理同样会变成真理。（2+3&#x3D;5和2&#x3D;5-3）</li></ul></li><li>形式系统和现实<ul><li>现实能不能用行驶系统来完整模仿吗？答案仍然不确定，因为答案关系到宇宙是否是以完全确定的方式运动。</li></ul></li><li>数学和符号处理<ul><li>我们无法在有限时间内通过穷举法验证形式系统的完整正确性</li><li>数学的乘法是基于一些加减法的性质，而这些性质被默认假定为对所有数字都有效，人们可以试验2x3的结果，但是无法验证123456789x987654321的结果</li></ul></li><li>算术的基本法则</li><li>理想的数：形式系统能够彻底把我数论的性质？<ul><li>欧几里得定理及其证明（注：搜索到的欧几里得定理和书中描写素数的定理不一致？）</li></ul></li><li>绕过无穷<ul><li>用有限的词语和正确的使用理解方式，来推广体现出无穷</li><li>欧几里得定理的仔细剖析可以得到数量极为庞大的互相有关联的微小证明</li></ul></li></ul></li></ul><p>无伴奏阿基里斯奏鸣曲</p><ul><li>模仿巴赫的「无伴奏小提琴奏鸣曲」</li><li>阿基里斯的电话独白</li><li>艾舍尔的「镶嵌画II」</li><li>开始引入「图形」与「衬底」的概念</li></ul><h2 id="第三章-图形与衬底"><a href="#第三章-图形与衬底" class="headerlink" title="第三章 图形与衬底"></a>第三章 图形与衬底</h2><ul><li>素数之别于合数</li><li>tq系统：pq系统的乘法版</li><li>把握合数：利用tq系统，如果xqy-tz-是定理，则Cx（是合数）是定理</li><li>对素数的非法刻画<ul><li>不能说对于一个数x，Cx不是定理，Px就是定理</li></ul></li><li>图形和衬底<ul><li>流畅可画出图形：衬底只是绘画过程中的替代品</li><li>倍流畅图形：图形和衬底都是流畅可画出的</li><li>例：以鸟作瓦、FIGURE-FIGURE</li></ul></li><li>音乐中的图形与衬底</li><li>递归可枚举集之别与递归集<ul><li>存在一个形式系统，其负空间（非定理集）不是任何一个形式系统的正空间（定理集）</li><li>存在非递归的递归可枚举集<ul><li>递归可枚举是艺术上的「流畅可画出」</li><li>递归是艺术上的「倍流畅」</li></ul></li></ul></li><li>素数作为图形而非衬底（证明素数）<ul><li>测试一个数能否被2整除，然后是3、4、5一直到x-1</li></ul></li></ul><p>对位藏头诗</p><ul><li>播放机在播放一些音乐的时候自我震碎了</li><li>Bach的上下前后颠倒以后，演奏尾声的时候，阿基里斯送给乌龟的巴赫的高脚杯炸碎</li></ul><h2 id="第四章-一致性、完全性和几何学"><a href="#第四章-一致性、完全性和几何学" class="headerlink" title="第四章 一致性、完全性和几何学"></a>第四章 一致性、完全性和几何学</h2><ul><li>隐含意义与显明意义<ul><li>很容易犯的错误：把全部意义归结于对象，而非对象与真实世界的联结。</li></ul></li><li>「对位藏头诗」的显明意义<ul><li>第一层意义是音乐意义</li><li>第二层意义是唱机引起的震颤序列<ul><li>第二层意义依赖于两个同构<ul><li>任意纹道模式与空气震颤之间的同构（发出声音）</li><li>任意的空气震颤与唱机震颤之间的同构</li></ul></li></ul></li></ul></li><li>「对位藏头诗」的隐含意义<ul><li>乌龟在前半部分是恶作剧的始作俑者，在后半部分却成了同样一出戏的受害者，这是一层和恶作剧本身一样的倒戈</li></ul></li><li>「对位藏头诗」与哥德尔定理之间的映射</li><li>赋格的艺术<ul><li>巴赫在将自己的名字使用进乐谱的时候，健康状况恶化，也是倒戈</li></ul></li><li>哥德尔的结果造成的问题<ul><li>没有一个足够强有利的形式系统会在下述意义上是完备的：能够把每一个真陈述都作为定理而重现在该系统中。</li><li>不完全性：对于任何一个形式系统，真理超出该系统所规定的定理资格</li></ul></li><li>修改了的pq系统与不一致性（x&#x3D;x+1）<ul><li>外部不一致：与世界真理不一致</li><li>内部不一致：x到底等于几？</li></ul></li><li>重新获得一致性：通过修改解释方法，q不再是等于，而是等于或小于</li><li>欧几里得几何的历史<ul><li>欧式几何的五条公设中，最后一条平行线公设最不美观</li><li>无数人试图证明第五共设是前四条共设的一部分，全部失败<ul><li>济罗拉莫·萨彻利，兰伯特，最后由雅诺·鲍勃和尼古拉伊·罗巴切夫斯基发现非欧氏几何</li></ul></li></ul></li><li>未定义项：没有确定的定义，而是借助在定理中扮演的角色而获得被动意义的（必去q可以使等于也可以是小于等于）</li><li>多重解释的可能性<ul><li>一致性不单是形式系统的性质，还依赖于为之提出的解释</li></ul></li><li>各种各样的一致性<ul><li>一致性：指其中每个定理经解释后都成为一个真陈述</li><li>如果每个定理经解释后成为真的，则系统加上解释是与外部世界一致的</li><li>如果所有的定理经解释后成为彼此相容的，则系统加上解释是内部一致的</li></ul></li><li>假想的世界和一致性<ul><li>一致性可以有很多标准：逻辑一致性、数学一致性、物理一致性、生物学一致性etc</li><li>有意思和没意思的分界线是年华在数学一致性和物理一致性之间的，也就是说，只有逻辑和书写的不一致性才算是</li><li>再次确认，破坏一致性只需要改变某些解释</li></ul></li><li>形式系统中嵌入形式系统<ul><li>形式系统常常是以相继的、或者说分层的方式构造出来的（形式系统1并入形式系统2并入3并入4）</li></ul></li><li>视知觉中的稳定性层次<ul><li>艾舍尔的「相对性」</li></ul></li><li>数论在每个可想象的世界里都是一样的吗？（注：抛砖引玉）<ul><li>皮亚诺算术</li></ul></li><li>完全性<ul><li>如果一致性是获得被动意义的最低条件，那么，完全性，是那些被动意义的最高确认</li><li>完全性：所有真的（在某个想象的世界里）且可表示成 系统中的良构符号串的都是定理。</li><li>pq系统就是完全的，不过它就像是低保音唱机，无法包容改进除了简单自然数加法外的数学理论</li></ul></li><li>一个解释怎样就能达到或破坏完全性？<ul><li>没有精确反映出定理在系统中的作为<ul><li>可以向系统中添加新的规则</li><li>可以紧缩解释</li></ul></li><li>修改后的pq系统：q不再是小于等于，而是等于或加1后等于</li></ul></li><li>形式化数论的不完全性<ul><li>试图增加规则以克服数论的不完全性，会陷入不断添加新的规则以克服之前添加规则的漏洞的无限迭代（类似「二部创意曲」一章）</li></ul></li></ul><p>和声小迷宫（图p169）</p><ul><li>阿基里斯和乌龟在游乐场玩，通过一条缆绳，在「大风车」的最顶端被拽入一架直升飞机内，郝晕说要把乌龟做成馅饼。阿基里斯和乌龟在郝晕的书房里发现一本叫做「阿基里斯和乌龟在全球瞎逛时引人入胜的历险」，开始阅读里面的一篇故事：「神怪和煮调饮」<ul><li>阿基里斯家<ul><li>故事中，阿基里斯和乌龟通过「推入露」进入到艾舍尔的「凹与凸」中，他们带着煮调饮以从画中回到现实。在画中，他们历险拿到神灯，神怪许给他们三个愿望，阿基里斯许愿他们能有一百克愿望可以被实现，但是神怪无法完成「元愿望」，只有通过自己的「元灯」找「元神怪」，「元神怪」通过自己的「元元灯」找「元元神怪」，一直到造物主，然后再次递归回来，告诉阿基里斯可以许一个无类型愿望，即任意愿望。神怪解释说，造物主「永远」到达不了，它不是某个神怪，而是在所有等级的神怪之外的概念。阿基里斯为了挑战无类型愿望的极限，他说他希望自己的冤枉不被批准。</li><li>系统因此崩塌，二者都被弹到了艾舍尔的「爬虫」中。阿基里斯不小心把带来的煮调饮碰掉，乌龟在读「乌龟和阿基里斯在全球各地转悠时的历险」，阿基里斯说要下一层去捡煮调饮，乌龟答应。<ul><li>这次他们进入了巴赫的「和声小迷宫」的唱片，他们在沟回之中奔走，乌龟说巴赫的这首曲子是以繁复的变调出名，在最后会留下隐忍遐想的突然不和谐终止。阿基里斯和乌龟都掉进大洞里，大洞是大雕（创造迷宫并且嘲笑一切迷路之人的大雕，暗指巴赫）的老窝，他们吃掉旁边的「弹出锅酥」，故事结束。</li></ul></li><li>二人向上爬了一层楼，从画中退出。</li></ul></li><li>二人回到了乌龟的房子</li></ul></li></ul><h2 id="第五章-递归结构和递归过程"><a href="#第五章-递归结构和递归过程" class="headerlink" title="第五章 递归结构和递归过程"></a>第五章 递归结构和递归过程</h2><ul><li>递归即嵌套<ul><li>地规定以从来不以某一事物自身来定义这个事物，而总是用比其自身简单一些的说法来定义这个事物。</li></ul></li><li>推入、弹出和堆栈：计算机科学概念<ul><li>堆栈可以理解为一摞盘子，往最上方放一个盘子为推入，从上方拿走一个盘子为弹出</li></ul></li><li>音乐中的堆栈</li><li>语言中的递归<ul><li>递归迁移网（RTN）：表示出为完成一项特殊任务可以遵循的各种通道</li><li>「终了」和异层结构<ul><li>定义中总会有一部分避免了自指，即到达了终了</li><li>异层结构：没有最高层次或控制层的程序结构，互相调用全部平等</li></ul></li><li>扩展节点：将所调用的程式代入调用的节点上</li></ul></li><li>图案G和递归序列（斐波那契数列）<ul><li>一个紊乱的序列<ul><li>Q(n) &#x3D; Q(n-Q(n-1)) + Q(n-Q(n-2)), when n&gt;2</li></ul></li></ul></li><li>两个令人惊异的递归图<ul><li>递归的定义需要1基底和2递归规则</li><li>INT图：由本身的无限迭代的副本组成的</li><li>G图，一个磁场中理想晶体里的电子的能量带</li></ul></li><li>物质最低层次上的递归<ul><li>裸粒子，即不和其他例子相互作用的粒子不存在。</li><li>例：当光子和电子为实际的「重正化了的」，二者要从A点到B点，必定会经过无法统计的互相牵扯。<ul><li>费因曼图案</li><li>每个存在的粒子都涉及到无数其他粒子的存在，在身后拖着「虚云」，「虚云」中的虚粒子又拖着它们的「虚云」，无限迭代</li></ul></li></ul></li><li>副本和同一性<ul><li>艾舍尔「鱼和鳞」「蝴蝶」</li><li>一个东西的部分是这个东西自身的副本，DNA，巴赫的音乐和艾舍尔的画都具有同一性，见微知著</li></ul></li><li>程序设计与递归：模块性、循环、过程<ul><li>循环：一遍一遍地执行某些相互有关联的步骤，当遇到指定的条件时就终止。</li><li>过程：（procedure？）把一组操作集合在一起，以方便随时调用</li><li>无处不在的「模块化」</li></ul></li><li>弈棋程序中的递归<ul><li>侯世达定律：做事所花费的时间总是比你预期的要长，及时你的预期中考虑了侯世达定律（注：这个定律其实也像是个递归）</li></ul></li><li>递归和不可预测性<ul><li>复杂到一定程度的递归系统，其能力可能会强有力得足够打破任何事先规定下来的模式。（使得智能能够成为智能）</li></ul></li></ul><p>音程递增的卡农</p><ul><li>对于同一文字序列的不同解释<ul><li>俳句</li><li>每个人都各有自己的方法来解译我们接受的信息</li></ul></li><li>音程增值的三首卡农在同一唱机上播放<ul><li>「4分33秒」约翰·卡奇</li></ul></li></ul><h2 id="第六章-意义位于何处"><a href="#第六章-意义位于何处" class="headerlink" title="第六章 意义位于何处"></a>第六章 意义位于何处</h2><ul><li>什么时候事物不总是同样的？<ul><li>意义是一条消息固有的，还是心灵或机器与一条消息的相互作用中产生的？</li></ul></li><li>信息携带者与信息揭示者：唱片与唱机</li><li>遗传型和表现型：DNA和生物</li><li>异常同构和平凡同构<ul><li>平凡同构：一个结构的各部分可以很容易地对应于另一个结构的各部分（唱片和唱机）</li><li>异常同构：遗传型和表现型的各部分不能很轻易地一一对应（DNA和生物）</li></ul></li><li>自动唱机和触发器<ul><li>触发器：触发了从遗传型到表现型的变化过程</li><li>唱机和唱片可以完全分离，意义位于长篇中，而唱机不过是大环境。DNA是否也是如此？</li></ul></li><li>DNA和化学环境的必要性<ul><li>一种观点认为：为了使DNA有意义，化学环境是必须的；另一种观点认为：揭示一束DNA的固有意义，只有智能是必须的</li></ul></li><li>一个假想的飞碟：如果一个</li><li>消息的理解层次<ul><li>就算外星人能够造出以太昌吉来播放唱片，仍然不能算是理解了唱片的真正意义</li><li>如果能直接在目标脑袋里制造同样的反应、景象和联想，那么不通过声音或光当做媒介也是可以的</li></ul></li><li>太空幻景<ul><li>任何消息是否在本质上都具有足够的内在逻辑，一旦遇到具有充分高智能的生物，其环境总能自动地建立起来？</li></ul></li><li>了不起的释读者<ul><li>「罗塞达碑」</li><li>意义在多大程度上以可以预测的方式作用于只能，就在此程度上是对象的一部分</li></ul></li><li>任何消息都分三层<ul><li>理解内在消息就是抽取出发送人所要传递的意义</li><li>理解框架消息就是确认需要一种解码机制</li><li>理解外在消息就是建造——或知道如何健在——能正确解译内在消息的解码机制</li></ul></li><li>薛定谔的非周期性晶体结构<ul><li>如果我们再某处发现一个非常规则的几何结构中「包裹着」非周期性晶体结构，那里就可能隐藏着一些内在信息</li></ul></li><li>三个层次行的语言<ul><li>如何从外部发现释读内在信息，如何在人们可能不知道内在信息解码机制的情况下，在外部信息中包括可以理解的解码机制？</li></ul></li><li>意义的「自动唱机」理论<ul><li>这个观点认为：消息不包含固有意义，因为在任何消息被理解之前，它都会被用作某个「自动唱机」的输入，而这就意味着该「自动唱机」所包含的信息一定会在消息中的意义被获取之前加在它上面。</li><li>悖论：但是人确实在理解一切，为什么？</li></ul></li><li>反驳自动唱机理论<ul><li>这个无限循环的迭代在人脑这一关卡停止，因为大脑是物理实体，并且运转过程中无需被告知如何运转，所以悖论被打破</li></ul></li><li>若智能是自然的，则意义是固有的<ul><li>在同样条件下，一个脑和另一和脑对一个给定的触发信号几乎产生完全一样的反应</li><li>如果我们相信人类只能只不过是一种普遍存在的自然现象的一个特例，那么所有智能生物都趋向于以和我们永阳的方式对这些触发信号做出反应，即以同样的方式解读意义</li></ul></li><li>地球沙文主义<ul><li>把意义归因于消息是出于：分布在宇宙各处的智能生物对消息所进行的处理具有不变性。但是这样考虑问题，会有地球沙文主义的嫌疑。</li></ul></li><li>太空中的两块金属板<ul><li>长遗传型：所包含的信息足以使智能生物能够仅从遗传型中推出把表现型从遗传型中抽取出来所需要的机制。</li></ul></li><li>再谈巴赫之别于卡奇<ul><li>智能喜爱模式化，厌恶随机性</li><li>要欣赏卡奇的艺术「4分33秒」，那么需要把整个艺术文化史和大环境全部表达出去，但要欣赏巴赫的音乐就不需要很多</li></ul></li><li>DNA中的消息有多大的普遍性<ul><li>DNA中的消息有限制地包含了一些其所在化学环境的信息</li><li>如果DNA序列使用碱基序列符号传送出去的话，那么就完全无法回复其化学环境，也就不可能被破译</li></ul></li></ul><p>半音阶幻想曲，及互格</p><ul><li>乌龟一直在自我矛盾，阿基里斯在为其指正，但阿基里斯最后居然被乌龟说服了</li></ul><h2 id="第七章-命题演算（注：百度百科词条「命题逻辑」）"><a href="#第七章-命题演算（注：百度百科词条「命题逻辑」）" class="headerlink" title="第七章 命题演算（注：百度百科词条「命题逻辑」）"></a>第七章 命题演算（注：百度百科词条「命题逻辑」）</h2><ul><li>词与符号</li><li>字母表和命题演算规则<ul><li>原子：演算过程中没有完全定义的placeholder，经常是大学英文字母或者小写希腊字母。一个原子没有固定的单一解释。</li><li>联结规则、分隔规则、双弯号规则、幻想规则、搬入规则、分离规则、易位规则、德·摩根（deMorgan）规则和思维陀螺（斯维彻罗？）规则</li></ul></li><li>良构串<ul><li>对于这个命题演算符号规则的一批例子</li></ul></li><li>幻想规则和递归<ul><li>无中生有制造定理的规则，一切定理的开始规则，用「[」和「]」表示开始和结束</li><li>幻想规则可以嵌套递归</li></ul></li><li>符号的预期解释<ul><li>对于原子的解释可以随着本身意义多种多样，<PVQ>可以解释为：要么你请客，要么我请客（要么两人都付钱AA制）</li><li>在命题演算中，所有的事情是纯粹「符号地」做出来的，完全机械的，不经思考的，硬性规定的，甚至是傻乎乎的。</li></ul></li><li>对规则的论证</li><li>摆弄这个系统（由这些规则进行一步一步的推理）</li><li>半解释：直接读出定理而不对原子进行解释</li><li>岩头之斧（一个由禅宗公案而来的复杂推理的例子）</li><li>存在一个对定理的判定过程吗？<ul><li>命题演算的结果是简单的，没有内容的，甚至感觉是浪费时间的，也正因如此，才能确保它在任何可能世界中都是真的，确保它是切合宇宙核心真理的。</li><li>判定过程：真值表方法（true table）</li></ul></li><li>我们知道系统是一致的吗？哪些预期的解释是否有资格被称为符号的被动意义？<ul><li>严谨观点（只有证明命题演算和世界的一致性） vs 马虎观点（命题演算的额定义本身就说明了其一致性）</li></ul></li><li>再谈卡罗尔对话（上一章中乌龟和阿基里斯的对话）</li><li>捷径与导出规则<ul><li>捷径：当一个定理被推倒证明了以后，就可以被用作一条新定理来证明其他的</li><li>但是因为导出的规则是非形式地导出的，它是在系统之外的，所以走这样的捷径丢丢掉了系统的形式性。</li></ul></li><li>将更高的层次格式化<ul><li>不能把不同层次的的推理混同在一起，就好像形式系统的语言和日常语言不能混淆一样</li></ul></li><li>对系统的长处和短处的思考<ul><li>可以对它本身的一些性质进行研究</li><li>命题演算能够很容易地扩充，把推理的其他一些主要的方面包括进来</li></ul></li><li>证明之别于推导<ul><li>一个证明是某种非形式的东西</li><li>一个推导是证明的人造对应物</li><li>证明是简单的，是我因为每一步都看上去是对的；推导是简单的，是指它的无数步骤中的每一步都被认为是微不足道的</li><li>命题演算应被当做是综合人工证明之类的结构的一般方法的一部分，它并没有很大的灵活性或一般性</li></ul></li><li>对付矛盾<ul><li>当我们遇到了一个矛盾，更可能会对导致了矛盾思维的信仰或推理方式产生疑问，而不是根据矛盾进行命题演算而得出结论</li><li>我们的思考方式和命题演算之间就存在着矛盾，也一直有人试图解决这种矛盾<ul><li>「相关蕴含」：仅当二者有关联的时候，一者才能由另外一者推导出</li></ul></li></ul></li></ul><p>螃蟹卡农</p><ul><li>巴赫的BWV1079：螃蟹卡农</li><li>模仿螃蟹卡农，所有人说的话在后半段以相反的顺序排列出来</li></ul><h2 id="第八章-印符数论"><a href="#第八章-印符数论" class="headerlink" title="第八章 印符数论"></a>第八章 印符数论</h2><ul><li>螃蟹卡农和间接自指<ul><li>印符数论TNT：Typographical Number Theory</li></ul></li><li>我们希望在TNT中都能表示些什么</li><li>数字 - 以0 为基础，S代表「后继」<ul><li>0 - 0</li><li>S0 - 1</li><li>SS0 - 2</li></ul></li><li>变元和术语<ul><li>变元：a,b,c,d,e,a’,a’’,b’’’</li><li>术语：加+、乘·、等&#x3D;</li><li>需要非常注意，不要把词语的普通意义和形式符号的严格手规则管辖的行为相混淆，尽管二者经常非常类似</li></ul></li><li>自由变元与量词<ul><li>量词<ul><li><span style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; background-color: rgb(255, 255, 255);">∃：exist 存在断言</span></li><li><div style="padding: 0px; color: rgb(0, 0, 0); word-break: keep-all; white-space: nowrap; -webkit-font-smoothing: antialiased; text-shadow: rgba(0, 0, 0, 0.00392157) 1px 1px 1px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; top: 6731px; left: 7297px; z-index: 350; background-color: rgb(255, 255, 255);">∀ ：any 全称断言</li></ul></li><li>量化变元：在量词管辖下的变元称为量化变元</li><li>带有自由变元的串表达了一个性质，量化变元的串表达了一个真实或者虚假的断言</li></ul></li><li>怎样区分真假</li><li>关于良构性的规则<ul><li>关于数字、变元、项（所有数字和变元以及其结合）、原子（如果s和t是项，s&#x3D;t是原子）、否定、复合、量化的规则</li></ul></li><li>一个非印符系统<ul><li>是否可能，以及如何印符地刻画所有对应于真理的串</li></ul></li><li>TNT的五条公理和第一条规则</li><li>皮亚诺五条公设：尽量把自然数的本质纳入到这五条公设支中</li><li>TNT的新规则：特称和概括<ul><li>特称的限制：用来替换串∀u:x中的u的项必须不包含任何在x中被量化了的变元</li><li>概括的限制：在一个幻想，不允许任何自由出现在该幻想的前提中的变元作概括</li></ul></li><li>存在量词<ul><li>互换规则：∀u:~ 和 ~<span style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; background-color: rgb(255, 255, 255);">∃u:</span></li><li>存在规则</li></ul></li><li>等号规则和后继规则</li><li>「全规则」<ul><li>如果在一个金字塔中的所有的串都是定理，那么，用来形容它们的全称量化的串同样也是定理。这一「全规则」的问题在于，只有从外部系统才能知道一个无穷集合的全部定理，所以超出了形式系统的范畴。</li><li>ω不完全系统与不可判定串<ul><li>ω不完全：一个系统的金字塔中所有的串都是定理，而全称量化的概述串却不是一个定理。</li></ul></li></ul></li><li>最后一条规则<ul><li>有一个起点，并且可以真理可以层层推下，那么可以归纳为∀</li><li>归纳规则：以0 为基础是真理，并且前一条真理（X{u}）指向了后一条真理(X{Su})，那么∀u:X{u}</li></ul></li><li>TNT中的紧张与解决<ul><li>数学推理中的美感和节奏</li></ul></li><li>形式推理之别于非形式推理<ul><li>在进行了彻底形式化之后，唯一可行的到道路就是放松形式化原则。否则，形式系统会过于庞大而笨重，以至于对任何实际的目的而言都是毫无用处的。</li><li>将所有思维模式放入TNT系统，对元语言进行形式化</li></ul></li><li>数论学家赋闲：如果TNT是完全的，那么所有数论问题都完全能够用纯粹机械的穷举法来解决了</li><li>希尔伯特方案<ul><li>希尔伯特和他领导的数学和逻辑学家希望，能够通过比TNT的推理模式更弱的推理系统来证明TNT的一致性</li><li>哥德尔定理证明：任何一个强得足以证明TNT的一致性的系统起码与TNT本身一样强</li></ul></li></ul><p>一首无的奉献</p><ul><li>禅宗公案<ul><li>把公案（一个词语序列）变成一个折起的串（一种三维的东西）<ul><li>转录：用拼音写出该公案，这种拼音只包涵四种符号，翻译出来的形式成为信使</li><li>翻译：利用「几何编码」，每三个几何符号决定了下一个折叠方式，将整个信使串完全折叠</li></ul></li><li>俱胝一指：对于模仿的反驳</li></ul></li><li>DNA</li></ul><h2 id="第九章-无门与哥德尔"><a href="#第九章-无门与哥德尔" class="headerlink" title="第九章 无门与哥德尔"></a>第九章 无门与哥德尔</h2><ul><li>什么是禅宗？<ul><li>没有任何办法能够刻画禅宗是什么。当试图用言语解释的时候，它总会跳到外面去</li><li>「破坏逻辑头脑」：只有跨出逻辑，摆脱理论，人才能跃入顿悟境地</li></ul></li><li>无门禅师</li><li>禅宗反对二元论的斗争<ul><li>二元论：把世界从概念上划分为种种范畴<ul><li>一旦你感知到一个客体，就已经把它与世界的其余部分化分开了</li><li>词语把我们引向某些真理（或某些虚假），但肯定不能引向所有真理</li></ul></li></ul></li><li>主义、无方式以及云门<ul><li>「主义」：禅所追求的东西。反哲学的，一种摒弃思维的存在方式</li><li>禅宗采纳整体论，并且推向逻辑的极端，认为整个世界根本不能被划分为一个个的事物，只能整体理解感悟</li><li>顿悟状态意味着自我和宇宙之间的分界消失了</li></ul></li><li>禅宗与堕界<ul><li>禅宗是一个系统，永远无法成为自己的元系统</li><li>艾舍尔和禅宗</li></ul></li><li>因陀罗之网：一切事物互相反映包含的网</li><li>无门论无</li><li>WU谜题的解：只有两条规则影响到J的数量，而除非一开始J的数量就是3的倍数，否则它们永远产生不了3的倍数来，所以WU不是WJU系统的定理</li><li>哥德尔配数<ul><li>将任何形式系统的问题都嵌入到数论之中，以数论规则来理解和解决</li><li>将每个符号都表示成一个数字，并且将规则用数字的变化规律表达出来</li></ul></li><li>从印符和算术两个角度看问题<ul><li>WJU系统可以视为一系列的音符操作，改变着符号的排列模式；也可以视为一系列算术运算，改变着数的量级</li><li>中心命题：在十进制中，若有一条印符规则表示为在数中进行移动、改变、删除或者插入，那么可以用算术运算法则来将其替代</li></ul></li><li>WJU可产生的数</li><li>「无朋」的两重性<ul><li>「无朋」：一个谈论WU谜题的TNT超长（注：长到没朋友？）符号串</li><li>两重性<ul><li>一个陈述可以通过哥德尔同构编码成一个数论问题（无朋成为编码消息）</li><li>数论陈述可以翻译到TNT系统中去（编码的符号成为了TNT符号）</li></ul></li></ul></li><li>编码与隐含意义<ul><li>现实中不存在未编码的消息</li><li>意义是在我们在辨认出同构时自动出现的副产品</li></ul></li><li>对TNT进行哥德尔配数<ul><li>TNT数会是一个递归可枚举集合</li><li>TNT试图吞掉自己：数论的形式化的本质导致其元语言嵌在其自身中</li></ul></li><li>G：以编码方式谈论自身的符号串<ul><li>G就是TNT的不完全的原因（注：类似第一章中的艾皮曼尼蒂斯悖论，即说谎者悖论），它表发了一个真理，然而却不是一个定理</li></ul></li></ul><h1 id="下篇-EGB-异集璧"><a href="#下篇-EGB-异集璧" class="headerlink" title="下篇 EGB 异集璧"></a>下篇 EGB 异集璧</h1><h2 id="前奏曲……"><a href="#前奏曲……" class="headerlink" title="前奏曲……"></a>前奏曲……</h2><ul><li>由费马大定理导向的：<ul><li>由现有的大气分子现状恢复几百年前巴赫的纯正演奏</li><li>证明过程中的自指</li></ul></li><li>由如何听巴赫「平均律钢琴曲集」中的赋格而提出整体论和简化论（注：或称为还原论）之间的互不兼容</li></ul><p>第十章 描述的层次和计算机系统</p><ul><li>描述的层次<ul><li>屏幕上显示的含义描述层次（卓别林在跑）和屏幕像素矩阵的含义（一大堆色点）</li></ul></li><li>组块化和棋术<ul><li>正常的对局过程中，会出现多次的某种局面，或者模式，大师对这种模式十分敏感。大师和新手在不同的层面上思考。</li><li>智能紧密地依赖于为复杂的对象构造高层描述的能力（将矩阵点理解为一副画面）</li></ul></li><li>相似的层次<ul><li>同一个系允许两种以上不同层次的描述，而这些描述又都是相似的，这种情况下容易混淆层次区别，迷失方向</li></ul></li><li>计算机系统<ul><li>存储器</li></ul></li><li>指令和数据<ul><li>指令：一组固定的有限的操作</li><li>数据：存储方式通常是记下数据的位置，并由指针指向那里</li></ul></li><li>机器语言之别于汇编语言<ul><li>汇编语言比机器语言更加高级</li><li>机器语言把机器语言的指令「组块化」了，更让人容易理解，更加便捷</li></ul></li><li>翻译程序的程序<ul><li>汇编程序：将汇编语言翻译成机器语言好让机器可以运行</li></ul></li><li>更高级的语言、编译程序和解释程序<ul><li>子程序&#x2F;过程（function&#x2F;procedure）：用已知的实体定义新的高层实体，并且可以随时通过名字调用</li><li>编译语言(compiled language)：将整个代码块同时进行完整的解释然后只能</li><li>解释语言(interpreted language)：每一行每一行地解释同时执行，读取、解释、执行同时进行<ul><li>Lisp（List Processing）语言：长期垄断人工智能语言</li></ul></li></ul></li><li>自举（注：bootstrap）：由程序自己来自动引导接下来的一系列行为，就像是哪些行为被包装好了<ul><li>一个部分完成了的编译程序而已对其他部分进行编译，直到完整得出整个所期望的编译程序</li></ul></li><li>运行着的程序的各种描述层次（注：最明显的例子就是当发生exception的时候我们查看的stacktrace）</li><li>微程序设计和操作系统<ul><li>微型计算机：非常低层次的微指令<ul><li>这种微指令可以做进电路，成为硬件的一部分</li></ul></li><li>操作系统</li></ul></li><li>方便用户并保护系统<ul><li>一个系统的多层级使得人们只需要关心最上层的实现，而无需关心底层的复杂，同时也避免了人们对系统底层的运行造成破坏</li></ul></li><li>计算机是过于灵活还是过于刻板？<ul><li>如果出现了任何拼写错误或者违反规则的编程方法，程序非常有可能立刻就会崩溃</li></ul></li><li>猜出程序员的意图<ul><li>灵活性和可靠性不能兼得</li></ul></li><li>人工智能的进展即语言的进展</li><li>妄想狂和操作系统<ul><li>操作系统无法回答它被编写的规则之外的问题</li></ul></li><li>软件和硬件之间的界限<ul><li>所有的灵活的软件下面都必然有着最底层的不灵活的硬件</li><li>人脑也可以分为硬件和软件，而我们软件的某些方面很明显是由硬件控制的</li></ul></li><li>中间层次和天气<ul><li>可以无限迭代下去的层次</li><li>地区的雨雪和全球冰川期相比是很低层次的，而和某个地点的一股风相比可以看做是很高层次的</li></ul></li><li>从龙卷风到夸克<ul><li>原子的结构也可以根据整体论和简化论（注：或称为还原论）而理解出不同的层面</li><li>「几乎可分解系统」，各个部分可以单独独立出来而又有互相联系的系统</li></ul></li><li>超导：一个关于重正化（重正化：第五章，表示粒子之间的作用力正常开启的模式）的「悖论」<ul><li>超导的原理是对部分进行了组块化，所以在该层次上出现了超导的现象</li></ul></li><li>「隔离」<ul><li>层次之间是相对隔离的（注：或者说越隔离越有灵活性），所以人们不需要下面层次的事物</li></ul></li><li>组块化和确定性之间的利弊平衡<ul><li>组块化模型通常不具有精确的预测力</li></ul></li><li>「计算机只能做你告诉它去做的事情」<ul><li>但是，人很难预知告诉计算机去做的事情可以导致什么结果</li></ul></li><li>两类系统<ul><li>第一类：某些部分的行为趋向于抵消另一些部分的行为，结果是在高层次看基本没有影响</li><li>第二类：单个底层时间的效果将被放大成一个巨大的高层后果</li></ul></li><li>旁效现象：整个系统组织的可见结果（人的极限跑步速度是根据全身的整体状态得来的）</li><li>心智能否完全区别于大脑？</li></ul><p>……蚂蚁赋格</p><ul><li>以一首四声部赋格的形式，通过对于三幅包含多个不同层次信息的图案，和蚁群马姨的层次划分和最高层的交流能力，以及蚁群和人脑之间的映射，来表达出对不同层次的理解会导致不同的看法，而且智能要在一定层次之上才会体现出来</li><li>被动符号 vs 主动符号</li><li>最高层次上描述似乎最有解释力</li><li>「信号」和「符号」，「信号」映射于兴奋状态的神经元，「符号」映射于大脑状态</li><li>在大脑中，主动的符号总是在调节自身，以反映出大脑的整个状态，这一切总是在符号水平之上</li><li>高层次会对低层次一无所知（注：应该只在封装隔离非常完好的情况下）</li></ul><h2 id="第十一章-大脑和思维"><a href="#第十一章-大脑和思维" class="headerlink" title="第十一章 大脑和思维"></a>第十一章 大脑和思维</h2><ul><li>关于思维的新观点</li><li>内涵与外延<ul><li>注意：在现实世界中，符号和事物之间不必具有严格的一一映射关系</li><li>内涵的：描述可以「篇幅」着而不落在实在具体的已知客体上<ul><li>一个关于世界的灵活的内涵表示是思维的全部所在（注：换句话说，思维就是一个能够构造虚构概念和世界的东西）</li></ul></li><li>外延的：概念依赖于物质实体</li></ul></li><li>大脑中的「蚂蚁」<ul><li>即神经元，人脑中有约100亿个，每个最多可以有20万个不同的输入端口，输入的综合超过阈值后发射电化学流，每秒频率可达上千次</li></ul></li><li>脑的大尺度结构</li><li>脑之间的映射<ul><li>所有蚯蚓的脑在神经细胞级别是完全同构的</li><li>人类脑之间的映射可以达到什么等级的同构？</li></ul></li><li>大脑过程的定位：一个谜<ul><li>无法确实地判断大脑思维过程究竟是不是对应于某个大脑区域</li></ul></li><li>视觉处理的特性<ul><li>视网膜的神经元-&gt;侧膝体中转站-&gt;大脑正后方的视觉皮层</li><li>简单细胞、复杂细胞、超复杂细胞和高阶超复杂细胞，依次渐渐从最简单的信号处理到高级的识别</li></ul></li><li>一个「祖母细胞」？<ul><li>是否存在一个「祖母细胞」，当祖母出现在视野中时，它就会被最终激活？</li></ul></li><li>汇集到神经模块<ul><li>并没有找到大尺度硬件和高层次软件之间的直接对应关系，无法确认哪一部分的大脑就是控制哪部分工作的</li><li>「汇集」替代「祖母细胞」：信息处理的终点是一组神经元，当祖母有进入视野的时候全部发射，对于每个不同的可识别对象，都有唯一的一个神经元网络和聚焦于该网络的汇集过程<ul><li>也有可能汇集的过程不是必须的，本身视觉细胞的反应印迹或集体反应可能就是标识</li><li>使人看到了同一对象的景象可以有无数个（穿着各种各样的祖母）</li><li>一个同样的印迹可以有不同的解释</li></ul></li></ul></li><li>作为思维过程媒介的模块<ul><li>对应于每个概念，都存在一个界说良好的可触发模块，「神经复合体」，但是这个模块的界限仍然无法圈定</li><li>作者感觉，要理解意识现象，对同一个脑的同一个状态来说，低层次的描述（面向神经元）要变成高层次的描述（面向模块）才可以。</li></ul></li><li>活跃的符号<ul><li>活跃的符号之间互相保持联系</li><li>符号的规模：大概是一个单独的词汇所能表示的东西</li></ul></li><li>类与例（一个类别和该类别的个例）</li><li>原型规则<ul><li>原性原则：最具体的时间可以被用作一雷时间的一个一般范例</li><li>一般性即寓于特殊性之中</li><li>例符号和类符号可能同时存在，而不仅仅前者是后者的激活方式</li></ul></li><li>从类中分离例<ul><li>当我们仅仅得知一个个体的类别的时候，我们本能地将脑中的类的属性继承给了该个体；当对于该个体了解得越来越多的时候，该个体也越来越独立于类而存在而拥有了自己的各种属性</li></ul></li><li>搞清符号间的纠葛是很难的<ul><li>一个极端：符号代表了一整个类，每个不同的个例都以不同的方式激活该符号</li><li>另一个极端：每一个个例都有一个符号</li><li>中间情况：多种类与例的区分方式</li><li>多个符号还可以绑定在一起成为一个新的符号</li></ul></li><li>符号——是软件还是硬件？<ul><li>一种理论认为存在硬件上可区分的符号</li><li>一种理论认为符号可以重叠，但能靠激活方式来彼此区别</li></ul></li><li>智能的可抽取性<ul><li>如果可以自足地解释高层次的符号激活通讯，建立一个不涉及底层神经事件的理论，那么只能就可能实现于不同于大脑的其他硬件上</li></ul></li><li>单个符号能否被隔离出来？<ul><li>符号可互相辨别区分但是不能隔（类似互相调用的RTN）</li><li>一个符号的个性存在于它与其他符号的相互联系</li></ul></li><li>昆虫的符号<ul><li>人独有的智能：类中产生例，例中产生类</li><li>例子：黄蜂像是被编码写好地重复机械程序</li><li>人思考「如果我这样就会这样这样」的能力来自于构造例并处理的能力</li></ul></li><li>类符号和假想世界<ul><li>符号可以成为符号的模板，这样人的心智就获得了某种相对于现实的独立性：人可以在想象中创造宇宙</li><li>人们的精神很大一部分是同构的，但是在边界区附近，愿意接受哪一种假想世界却是带有鲜明主观色彩的</li></ul></li><li>直观的物理定律<ul><li>物理定律可以为假想的物理定律所取代</li></ul></li><li>过程性知识和描述性知识<ul><li>描述性知识：具象地存在大脑某处（北京总人口）</li><li>过程性知识：分布在各处，是一个程序的工作过程的全局性结果，是旁效现象的结果（家里有几张桌子）</li></ul></li><li>视觉表象<ul><li>思维是如何构成一个虚拟的视觉表象的？<ul><li>表象可能是基于我们对运动行为的抑制能力的</li></ul></li><li>即使是言语可达的知识，也要以复杂得不可达的过程为媒介，才能到达可以用语言表达的状态中</li></ul></li></ul><p>英、法、德、中组曲</p><ul><li>刘易斯·卡罗尔的Jabberwocky和它的各种译文组成，毫无意义</li><li>试图引入这个问题：不同的语言，或者说不同的心智，可以互相映射吗？</li></ul><h2 id="第十二章-心智和思维"><a href="#第十二章-心智和思维" class="headerlink" title="第十二章 心智和思维"></a>第十二章 心智和思维</h2><ul><li>心智之间能够彼此映射吗？<ul><li>我们关心的是在符号层次上是否存在同构</li><li>我们可以放弃寻找精确的同构软件，不过很明显存在着某些部分的软件同构，能将风格相似的大脑联系起来</li></ul></li><li>不同语义网络的比较<ul><li>任何网状结构，都可以考察局部性和总体性</li></ul></li><li>Jabberwocky的翻译<ul><li>说明在两个不同的网络中，试图找出「相同的结点」这样的问题</li><li>所有语言的翻译，读者在大脑之间存在着一种粗略的同构，部分是总体的，部分是局部的</li></ul></li><li>自想国：凭靠想象画出的精确国家地图</li><li>版图换掉：在自想国中旅游，却拿着显示的地图。在大方面会有不少一致，但细节方面全乱套了</li><li>中心性和普遍性<ul><li>中心即为「节点」，类似符号，公路则像是潜在的触发通道</li><li>每个人的符号网络很大一部分是有普遍性的，人们在大多数方面是一致的</li></ul></li><li>语言和文化在多大程度上引导思维？<ul><li>语言的本地性不仅要依靠用词，词汇之上还有「联想层次」</li><li>不通语言的人，思维在符号的层面上很相似，但更精细的层面就不那么相似了</li></ul></li><li>自想国中的旅行和旅行路线<ul><li>一个想法若充分经常地在一个人的大脑中重现，它就会逐渐地组块化而形成一个单独的概念</li><li>旅行路线代表思维过程</li></ul></li><li>可能的、潜在的、反常的通道<ul><li>潜在的通道：只出现特殊外部环境的时候我们才走它</li><li>任何离奇的通道都可以分解为一些不离奇的路段，离奇的思维可以分解成简单的信念和知识</li></ul></li><li>小说翻译的不同风格<ul><li>对于不同翻译风格的比较</li><li>有一种可以客观描述的意义隐藏在符号之中，也就是说，一个很好的程序是有可能捕捉到其意义的</li></ul></li><li>程序之间的高层次比较<ul><li>比较程序的时候，我们事实上实在比较不同程序所做的事情是否一样，即所谓「以太件」（相对于软件硬件）</li></ul></li><li>大脑之间的高层次比较<ul><li>人的大脑高层次是肯定可以被读出的，因为我们的语言就是用词汇来形容所思所想</li><li>我们的描述是高度组块化的，以至于我们不必在乎描述的是大脑的哪一部分</li></ul></li><li>潜在信念，潜在符号<ul><li>大脑状态本身不具有说明哪条路线将被采纳的信息，外界环境在决定路线的选择时扮演着极为重要的角色</li><li>一个大脑状态的组块化描述将由一个带或然性的登记表构成，其中列着一些符号，它们在各式各样「多半合理」的环境中（这些环境也是在组块层次上描述的）最可能被唤起。</li></ul></li><li>自我意识在哪里？<ul><li>意识是系统的一种性质，每当系统中有服从触发模式的符号时，这种性质就会出现</li></ul></li><li>子系统<ul><li>一个复杂的符号，符号集群，具有自己的可选符号集，并且在其内部可以相互触发</li><li>我们的亲密朋友在我们大脑中就是以子系统的方式存在的</li></ul></li><li>子系统和共用编码<ul><li>子系统可以调用大脑其他部分的符号，假设子系统所代表的事物的观念中和我的观念中该符号的意义等同（注：这一点其实是默认的）</li><li>计算机的某些方面正在达到同样的复杂性，互相调用，多个程序共用一段编码</li><li>艾舍尔的例子说明，大脑中的某类子系统一旦被激活，就几乎是自主的了（注：应该只在很复杂的子系统中存在）</li></ul></li><li>自我符号与意识<ul><li>由于自我子系统可以对自己进行观察，它必定有表示心智活动的符号，即符号的符号</li><li>自我符号即意识</li></ul></li><li>我们与卢卡斯的初次会面<ul><li>卢卡斯认为，有意识物是个整体，因为能够在意识到别的东西的同时意识到自己，并且不可分解，所以破解了哥德尔式的问题。而机器需要更加复杂，复杂到临界点以上的程度，才会开始自行其是不可预知。</li></ul></li></ul><p>咏叹调及其种种变调</p><ul><li>巴赫的「哥德堡变奏曲」</li><li>「哥德巴赫猜想」有穷的证明</li><li>「哥德巴赫变奏」无穷的证明</li><li>有穷但不知道终点于何处（有终止但不可预测其终止）的检验</li><li>数论中，单个数字的特性都是所有数的特性的体现。（注：推而广之，我想任何存在的任何特性都是周围大环境的部分体现）</li></ul><h2 id="第十三章-BlooP和FlooP和GlooP"><a href="#第十三章-BlooP和FlooP和GlooP" class="headerlink" title="第十三章 BlooP和FlooP和GlooP"></a>第十三章 BlooP和FlooP和GlooP</h2><ul><li>BlooP和FlooP和GlooP是三门专门为本章发明的语言</li><li>自我意识和无序<ul><li>要在形式化的情况下分析自我意识</li><li>一个奇怪的现象：一个复杂到能反映自身的有序系统不可能是完全有序的，其中必定包含某种无序特征（而在无序之中，又有种某种奇特的无序的有序）</li></ul></li><li>可体现性与冰箱<ul><li>冰箱对于唱片内容的体现性不足</li><li>全部原始递归真理的可体现性将作为一个系统足够强有力的判别标准</li></ul></li><li>元数学中的岩头之斧：无论系统如何，哥德尔之斧都会说它是不完全的</li><li>选择适当的过滤器来发现有序<ul><li>一些复杂的无序现象，人们后来都发现只不过是很温顺的有序现象的某个不同角度的看法</li></ul></li><li>BlooP语言（Bounded Loop）<ul><li>只能相加、相乘和比较，并且循环有次数上界</li><li>块结构（Block）</li><li>IF条件语句和分支</li><li>自动组块（调用之前已经定义的过程）</li><li>可以输出boolean（T或F）</li><li>定义了一个过程之后，需要调用才算开始运行</li><li>可以用BlooP来计算的函数叫做「原始递归函数」，可以用BlooP来测验证的性质叫做「原始递归谓词」</li></ul></li><li>可表示性和可体现性<ul><li>可表示性：可以从自然语言翻译到严格的形式化表述</li><li>可体现性：谓词的全部真的例都是定理，假的不是定理</li></ul></li><li>原始递归谓词在TNT中是可体现的<ul><li>如果能为自然数的某个性质写出一个BlooP测试，那么这个性质在TNT中是可体现的</li></ul></li><li>存在非原始递归的函数</li><li>B库、索引编号和蓝程序<ul><li>我们通过过滤，在B库（即所有可能的BlooP程序的库）中选出「计算哪些恰有一个输入参数的函数」，称为蓝程序。按照程序的字符长度排序，并给予编号。</li></ul></li><li>对角线法<ul><li>定义程序「蓝对角」（N）&#x3D;1+蓝程序[#N]（N）</li><li>如果蓝对焦是一个蓝程序，也就有了一个编号，比如说是X，「蓝对角」（N）&#x3D;蓝程序[#X]（N）</li><li>当N&#x3D;X的时候，上面两个程式出现悖论，也就是说，按对角不在B库里面，不能用BlooP语言写出</li></ul></li><li>康托尔本人给出的原始对角线论证<ul><li>证明如果建立了一个实数的「登记表」，那么它就不可避免地要把某些实数拒之门外</li><li>把0-1之间的无限个小数实数写出来，取对角线上的数字（即第一个数字的第一位，第二个数字的第二位……），然后全部减去1.这样一来，新得到的数字和所有数字都至少有一位不同，即不在表中。</li></ul></li><li>FlooP<ul><li>和BlooP的唯一区别就在于没有循环次数上限</li><li>一个很吸引人的想法：制造出一个有限的判断过程来判断FlooP有否终止<ul><li>图灵的妙计：将程序进行哥德尔配数法送入判断程序之中</li><li>如果存在终止测试器，那它的能力可以直接判断任何数论性质的正确与否</li><li>最后在Gloop之后论证，这种判断不存在</li></ul></li><li>F库、索引编号和绿程序<ul><li>绿对角和蓝对角一样，但是它有可能遇上没有终止的程序，所以无法确定值</li><li>假设存在终止测试器，并将其设定为最后一个过滤器，得到红程序库，红对角就成了和蓝对焦一样的悖论：我们有一个函数可以人工计算，但是不在FlooP计算能力之内</li></ul></li></ul></li><li>GlooP<ul><li>将Floop再一次「释放」？</li><li>丘奇-图灵论题：<ul><li>人所能计算的也就是及其所能计算的</li></ul></li><li>如果丘奇-图灵论题为真，那么GlooP不存在</li></ul></li><li>一些概念<ul><li>「原始递归」：BlooP可计算</li><li>「一般递归」：能用有终止的FlooP程序计算的</li><li>「部分递归」：能用没有终止的FlooP程序计算的</li></ul></li><li>TNT的能力：原始和一般递归的完全性</li></ul><p>G弦上的咏叹调</p><ul><li>暗示着哥德尔的自指，用类似于「“由六个字组成”由六个字组成」或「“放在其引文后面得到假句子”放在其引文后面得到假句子」之类主语即除了主语外的句子本身的自指来类比</li></ul><h2 id="第十四章-论TNT及有关系统中形式上不可判定的命题"><a href="#第十四章-论TNT及有关系统中形式上不可判定的命题" class="headerlink" title="第十四章 论TNT及有关系统中形式上不可判定的命题"></a>第十四章 论TNT及有关系统中形式上不可判定的命题</h2><ul><li>「牡蛎」里的两个想法<ul><li>某些TNT符号串能解释成在谈论另一些TNT符号串，即「自省」</li><li>这种自我审视的性质可以全部集中于一个单个的符号串</li></ul></li><li>第一个想法：证明对<ul><li>两个自然数形成一个TNT证明对，当且仅当m是某个TNG推导的哥德尔数，而该推导的最末一行是哥德尔数为n的符号串</li><li>「是证明对」测试时原始递归的，因而可再TNT中实现</li></ul></li><li>证明对的威力<ul><li>证明对既可以用TNT共识表示，也可以用其体现</li><li>表现出了TNT「自省」的能力</li></ul></li><li>代入导致的第二个想法<ul><li>将一个值（或者表达式）的哥德尔数代入到原方程的哥德尔数中去</li></ul></li><li>算术㧟(注：kuai三声)摁（蒯恩的音似体）<ul><li>ARITHMOQUINE(a’’,a’)：a’是对哥德尔数的算术㧟摁所得公式的哥德尔数</li></ul></li><li>最后一锤<ul><li>悖论出现了<ul><li>G的「服」号串：~<span style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; background-color: rgb(255, 255, 255);">∃a:</span><span style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: nowrap; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none; background-color: rgb(255, 255, 255);">∃a’:&lt;TNT-PROOF-PAIR{a, a’} AND ARITHMOQUINE{a’’, a’}&gt;</span></li><li><span style="background-color: rgb(255, 255, 255);">将G的</span>「服」号串哥德尔配数，表示为u</li><li>将u重新代入G的唯一自由变量a’’</li><li>所得到的TNT翻译成话：不存在数a和数a’使得：1. 它们形成TNT证明对 2. a’是u的算是㧟摁化</li><li>因为G本身就是u的算术㧟摁化，2肯定是错的，所以只能说它们a和a’不是证明对</li><li>也就是说G在说：没有一个数a能与u的算术㧟摁化形成TNT对</li><li>即u的算术㧟摁化不是TNT定理（因为不能找到TNT证明对）</li><li>但u的算是㧟摁化就是G本身</li><li>也就是说，经过这些推论，我们得出G本身在说「自己不是TNT定理」的结论</li><li>如果假设G是定理，那么很显然是矛盾；如果G不是定理，没有直接矛盾，但是G不是定理这一事实正是由G所断定的，所以G讲的是真理，但G又不是定理，是真理但不是定理，所以TNT出现了不完全性。</li></ul></li></ul></li><li>哥德尔第二定理<ul><li>在TNT内部表示TNT一致：不一致性是说两个相悖的公式都是定理。而根据TNT命题演算规则，所有良构的公式就是定理。所以，要说明TNT的一致性，只需要提出一个TNT的句子，然后说明这个句子可以被证明为不是定理就行了。例：证明公式~0&#x3D;0不是TNT定理。</li><li>（注：这一方法好像只能证明在一些特定情况下的TNT一致性）</li><li>TNT用来表示一些事物的时候，可以很轻易地表现出反省的能力。但是要让它证明这些事物，反省能力就很差劲了</li></ul></li><li>TNT是ω不完全的<ul><li>由于G本身不是定理，当然也就没有自然数会和G的哥德尔数构成证明对，也就是说，任何数和u的算术㧟摁化都不形成TNT对，即在所有值代入情况下G都是真的，但是G本身不是定理，即ω不完全</li></ul></li><li>两个不同的补洞方法<ul><li>把G加进去作为新公理</li><li>把G的否定(~G)加进去作为新公理<ul><li>超自然数I<ul><li>与u的算术㧟摁化形成TNT证明对的数</li><li>通过重新解释存在量词和全称量词，也就是在自然数中引入了超自然数，矛盾自然消失，TNT+G变成了一个一致的系统</li></ul></li><li>我们需要习惯这样的想法：~G（G有证明）是真理，而G（G没有证明）不是真理</li><li>超自然数的加减法<ul><li>用三个一组的数字为超自然数I进行编号，以方便进行加减乘除法</li><li>没有一个编号方案能既方便地算加法和乘法（注：好像还没有定义超自然数的加法和乘法？）</li></ul></li><li>超自然数是有用的，并且作为数学工具，在特定情况下是真实有效的</li><li>几何学的分叉现象与物理学家<ul><li>物理学家用何种不同的几何学来分析内涵</li></ul></li><li>数论的分叉现象与银行家<ul><li>数论是分析工具，再古怪的数论也不能否认现实中单纯十进制算术的正确性，银行家不同担心</li></ul></li><li>数论中的分叉现象与元数学家<ul><li>和银行家和物理学家不同，数理逻辑学家必须去分清这些概念</li><li>一般说来，数理逻辑学家相信TNT是ω一直的，所以在该系统中所构造出的哥德尔符号串都是在该系统诶不可判定的。</li></ul></li></ul></li></ul></li><li>希尔伯特第十问题与乌龟<ul><li>丢番图方程</li></ul></li></ul><p>生日大合唱哇哇哇乌阿乌阿乌阿……</p><h2 id="第十五章-跳出系统"><a href="#第十五章-跳出系统" class="headerlink" title="第十五章 跳出系统"></a>第十五章 跳出系统</h2><ul><li>一个更强有力的形式系统<ul><li>TNT的弱点本质就在于它能表示自指陈述，即「我在形式系统TNT中不可证」</li><li>TNT+G</li><li>再用哥德尔方法，同样得到「我在形式系统TNT+G中不可证」</li></ul></li><li>多重分叉现象<ul><li>叉的产生源自于选择G还是~G作为系统补充</li><li>可以呈树状结构二叉树无限分叉下去</li></ul></li><li>本质不完全性<ul><li>只要一个系统是良定义的，它就变得脆弱了</li><li>在康托尔对角线法中，正式「明晰地排列」0-1之间的实数这一举动导致了垮台</li><li>哥德尔自指方法所以来的3个条件，所有符合这三个条件的形式都能被证明不完全<ul><li>陈述：该系统要足够丰富，以便全部所需要的有关数的陈述，无论真假，都能在其中表示</li><li>推理变化：所有一般的递归关系（注，即能用有终止的FlooP程序计算的）都能用该系统中的公式体现</li><li>辨认定理：公理以及根据该系统的规则所确定的印符模式，都能通过某个有终止的过程来辨认。（辨认出是不是公理和定理）</li></ul></li></ul></li><li>卢卡斯式的非难<ul><li>卢卡斯会用不完全性当做机器人无法达到人类智慧的证据，因为人类能发现一个真的数论语句，但计算机却无法打印出来</li></ul></li><li>跳高一维<ul><li>艾舍尔「龙」</li></ul></li><li>智能系统的限度<ul><li>反驳卢卡斯：正因为我们无法写出哥德尔化的程序这个事实，才让我们应该怀疑我们是不是在一切情形下都能使用哥德尔办法</li><li>不存在能给序数命名的递归规则，同理，没有一个算法能说清如何对所有种类的形式系统使用哥德尔方法。</li><li>任何一个人将在某一点上达到他自己作哥德尔化能力的极限。超过这一点后，尽管这个形式系统仍旧不完全，但却和人一样强有力（注：事实上也是在暗示人的思维也不完全）</li><li>这只是反驳卢卡斯的一个方法</li></ul></li><li>对卢卡斯的其他反驳</li><li>超越自我——一个现代的神话<ul><li>一个人能从大脑的一个子系统中跳刀一个更宽广的子系统去，这可能会让人们产生超越自我的错觉</li><li>上帝能不能创造出一块自己举不动的石头？</li></ul></li><li>广告和框架手法<ul><li>框架手法先创造出一个局限，然后就可以通过条粗那个局限让人们觉得释放、解脱和超越</li></ul></li><li>辛普利奇奥、萨尔维亚蒂、萨哲杜：为什么要三个<ul><li>萨哲杜作为一个中间人，但仍然是系统的一部分，需要更高一层的冲裁，然后是更高一层的，无限迭代</li></ul></li><li>禅宗和「走出」<ul><li>通过逐步加深一个人的自我意识，打破他领悟到的所有束缚自己的规律，逐渐扩展「该系统」的范围，他最终将会感到与整个宇宙相一致。</li></ul></li></ul><p>一位烟民富于启发性的思想</p><ul><li>关于唱机的讨论暗示了哥德尔不完全定理的牢不可破</li><li>关于摄像机和屏幕的讨论暗示了互相嵌套，以及不断往系统内添加新的元素（注：类似于G）以反应整个系统的无限迭代</li></ul><h2 id="第十六章-自指和自复制"><a href="#第十六章-自指和自复制" class="headerlink" title="第十六章 自指和自复制"></a>第十六章 自指和自复制</h2><ul><li>隐性和显性的句子<ul><li>例：「本句子有七个字」就是隐性的，需要人有足够的语言能力理解「本句子」的指代</li><li>如果用该句子本身代替「本句子」三个字，那么会陷入无限循环</li><li>蒯恩的构造在这个意义上很像哥德尔构造：都是通过描述另一个同构于蒯恩的句子的字符串来创造自指。这间接地跳过了无限循环的陷阱。</li></ul></li><li>一个自复制程序<ul><li>接受一个参数，并且重新打印出和该函数（拥有同样的输入参数）一模一样的输出</li><li>秘密在于，有一个符号串以两种方式起着作用，首先是作为程序，其次是作为数据（注：有点让人想到编程中的反射机制）</li><li>利用词组「本句子」几乎可以说是个骗局，因为对于「本句子」的分析很依赖于人们的解读，其本身并没有直接揭示自指性</li></ul></li><li>什么是副本？<ul><li>一首自复制的歌<ul><li>歌曲的自制内容不在选个按钮上，而在唱机里</li></ul></li><li>一个螃蟹程序<ul><li>一样东西和它的镜像是否含有同样的信息？</li><li>它们有不同的外在消息，却有同样的内在消息。如果我们再确定意义的时候忽略一定的外在消息，那么本体和镜像就包含相同的信息</li></ul></li><li>说谎者横跨太平洋<ul><li>「这句话翻译成太平洋另一侧的语言，并在前面加上引号，就得到假句子」is an expression which, when it is preceded by its translation, places in quotation marks, into the language originating on the other side of the Pacific Ocean, yields a falsehood.</li></ul></li><li>打印字机的哥德尔数的程序</li><li>哥德尔式的自指<ul><li>G是借助翻译（注：翻译成哥德尔数）达到自指的一个突出例子</li></ul></li><li>通过增值达到的自复制<ul><li>有些微变化的自复制同属于一类，复制的东西也是一类而不是一例</li></ul></li><li>凯姆式自复制：输入一条错误信息给程序，设法让程序打印出同样的错误信息</li></ul></li><li>什么是原件？<ul><li>自复制可以包括比单纯复制自己更丰富的内容，可以包括其程序，解释程序和处理机</li></ul></li><li>印符遗传学<ul><li>用来模拟分子生物学中DNA在细胞中的自复制</li><li>串、基、酶<ul><li>基：ACGT四个字母（嘧啶：T（胸腺嘧啶）C（胞嘧啶），嘌呤A（腺嘌呤）G（鸟嘌呤））</li><li>单元：基所占的位置</li><li>串：ACGT组成的任意序列</li><li>酶：对串进行操作的机器<ul><li>最开始喜欢拴在某种基之上</li><li>对串进行一系列的操作</li></ul></li></ul></li><li>复制状态和双串<ul><li>复制一个串，把基的相反(A-T; G-C)倒置在单元上</li></ul></li><li>氨基酸<ul><li>共有十五种指令，每个指令代表着一种氨基酸，也就是说，酶是一串氨基酸组成的</li></ul></li><li>翻译和印符遗传密码<ul><li>根据印符遗传密码，每两个基翻译成一个氨基酸</li></ul></li><li>酶的三级结构<ul><li>一级结构是指氨基酸序列，三级结构是由一级结构决定的，指的是酶的折叠方式，折叠方式决定了「喜欢」栓的基的种类</li></ul></li><li>标点、基因与核糖体<ul><li>标点：AA串表示一个酶的结束</li><li>基因：一个串中，给一个酶编码的那个部分</li><li>核糖体：读串并产生出它们编码的酶的装置（在印符遗传学中，就是人）</li></ul></li><li>串定义了酶，核糖体读出酶以后，酶重新作用于串，得到新的串，再继续产生新的酶，以此循环</li></ul></li><li>怪圈、TNT及实际的遗传学<ul><li>DNA与核苷酸<ul><li>核苷酸：脱氧核糖+磷酸基+基。基可以用来鉴别核苷酸。</li><li>DNA：脱氧核糖核酸。由核苷酸构成。通常是两条逐个配对的核苷酸串组成，顺着脊柱方向是由强共价键相连的，双串之间由弱氢键相连。</li></ul></li><li>信使RNA与核糖体<ul><li>核糖体在细胞质内，DNA在细胞核内，mRNA（信使RNA）负责传递信息</li><li>转录：DNA复制到mRNA上。DNA拆成单串，其中一个作为模板，mRNA与其对应配对，不过mRNA中没有T，而要换成U</li><li>酶属于蛋白质，而核糖体是制造蛋白质，而不仅仅是酶。但不是酶的蛋白质大多不活跃，所以我们这里不再区分。</li></ul></li><li>氨基酸<ul><li>20种</li></ul></li><li>核糖体和录音机<ul><li>翻译：mRNA进入细胞质和核糖体发生的过程</li></ul></li><li>遗传密码<ul><li>三元组而不是二元组</li><li>三级结构：三级结构蕴含在一级结构之中，但是中间的推导方式仍然复杂且未知</li></ul></li><li>蛋白质功能的简化论解释<ul><li>在实际的酶中，组成酶的氨基酸不是负责一个明晰的作用片段。确定酶作用方式的，是整体的三级结构</li></ul></li><li>转移RNA与核糖体<ul><li>tRNA：DNA产出，带有遗传密码和氨基酸。当核糖体解析mRNA的时候，核糖体会抓住一个漂浮在附近的额正好与解析中的mRNA互补的tRNA，并从上面撤下氨基酸，放到正在组创的蛋白质上</li></ul></li><li>标点和阅读框架<ul><li>标点同样标出一个蛋白质结束构造</li><li>阅读框架：DNA含有多层含义，可以通过改变其阅读框架的方式，对同一个串进行不同的解析</li></ul></li></ul></li><li>蛋白质与音乐中的多层结构和意义<ul><li>蛋白质一二三四级结构层次，可以对应音乐中乐句、旋律、乐章、全曲</li></ul></li><li>多核糖体和二排卡农<ul><li>多核糖体对统一mRNA的解析，和多mRNA从同一DNA上的生成，形成了先后有时差的二排卡农</li></ul></li><li>谁生谁——核糖体与蛋白质<ul><li>核糖体是由蛋白质组成的，蛋白质又是核糖体产生的，那么谁先生谁？</li></ul></li><li>蛋白质的功能<ul><li>大多数酶只执行单一任务，而不是一串任务</li><li>生物酶可能对细胞中所有东西发生反应</li></ul></li><li>DNA指挥自己复制需要一个强有力的支撑系统<ul><li>需要保证mRNA能从DNA中制造出蛋白质——比如RNA聚合酶</li><li>某些核糖体</li></ul></li><li>DNA如何自复制<ul><li>两个串分开（DNA核酸内切酶）</li><li>给刚刚得到的两个新单串各配上一个新串（催化酶复制并移动，连接酶去连接新串上可能存在的缝隙）</li></ul></li><li>DNA的层次<ul><li>DNA所包含的意义从一系列氨基酸、蛋白质代码，以致高到个人特征</li><li>从DNA到特征有两种方法，一个是做出伪渐成程序，模拟整个演化过程。一个是捷径，从遗传型直接读出表现型</li></ul></li><li>中心法则映射<ul><li>分子生物学中心法则与数理逻辑中心法则的映射</li></ul></li><li>中心法则映射与「对位藏头诗」<ul><li>哥德尔的对应物看起来是一种自杀性的病毒，并没什么意义</li></ul></li><li>大肠杆菌与T4之战<ul><li>分子特洛伊木马：T4侵入大肠杆菌后，向细胞中注入病毒DNA，并伪装骗过本土核糖体开始生产病毒蛋白质，然后组装新的病毒本身</li><li>识别、伪装和标识：标识出本土DNA并排斥一切未标识的</li></ul></li><li>汉肯句子：断言自己在特定形式系统中可以生成的句子。<ul><li>和G很类似，只不过没有开始的否定号。G是断言自己不能生成。</li><li>隐式汉肯句子和显式汉肯句子<ul><li>显式汉肯句子显式地描述了自己的推导，但显式汉肯句子不一定是定理</li></ul></li><li>自组装病毒和非自组装病毒<ul><li>自组装病毒不必告诉细胞任何有关它们结构的事情就可以复制，而后者需要给出一些如何组装它们的指令</li></ul></li></ul></li><li>两个突出的问题：分化与形态发生<ul><li>反馈和前馈<ul><li>当需要的物质太多或者太少，就会发生反馈，调整组装这种物质的生产线</li><li>否定的前馈或者反馈<ul><li>抑制：阻止有关的酶起作用</li><li>阻遏：阻止有关的酶产生<ul><li>阻遏物：在DNA长线上的一个障碍物，组织RNA聚合酶工作</li></ul></li></ul></li><li>肯定的额前馈或者反馈<ul><li>反抑制</li><li>反阻遏<ul><li>诱导物：和阻遏物结合，从而阻遏「阻遏物」生效</li></ul></li></ul></li><li>两个相邻的、具有完全相同基因类型、但有不同功能的细胞之间的额区别，在于它们的基因组中的不同节段收到阻遏</li></ul></li><li>分化<ul><li>复制的过程中，经常要出一些疏漏，每一副本也会有些不同，最后导致了相差很大的结果</li></ul></li></ul></li><li>细胞中的层次混合<ul><li>各个层次之间 （程序、解释程序、处理剂、数据）紧密相关交叉混合</li><li>用计算机科学的用语来总结DNA复制过程中的元素（注：感觉非常杂乱）<ul><li>DNA：用高层语言写出，随后被翻译成机器语言的程序；一段数据</li><li>蛋白质：「细胞的机器」语言写成的程序；数据；解释程序</li><li>处理机：细胞</li><li>翻译：从高级语言到机器语言</li><li>tRNA：规定了高级语言的定义</li></ul></li></ul></li><li>生命的起源<ul><li>这种复杂是如何开始的？</li></ul></li></ul><p>的确该赞美螃蟹</p><ul><li>螃蟹使用了长笛来演奏数论陈述，并通过其优美与否判断真假</li></ul><h2 id="第十七章-丘奇、图灵、塔斯基和别的人"><a href="#第十七章-丘奇、图灵、塔斯基和别的人" class="headerlink" title="第十七章 丘奇、图灵、塔斯基和别的人"></a>第十七章 丘奇、图灵、塔斯基和别的人</h2><ul><li>形式的和非形式的系统<ul><li>思维的每一个方面，都可以看成是从较高的层次上描述的一个位于较低层、受某些简单的乃至形式的规则支配的系统</li><li>要了解大脑这复杂的系统，唯一的方法是在越来越高的层次上对之组块，因而每一步都要损失一些严格性。</li><li>大脑智能最外层表现出来的是飞行石化的、公开的、软件的层次，而基层是一个形式化的、隐蔽的、硬件的层次</li></ul></li><li>直觉和值得赞美的螃蟹<ul><li>丘奇定理：没有一个切实可靠的方法总能区分开TNT的定理和非定理</li><li>塔斯基-丘奇-图灵定理：没有一种切实可靠的方法总能区分开真的数论语句和假的数论语句</li></ul></li><li>丘奇-图灵论题<ul><li>同义反复形式：数学问题只能通过数学推演来解决</li><li>标准形式：假设有一种方法，一个有感知能力的生物可以根据这种方法逐个把数分成两类。又假定这种方法总能在有穷时间内得出答案，而且对于给定的数，这种方法总能给出相同的答案。那么：存在一个有终止的FlooP（即一般递归函数），它给出的答案恰好与这个有感知能力的生物的方法所得到的答案一样。（即：把数分成两类的任何一个心智过程都可以用FlooP程序来描述）</li><li>大众过程形式：鉴于一些超常人的特殊能力，要加上条件：假定这种方法可以通过语言由一个感知能力的生物不走样地传达给另一个有感知能力的生物。<ul><li>Srinivasa Ramanujan，印度著名数学能力超常者</li><li>驳斥心算家，只是能够快速地调补运算，而不是直接得出答案</li></ul></li><li>哈代形式：从本质上讲，所有数学家都同构（注：拥有同样的数学逻辑思维来解决问题）</li><li>同构形式：标准形式添加结论：这个心智过程和这个FlooP在下述意义上同构：在某个层次上，计算机和大脑各自执行的那些步骤之间存在一个对应</li><li>微观形式：一个生物体的各组成部分的行为能够用计算机来模拟。也就是说，任何元素的行为，都能用一个FlooP程序——在给定该元素的内部状态和外部环境的一个足都精确的描述之后——计算到任意精读的程度</li><li>简化论形式：全部的大脑过程都可以从一个可计算的基质中导出。</li><li>唯灵论形式：大脑所能做的某些种类的事情可以大致地由一台计算机来模拟，不过不是大多数事情，而是些不那么吸引人的事情。不管怎么说，及时都能模拟，灵魂仍将留待解释，而且没有什么方法能让计算机来承担这个任务</li><li>反科学形式：计算机是荒唐的。一般说来科学也都是如此。</li><li>人工智能形式：任何种类的心智过程都可以用一个计算机程序来模拟，而该程序的基础语言与FlooP一样强。</li></ul></li><li>对于现实世界的知识的表示<ul><li>一个数论问题一经提出就完全是自足的了，然而现实问题却不然，根本不能绝对有把握地把它与现实世界的任何一个部分隔离开来</li><li>数论世界中，顶层体现和底层实现可以隔绝开来，现实世界中，人脑的思维方式却不能<ul><li>如果要反映大脑对现实世界的理解过程，就必须反映正在发生的某些较低层次的事情。</li><li>想象和类比的思维过程本质上都需要有若干层次的基质，因而本质上都不可撇出。就是在这些地方，创造性可能开始浮现</li></ul></li></ul></li><li>人工智能研究能否对大脑的模拟平行发展？<ul><li>根据人工智能的标准不同，我们可以说我们已经有了各种各样的AI</li></ul></li><li>非理性的东西与理性的东西可以共存于不同的层次<ul><li>任何非理性的东西，如果存在，就是在较高的层次上，而且是低层事件的旁效现象——一个后果而已。</li></ul></li><li>人工智能论题：随着智能机的发展，它的基础机制会逐渐收敛于人类只能的基础机制</li><li>丘奇定理和塔斯基定理<ul><li>反证了无论如何都不会有什么方法能使人类可靠地分清定理和非定理</li></ul></li><li>形式的两种类型<ul><li>句法性质：可以用有终止的检验来检查的性质</li><li>语义性质：不可以用有终止的检验来检查的性质</li><li>句法的判断是固定的，存在于所考虑的客体内的，但意义来自认知结构间的联系，并可以无限延展</li></ul></li><li>美的概念是极难把握的</li><li>说谎者悖论的神经机制<ul><li>也许大脑并不总是能够为真理概念提供不过一个完全精确的描写</li></ul></li></ul><p>施德鲁，人设计的玩具</p><ul><li>用人和AI之间的互动来阐明设计AI的时候需要注意到的繁多事项。哪怕是很简单的步骤，也可能有多种歧义需要判断。</li></ul><h2 id="第十八章-人工智能：回顾"><a href="#第十八章-人工智能：回顾" class="headerlink" title="第十八章 人工智能：回顾"></a>第十八章 人工智能：回顾</h2><ul><li>图灵测验<ul><li>进行问话，通过回答能否确定被问者是机器还是人类</li><li>因为是希望机器模仿人类，那么对于机器就很不公平。难道说机器就不能某种思维，但是人类却不具有吗？</li><li>图灵预料到了该有的反对意见，并且一一提前进行驳斥，包括的方面：神学、鸵鸟式、数学化、各种缺陷、洛夫莱斯命妇、神经系统、行为非形式化和超感官知觉</li></ul></li><li>「帕里遇上了医生」<ul><li>医生是模拟精神病医生的程序，帕里是模拟妄想狂的信念结构的程序，二者的对话毫无意义</li><li>依赖于对输入的性质的巧妙猜测，然后从库中甄选出答案</li><li>人们对此缺乏警惕和怀疑心理，是利用了人清新心理</li></ul></li><li>人工智能简史<ul><li>1822年差分机</li><li>泰勒斯定理：一旦某些心智功能被程序化了，人们很快就不再把它看做「真正的思维」的一种本质成分。即，人工智能是尚未做到的东西。</li></ul></li><li>人工智能领域概览<ul><li>机器翻译<ul><li>涉及到建立一个心智模型，然后去处理模型中的符号。否则很快就会陷入意义不清的混乱。</li></ul></li><li>计算机弈棋<ul><li>人们低估了弈棋的难度。有可能超前几步模拟搜索是没用的，需要把超前的信息蒸馏成一种感觉</li></ul></li><li>塞缪尔的跳棋程序<ul><li>动态和静态，超前搜索和静态估值之间互相影响综合得出结果</li></ul></li><li>计算机音乐<ul><li>如果计算机是一个创造性的工具，被人用来实现想法，那么计算机就没有功劳。如果计算机可以独自源源不断地拥有灵活性和自我意识地创造音乐，计算机和发明者功劳各占一半。</li><li>对于一句话中「我」字指向于谁的探讨</li></ul></li><li>定理证明和问题分解<ul><li>订立证明的难点在于要让程序朝向「有关的」方向前进，以免陷入使用纯粹蛮力遍历的情况</li><li>问题分解：把总目标转化成推导的局部策略</li></ul></li><li>改变问题空间<ul><li>狗和骨头面前有一道篱笆，狗可以选择绕过篱笆，也可以选择在篱笆前狂吠</li><li>在一个空间中被看成是后退的行为，在另一个空间中可能被看成一个革命性的进步。</li></ul></li></ul></li><li>程序何时才有独创性？<ul><li>看证明是本来深藏在程序之中，还是接近程序的表面。也就是说，要使多大劲才能看清程序为什么要做它所做的事？</li></ul></li><li>再谈W和J方式<ul><li>J方式被嵌入到某个固定的框架之中，W方式总可以后退几步看清全貌</li></ul></li><li>人工智能用于数学<ul><li>「麦克西玛」程序帮助处理复杂的数学表达式</li><li>另一个程序在初等数学中发明概念并发现现实</li></ul></li><li>人工智能的关键：知识表示<ul><li>一个领域的表示方式，很大程度上决定了该领域是怎样被理解的</li><li>人类用很复杂的方式存储事实</li><li>设计信息编码的时候可以设计成编码为数据或过程，看哪种最合适</li></ul></li><li>遗传信息存在DNA而不在蛋白质中的优点：容易重组，容易复制翻译到蛋白质中，而且占地小。</li><li>知识的模块性<ul><li>模块化越高，对于修改单独层面的信息就越容易</li><li>知识表示与人希望以何种方式使用这条知识也有关</li></ul></li><li>在一个逻辑系统中表示知识<ul><li>使用类似TNT中的命题和量词来表示知识</li><li>反向链接：从大目标开始反向工作，寻找可以达成大目标的子目标</li></ul></li><li>演绎式认识之别于类比式认识<ul><li>注：演绎式类似推导，类比式类似联想</li><li>当人遗忘，往往是失去了一个高层指针，而不是某些信息被破坏或者删除</li></ul></li><li>一个小型图灵实验<ul><li>作者程序的3个句子和9个摘录的句子混在一起（注：有些很难分辨出来）</li></ul></li><li>一个关于思维的想象<ul><li>思维是交轨的列车，互相影响变化</li></ul></li><li>一个程序生成的公案<ul><li>漏洞百出缺乏逻辑，但是有点公案的意思</li></ul></li><li>音乐的语法<ul><li>音乐的语法看起来是纯粹符号的简介，但是其内涵是和人的心智缠绕在一起的</li></ul></li><li>维诺格拉德的程序「施德鲁」<ul><li>程序没有把问题分解，而是把一系列操作以一种过程性的只是表示形式缠绕在一起</li><li>基本观点：所有语言的使用都可以被看成是一种激活听话人心中的过程的手段</li><li>使用Planner语言，具有分解问题和回溯（一条路走不通回去换一条）的特点</li><li>施德鲁虽然是以数学逻辑构成的，但是对数学却一窍不通，因为层次之间分隔良好</li></ul></li><li>一个系统的分层应该多少层最合适？</li></ul><p>对实</p><ul><li>对位+反事实</li><li>对话中很多事实都充满了用词错乱</li><li>对于一场比赛可能发生情况的模拟，应该是在暗指人工智能在给定事实之后对未来走向的判断，有点像弈棋</li><li>暗指下一章的内容</li><li>最后表示众人也在虚拟的世界里</li></ul><h2 id="第十九章-人工智能：展望"><a href="#第十九章-人工智能：展望" class="headerlink" title="第十九章 人工智能：展望"></a>第十九章 人工智能：展望</h2><ul><li>「差一点出现」的情景与虚拟情景<ul><li>日常思维中，从我们面临的情况、拥有的想法和客观发生的事件之中，我们总会构造出一些精神上的「变奏曲」，让某些性质保持原样，而让另一些性质发生「滑动」，从而形成一些虚拟的（或称为对实的）情景<ul><li>假如没有这种幻想的、虚拟的、反决定论的语言工具，没有产生并存储在大脑皮质的「多余」部分中的语义能力，并以此来想象和表达那些在单调沉闷的生物性衰退和死亡之外的各种可能性，人类是几乎不可能生存至今的。（p849）</li></ul></li><li>哪些性质是允许滑动的？</li><li>哪些滑动是自然的？</li></ul></li><li>稳定性的分层<ul><li>某些事情特征的可滑动性，取决于我们在一个什么样的嵌套环境集合中感知此事件的发生。<ul><li>类似常量、参量和变量的可变性层次区分</li></ul></li></ul></li><li>框架和嵌套的环境<ul><li>框架：一个环境的可计算例式</li><li>框架语言中，情景的心智表示包含着彼此嵌套的框架。情境中的各种成分都有它自己的框架。<ul><li>世界是由半封闭的子系统构成的，其中每个子系统都能充当其他子系统的环境，并且在此过程中不会受到或造成太大的破坏。</li><li>例：如果一个人是橄榄球队员，那么就有了橄榄球队员的框架，有了一个橄榄球队员的各种缺省值（缺席选择）</li></ul></li></ul></li><li>邦加德问题：分辨出两组图形之间的差别<ul><li>通过预处理选择微词汇表<ul><li>处理出所有的显著特征，例如线条、颜色、大小、形状等等</li><li>差不多是潜意识和意识的交汇点</li></ul></li><li>高层描述<ul><li>不一定所有的描述都是真正正确而有预见性的</li><li>解决手段：添加、去掉信息，从另一个角度看同样的信息</li></ul></li><li>模板和同一性检测器<ul><li>同一性检测器：在个体的描述之间巡视，找出同一性</li><li>模板&#x2F;描述模式：适用于描述问题中所有框的统一模式。例：大圈x个，小圈y个<ul><li>槽：模板上需要被子描述填充的变量</li></ul></li><li>概念网：网络中所有已知明晰、形容词等等都被相互联接起来了，而联接的方式就说明了它们的相互关系<ul><li>允许开始的错误想法被一点点修改，直至变成正确的</li></ul></li></ul></li></ul></li><li><ul><li>滑动和尝试性<ul><li>例：线段、线列之间的滑动</li></ul></li><li>元描述<ul><li>情况复杂难以入手的情况，本身就说明了差别存在于较高的抽象层次上，而不是存在于简单的几何描述中，也就是说，要用「元描述」来描述</li></ul></li><li>灵活性<ul><li>灵活性很重要，而且程序中很可能解决问题的过程不唯一</li></ul></li><li>集聚和过滤<ul><li>集聚：聚焦于图像的某一部分，而排除掉其他的部分</li><li>过滤：以某种特定的方式来观察框的内容，而完全不顾及其他方面</li></ul></li><li>科学研究和邦加德问题的世界<ul><li>范式转换：常规科学和观念革命之间的分水岭（注：指的好像是思维方式和角度的转换）</li></ul></li><li>与其他类型思维的联系<ul><li>要明白认知中的一些过程，比如回溯、转换层次、忽略一些差别等等都需要直觉，而直觉来自于思维的一般经验</li><li>人关于世界中真实对象的经验对他描述或重新描述某些框的方式会产生微妙的影响</li></ul></li></ul></li><li>传送消息的语言、框架和符号<ul><li>演员形式：彼此间往返传送精心设计的任意长、任意复杂的消息<ul><li>每个演员都用自己的特有方式来解释给定的消息</li><li>框架+演员&#x3D;符号（注：即多重相对层次之间的关系，和所有部分之间的信息传送，组成了可以生成和解释复杂消息的符号）</li></ul></li><li>传送消息类似于邮政系统</li></ul></li><li>酶与人工智能<ul><li>酶一触即发，用在人工智能中称为「精灵」</li><li>酶递归的多级瀑布</li></ul></li><li>裂变与聚变<ul><li>裂变：一个符号逐渐脱离它的母符号</li><li>聚变：多个原来互不相干的符号由于参与了某个「连带激活」，彼此频繁地往返传送消息，紧密地联系在一起<ul><li>很难设想出一个通用的算法，能从相互碰撞的符号中构造出有意义的新符号来。</li></ul></li><li>例：螃蟹卡农的渐成过程</li></ul></li><li>概念骨架和概念映射<ul><li>概念骨架：连接两个不同想法的抽象结构（沿某个特定角度对一个概念进行抽象后得到的一种观点）</li><li>概念映射：思想在不同抽象层次上不断地映射的过程</li></ul></li><li>重组的思想<ul><li>一旦决定要使两个观念发生聚变，问题就变成：从某个能使类似部分得以表现的层次上来观察它们，然后逐步在各部分间建立映射关系，如此递归地工作下去，知道发现某个满意的层次为止</li></ul></li><li>抽象、骨架、类比<ul><li>概念骨架类似于一个常量特征集，这些特征不产生滑动</li></ul></li><li>多重表示<ul><li>概念骨架存在于不同的抽象层次和概念维度上</li><li>一个类比可以有很多重理解方式</li></ul></li><li>出入口<ul><li>每种特殊的思维类型的特点之一，就是看新经验是如何被分类装入记忆中的，因为这就定义了将来把它们取出来时候所用的「把柄」</li><li>出入口：能够唤醒某个思维的特征。</li><li>隔板：符号之间的滑动阻碍</li></ul></li><li>受迫匹配：高层的相似关系具有很大的强制性，以至于即使这种对应没有明显地延续到低层，你也得去造出一个来</li><li>概括（p888）</li><li>创造性和随机性<ul><li>流行观念认为创造性依赖于随机性</li><li>随机性是思维的一种固有特性，不能认为人类思维的随机性来自于衰变的原子核或者随机数表之类</li><li>表面相似的东西常常并没有深入的联系，而有深入联系的东西又常常看上去毫不相干。(p890)</li></ul></li><li>从所有层次上取出模式<ul><li>机器不具有形成新概念或识别模式的本部分裤，它没有关于多余的东西和总体概貌的意识</li></ul></li><li>语言的灵活性<ul><li>语言的奇妙：我们很不准确地使用它，但仍能不出毛病。</li></ul></li><li>智能与情感<ul><li>举例说明了要想理解情感需要明白的海量人类相关知识和经验</li></ul></li><li>人工智能任重道远</li><li>是个人工智能相关的问题和推测</li></ul><p>树懒卡农</p><ul><li>模仿巴赫的「反向进行的增值卡农」</li><li>开始呼应开头的三部创意曲和二部创意曲了（乌龟和阿基里斯赛跑）</li></ul><h2 id="第二十章-怪圈，或缠结的层次结构"><a href="#第二十章-怪圈，或缠结的层次结构" class="headerlink" title="第二十章 怪圈，或缠结的层次结构"></a>第二十章 怪圈，或缠结的层次结构</h2><ul><li>机器能具有创造性吗？<ul><li>阿瑟·塞穆尔：除非机器已经得到如何去做这些事的指令，否则它不会也不可能去做这些事</li><li>驳斥塞穆尔：机器和人两者都是由硬件构成的，而硬件可以按照物理学定律完全独立地运行。<ul><li>机器在某一天仍可能具有意愿。它们拥有意愿的原因和你相同——都是因为许多层次上硬件和软件的组织与结构</li></ul></li></ul></li><li>每个缠结的层次结构下面都有一个不受干扰的层次<ul><li>言语和思维在最底层硬件上遵从形式规则</li><li>软件的灵活性来自与硬件的稳固性</li></ul></li><li>一种自我修改的棋<ul><li>可以修改规则的棋，会产生元规则，元元规则等等</li><li>每走一步棋，规则都会相应变化，变化后的规则又影响走棋本身</li><li>不受干扰层和缠结层永远可以混淆在一起</li></ul></li><li>再谈作者三角形<ul><li>三角形的三个人都是坐着陛下的任务，这样就完成了现实中不可能完成的循环圆</li></ul></li><li>艾舍尔「画手」</li><li>大脑和心智：一个神经元纠结支持一个符号纠结<ul><li>类似反馈的简单缠结，不会涉及到扰乱预先设定的层次划分</li><li>在语言谈论自身的时候，无论间接还是直接，它的确构成了一个怪圈</li><li>如果走得足够远，往往可以发现能引向无缠结事物的线索</li></ul></li><li>政府中的怪圈<ul><li>政府本身犯法，由谁来决定审判权和法律解释权？</li><li>0915 一旦……无法跳出系统寻求更高层的权威，那时唯一办法是求助于那些看上去没有用规则定义清楚的力量，而它们才是更高层规则的唯一来源——这就是低层规则。</li></ul></li><li>与科学和鬼话有关的缠结<ul><li>那些超感官知觉的人想说明：出了毛病的并不是他们的想法，而是科学的信念系统</li></ul></li><li>证据的本质<ul><li>不能用规则规定什么是证据</li><li>我们确定事物的有效性和真实性的过程是一门艺术，它深深地依赖于一种对美和简单性的感受力</li><li>「什么是证据？」这个问题的重要性</li></ul></li><li>认识自己<ul><li>0920 关于“我是谁”的完整画面是在整个精神结构中通过某种极其复杂的方式被拼出来的。而对我们每个人来说，这幅画面中都包含大量尚未解决，可能是无法解决的矛盾。这无疑提供了大量的动态张力，而这种张力对人来说起着很大作用。从这种张力之中，在关于我是谁的内部观念和外部观念之间，产生了指向各种不同目标的心理驱力，这就使我们每个人都成为独一无二的。</li></ul></li><li>其他学科中可以和哥德尔定理类似的联想</li><li>哥德尔第二定理表明，一个精神失常的人断定自己是一致的时候，必然会有矛盾出现</li><li>我们能否理解我们自己的心智或大脑<ul><li>对大脑状态的完全控制是天方夜谭，但深刻地理解自身的心智结构是有可能的</li><li>对一个需要快速做出许多决定的世界，张力和混乱是必不可少的。</li></ul></li><li>哥德尔定理和个人的不存在<ul><li>试图家乡自己的不存在的情况以跳出自己之外，必然无法做到</li></ul></li><li>科学与二元论<ul><li>量子力学观察者和观察对象的相互干扰</li><li>元数学中主体、客体的混合</li></ul></li><li>现代音乐与绘画中的符号与对象之别<ul><li>抽象、超现实画派和无意义音乐</li></ul></li><li>玛格丽特的语义错觉画：「常识」、「两个谜」和作者的两幅「烟斗」</li><li>现代绘画的「编码」<ul><li>现代画家希望取消「翻译」的这个步骤，而直接将图画中蕴含的信息表达给观众，当然是失败的</li><li>艺术品的框架效应：观众们会因好奇心而产生疑虑，去琢磨出原本不存在的含义来</li><li>现代艺术晦涩难懂的原因，是因为艺术对象中传送了一个消息的缠结的层次结构</li></ul></li><li>再谈主义<ul><li>主义：一般是某个词的后一部分，正好暗示了一种没有内容的意识形态，体现了意识中的禅宗精神</li><li>0933 我们正是这样看世界的：我们把它看作存在于我们之外，尽管它只不过是我们在内心中所体验到的一个对于世界的心智表示而已。</li></ul></li><li>理解心智<ul><li>如果不下降到硬件层次，那么理解是完全可能的</li><li>哥德尔定理并没有禁止我们用过程序再现我们自己的智力水平（DNA和繁殖生长已经证明了这一点）</li></ul></li><li>智能是碰巧不可说明的吗？<ul><li>在自我理解实在的时候，不一定始作俑者是哥德尔式的缠绕，也有可能知识人的智能达不到理解原理而已</li></ul></li><li>不可判定性与高层观点不可分离<ul><li>一个系统的高层观点可能会包含某种在低层上完全不具有的解释能力</li><li>解释G的非定理性的唯一途径是发现哥德尔配数，在一个完全不同的层次上来看TNT</li><li>每个不可判定命题实际上都是一个哥德尔语句，它通过某种编码在某一系统中陈述了它自身的非定理性</li></ul></li><li>意识是一种高层所具有的现象<ul><li>哥德尔的证明提示了可能存在某种观察心与脑的高层方式，设计到在低层不出现的概念 ，而且在这个层次上可能会有在低层次上不存在的解释能力。</li></ul></li><li>意识的核心是怪圈<ul><li>对我们大脑中浮现出来的现象的解释都基于一种怪圈，一种层次相互作用，其中顶层下到底层并对峙产生影响，而与此同时它自身又被底层所确定。</li><li>自我理解的核心，将会是对我们心智中的层次结构的理解</li></ul></li><li>自我符号与自由意志<ul><li>当机器人可以使用自我付好来影响所作的决定时，开始产生了自由意志和意义</li></ul></li><li>一个层次交错的哥德尔漩涡<ul><li>自由意志产生于有自知之明和无自知之明的平衡中</li></ul></li><li>一个层次交错的艾舍尔漩涡<ul><li>为哥德尔的定理提供了形象的比喻描述</li></ul></li><li>一个层次交错的巴赫漩涡<ul><li>复杂的「音乐的奉献」，「无穷升高的卡农」</li></ul></li></ul><p>六部无插入赋格</p><ul><li>阿基里斯、乌龟、螃蟹、巴比奇、作者和图灵按照巴赫「六部无插入赋格」的方式交谈</li><li>作者解释了一部分书中此类章节的巧妙内涵</li><li>各种乱七八糟的自指</li><li>通过灵笨机来阐述人工智能</li><li>图灵和巴比奇的怪圈和图灵测试</li><li>对本书开头导演的模糊自指，完成一个大圈</li></ul>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GEB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab计算</title>
    <link href="/Blogs/2025/08/28/Matlab%E8%AE%A1%E7%AE%97/"/>
    <url>/Blogs/2025/08/28/Matlab%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="MATLAB-代数"><a href="#MATLAB-代数" class="headerlink" title="MATLAB 代数"></a>MATLAB 代数</h1><p>到目前为止，我们已经看到所有示例都可以在MATLAB及其GNU（也称为Octave）中运行。但是，为了求解基本的代数方程，MATLAB和Octave几乎没有什么不同，因此我们将尝试在单独的部分中介绍MATLAB和Octave。</p><p>我们还将讨论代数表达式的分解和简化。</p><h2 id="在MATLAB中求解基本代数方程"><a href="#在MATLAB中求解基本代数方程" class="headerlink" title="在MATLAB中求解基本代数方程"></a>在MATLAB中求解基本代数方程</h2><p><strong>solve</strong>函数用于求解代数方程。最简单的形式是，solve函数将用引号引起来的方程式作为参数。</p><p>例如，让我们求解方程x-5 &#x3D; 0中的x</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">solve(<span class="hljs-string">&#x27;x-5=0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">ans</span> =<br>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>您也可以将Solve函数称为-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y = solve(<span class="hljs-string">&#x27;x-5 = 0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y =<br>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>您甚至可能不包括等式的右侧-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">solve(<span class="hljs-string">&#x27;x-5&#x27;</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">ans</span> =<br>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果方程式包含多个符号，则默认情况下MATLAB会假定您正在求解x，但是，solve函数具有另一种形式-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">solve(equation, variable)<br></code></pre></td></tr></table></figure><p>在这里，您还可以提及变量。</p><p>例如，让我们求解v的方程v – u – 3t 2 &#x3D;0。在这种情况下，我们应该写-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">solve(<span class="hljs-string">&#x27;v-u-3*t^2=0&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">ans</span> =<br>   <span class="hljs-number">3</span>*t^<span class="hljs-number">2</span> + u<br></code></pre></td></tr></table></figure><h2 id="用Octave法求解基本代数方程"><a href="#用Octave法求解基本代数方程" class="headerlink" title="用Octave法求解基本代数方程"></a>用Octave法求解基本代数方程</h2><p><strong>roots</strong>函数用于求解Octave中的代数方程式，您可以编写以下示例，如下所示：</p><p>例如，让我们求解方程x-5 &#x3D; 0中的x</p><p>示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">roots</span><span class="hljs-params">([<span class="hljs-number">1</span>, -<span class="hljs-number">5</span>])</span></span><br></code></pre></td></tr></table></figure><p>Octave将执行以上语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>您也可以将Solve函数称为-</p><p>示例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">y</span> = roots([<span class="hljs-number">1</span>, -<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p>Octave将执行以上语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="在MATLAB中求解二次方程"><a href="#在MATLAB中求解二次方程" class="headerlink" title="在MATLAB中求解二次方程"></a>在MATLAB中求解二次方程</h2><p><strong>solve</strong>函数还可以求解高阶方程。它通常用于求解二次方程。该函数以数组形式返回方程式的根。</p><p>以下示例解决了二次方程x 2 -7x +12 &#x3D;0。创建脚本文件并键入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">eq = <span class="hljs-string">&#x27;x^2 -7*x + 12 = 0&#x27;</span>;<br>s = solve(eq);<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The first root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">1</span>));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The second root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">The first root is: <br>   <span class="hljs-number">3</span><br>The second root is: <br>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="用Octave法求解二次方程"><a href="#用Octave法求解二次方程" class="headerlink" title="用Octave法求解二次方程"></a>用Octave法求解二次方程</h2><p>下面的示例以Octave求解二次方程x 2 -7x +12 &#x3D; 0。创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">s = roots([<span class="hljs-number">1</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">12</span>]);<br><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The first root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">1</span>));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The second root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">The first root is: <br>   <span class="hljs-number">4</span><br>The second root is: <br>   <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="在MATLAB中求解高阶方程"><a href="#在MATLAB中求解高阶方程" class="headerlink" title="在MATLAB中求解高阶方程"></a>在MATLAB中求解高阶方程</h2><p><strong>solve</strong>函数还可以求解高阶方程。例如，让我们求解一个三次方程为(x-3)2(x-7)&#x3D; 0</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">solve</span>(&#x27;(x-<span class="hljs-number">3</span>)^<span class="hljs-number">2</span>*(x-<span class="hljs-number">7</span>)=<span class="hljs-number">0</span>&#x27;)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span><br>   <span class="hljs-number">3</span><br>   <span class="hljs-number">3</span><br>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>对于高阶方程，根长包含许多项。您可以通过将此类根转换为double来获得其数值。以下示例解决了四阶方程x 4 − 7x 3+ 3x 2 − 5x + 9 &#x3D; 0。</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">eq = <span class="hljs-string">&#x27;x^4 - 7*x^3 + 3*x^2 - 5*x + 9 = 0&#x27;</span>;<br>s = solve(eq);<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The first root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">1</span>));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The second root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">2</span>));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The third root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">3</span>));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The fourth root is: &#x27;</span>), <span class="hljs-built_in">disp</span>(s(<span class="hljs-number">4</span>));<br><br><span class="hljs-comment">%将根转换为double类型</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of first root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">1</span>)));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of second root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">2</span>)));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of third root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">3</span>)));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of fourth root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">4</span>)));<br></code></pre></td></tr></table></figure><p>运行文件时，它返回以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs matlab">The first root is: <br><span class="hljs-number">6.630396332390718431485053218985</span><br> The second root is: <br><span class="hljs-number">1.0597804633025896291682772499885</span><br> The third root is: <br>- <span class="hljs-number">0.34508839784665403032666523448675</span> - <span class="hljs-number">1.0778362954630176596831109269793</span>*<span class="hljs-built_in">i</span><br> The fourth root is: <br>- <span class="hljs-number">0.34508839784665403032666523448675</span> + <span class="hljs-number">1.0778362954630176596831109269793</span>*<span class="hljs-built_in">i</span><br>Numeric value of first root<br>   <span class="hljs-number">6.6304</span><br>Numeric value of second root<br>   <span class="hljs-number">1.0598</span><br>Numeric value of third root<br>   <span class="hljs-number">-0.3451</span> - <span class="hljs-number">1.0778</span><span class="hljs-built_in">i</span><br>Numeric value of fourth root<br>   <span class="hljs-number">-0.3451</span> + <span class="hljs-number">1.0778</span><span class="hljs-built_in">i</span><br></code></pre></td></tr></table></figure><p>请注意，最后两个根是复数。</p><h2 id="在Octave中求解高阶方程"><a href="#在Octave中求解高阶方程" class="headerlink" title="在Octave中求解高阶方程"></a>在Octave中求解高阶方程</h2><p>以下示例解决了四阶方程x 4 − 7x 3 + 3x 2 − 5x + 9 &#x3D; 0。</p><p>创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">v = [<span class="hljs-number">1</span>, <span class="hljs-number">-7</span>,  <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">9</span>];<br>s = roots(v);<br><br><span class="hljs-comment">%将根转换为double类型</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of first root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">1</span>)));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of second root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">2</span>)));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of third root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">3</span>)));<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;Numeric value of fourth root&#x27;</span>), <span class="hljs-built_in">disp</span>(double(s(<span class="hljs-number">4</span>)));<br></code></pre></td></tr></table></figure><p>运行文件时，它返回以下结果-</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">Numeric</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">first</span> root<br> <span class="hljs-number">6.6304</span><br><span class="hljs-type">Numeric</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">second</span> root<br><span class="hljs-number">-0.34509</span> <span class="hljs-operator">+</span> <span class="hljs-number">1.07784</span>i<br><span class="hljs-type">Numeric</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> third root<br><span class="hljs-number">-0.34509</span> <span class="hljs-operator">-</span> <span class="hljs-number">1.07784</span>i<br><span class="hljs-type">Numeric</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> fourth root<br> <span class="hljs-number">1.0598</span><br></code></pre></td></tr></table></figure><h2 id="在MATLAB中求解方程组"><a href="#在MATLAB中求解方程组" class="headerlink" title="在MATLAB中求解方程组"></a>在MATLAB中求解方程组</h2><p><strong>solve</strong>函数还可用于生成涉及多个变量的方程组的解。让我们举一个简单的实例来演示这种用法。</p><p>让我们求解方程式-</p><p>5x + 9y &#x3D; 5</p><p>3x – 6y &#x3D; 4</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span> = solve(&#x27;<span class="hljs-number">5</span>*x + <span class="hljs-number">9</span>*y = <span class="hljs-number">5</span>&#x27;,&#x27;<span class="hljs-number">3</span>*x - <span class="hljs-number">6</span>*y = <span class="hljs-number">4</span>&#x27;);<br><span class="hljs-attribute">s</span>.x<br><span class="hljs-attribute">s</span>.y<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span><br>   <span class="hljs-number">22</span>/<span class="hljs-number">19</span><br><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span><br>   -<span class="hljs-number">5</span>/<span class="hljs-number">57</span><br></code></pre></td></tr></table></figure><p>同样，您可以求解更大的线性系统。考虑以下一组方程式-</p><p>x + 3y -2z &#x3D; 5</p><p>3x + 5y + 6z &#x3D; 7</p><p>2x + 4y + 3z &#x3D; 8</p><h2 id="Octave方程组的求解"><a href="#Octave方程组的求解" class="headerlink" title="Octave方程组的求解"></a>Octave方程组的求解</h2><p>我们有一些不同的方法来求解n个未知数中的n个线性方程组。让我们举一个简单的实例来演示这种用法。</p><p>让我们求解方程式-</p><p>5x + 9y &#x3D; 5</p><p>3x – 6y &#x3D; 4</p><p>这样的线性方程组可以写成单矩阵方程Ax &#x3D; b，其中A是系数矩阵，b是包含线性方程右侧的列向量，x是表示解的列向量，如下所示：在下面的程序中显示-</p><p>创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">A</span> = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span><span class="hljs-comment">; 3, -6];</span><br>b = [<span class="hljs-number">5</span><span class="hljs-comment">;4];</span><br>A \ b<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span><br><br>   <span class="hljs-number">1.157895</span><br>  -<span class="hljs-number">0.087719</span><br></code></pre></td></tr></table></figure><p>同样，您可以解决较大的线性系统，如下所示-</p><p>x + 3y -2z &#x3D; 5</p><p>3x + 5y + 6z &#x3D; 7</p><p>2x + 4y + 3z &#x3D; 8</p><h2 id="在MATLAB中展开和收集方程式"><a href="#在MATLAB中展开和收集方程式" class="headerlink" title="在MATLAB中展开和收集方程式"></a>在MATLAB中展开和收集方程式</h2><p><strong>expand</strong>和<strong>collect</strong>分别用来展开和收集一个方程。以下示例演示了概念-</p><p>当使用许多符号函数时，应声明变量是符号性的。</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x   <span class="hljs-comment">%符号变量x</span><br>syms y   <span class="hljs-comment">%符号变量y</span><br><br><span class="hljs-comment">%扩展方程</span><br>expand((x<span class="hljs-number">-5</span>)*(x+<span class="hljs-number">9</span>))<br>expand((x+<span class="hljs-number">2</span>)*(x<span class="hljs-number">-3</span>)*(x<span class="hljs-number">-5</span>)*(x+<span class="hljs-number">7</span>))<br>expand(<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*x))<br>expand(<span class="hljs-built_in">cos</span>(x+y))<br> <br><span class="hljs-comment">%收集方程式</span><br>collect(x^<span class="hljs-number">3</span> *(x<span class="hljs-number">-7</span>))<br>collect(x^<span class="hljs-number">4</span>*(x<span class="hljs-number">-3</span>)*(x<span class="hljs-number">-5</span>))<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">ans</span> =<br>   x^<span class="hljs-number">2</span> + <span class="hljs-number">4</span>*x - <span class="hljs-number">45</span><br><span class="hljs-built_in">ans</span> =<br>   x^<span class="hljs-number">4</span> + x^<span class="hljs-number">3</span> - <span class="hljs-number">43</span>*x^<span class="hljs-number">2</span> + <span class="hljs-number">23</span>*x + <span class="hljs-number">210</span><br><span class="hljs-built_in">ans</span> =<br>   <span class="hljs-number">2</span>*<span class="hljs-built_in">cos</span>(x)*<span class="hljs-built_in">sin</span>(x)<br><span class="hljs-built_in">ans</span> =<br>   <span class="hljs-built_in">cos</span>(x)*<span class="hljs-built_in">cos</span>(y) - <span class="hljs-built_in">sin</span>(x)*<span class="hljs-built_in">sin</span>(y)<br><span class="hljs-built_in">ans</span> =<br>   x^<span class="hljs-number">4</span> - <span class="hljs-number">7</span>*x^<span class="hljs-number">3</span><br><span class="hljs-built_in">ans</span> =<br>   x^<span class="hljs-number">6</span> - <span class="hljs-number">8</span>*x^<span class="hljs-number">5</span> + <span class="hljs-number">15</span>*x^<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="倍频程中的展开和收集方程"><a href="#倍频程中的展开和收集方程" class="headerlink" title="倍频程中的展开和收集方程"></a>倍频程中的展开和收集方程</h2><p>您需要拥有一个<strong>symbolic</strong>软件包，该软件包分别提供<strong>expand</strong>和<strong>collect</strong>函数来扩展和收集方程式。以下示例演示了概念-</p><p>当使用许多符号函数时，应声明变量是符号变量，但是Octave定义符号变量的方法不同。注意使用<strong>Sin</strong>和<strong>Cos</strong>，它们也在符号包中定义。</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%首先，加载包，确保它已安装。</span><br>pkg load symbolic<br><br><span class="hljs-comment">%使symbols模块可用</span><br>symbols<br><br><span class="hljs-comment">%定义符号变量</span><br>x = sym (<span class="hljs-string">&#x27;x&#x27;</span>);<br>y = sym (<span class="hljs-string">&#x27;y&#x27;</span>);<br>z = sym (<span class="hljs-string">&#x27;z&#x27;</span>);<br><br><span class="hljs-comment">%扩展方程</span><br>expand((x<span class="hljs-number">-5</span>)*(x+<span class="hljs-number">9</span>))<br>expand((x+<span class="hljs-number">2</span>)*(x<span class="hljs-number">-3</span>)*(x<span class="hljs-number">-5</span>)*(x+<span class="hljs-number">7</span>))<br>expand(Sin(<span class="hljs-number">2</span>*x))<br>expand(Cos(x+y))<br> <br><span class="hljs-comment">%收集方程式</span><br>collect(x^<span class="hljs-number">3</span> *(x<span class="hljs-number">-7</span>), z)<br>collect(x^<span class="hljs-number">4</span>*(x<span class="hljs-number">-3</span>)*(x<span class="hljs-number">-5</span>), z)<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">ans</span> =<br><br><span class="hljs-number">-45.0</span>+x^<span class="hljs-number">2</span>+(<span class="hljs-number">4.0</span>)*x<br><span class="hljs-built_in">ans</span> =<br><br><span class="hljs-number">210.0</span>+x^<span class="hljs-number">4</span>-(<span class="hljs-number">43.0</span>)*x^<span class="hljs-number">2</span>+x^<span class="hljs-number">3</span>+(<span class="hljs-number">23.0</span>)*x<br><span class="hljs-built_in">ans</span> =<br><br><span class="hljs-built_in">sin</span>((<span class="hljs-number">2.0</span>)*x)<br><span class="hljs-built_in">ans</span> =<br><br><span class="hljs-built_in">cos</span>(y+x)<br><span class="hljs-built_in">ans</span> =<br><br>x^(<span class="hljs-number">3.0</span>)*(<span class="hljs-number">-7.0</span>+x)<br><span class="hljs-built_in">ans</span> =<br><br>(<span class="hljs-number">-3.0</span>+x)*x^(<span class="hljs-number">4.0</span>)*(<span class="hljs-number">-5.0</span>+x)<br></code></pre></td></tr></table></figure><h2 id="代数表达式的因式分解和简化"><a href="#代数表达式的因式分解和简化" class="headerlink" title="代数表达式的因式分解和简化"></a>代数表达式的因式分解和简化</h2><p><strong>factor</strong>函数分解一个表达式，<strong>simplify</strong>函数简化一个表达式。以下示例演示了概念-</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x<br>syms y<br><span class="hljs-built_in">factor</span>(x^<span class="hljs-number">3</span> - y^<span class="hljs-number">3</span>)<br><span class="hljs-built_in">factor</span>([x^<span class="hljs-number">2</span>-y^<span class="hljs-number">2</span>,x^<span class="hljs-number">3</span>+y^<span class="hljs-number">3</span>])<br>simplify((x^<span class="hljs-number">4</span><span class="hljs-number">-16</span>)/(x^<span class="hljs-number">2</span><span class="hljs-number">-4</span>))<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">ans</span> =<br>   (x - y)*(x^<span class="hljs-number">2</span> + x*y + y^<span class="hljs-number">2</span>)<br><span class="hljs-built_in">ans</span> =<br>   [ (x - y)*(x + y), (x + y)*(x^<span class="hljs-number">2</span> - x*y + y^<span class="hljs-number">2</span>)]<br><span class="hljs-built_in">ans</span> =<br>   x^<span class="hljs-number">2</span> + <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab高级教程</title>
    <link href="/Blogs/2025/08/28/Matlab%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <url>/Blogs/2025/08/28/Matlab%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MATLAB-绘图（Plot）"><a href="#MATLAB-绘图（Plot）" class="headerlink" title="MATLAB 绘图（Plot）"></a>MATLAB 绘图（Plot）</h1><p>要绘制函数的图形，需要执行以下步骤：</p><ul><li>通过指定变量 x 的值范围来定义 x，为此函数将绘制出来</li><li>定义函数， <strong>y &#x3D; f(x)</strong></li><li>调用 <strong>plot</strong> 命令，如下 <strong>plot(x, y)</strong></li></ul><p>下面的实例将演示这个概念。让我们绘制一个简单的函数y&#x3D;x，x的取值范围为0到100，增量为5。</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span> = [<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">100</span>];<br><span class="hljs-variable language_">y</span> = <span class="hljs-variable language_">x</span>;<br>plot(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>运行文件时，MATLAB显示以下图-</p><p>让我们再举一个实例来绘制函数y &#x3D; x 2。在此示例中，我们将绘制两个具有相同功能的图形，但是第二次，我们将减小增量值。请注意，随着我们减少增量，图形会变得更加平滑。</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span> = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span>];<br><span class="hljs-variable language_">x</span> = [<span class="hljs-number">-100</span>:<span class="hljs-number">20</span>:<span class="hljs-number">100</span>];<br><span class="hljs-variable language_">y</span> = <span class="hljs-variable language_">x</span>.^<span class="hljs-number">2</span>;<br>plot(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>运行文件时，MATLAB显示以下图-</p><p>稍微更改代码文件，将增量减少到5-</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span> = [<span class="hljs-number">-100</span>:<span class="hljs-number">5</span>:<span class="hljs-number">100</span>];<br><span class="hljs-variable language_">y</span> = <span class="hljs-variable language_">x</span>.^<span class="hljs-number">2</span>;<br>plot(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>MATLAB绘制更平滑的图形-</p><h2 id="在图形上添加标题，标签，网格线和缩放"><a href="#在图形上添加标题，标签，网格线和缩放" class="headerlink" title="在图形上添加标题，标签，网格线和缩放"></a>在图形上添加标题，标签，网格线和缩放</h2><p>MATLAB 允许您添加标题、沿 x 轴和 y 轴的标签、网格线，并且还可以调整轴以使图形更漂亮。</p><ul><li><strong>xlabel</strong> 和 <strong>ylabel</strong> 命令产生沿x轴和y轴的标签。</li><li><strong>title</strong> 命令允许您在图形上放置标题。</li><li><strong>grid on</strong> 命令允许您将网格线放在图形上。</li><li><strong>axis equal</strong> 命令允许使用相同的比例因子和两个轴上的间距生成图。</li><li><strong>axis square</strong> 命令生成一个正方形图。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">x</span> = [<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">10</span>];<br><span class="hljs-attribute">y</span> = <span class="hljs-built_in">sin</span>(x);<br><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x, y)</span></span>, <span class="hljs-built_in">xlabel</span>(<span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-built_in">ylabel</span>(<span class="hljs-string">&#x27;Sin(x)&#x27;</span>), <span class="hljs-built_in">title</span>(<span class="hljs-string">&#x27;Sin(x) Graph&#x27;</span>),<br><span class="hljs-attribute">grid</span> on, axis equal<br></code></pre></td></tr></table></figure><h2 id="在同一图形上绘制多个函数"><a href="#在同一图形上绘制多个函数" class="headerlink" title="在同一图形上绘制多个函数"></a>在同一图形上绘制多个函数</h2><p>您可以在同一图上绘制多个图形。以下示例演示了概念-</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">x</span> = [<span class="hljs-number">0</span> : <span class="hljs-number">0.01</span>: <span class="hljs-number">10</span>];<br><span class="hljs-attribute">y</span> = <span class="hljs-built_in">sin</span>(x);<br><span class="hljs-selector-tag">g</span> = <span class="hljs-built_in">cos</span>(<span class="hljs-attribute">x</span>);<br><span class="hljs-function"><span class="hljs-title">plot</span><span class="hljs-params">(x, y, x, g, <span class="hljs-string">&#x27;.-&#x27;</span>)</span></span>, <span class="hljs-selector-tag">legend</span>(<span class="hljs-string">&#x27;Sin(x)&#x27;</span>, <span class="hljs-string">&#x27;Cos(x)&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="在图形上设置颜色"><a href="#在图形上设置颜色" class="headerlink" title="在图形上设置颜色"></a>在图形上设置颜色</h2><p>MATLAB提供了八种基本的颜色选项来绘制图形。下表显示了颜色及其代码-</p><table><thead><tr><th align="center">代码</th><th align="center">颜色</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">白色</td></tr><tr><td align="center">k</td><td align="center">黑色</td></tr><tr><td align="center">b</td><td align="center">蓝色</td></tr><tr><td align="center">r</td><td align="center">红色</td></tr><tr><td align="center">c</td><td align="center">青色</td></tr><tr><td align="center">g</td><td align="center">绿色</td></tr><tr><td align="center">m</td><td align="center">洋红色</td></tr><tr><td align="center">y</td><td align="center">黄色</td></tr></tbody></table><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>让我们画出两个多项式的图</p><ul><li>f(x)&#x3D; 3x 4 + 2x 3 + 7x 2 + 2x + 9和</li><li>g(x)&#x3D; 5x 3 + 9x + 2</li></ul><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span> = [<span class="hljs-number">-10</span> : <span class="hljs-number">0.01</span>: <span class="hljs-number">10</span>];<br><span class="hljs-variable language_">y</span> = <span class="hljs-number">3</span>*<span class="hljs-variable language_">x</span>.^<span class="hljs-number">4</span> + <span class="hljs-number">2</span> * <span class="hljs-variable language_">x</span>.^<span class="hljs-number">3</span> + <span class="hljs-number">7</span> * <span class="hljs-variable language_">x</span>.^<span class="hljs-number">2</span> + <span class="hljs-number">2</span> * <span class="hljs-variable language_">x</span> + <span class="hljs-number">9</span>;<br>g = <span class="hljs-number">5</span> * <span class="hljs-variable language_">x</span>.^<span class="hljs-number">3</span> + <span class="hljs-number">9</span> * <span class="hljs-variable language_">x</span> + <span class="hljs-number">2</span>;<br>plot(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-variable language_">x</span>, g, <span class="hljs-string">&#x27;g&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="设定轴比例"><a href="#设定轴比例" class="headerlink" title="设定轴比例"></a>设定轴比例</h2><p><strong>axis</strong>命令允许您设置轴刻度。您可以按以下方式使用axis命令提供x和y轴的最小值和最大值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">axis ( <span class="hljs-selector-attr">[xmin xmax ymin ymax]</span> )<br></code></pre></td></tr></table></figure><p>以下示例显示了这一点-</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span> = [<span class="hljs-number">0</span> : <span class="hljs-number">0.01</span>: <span class="hljs-number">10</span>];<br><span class="hljs-variable language_">y</span> = <span class="hljs-built_in">exp</span>(-<span class="hljs-variable language_">x</span>).* <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*<span class="hljs-variable language_">x</span> + <span class="hljs-number">3</span>);<br>plot(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>), axis([<span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="生成子图"><a href="#生成子图" class="headerlink" title="生成子图"></a>生成子图</h2><p>在同一图形中创建一个绘图数组时，每个绘图都称为子绘图。<strong>subplot</strong> 命令用于创建子图。</p><p>该命令的语法是-</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">subplot</span><span class="hljs-params">(m, n, p)</span></span><br></code></pre></td></tr></table></figure><p>其中，<em>m</em>和<em>n</em>是绘图数组的行数和列数，而<em>p</em>指定放置特定绘图的位置。</p><p>使用subplot命令创建的每个图都可以具有自己的特征。以下示例演示了概念-</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>让我们生成两个图-</p><p>y &#x3D; e −1.5x sin(10x)</p><p>y &#x3D; e -2x sin(10x)</p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">x</span> = [<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">5</span>];<br><span class="hljs-variable language_">y</span> = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-1.5</span>*<span class="hljs-variable language_">x</span>).*<span class="hljs-built_in">sin</span>(<span class="hljs-number">10</span>*<span class="hljs-variable language_">x</span>);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>plot(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>), xlabel(<span class="hljs-string">&#x27;x&#x27;</span>),ylabel(<span class="hljs-string">&#x27;exp(–1.5x)*sin(10x)&#x27;</span>),axis([<span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br><span class="hljs-variable language_">y</span> = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-2</span>*<span class="hljs-variable language_">x</span>).*<span class="hljs-built_in">sin</span>(<span class="hljs-number">10</span>*<span class="hljs-variable language_">x</span>);<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>plot(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>),xlabel(<span class="hljs-string">&#x27;x&#x27;</span>),ylabel(<span class="hljs-string">&#x27;exp(–2x)*sin(10x)&#x27;</span>),axis([<span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="绘制条形图bar"><a href="#绘制条形图bar" class="headerlink" title="绘制条形图bar"></a>绘制条形图bar</h2><p><strong>bar</strong> 命令绘制二维条形图。让我们举一个实例来说明这个想法。</p><h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><p>让我们有一个假想的教室，有10个学生。我们知道这些学生获得的分数百分比是75、58、90、87、50、85、92、75、60和95。我们将绘制此数据的条形图。</p><p>创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">x</span> = [<span class="hljs-number">1</span>:<span class="hljs-number">10</span>];<br><span class="hljs-attribute">y</span> = [<span class="hljs-number">75</span>, <span class="hljs-number">58</span>, <span class="hljs-number">90</span>, <span class="hljs-number">87</span>, <span class="hljs-number">50</span>, <span class="hljs-number">85</span>, <span class="hljs-number">92</span>, <span class="hljs-number">75</span>, <span class="hljs-number">60</span>, <span class="hljs-number">95</span>];<br><span class="hljs-function"><span class="hljs-title">bar</span><span class="hljs-params">(x,y)</span></span>, <span class="hljs-built_in">xlabel</span>(<span class="hljs-string">&#x27;Student&#x27;</span>),<span class="hljs-built_in">ylabel</span>(<span class="hljs-string">&#x27;Score&#x27;</span>),<br><span class="hljs-function"><span class="hljs-title">title</span><span class="hljs-params">(<span class="hljs-string">&#x27;First Sem:&#x27;</span>)</span></span><br>print -deps graph.eps<br></code></pre></td></tr></table></figure><h2 id="绘制等高线contour"><a href="#绘制等高线contour" class="headerlink" title="绘制等高线contour"></a>绘制等高线contour</h2><p>两个变量的函数的等高线是一条曲线，沿该曲线函数有一个常数。等高线用于创建等高线图，方法是将给定高程（如平均海平面）上的等高点连接起来。</p><p>MATLAB提供了用于绘制等高线的函数 <strong>contour</strong> 。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>让我们生成一个等高线图，显示给定函数g&#x3D;f(x,y)的等高线。这个函数有两个变量。因此，我们必须生成两个独立变量，即两个数据集x和y。这是通过调用meshgrid命令来完成的。</p><p><strong>meshgrid</strong>命令用于生成元素矩阵，这些元素矩阵给出x和y的范围以及每种情况下的增量说明。</p><p>让我们绘制函数g &#x3D; f(x, y)，其中−5≤x≤5，−3≤y≤3。让我们对两个值取0.1的增量。变量设置为-</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[x,y] = meshgrid(–<span class="hljs-number">5:0.1:5</span>, –<span class="hljs-number">3:0.1:3</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>最后，我们需要给函数赋值能。令我们的函数为：x 2 + y 2</p><p>创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">[<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>] = meshgrid(<span class="hljs-number">-5</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">5</span>,<span class="hljs-number">-3</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">3</span>);   %自变量<br>g = <span class="hljs-variable language_">x</span>.^<span class="hljs-number">2</span> + <span class="hljs-variable language_">y</span>.^<span class="hljs-number">2</span>;                       %我们的函数<br>contour(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>,g)                         %调用等高线函数<br>print -deps graph.eps<br></code></pre></td></tr></table></figure><p>运行文件时，MATLAB显示轮廓图</p><p>让我们稍微修改一下代码以整理映射</p><p>示例</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">[<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>] = meshgrid(<span class="hljs-number">-5</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">5</span>,<span class="hljs-number">-3</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">3</span>);   %independent variables<br>g = <span class="hljs-variable language_">x</span>.^<span class="hljs-number">2</span> + <span class="hljs-variable language_">y</span>.^<span class="hljs-number">2</span>;                       % our <span class="hljs-keyword">function</span><br>[C, h] = contour(<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>,g);               % call the contour <span class="hljs-keyword">function</span><br>set(h,<span class="hljs-string">&#x27;ShowText&#x27;</span>,<span class="hljs-string">&#x27;on&#x27;</span>,<span class="hljs-string">&#x27;TextStep&#x27;</span>,get(h,<span class="hljs-string">&#x27;LevelStep&#x27;</span>)*<span class="hljs-number">2</span>)<br>print -deps graph.eps<br></code></pre></td></tr></table></figure><h2 id="三维图"><a href="#三维图" class="headerlink" title="三维图"></a>三维图</h2><p>三维图基本上显示了由函数定义的两个变量g &#x3D; f(x,y)的曲面。</p><p>如前所述，要定义g，我们首先使用<strong>meshgrid</strong>命令在函数的范围内创建一组(x,y)点。接下来，我们分配函数本身。最后，我们使用<strong>surf</strong>命令创建表面图。</p><p>以下示例演示了概念-</p><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>让我们为函数g &#x3D; xe- （x 2 + y 2）创建3D表面图。</p><p>创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">[<span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span>] = meshgrid(<span class="hljs-number">-2</span>:<span class="hljs-number">.2</span>:<span class="hljs-number">2</span>);<br>g = <span class="hljs-variable language_">x</span> .* <span class="hljs-built_in">exp</span>(-<span class="hljs-variable language_">x</span>.^<span class="hljs-number">2</span> - <span class="hljs-variable language_">y</span>.^<span class="hljs-number">2</span>);<br>surf(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, g)<br>print -deps graph.eps<br></code></pre></td></tr></table></figure><p>您也可以使用<strong>mesh</strong>命令生成三维表面。但是，<strong>surf</strong>命令同时以颜色显示连接线和曲面的面，而<strong>mesh</strong>命令创建的线框表面带有连接定义点的彩色线。</p><h1 id="Symbolic-Maths"><a href="#Symbolic-Maths" class="headerlink" title="Symbolic Maths"></a>Symbolic Maths</h1><h2 id="符号对象-Symbolic-Objects"><a href="#符号对象-Symbolic-Objects" class="headerlink" title="符号对象(Symbolic Objects)"></a><strong>符号对象(Symbolic Objects)</strong></h2><p>Symbolic Maths Toolbox使用一种称为符号对象的特殊数据类型，该数据类型可用于表示可根据代数和微积分的规则进行操作的符号变量，数字和表达式。</p><h3 id="创建符号变量-Creating-Symbolic-Variables"><a href="#创建符号变量-Creating-Symbolic-Variables" class="headerlink" title="创建符号变量(Creating Symbolic Variables)"></a>创建符号变量(Creating Symbolic Variables)</h3><p>可以使用sym()函数创建符号变量和表达式，例如，创建两个变量x和y分别显示为x和y，</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = sym(<span class="hljs-string">&#x27;x&#x27;</span>);<br>y = sym(<span class="hljs-string">&#x27;y&#x27;</span>);<br></code></pre></td></tr></table></figure><p>如果变量名称和显示字符串相同，则使用syms更简单。例如，创建符号变量x, y</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x y<br></code></pre></td></tr></table></figure><p>然而，以这种方式创建的变量都是复数。在sym() 中添加’real’ 可以使一个变量变为实数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = sym( <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;real&#x27;</span>);<br>y = sym( <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;real&#x27;</span>);<br><span class="hljs-comment">% 或者使用syms 并在最后加real</span><br>syms x y <span class="hljs-built_in">real</span> <br></code></pre></td></tr></table></figure><h3 id="Symbolic-Numbers-这个你让我怎么翻译呀QAQ"><a href="#Symbolic-Numbers-这个你让我怎么翻译呀QAQ" class="headerlink" title="Symbolic Numbers(这个你让我怎么翻译呀QAQ)"></a>Symbolic Numbers(这个你让我怎么翻译呀QAQ)</h3><p>数字也可以使用sym()表示,转换为有理数形式。 默认情况下，如果存在数字，则将这些数字以有理形式表示。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = sym(<span class="hljs-number">0.1</span>)<br><span class="hljs-comment">% 等同于x = sym(0.1, &#x27;r&#x27;)</span><br><span class="hljs-comment">% ans = 1/10</span><br>y = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)<br><span class="hljs-comment">% ans = 5^(1/2)</span><br></code></pre></td></tr></table></figure><p>然而， 为无理数，则可以使用无限精度(infinite precision)地进行计算。数字的其他符号表示也是可能的。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y = sym(<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>), <span class="hljs-string">&#x27;d&#x27;</span>)<br><span class="hljs-comment">% ans = 2.2360679774997898050514777423814</span><br><span class="hljs-comment">% 结果位数取决于位数设置（默认为32位）。也可将该值设置为10位</span><br>digits(<span class="hljs-number">10</span>)<br>y = sym(<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>), <span class="hljs-string">&#x27;d&#x27;</span>)<br><span class="hljs-comment">% ans =  2.236067977</span><br></code></pre></td></tr></table></figure><h3 id="符号表达式和函数-Symbolic-Expressions-and-Functions"><a href="#符号表达式和函数-Symbolic-Expressions-and-Functions" class="headerlink" title="符号表达式和函数( Symbolic Expressions and Functions)"></a>符号表达式和函数( Symbolic Expressions and Functions)</h3><p>Symbolic工具箱可以创建符号表达式和符号变量的函数，例如</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x a b<br>f = <span class="hljs-built_in">sin</span>(a*x + b)<br><span class="hljs-comment">% Note: 当f根据符号变量定义时，f将自动转换为符号对象。</span><br></code></pre></td></tr></table></figure><p>为了以更易读的形式在屏幕上显示符号表达式，pretty()函数可能非常有用。它以一种更易读的形式显示表达式（个人认为在显示高次数方程时比较方便），</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">pretty(f)<br><span class="hljs-comment">% f =  sin(b + a x)</span><br>f1 = x^<span class="hljs-number">4</span> + <span class="hljs-number">2</span>*x^<span class="hljs-number">3</span> - <span class="hljs-number">6</span>*x^<span class="hljs-number">2</span> + <span class="hljs-number">10</span><br>pretty(f1)<br><span class="hljs-comment">% f1 = </span><br><span class="hljs-comment">%  4      3      2</span><br><span class="hljs-comment">% x  + 2 x  - 6 x  + 10</span><br></code></pre></td></tr></table></figure><h3 id="绘图（Plotting-Functions）"><a href="#绘图（Plotting-Functions）" class="headerlink" title="绘图（Plotting Functions）"></a>绘图（Plotting Functions）</h3><p>fplot()函数可用于绘制符号函数。它将使用fplot(f)在默认范围-5≤x≤5(可指定范围)内绘制一个变量f(x)的函数。它还可以绘制隐函数f(x, y)或参数定义的曲线，即f(x, y)。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y = <span class="hljs-built_in">tan</span>(x)<br>fplot(y)<br></code></pre></td></tr></table></figure><h3 id="求解代数方程-Solving-Algebraic-Equations"><a href="#求解代数方程-Solving-Algebraic-Equations" class="headerlink" title="求解代数方程(Solving Algebraic Equations)"></a>求解代数方程(Solving Algebraic Equations)</h3><h4 id="简化-Simplification-of-Expressions"><a href="#简化-Simplification-of-Expressions" class="headerlink" title="简化(Simplification of Expressions)"></a>简化(Simplification of Expressions)</h4><p>有许多函数可以简化表达式并执行替换。它们包括collect(), expand(), factor() 和simplify()。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% collect()：将所有指数相同的底数的系数相加</span><br>f = <span class="hljs-number">2</span>*x - <span class="hljs-number">6</span> + x*(x^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x <span class="hljs-number">-7</span>);<br>collect(f)<br><span class="hljs-comment">% ans = x^3 + 2*x^2 - 5*x - 6</span><br><br><span class="hljs-comment">% expand(): 将方程展开</span><br>f = a*(x+y)<br>expand(f)<br><span class="hljs-comment">% ans = a*x + a*y</span><br>f = <span class="hljs-built_in">cos</span>(x+y)<br>expand(f)<br><span class="hljs-comment">% ans =  cos(x)*cos(y) - sin(x)*sin(y)</span><br><br><span class="hljs-comment">% factor(): 合并</span><br>f = x^<span class="hljs-number">3</span> + <span class="hljs-number">2</span>*x^<span class="hljs-number">2</span> - <span class="hljs-number">5</span>*x <span class="hljs-number">-6</span><br><span class="hljs-built_in">factor</span>(f)<br><span class="hljs-comment">% ans = [ x - 2, x + 3, x + 1] = (x-2)*(x+3)*(x+1)</span><br><br><span class="hljs-comment">% simplify(): 简化，消除公因数等等。</span><br><span class="hljs-comment">% 注：产生具有最少字符数的表达形式（并非总是最有用的结果）</span><br>f = (x^<span class="hljs-number">2</span> <span class="hljs-number">-2</span>*x + <span class="hljs-number">1</span>)/(x<span class="hljs-number">-1</span>);<br>simplify(f)<br><span class="hljs-comment">% ans = x-1</span><br></code></pre></td></tr></table></figure><h4 id="替换（Substitutions）"><a href="#替换（Substitutions）" class="headerlink" title="替换（Substitutions）"></a>替换（Substitutions）</h4><p>subs(s, old, new)将s中所有出现的old替换为new。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = (x+y)*<span class="hljs-number">4</span> + <span class="hljs-number">3</span><br>subs(f, (x+y), z)<br><span class="hljs-comment">% ans = 4*z + 3</span><br></code></pre></td></tr></table></figure><h3 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h3><p>求解函数对一个或多个方程式求解指定变量。最简单的形式是只接受一个表达式作为参数，将方程转化为f(x) &#x3D; 0求解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 求解x^2 = 2</span><br>f = x^<span class="hljs-number">2</span> - <span class="hljs-number">2</span><br>solve(f)<br><span class="hljs-comment">% ans = </span><br>  <span class="hljs-number">2</span>^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)<br> <span class="hljs-number">-2</span>^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>求解联立方程</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 求解x+y = 0； x-y = 0</span><br>f1 = x + y<br>f2 = x - y<br>Ans = solve(f1, f2)<br><span class="hljs-comment">% 此时返回的Ans是一个struct</span><br><span class="hljs-built_in">disp</span>(Ans.x)<br><span class="hljs-built_in">disp</span>(Ans.y)<br></code></pre></td></tr></table></figure><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><h3 id="diff-求微分求导"><a href="#diff-求微分求导" class="headerlink" title="diff()求微分求导"></a>diff()求微分求导</h3><p>diff()函数可以用于求导。diff(需要求导的公式，自变量)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = <span class="hljs-built_in">sin</span>(a*x + b)<br>diff(f, <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-comment">% ans = a*cos(b + a*x)</span><br>f1 = x^<span class="hljs-number">4</span> + <span class="hljs-number">2</span>*x^<span class="hljs-number">3</span> - <span class="hljs-number">6</span>*x^<span class="hljs-number">2</span> + <span class="hljs-number">10</span><br>diff(f1, <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-comment">% ans = 4*x^3 + 6*x^2 - 12*x</span><br></code></pre></td></tr></table></figure><h3 id="int-求积分-与diff-函数用法相同"><a href="#int-求积分-与diff-函数用法相同" class="headerlink" title="int()求积分, 与diff()函数用法相同"></a>int()求积分, 与diff()函数用法相同</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms y<br>f = y^(<span class="hljs-number">-1</span>);<br>int(f)<br><span class="hljs-comment">% ans =</span><br><span class="hljs-comment">% log(y)</span><br><br><span class="hljs-comment">% 加上下限 int(f, a, b)</span><br>syms x<br>f = x^<span class="hljs-number">7</span>;<br>a = <span class="hljs-number">0</span>;<br>b = <span class="hljs-number">1</span>;<br>int(f, a, b)<br><span class="hljs-comment">% ans =</span><br><span class="hljs-comment">% 1/8</span><br></code></pre></td></tr></table></figure><h3 id="symsum-求和"><a href="#symsum-求和" class="headerlink" title="symsum()求和"></a>symsum()求和</h3><p>F &#x3D; symsum(f,k,a,b)返回级数F关于求和索引k从下界a到上界b的和。如果不指定k, symsum使用由symvar确定的变量作为求和索引。如果f是常数，那么默认变量是x。 <code>symsum(f,k,[a b]) = symsum(f,k,[a; b]) = symsum(f,k,a,b)</code>.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms k x<br><span class="hljs-comment">% k^2从0到10求和</span><br>F1 = symsum(k^<span class="hljs-number">2</span>,k,<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment">% k^(-2)从1到正无穷求和</span><br>F2 = symsum(<span class="hljs-number">1</span>/k^<span class="hljs-number">2</span>,k,<span class="hljs-number">1</span>,Inf)<br></code></pre></td></tr></table></figure><h3 id="limit-求极限"><a href="#limit-求极限" class="headerlink" title="limit()求极限"></a>limit()求极限</h3><p>当x趋向0时，计算这个符号表达式的双向极限。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x h<br>f = <span class="hljs-built_in">sin</span>(x)/x;<br>limit(f,x,<span class="hljs-number">0</span>)<br><span class="hljs-comment">% ans = 1</span><br></code></pre></td></tr></table></figure><p>计算这个表达式在h趋于0时的极限。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = (<span class="hljs-built_in">sin</span>(x+h)-<span class="hljs-built_in">sin</span>(x))/h;<br>limit(f,h,<span class="hljs-number">0</span>)<br><span class="hljs-comment">% ans = cos(x)</span><br></code></pre></td></tr></table></figure><p>计算符号表达式的左右极限。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x f = <span class="hljs-number">1</span>/x; <br>limit(f,x,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;right&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab高级教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mbed OS</title>
    <link href="/Blogs/2025/08/28/Mbed%20OS/"/>
    <url>/Blogs/2025/08/28/Mbed%20OS/</url>
    
    <content type="html"><![CDATA[<h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><h3 id="PWM-频率"><a href="#PWM-频率" class="headerlink" title="PWM 频率"></a>PWM 频率</h3><p>   PWM信号的周期是不变的，而高电平的宽度是变化的。</p><h3 id="PWM-占空比-Duty-circle"><a href="#PWM-占空比-Duty-circle" class="headerlink" title="PWM 占空比 (Duty circle)"></a>PWM 占空比 (Duty circle)</h3><p>高电平的时间占整个周期的比值。占空比越高，LED就越暗</p><p>  PWM 的占空比&#x3D;100%*（高电平时间）&#x2F;（脉冲周期）。PWM 的占空比决定了输出信号的电压平均值，占空比高，输出的平均值就高。使用一个RC滤波器电路就可以方便地将PWM 信号转换成平均值的电信号。所以PWM是另一种形式的模拟量输出方式。</p><h3 id="Mbed-OS-PWMOut-类"><a href="#Mbed-OS-PWMOut-类" class="headerlink" title="Mbed OS PWMOut 类"></a>Mbed OS PWMOut 类</h3><p>  Mbed 提供了PWMOut 类，它内部是使用STM32 中的TIM 产生PWM 信号的。所以并不是所有GPIO脚都可以输出PWM信号的。具体的选择方式要查找modular-2 IO引脚定义表。</p><table><thead><tr><th align="center">构造函数</th><th></th></tr></thead><tbody><tr><td align="center">pwmout()</td><td></td></tr><tr><td align="center">成员函数</td><td></td></tr><tr><td align="center">write (float value)</td><td>写入当前的占空比(Duty circle)。浮点百分比</td></tr><tr><td align="center">Read()</td><td>读出当前的占空比。浮点百分比</td></tr><tr><td align="center">period (float seconds)</td><td>设置周期（秒）</td></tr><tr><td align="center">period_ms (int ms)</td><td>设置周期（豪秒）</td></tr><tr><td align="center">period_us (int us)</td><td>设置周期（微秒）</td></tr><tr><td align="center">pulsewidth (float seconds)</td><td>脉冲宽度（秒）</td></tr><tr><td align="center">pulsewidth_ms (int ms)</td><td>脉冲宽度（毫秒）</td></tr></tbody></table><h2 id="作图"><a href="#作图" class="headerlink" title="作图"></a>作图</h2><p><img src="https://img-blog.csdnimg.cn/20200127210316749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>上图中 脉宽时间占总周期时间的比例，就是占空比</p><p><strong>比方说周期的时间是10ms，脉宽时间是8ms 那么低电平时间就是2ms 总的占空比 8&#x2F;(8+2)&#x3D; 80%</strong></p><p>这就是占空比为80%的脉冲信号</p><p><strong>PWM就是在合适的信号频率下，通过一个周期里改变占空比的方式来改变输出的有效电压</strong></p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>PWM has many useful applications in embedded systems.</p><p>The main two categories are:</p><p>When a microcontroller does not have a DAC circuit, PWM can be used to modulate different analog values.</p><p>Some devices are built to be used with PWM. The most famous example is servo motors.</p><p>Controlling the brightness of LED by adjusting the duty cycle</p><p>With an RGB (red green blue) LED, you can control how much of each of the three colors you want in the mix of color by dimming them with various amounts.</p><h1 id="SPI-I2C"><a href="#SPI-I2C" class="headerlink" title="SPI &amp; I2C"></a>SPI &amp; I2C</h1><p>I2C xy (D1, D2);<br>SPI xys (D1, D2, D3) ;</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mbed OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Memory</title>
    <link href="/Blogs/2025/08/28/Memory/"/>
    <url>/Blogs/2025/08/28/Memory/</url>
    
    <content type="html"><![CDATA[<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><p>Stuff that needs to be remembered is data and it is held in memory • It can be stored, (modified) and retrieved for use<br>Physically there are several media on which we can store the data – the memory system – The choice comes down to speed, cost, power consumption, size etc.<br>A memory bit is “bistable”, i. e., stable in two positions either 0 or 1. • Each location is identified by its address, and it holds data. For our mbed both address and data are of 32 bits each.</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/6AXJMmPWkx98DwE3hHw7QcRmlLzIYagN13XuCmchHdicviaRw5x7duP0jSnumjBxRCCIKJzKmI2WOy8IolKnwW5g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><h2 id="计算机存储的原理"><a href="#计算机存储的原理" class="headerlink" title="计算机存储的原理"></a>计算机存储的原理</h2><p>是这样一个电路</p><p><img src="https://picx.zhimg.com/80/v2-268e364e2c42eb64957d934adc2d0fa2_1440w.webp?source=1940ef5c" alt="img"></p><p>是两个<a href="https://www.zhihu.com/search?q=NAND%E9%97%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2372963679%7D">NAND门</a>（与非门）的组合，，先与然后取非，比如给定输入1和0，那么与运算后为0，非运算后为1</p><h2 id="Volatile-memory（易失性存储器）-RAM"><a href="#Volatile-memory（易失性存储器）-RAM" class="headerlink" title="Volatile memory（易失性存储器）(RAM)"></a>Volatile memory（易失性存储器）(RAM)</h2><p> 随机存取存储器（random access memory，RAM）又称作“<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8">随机存储器</a>”，是与<a href="https://baike.baidu.com/item/CPU">CPU</a>直接交换数据的<a href="https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8">内部存储器</a>，也叫<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98">主存</a>(内存)。它可以随时读写，而且速度很快，通常作为<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>或其他正在运行中的程序的临时数据存储媒介。 </p><p>loses all data when power is removed, but is easy to write to. </p><ul><li>Volatile memory is traditionally used for data memory; it is essential to be able to write to memory easily, and there is little expectation for data to be retained when the product is switched off.</li></ul><p>Ex. 主储存器，DRAM（动态随机存储器），快速CPU高速缓存存储器，Battery backed up static ram</p><p>* </p><table><thead><tr><th align="center"><strong>Static RAM (SRAM)</strong></th><th align="center">Dynamic RAM (DRAM)</th></tr></thead><tbody><tr><td align="center">Flip flops</td><td align="center">Capacitor</td></tr><tr><td align="center">It is static since it just stays put and remembers</td><td align="center">It is dynamic since it loses it’s charge and has to be continually refreshed</td></tr><tr><td align="center">More expensive&amp;Low power consumption</td><td align="center">Higher power consumption</td></tr><tr><td align="center">Faster</td><td align="center">Slower</td></tr><tr><td align="center">Processor cache memory is usually SRAM</td><td align="center">Computer RAM is usually DRAM</td></tr><tr><td align="center">Slightly bigger area</td><td align="center">Small area</td></tr></tbody></table><h3 id="SRAM静态存储器"><a href="#SRAM静态存储器" class="headerlink" title="SRAM静态存储器"></a>SRAM静态存储器</h3><p>静态随机存取存储器（Static Random-Access Memory，SRAM）是随机存取存储器的一种。所谓“静态”指这种存储器<strong>只要保持通电，里面储存的数据就可以恒常保持，不需要周期性充电更新</strong></p><p>工作原理： 利用双稳态触发器，存储元是用双稳态触发器（六管 MOS）来记忆信息的，即使信息被读出，它仍保持其原状态而不需要再生（非破坏性读出）；<strong>只要电源被切断， 原来的保存信息便会丢失</strong>，它是易失性半导体存储器。</p><p>一般用来组成高速缓冲存储器Cache。</p><p>优点： </p><ul><li>不需要刷新电路只要保持通电即能保存它内部存储的数据，因此具有较高的性能</li><li>it is low power, can be written to and read from with ease, can be embedded onto a microcontroller, and hence forms the standard way of implementing data memory in most embedded systems.</li></ul><p>局限性：</p><p> 集成度较低，功耗比DRAM大，相同容量的DRAM可以设计为较小的体积，而SRAM却需要很大的体积。同样面积的硅片可以做出更大容量的DRAM，因此SRAM显得更贵</p><ul><li>These have to be addressable, so that just the right group of cells is written to, or read from, at any one time. </li><li>To make this possible, two extra transistors are added to the two outputs. </li><li>To reduce the power consumption, the two resistors are usually replaced by two transistors also. That means six transistors per memory cell</li></ul><h3 id="DRAM动态随机存取存储器"><a href="#DRAM动态随机存取存储器" class="headerlink" title="DRAM动态随机存取存储器"></a>DRAM动态随机存取存储器</h3><p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">动态随机存取存储器</a>（DRAM）里面所储存的数据就需要周期性地更新。 速度快，集成度低，高速缓冲存储器</p><p>intended to do the same thing as SRAM with a reduced silicon area.</p><p>Dynamic Random Access Memory，DRAM 是一种半导体存储器，主要是利用电容内存储电荷的多少来代表一个二进制比特是1还是0。由于在现实中晶体管会有<strong>漏电电流的现象</strong>，导致数据毁损，因此DRAM<strong>需要周期性地进行充电刷新</strong></p><p>工作原理：</p><p> 利用电容。电容中有电荷则存储的内容为1，没有电荷则表示内容为0，是利用存储元电路中栅极电容 上的电荷来存储信息的。【采用地址复用技术，地址线是原来的1&#x2F;2，且地址信号分行、列两次传送</p><ul><li>Instead of using a number of transistors, one bit of information is stored in a tiny capacitor, like a small rechargeable battery.</li><li>Such capacitors can be fabricated in large numbers on an IC.</li><li>In order to select the capacitor for reading or writing, a simple transistor switch is required.</li></ul><p>不足：</p><ul><li>Unfortunately, owing to the small capacitors and leakage currents on the chip, the memory loses its charge over a short period of time (around 10 to 100 ms).  So the DRAM needs to be accessed every few milliseconds to refresh the charges, otherwise the information is lost. </li><li>DRAM has about four times larger storage capacity than SRAM at about the same cost and chip size, with a compromise of the extra work involved in regular refreshing.</li></ul><p>• It is, moreover, power hungry, so inappropriate for any battery-powered device. DRAM has found wide application as data memory in mains-powered computers, such as the PC. </p><h2 id="Non-volatile-memory-（非易失性存储器）"><a href="#Non-volatile-memory-（非易失性存储器）" class="headerlink" title="Non-volatile memory （非易失性存储器）"></a>Non-volatile memory （非易失性存储器）</h2><p>retains its data when power is removed, but  tends to be more complex to write to in the first place. </p><ul><li>Non-volatile memory is generally required for program memory, so that the  program data is there and ready when the processor is powered up.</li></ul><p>ex. 闪存，ROM，PROM，EPROM，FLASH等</p><h3 id="ROM-Read-only-memory"><a href="#ROM-Read-only-memory" class="headerlink" title="ROM(Read-only memory)"></a>ROM(Read-only memory)</h3><p> 只读内存（Read-Only Memory）是一种只能读取资料的内存。在制造过程中，将资料以一特制光罩（mask）烧录于线路中，其资料内容在写入后就不能更改，所以有时又称为“光罩式只读内存”（mask ROM）。此内存的制造成本较低，常用于电脑中的开机启动</p><p>The original ROMs and programmable read only memories (PROMs) could only ever be programmed once, and have now completely disappeared from normal usage. The first type of non-volatile reprogrammable semiconductor memory, electrically programmable read only memory (EPROM), represented a huge step forward:– A non-volatile memory could now be reprogrammed! With a process called hot electron injection (HEI), electrons can be forced through a very thin layer of insulator, onto a tiny conductor embedded within the insulator, and can be trapped there almost indefinitely. </p><p>工作特点：</p><p>非易失性存储器，工作时需要电源，当电源消失，存储的信息不会丢失</p><p>发展历程：</p><p>早期的只读存储器——在厂家就写好了内容，不可编写和更改<br>改进1——用户可以自己写——一次性编程不可擦除<br>改进2——可以多次写——能对信息进行擦除但不方便且擦除设备为另外特定设备<br>改进3——电可擦写——特定设备<br>改进4——电可擦写——直接连接在计算机上<br>常见ROM列举：</p><p>掩模ROM（MROM）不可编写和更改<br>PROM一次性编程<br>EPROM多次性编程，利用紫外线进行信息擦除，不方便<br>EEPROM多次性编程，电可擦写，可局部擦写也可全部擦写<br>FlashMemory闪速型存储器，有些设备可用它直接作硬盘，或者将它作为内存和硬盘间的缓冲</p><p>1.PROM 　　</p><p>可编程程序只读内存（Programmable ROM，PROM）之内部有行列式的镕丝，视需要利用电流将其烧断，写入所需的资料，但仅能写录一次。 PROM在出厂时，存储的内容全为1，用户可以根据需要将其中的某些单元写入数据0(部分的PROM在出厂时数据全为0，则用 户可以将其中的部分单元写入1)， 以实现对其“编程”的目的。PROM的典型产品是“双极性熔丝结构”，如果我们想改写某些单元，则可以给这些单元通以足够大的电流，并维持一定的时间，原 先的熔丝即可熔断，这样就达到了改写某些位的效果。另外一类经典的PROM为使用“肖特基二极管”的PROM，出厂时，其中的二极管处于反向截止状态，还 是用大电流的方法将反相电压加在“肖特基二极管”，造成其永久性击穿即可。 　　</p><p> 2.EPROM 　　</p><p>可抹除可编程只读内存（Erasable Programmable Read Only Memory，EPROM）可利用高电压将资料编程写入，抹除时将线路曝光于紫外线下，则资料可被清空，并且可重复使用。通常在封装外壳上会预留一个石英透明窗以方便曝光。 　　            </p><ol start="3"><li>OTPROM 　　<br>一次编程只读内存（One Time Programmable Read Only Memory，OPTROM）之写入原理同EPROM，但是为了节省成本，编程写入之后就不再抹除，因此不设置透明窗。</li></ol><p> 　</p><p> 4.EEPROM 　</p><p>　电子式可抹除可编程只读内存（Electrically Erasable Programmable Read Only Memory，EEPROM）之运作原理类似EPROM，但是抹除的方式是使用高电场来完成，因此不需要透明窗。 　　</p><p>5.快闪存储器 　</p><p>　快闪存储器（Flash memory）的每一个记忆胞都具有一个“控制闸”与“浮动闸”，利用高电场改变浮动闸的临限电压即可进行编程动作。 　　</p><p>6.快闪存储器 　</p><p>　指从游戏机主文件存储器里或者正版游戏卡带提取的游戏主文件，可以在各类模拟器上使用。例如街机模拟器，GBA模拟器的ROM，正是此意。</p><h3 id="flash-memory"><a href="#flash-memory" class="headerlink" title="flash memory"></a>flash memory</h3><p>Whole blocks have to be erased at any one time, ‘in a flash’. </p><p>This compromise leads to a huge advantage:  flash memory is very high density indeed, more or less the highest available. </p><p>主要特性</p><ul><li>需要先擦除再写入<br>Flash Memory 写入数据时有一定的限制。它只能将当前为 1 的比特改写为 0，而无法将已经为 0 的比特改写为 1，只有在擦除的操作中，才能把整块的比特改写为 1。</li><li>块擦除次数有限<br>Flash Memory 的每个数据块都有擦除次数的限制（十万到百万次不等），擦写超过一定次数后，该数据块将无法可靠存储数据，成为坏块。<br>为了最大化的延长 Flash Memory 的寿命，在软件上需要做擦写均衡（Wear Leveling），通过分散写入、动态映射等手段均衡使用各个数据块。同时，软件还需要进行坏块管理（Bad Block Management，BBM），标识坏块，不让坏块参与数据存储。（注：除了擦写导致的坏块外，Flash Memory 在生产过程也会产生坏块，即固有坏块。）</li><li>读写干扰<br>由于硬件实现上的物理特性，Flash Memory 在进行读写操作时，有可能会导致邻近的其他比特发生位翻转，导致数据异常。这种异常可以通过重新擦除来恢复。Flash Memory 应用中通常会使用 ECC 等算法进行错误检测和数据修正。</li><li>电荷泄漏<br>存储在 Flash Memory 存储单元的电荷，如果长期没有使用，会发生电荷泄漏，导致数据错误。不过这个时间比较长，一般十年左右。此种异常是非永久性的，重新擦除可以恢复。</li></ul><h2 id="数据与内存"><a href="#数据与内存" class="headerlink" title="数据与内存"></a>数据与内存</h2><p>Data is transferred between memory and the rest of the system on <strong>buses</strong>. These are shared sets of wires that join the components, like a multi-lane highway. In the case of the 32 bit µC on the mbed, there are 32 parallel wires.</p><p>Several sets of these parallel wires are required :</p><p>• Address bus – carries address</p><p>• Data bus – carries the data bits either from the memory (read) or to the memory (write)</p><p>• Control lines are also needed to synchronise timing, select read&#x2F;write, ensure that only one device tries to use the bus at once</p><h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><h3 id="冯·诺依曼结构（von-Neumann-architecture）"><a href="#冯·诺依曼结构（von-Neumann-architecture）" class="headerlink" title="冯·诺依曼结构（von Neumann architecture）"></a>冯·诺依曼结构（von Neumann architecture）</h3><p>冯·诺依曼结构的处理器使用同一个存储器，经由同一个总线传输。冯·诺依曼结构处理器具有以下几个特点：</p><ul><li>必须有一个存储器；</li><li>必须有一个控制器；</li><li>必须有一个运算器，用于完成算术运算和逻辑运算；</li><li>必须有输入和输出设备，用于进行人机通信。</li></ul><h3 id="哈佛结构（Harvard-Architecture）"><a href="#哈佛结构（Harvard-Architecture）" class="headerlink" title="哈佛结构（Harvard Architecture）"></a>哈佛结构（<strong>Harvard</strong> Architecture）</h3><p>一种将<strong>程序指令存储</strong>和<strong>数据存储</strong>分开的存储器结构</p><p>央处理器首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。程序指令存储和数据存储分开，可以使<strong>指令和数据有不同的数据宽度</strong></p><p>与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点：</p><p>(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p><p>(2).使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。</p><p>后来，又提出了改进的哈佛结构，其结构特点为：</p><p>(1).使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p><p>(2).具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；</p><p>(3).两条总线由程序存储器和数据存储器分时共用。</p><h1 id="Memory-Mapped-Input-Output-I-O"><a href="#Memory-Mapped-Input-Output-I-O" class="headerlink" title="Memory-Mapped Input&#x2F;Output I&#x2F;O"></a>Memory-Mapped Input&#x2F;Output I&#x2F;O</h1><p>内存映射输入输出</p><p><strong>存储器映射就是为物理内存按一定编码规则分配地址的行为</strong></p><p>This is the most common way of treating the input&#x2F;output ports.</p><p>– I&#x2F;O ports are connected like memory</p><p>– I&#x2F;O ports are assigned addresses</p><p>– Software accesses I&#x2F;O using reads and writes to the specific I&#x2F;O addresses</p><p>The same instructions are used for accessing I&#x2F;O ports and memory</p><p>– Inputs from an input device: same instructions as a memory read</p><p>– Outputs to an output device: same instructions as a memory write</p><p>Easier to design, and software is easier to write</p><p>I&#x2F;O-mapped I&#x2F;O (used in older Intel devices)</p><p>– The control bus signals that activate the I&#x2F;O are separate from those that activate the memory devices </p><p>– Separate address space</p><p>– Separate instructions to access the I&#x2F;O devices</p><p>– Software can not without intention access I&#x2F;O when it thinks it is accessing memory</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Microelectronic system嵌入式系统</title>
    <link href="/Blogs/2025/08/28/Microelectronic%20system%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <url>/Blogs/2025/08/28/Microelectronic%20system%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>主要掌握Mbed Nucleo的编程，是基于C++语言的，考试主要考微电子系统的概念，其中包含：</p><p>[[1. Embedded System]]</p><p>[[2. Memory]]</p><p>[[3. ADC&amp;DAC]]</p><p>[[4. Semiconductor]]</p><p>[[5.multiplexer&amp;demultiplexer]]</p><p>[[6.通信协议]]</p><p>[[10. PWM]]</p><p>[[11. Mbed OS]]</p><p>[[12. STM32]]</p><p>[[13. 开发硬件]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Microelectronic system嵌入式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWM</title>
    <link href="/Blogs/2025/08/28/PWM/"/>
    <url>/Blogs/2025/08/28/PWM/</url>
    
    <content type="html"><![CDATA[<p>PWM波的<strong>频率</strong>是一个周期的时间倒数，而<strong>占空比</strong>就是指在一个周期内，信号处于高电平的时间占据整个信号周期的百分比</p><h1 id="Pulse-Width-Modulation-PWM"><a href="#Pulse-Width-Modulation-PWM" class="headerlink" title="Pulse Width Modulation (PWM)"></a>Pulse Width Modulation (PWM)</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h3><p> PWM is a commonly used <strong>control technique</strong> that generates analog signals from digital devices such as microcontrollers.</p><p>In PWM technique, the signal’s energy is distributed <strong>through a series of pulses</strong> rather than a continuously varying (analog) signal.</p><p>Pulse width modulation is an effective method that is used <strong>to control the amount of power delivered to a load without dissipating any wasted power</strong>.</p><p>In electronics, modulation is the process of varying one or more properties of a periodic waveform.</p><p>Pulse modulation is a type of modulation in which the signal is transmitted in the form of pulses.</p><p>PWM（Pulse Width Modulation）控制——脉冲宽度调制技术，通过对一系列<strong>脉冲的宽度</strong>进行调制，来等效地获得所需要波形（含形状和幅值）.PWM控制技术在逆变电路中应用最广，应用的逆变电路绝大部分是PWM型，PWM控制技术正是有赖于在逆　变电路中的应用，才确定了它在电力电子技术中的重要地位</p><p>The general purpose of Pulse Width Modulation is to control power delivery, especially to inertial electrical devices.</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>By Controlling the Pulse width, we can control the voltage applied to LED and hence the brightness</p><p>PWM uses a rectangular pulse wave whose pulse width is modulated resulting in the variation of the average value of the waveform.</p><p>占空比</p><ul><li><p>Duty cycle &#x3D; (T on &#x2F;T) * 100 </p><ul><li>“Ratio of ON time to total time period”</li></ul></li><li><p>If duty cycle is 50%, it means the pulse remain ON for 50% of the time.</p></li><li><p>By changing the duty cycle, we control the average voltage applied to load and we can control different devices</p></li><li><p>输出的PWM中，<strong>高电平保持的时间与该PWM的时钟周期的时间 之比</strong></p></li><li><p>如，一个PWM的频率是1000Hz，那么它的时钟周期就是1ms，就是1000us，如果高电平出现的时间是200us，那么低电平的时间肯定是800us，那么占空比就是200:1000，也就是说PWM的占空比就是1:5。</p></li></ul><p>Signal Average Value</p><ul><li><p>Average value of a pulse waveform f(t) with period T, low value VL, high value VH can be found as:</p></li><li><p>Vavg &#x3D;D*V（High）+（1-D）V（Low）</p></li><li><p>The average value of the signal is directly dependent on the duty cycle D</p></li><li></li></ul><p>分辨率</p><ul><li><p><strong>占空比最小能达到多少</strong>，如8位的PWM，理论的分辨率就是1:255(单斜率)， 16位的的PWM理论就是1:65535(单斜率)。</p></li><li><p>频率就是这样的，如16位的PWM，它的分辨率达到了1:65535，要达到这个分辨率，T&#x2F;C就必须从0计数到65535才能达到，如果计数从0计到80之后又从0开始计到80…….，那么它的分辨率最小就是1:80了，但是，它也快了，也就是说PWM的输出频率高了。</p></li></ul><p>双斜率 &#x2F; 单斜率</p><ul><li><p>假设一个PWM从0计数到80，之后又从0计数到80…….  这个就是单斜率。</p></li><li><p>假设一个PWM从0计数到80，之后是从80计数到0…….  这个就是双斜率。</p></li><li><p>双斜率的计数时间多了一倍，所以输出的PWM频率就慢了一半，但是分辨率却是1:(80+80) &#x3D;1:160，就是提高了一倍。</p></li></ul><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>冲量相等而形状不同的窄脉冲加在具有惯性的环节上时，其效果基本相同。冲量指窄脉冲的面积。效果基本相同，是指环节的输出响应波形基本相同。低频段非常接近，仅在高频段略有差异。<br><img src="http://www.elecfans.com/uploads/allimg/121102/1183908-12110210504L23.jpg" alt="img"><br>                   图1　形状不同而冲量相同的各种窄脉冲<br>面积等效原理：</p><p>分别将如图1所示的电压窄脉冲加在一阶惯性环节（R-L电路）上，如图2a所示。其输出电流i(t)对不同窄脉冲时的响应波形如图2b所示。从波形可以看出，在i(t)的上升段，i(t)的形状也略有不同，但其下降段则几乎完全相同。脉冲越窄，各i(t)响应波形的差异也越小。如果周期性地施加上述脉冲，则响应i(t)也是周期性的。用傅里叶级数分解后将可看出，各i(t)在低频段的特性将非常接近，仅在高频段有所不同。<br><img src="http://www.elecfans.com/uploads/allimg/121102/1183908-12110210531Ea.jpg" alt="img"></p><p>​                 图2 冲量相同的各种窄脉冲的响应波形<br>用一系列等幅不等宽的脉冲来代替一个正弦半波，正弦半波N等分，看成N个相连的脉冲序列，宽度相等，但幅值不等；用矩形脉冲代替，等幅，不等宽，中点重合，面积（冲量）相等，宽度按正弦规律变化。SPWM波形——脉冲宽度按正弦规律变化而和正弦波等效的PWM波形。<br><img src="http://www.elecfans.com/uploads/allimg/121102/1183908-121102105506300.jpg" alt="img"></p><p>​                图3 用PWM波代替正弦半波</p><p>要改变等效输出正弦波幅值，按同一比例改变各脉冲宽度即可。 PWM电流波： 电流型逆变电路进行PWM控制，得到的就是PWM电流波。 PWM波形可等效的各种波形： 直流斩波电路：等效直流波形<br>SPWM波：等效正弦波形，还可以等效成其他所需波形，如等效所需非正弦交流波形等，其基本原理和SPWM控制相同，也基于等效面积原理。<br>模拟信号的值可以连续变化，其时间和幅度的分辨率都没有限制。9V电池就是一种模拟器件，因为它的输出电压并不精确地等于9V，而是随时间发生变化，并可取任何实数值。与此类似，从电池吸收的电流也不限定在一组可能的取值范围之内。模拟信号与数字信号的区别在于后者的取值通常只能属于预先确定的可能取值集合之内，例如在{0V, 5V}这一集合中取值。</p><h3 id="Generating-of-PWM"><a href="#Generating-of-PWM" class="headerlink" title="Generating of PWM"></a>Generating of PWM</h3><p>The simplest way of generating PWM is using a comparator circuit.</p><p>A voltage comparator considers two voltage waveforms A and B, and outputs a binary (two-valued) voltage waveform indicating which is larger (high voltage for 𝑉out states that A is larger and a low voltage that B is larger).</p><p>When the voltage of triangular wave is greater than the control voltage, the output of comparator will be high</p><p>When voltage of triangular wave is less than the control voltage, the output of comparator will be low</p><p>The width of the pulse can be changed depending on the value of the control voltage.</p><p>If we reduce the control voltage, the width of the output pulse increases</p><p>We can generate PWM from a digital output by switching it on and off, and changing the time for which the digital signal is “high” or “low”, but that would take up the time and effort of the CPU.</p><ul><li>The advantage of handling over responsibility of the PWM signal generation to the specific peripheral in the microcontroller chip, is that the CPU is then available to do other stuff.</li><li>This is one of the powerful aspects of a highly functionalised microcontroller – devolving responsibility for things low PWM, D&#x2F;A and A&#x2F;D to the peripherals frees up the time of the CPU.</li></ul><h3 id="Analog-Geneation-of-PWM"><a href="#Analog-Geneation-of-PWM" class="headerlink" title="Analog Geneation of PWM"></a>Analog Geneation of PWM</h3><p>The Intersective Method: </p><p>Allows for analog creation of PWM signal through noting intersections between a <strong>sawtooth trigger signal and a reference sinusoid</strong>.</p><p>Length of pulses is dependent upon intersection of reference sinusoid and trigger signal.</p><p>When sinusoid is greater than trigger signal, PWM pulse is switched to on&#x2F;high position, otherwise it is switched to off&#x2F;low.</p><h3 id="Turning-PWM-back"><a href="#Turning-PWM-back" class="headerlink" title="Turning PWM back"></a>Turning PWM back</h3><p>The average value of the signal will be determined by the duty cycle</p><p>By controlling the duty cycle, we can control the average value </p><p>If “on” time is small, average value is low; if “on” time is large,</p><p>average value is higher</p><p>The average value can be extracted from the PWM signal <strong>with a low pass filter</strong> – then Vout is an analogue output</p><h3 id="3-types-of-PWM"><a href="#3-types-of-PWM" class="headerlink" title="3 types of PWM"></a>3 types of PWM</h3><p>Lead Edge Modulation: </p><ul><li>The leading edge of the signal is fixed and the <strong>trailing edge is modulated</strong> in accordance with instantaneous values of message signal.</li></ul><p>Trail Edge Modulation</p><ul><li>The trailing edge of the trigger signal is fixed and the <strong>leading edge is modulated</strong> in accordance with instantaneous values of message signal.</li></ul><p>Pulse Center Two Edge Modulation</p><ul><li>The pulse center is fixed in the middle and <strong>both edges are modulated</strong> about the center of the trigger signal.</li></ul><h2 id="Pros-Cons"><a href="#Pros-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>Average value <strong>proportional</strong> to duty cycle</p><p>Low power used in transistors to switch the signal, and <strong>fast switching possible</strong> due to MOSFETS (metal-oxide-semiconductor field-effect transistor) and power transistors at speeds in excess of 100 kHz</p><p>To fulfill partial power requirements, variable resistance devices such as rheostats were used to control the current entering a device (e.g. sewing machines)</p><p>Alleviates the problem of high heat losses through resistive elements at intermediate voltage points</p><p>The main advantage of PWM is that power loss in digital switching devices (the FET) is very low.</p><p>When a switch is off there is practically no current leaking</p><ul><li>When it is on and power is being transferred to the load, there is almost no voltage drop across the switch</li><li>Power loss, being the product of voltage and current, is thus in both cases close to zero</li></ul>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PN结</title>
    <link href="/Blogs/2025/08/28/PN%E7%BB%93/"/>
    <url>/Blogs/2025/08/28/PN%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ul><li>​<strong>​内建电场​</strong>​：空间电荷区 → 扩散与漂移平衡</li><li>​<strong>​偏压响应​</strong>​：<ul><li>正向：势垒降低 → 扩散主导 (I∝eeV&#x2F;kT)</li><li>反向：势垒增宽 → 饱和电流 Is​</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
      <category>电子器件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PN结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab入门</title>
    <link href="/Blogs/2025/08/28/Matlab%E5%85%A5%E9%97%A8/"/>
    <url>/Blogs/2025/08/28/Matlab%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="matlab简介"><a href="#matlab简介" class="headerlink" title="matlab简介"></a>matlab简介</h1><ul><li><code>help</code> 在命令窗口（command windows）显示指定命令的简短使用说明</li><li><code>doc</code> 以网页形式显示指定命令的帮助页，此命令显示的标准更加具体，还有各种使用举例</li><li><code>lookfor</code> 按指定的关键词查询与之相关的命令</li><li><code>which</code> 显示指定函数所在的目录. 例如</li><li><code>cd、dir、more</code><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-number">1.</span> help eig # 用于查看eig函数的帮助文档，查询结果在command窗口显示<br><span class="hljs-number">2.</span> doc eig  # 同样是查看eig函数帮助文档，结果在单独的查看显示，比help显示更加完整详细<br><span class="hljs-number">3.</span> lookfor eig # 模糊查找， 比如说你知道某个可能的函数是plo***， 但是你有记不清就可以用这个命令了<br><span class="hljs-number">4.</span> which eig #查找函数具体在什么位置<br></code></pre></td></tr></table></figure><img src="https://pic1.zhimg.com/v2-5cb6390fc4108866fa9fc1a43545ccb8_180x120.jpg"></li></ul><h1 id="Matlab-变量"><a href="#Matlab-变量" class="headerlink" title="Matlab 变量"></a>Matlab 变量</h1><p>变量命名原则：以字母或者下划线开头(很少用下划线打头啊)；后面可以跟字母、数字和下划线；变量名区分字母的大小写.</p><h2 id="Matlab-语句的通常形式"><a href="#Matlab-语句的通常形式" class="headerlink" title="Matlab 语句的通常形式"></a>Matlab 语句的通常形式</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">变量 <span class="hljs-operator">=</span> 表达式<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>表达式是用运算符将有关运算量连接起来的式子，其结果被赋给赋值号“<code>=</code>”左边的变量</p><h2 id="分号和续行符的作用"><a href="#分号和续行符的作用" class="headerlink" title="分号和续行符的作用"></a>分号和续行符的作用</h2><ul><li>若<strong>不想在命令行窗口的屏幕上输出结果</strong>，可以在语句最后加分号；</li><li>如果语句很长，可用续行符 “<code>…</code>”（三个点）续行； 续行符的前面最好留一个空格.<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">1</span>  % a=<span class="hljs-number">1</span>就会在命令行窗口输出<br><span class="hljs-attribute">b</span> = <span class="hljs-number">1</span>;  % 加了分号就不显示在命令行窗口<br><span class="hljs-attribute">c</span> = <span class="hljs-number">123</span>+<span class="hljs-number">456</span>+<span class="hljs-number">789</span>+ ...<br>    <span class="hljs-attribute">123456</span>  %三个点换行<br></code></pre></td></tr></table></figure></li></ul><h2 id="变量的查询"><a href="#变量的查询" class="headerlink" title="变量的查询"></a>变量的查询</h2><ul><li><code>who</code> 显示工作空间中的所有变量；<code>whos</code> 查看工作空间中变量的详细属性<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br>&gt;&gt; c = <span class="hljs-built_in">pi</span>;<br>&gt;&gt; who<br>您的变量为:<br>a  b  c  <br>&gt;&gt; whos<br>  Name      Size            Bytes  Class     Attributes<br><br>  a         <span class="hljs-number">1</span>x1                 <span class="hljs-number">8</span>  double              <br>  b         <span class="hljs-number">1</span>x1                 <span class="hljs-number">8</span>  double              <br>  c         <span class="hljs-number">1</span>x1                 <span class="hljs-number">8</span>  double   <br></code></pre></td></tr></table></figure></li></ul><h2 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h2><ul><li><code>pi</code> ： 圆周率 π ；<code>inf, Inf</code> ：无穷大；<code>nan, NaN</code> ：Not-a-Number，一个不定值，如 0&#x2F;0；<code>eps</code> ：浮点运算相对精度</li><li><code>i, j</code> ：虚部单位, 通常为了避免混淆我们写作<code>1i, 1j</code></li><li>特殊变量 <code>ans</code> – 应尽量避免给系统预定义变量重新赋值</li></ul><h2 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h2><ul><li>加法；- 减法；* 乘法；&#x2F; 和 \ 除法（右左除）:^ 幂运算；<br>点乘 (<code>.*</code>) 与点除 (<code>./</code> ): 这两个用的特别多，例如<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x  = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>];<br>y  = [ <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>];<br>x.*y  <span class="hljs-comment">% 输出1*2   2*4  3*6</span><br>y./x <span class="hljs-comment">%输出  2/1  4/2 6/3</span><br>x.^<span class="hljs-number">3</span> <span class="hljs-comment">%输出  1^3  2^3  3^3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>&#x2F;（向右倒称为右除）           右除         AB&#x3D;C   A&#x3D;C&#x2F;B</strong><br><strong>\（向左倒称为左除）           左除         AB&#x3D;C   B&#x3D;A\C</strong></p><table><thead><tr><th align="center">运算符</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center"><strong>+</strong></td><td align="center">加; 加法运算符。</td></tr><tr><td align="center"><strong>-</strong></td><td align="center">减; 减法运算符。</td></tr><tr><td align="center">*****</td><td align="center">标量和矩阵乘法运算符。</td></tr><tr><td align="center"><strong>.*</strong></td><td align="center">数组乘法运算符。</td></tr><tr><td align="center"><strong>^</strong></td><td align="center">标量和矩阵求幂运算符。</td></tr><tr><td align="center"><strong>.^</strong></td><td align="center">数组求幂运算符。</td></tr><tr><td align="center"><code>\</code></td><td align="center">左除法运算符。</td></tr><tr><td align="center"><code>/</code></td><td align="center">右除法运算符。</td></tr><tr><td align="center">&#96;&#96;.`</td><td align="center">数组左除法运算符。</td></tr><tr><td align="center"><strong>.&#x2F;</strong></td><td align="center">数组右除法运算符。</td></tr><tr><td align="center"><strong>:</strong></td><td align="center">冒号；生成规则间距的元素并表示整行或整列。</td></tr><tr><td align="center"><strong>( )</strong></td><td align="center">圆括号；封闭函数参数和数组索引；重写优先级。</td></tr><tr><td align="center"><strong>[ ]</strong></td><td align="center">括号；附件数组元素。</td></tr><tr><td align="center"><strong>.</strong></td><td align="center">小数点。</td></tr><tr><td align="center"><strong>…</strong></td><td align="center">省略号；行连续运算符</td></tr><tr><td align="center"><strong>,</strong></td><td align="center">逗号；分隔一行中的语句和元素</td></tr><tr><td align="center"><strong>;</strong></td><td align="center">分号; 分隔列并抑制显示。</td></tr><tr><td align="center"><strong>%</strong></td><td align="center">百分号；指定注释并指定格式。</td></tr><tr><td align="center"><strong>_</strong></td><td align="center">引用符号和转置运算符。</td></tr><tr><td align="center"><strong>._</strong></td><td align="center">Nonconjugated转置运算符。</td></tr><tr><td align="center"><strong>&#x3D;</strong></td><td align="center">赋值运算符。</td></tr></tbody></table><h2 id="特殊变量与常量"><a href="#特殊变量与常量" class="headerlink" title="特殊变量与常量"></a>特殊变量与常量</h2><table><thead><tr><th align="center">名称</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center"><strong>ans</strong></td><td align="center">最近计算的答案。</td></tr><tr><td align="center"><strong>eps</strong></td><td align="center">浮点精度。</td></tr><tr><td align="center"><strong>i,j</strong></td><td align="center">虚数单位√-1。</td></tr><tr><td align="center"><strong>Inf</strong></td><td align="center">无穷。</td></tr><tr><td align="center"><strong>NaN</strong></td><td align="center">未定义的数值结果（不是数字）。</td></tr><tr><td align="center"><strong>pi</strong></td><td align="center">π</td></tr></tbody></table><h2 id="命令分隔符：逗号和分号"><a href="#命令分隔符：逗号和分号" class="headerlink" title="命令分隔符：逗号和分号"></a>命令分隔符：逗号和分号</h2><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Matlab 以双精度执行所有的运算，运算结果可以在屏幕上输出，同时赋给指定变量；若无指定变量，则系统会自动将结果赋给变量 “ans”；Matlab 中数的输出格式可以通过 <code>format</code> 命令指定；<code>format</code> 只改变变量的输出格式，但不会影响变量的值！</p><p><a href="https://zhuanlan.zhihu.com/p/140027256">石头：matlab入门2：变量与赋值，数据保存于读取9 赞同 · 2 评论文章</a></p><h3 id="format命令"><a href="#format命令" class="headerlink" title="format命令"></a>format命令</h3><p>默认情况下，MATLAB显示带有四个小数位值的数字。这就是所谓的<strong>short format</strong>。</p><p>但是，如果要提高精度，则需要使用<strong>format</strong>命令。</p><p><strong>format long</strong>命令在小数点后显示16位数字。</p><h1 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h1><h2 id="用于管理会话的命令"><a href="#用于管理会话的命令" class="headerlink" title="用于管理会话的命令"></a>用于管理会话的命令</h2><table><thead><tr><th align="center">命令</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">clc</td><td align="center">清除命令窗口。</td></tr><tr><td align="center">clear</td><td align="center">从内存中删除变量。</td></tr><tr><td align="center">exist</td><td align="center">检查文件或变量的存在。</td></tr><tr><td align="center">global</td><td align="center">声明变量为全局变量。</td></tr><tr><td align="center">help</td><td align="center">搜索帮助主题。</td></tr><tr><td align="center">lookfor</td><td align="center">在帮助条目中搜索关键字。</td></tr><tr><td align="center">quit</td><td align="center">停止MATLAB。</td></tr><tr><td align="center">who</td><td align="center">列出当前变量。</td></tr><tr><td align="center">whos</td><td align="center">列出当前变量（长显示）。</td></tr></tbody></table><h3 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h3><p>save  文件名 变量名列表</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">save  <span class="hljs-string">&#x27;file1.mat&#x27;</span> p q <span class="hljs-comment">%将变量 p与去存储到文件file1.mat里面</span><br><br>save(<span class="hljs-string">&#x27;file1.mat&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>) <span class="hljs-comment">%和上面结果一样 </span><br></code></pre></td></tr></table></figure><ul><li>变量名列表中各变量之间用空格分隔</li></ul><p><strong>save</strong>命令用于将工作空间中的所有变量保存为当前目录中扩展名为.mat的文件。</p><p>例如，</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">save myfile</span><br></code></pre></td></tr></table></figure><p>您以后可以随时使用<strong>load</strong>命令重新加载文件。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">load myfile</span><br></code></pre></td></tr></table></figure><ul><li>清除当前工作空间中的变量；<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear A  x   <span class="hljs-comment">%清除指定的变量</span><br><br>clear  all <span class="hljs-comment">% 清除所有工作空间变量</span><br></code></pre></td></tr></table></figure></li><li></li></ul><h3 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h3><p><strong>who</strong>命令显示您已使用的所有变量名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">who</span><br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">Your <span class="hljs-keyword">variables</span> are:<br>a    <span class="hljs-comment">ans  b    c</span><br></code></pre></td></tr></table></figure><p><strong>whos</strong>命令显示了有关变量的更多信息-</p><ul><li>当前内存中的变量</li><li>每个变量的类型</li><li>分配给每个变量的内存</li><li>它们是否为复杂变量</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">whos</span><br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Attr Name        Size        Bytes      Class<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>        <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>        <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>       <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <br>   a             <span class="hljs-number">1</span>x1           <span class="hljs-number">8</span>        double<br>   ans           <span class="hljs-number">1</span>x70         <span class="hljs-number">757</span>        cell<br>   b             <span class="hljs-number">1</span>x1           <span class="hljs-number">8</span>        double<br>   c             <span class="hljs-number">1</span>x1           <span class="hljs-number">8</span>        double<br><br>Total is <span class="hljs-number">73</span> elements using <span class="hljs-number">781</span> bytes<br></code></pre></td></tr></table></figure><p>该<strong>clear</strong>命令variable(s)从内存中删除所有（或指定的）。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">clear x     <span class="hljs-comment">% it will delete x, won&#x27;t display anything</span><br>clear       <span class="hljs-comment">% it will delete all variables in the workspace</span><br>            <span class="hljs-comment">%  peacefully and unobtrusively</span><br></code></pre></td></tr></table></figure><h2 id="用于系统的命令"><a href="#用于系统的命令" class="headerlink" title="用于系统的命令"></a>用于系统的命令</h2><p>MATLAB提供了各种有用的命令来处理系统，例如将当前工作作为文件保存在工作区中，并在以后加载文件。</p><p>它还为其他与系统相关的活动提供各种命令，例如显示日期，在目录中列出文件，显示当前目录等。</p><p>下表显示了一些常用的与系统相关的命令-</p><table><thead><tr><th align="center">命令</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">cd</td><td align="center">更改当前目录。</td></tr><tr><td align="center">date</td><td align="center">显示当前日期。</td></tr><tr><td align="center">delete</td><td align="center">删除文件。</td></tr><tr><td align="center">diary</td><td align="center">开启&#x2F;关闭日记文件录制。</td></tr><tr><td align="center">dir</td><td align="center">列出当前目录中的所有文件。</td></tr><tr><td align="center">load</td><td align="center">从文件加载工作区变量。</td></tr><tr><td align="center">path</td><td align="center">显示搜索路径。</td></tr><tr><td align="center">pwd</td><td align="center">显示当前目录。</td></tr><tr><td align="center">save</td><td align="center">将工作空间变量保存在文件中。</td></tr><tr><td align="center">type</td><td align="center">显示文件的内容。</td></tr><tr><td align="center">what</td><td align="center">列出当前目录中的所有MATLAB文件。</td></tr><tr><td align="center">wklread</td><td align="center">读取.wk1电子表格文件。</td></tr></tbody></table><h2 id="输入和输出命令"><a href="#输入和输出命令" class="headerlink" title="输入和输出命令"></a>输入和输出命令</h2><p>MATLAB提供以下与输入和输出相关的命令-</p><table><thead><tr><th align="center">命令</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">disp</td><td align="center">显示数组或字符串的内容。</td></tr><tr><td align="center">fscanf</td><td align="center">从文件中读取格式化的数据。</td></tr><tr><td align="center">format</td><td align="center">控制屏幕显示格式。</td></tr><tr><td align="center">fprintf</td><td align="center">执行对屏幕或文件的格式化写入。</td></tr><tr><td align="center">input</td><td align="center">显示提示并等待输入。</td></tr><tr><td align="center">;</td><td align="center">禁止丝网印刷。</td></tr></tbody></table><p><strong>fscanf</strong>和<strong>fprintf</strong>命令的行为像C的scanf和printf函数。它们支持以下格式代码-</p><table><thead><tr><th align="center">格式代码</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center"><strong>%s</strong></td><td align="center">格式化为字符串。</td></tr><tr><td align="center"><strong>%d</strong></td><td align="center">格式化为整数。</td></tr><tr><td align="center"><strong>%f</strong></td><td align="center">格式化为浮点值。</td></tr><tr><td align="center"><strong>%e</strong></td><td align="center">以科学计数形式格式化为浮点值。</td></tr><tr><td align="center"><strong>%g</strong></td><td align="center">以最紧凑的格式进行格式化：％f或％e。</td></tr><tr><td align="center"><strong>\n</strong></td><td align="center">在输出字符串中插入新行。</td></tr><tr><td align="center"><strong>\t</strong></td><td align="center">在输出字符串中插入一个选项卡。</td></tr></tbody></table><p>格式函数具有以下用于数字显示的形式-</p><table><thead><tr><th align="center">格式功能</th><th align="center">最多显示</th></tr></thead><tbody><tr><td align="center">format short</td><td align="center">四个小数位(默认值)。</td></tr><tr><td align="center">format long</td><td align="center">16位小数。</td></tr><tr><td align="center">format short e</td><td align="center">五位数加指数。</td></tr><tr><td align="center">format long e</td><td align="center">16位数字加指数。</td></tr><tr><td align="center">format bank</td><td align="center">两个小数位数。定点货币形式</td></tr><tr><td align="center">format +</td><td align="center">正数，负数或零。</td></tr><tr><td align="center">format rat</td><td align="center">有理近似。小数分数表示</td></tr><tr><td align="center">format compact</td><td align="center">禁止某些换行符。</td></tr><tr><td align="center">format loose</td><td align="center">重置为不太紧凑的显示模式。</td></tr></tbody></table><h2 id="向量，矩阵和数组命令"><a href="#向量，矩阵和数组命令" class="headerlink" title="向量，矩阵和数组命令"></a>向量，矩阵和数组命令</h2><p>下表显示了用于处理数组，矩阵和向量的各种命令-</p><table><thead><tr><th align="center">命令</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">cat</td><td align="center">连接数组。</td></tr><tr><td align="center">find</td><td align="center">查找非零元素的索引。</td></tr><tr><td align="center">length</td><td align="center">计算元素数。</td></tr><tr><td align="center">linspace</td><td align="center">创建规则间隔的矢量。</td></tr><tr><td align="center">logspace</td><td align="center">创建对数间隔的向量。</td></tr><tr><td align="center">max</td><td align="center">返回最大元素。</td></tr><tr><td align="center">min</td><td align="center">返回最小的元素。</td></tr><tr><td align="center">prod</td><td align="center">每列的乘积。</td></tr><tr><td align="center">reshape</td><td align="center">更改大小。</td></tr><tr><td align="center">size</td><td align="center">计算数组大小。</td></tr><tr><td align="center">sort</td><td align="center">对每一列进行排序。</td></tr><tr><td align="center">sum</td><td align="center">对每列求和。</td></tr><tr><td align="center">eye</td><td align="center">创建一个单位矩阵。</td></tr><tr><td align="center">ones</td><td align="center">创建一个数组。</td></tr><tr><td align="center">zeros</td><td align="center">创建一个零数组。</td></tr><tr><td align="center">cross</td><td align="center">计算矩阵叉积。</td></tr><tr><td align="center">dot</td><td align="center">计算矩阵点积。</td></tr><tr><td align="center">det</td><td align="center">计算数组的行列式。</td></tr><tr><td align="center">inv</td><td align="center">计算矩阵的逆。</td></tr><tr><td align="center">pinv</td><td align="center">计算矩阵的伪逆。</td></tr><tr><td align="center">rank</td><td align="center">计算矩阵的秩。</td></tr><tr><td align="center">rref</td><td align="center">计算精简行梯形表格。</td></tr><tr><td align="center">cell</td><td align="center">创建单元格数组。</td></tr><tr><td align="center">celldisp</td><td align="center">显示单元格数组。</td></tr><tr><td align="center">cellplot</td><td align="center">显示单元格数组的图形表示形式。</td></tr><tr><td align="center">num2cell</td><td align="center">将数字数组转换为单元格数组。</td></tr><tr><td align="center">deal</td><td align="center">匹配输入和输出列表。</td></tr><tr><td align="center">iscell</td><td align="center">标识单元格数组。</td></tr></tbody></table><h2 id="绘图命令"><a href="#绘图命令" class="headerlink" title="绘图命令"></a>绘图命令</h2><p>MATLAB提供了许多用于绘制图形的命令。下表显示了一些常用的绘图命令-</p><table><thead><tr><th align="center">命令</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">axis</td><td align="center">设置轴限制。</td></tr><tr><td align="center">fplot</td><td align="center">函数的智能绘图。</td></tr><tr><td align="center">grid</td><td align="center">显示网格线。</td></tr><tr><td align="center">plot</td><td align="center">生成xy图。</td></tr><tr><td align="center">print</td><td align="center">打印图或将图保存到文件中。</td></tr><tr><td align="center">title</td><td align="center">将文本放在图的顶部。</td></tr><tr><td align="center">xlabel</td><td align="center">在x轴上添加文本标签。</td></tr><tr><td align="center">ylabel</td><td align="center">将文本标签添加到y轴。</td></tr><tr><td align="center">axes</td><td align="center">创建轴对象。</td></tr><tr><td align="center">close</td><td align="center">关闭当前图。</td></tr><tr><td align="center">close all</td><td align="center">关闭所有地块。</td></tr><tr><td align="center">figure</td><td align="center">打开一个新的图形窗口。</td></tr><tr><td align="center">gtext</td><td align="center">通过鼠标启用标签放置。</td></tr><tr><td align="center">hold</td><td align="center">冻结当前图。</td></tr><tr><td align="center">legend</td><td align="center">用鼠标放置图例。</td></tr><tr><td align="center">refresh</td><td align="center">重新绘制当前图形窗口。</td></tr><tr><td align="center">set</td><td align="center">指定对象（例如轴）的属性。</td></tr><tr><td align="center">subplot</td><td align="center">在子窗口中创建图。</td></tr><tr><td align="center">text</td><td align="center">在图中放置字符串。</td></tr><tr><td align="center">bar</td><td align="center">创建条形图。</td></tr><tr><td align="center">loglog</td><td align="center">创建对数-对数图。</td></tr><tr><td align="center">polar</td><td align="center">创建极坐标图。</td></tr><tr><td align="center">semilogx</td><td align="center">创建半对数图。（对数横坐标）。</td></tr><tr><td align="center">semilogy</td><td align="center">创建半对数图。（对数纵坐标）。</td></tr><tr><td align="center">stairs</td><td align="center">创建楼梯图。</td></tr><tr><td align="center">stem</td><td align="center">创建茎图。</td></tr></tbody></table><h2 id="几个小技巧"><a href="#几个小技巧" class="headerlink" title="几个小技巧"></a>几个小技巧</h2><ul><li>Matlab的命令记忆功能：上下箭头键(先输入命令的前几个字符，再按上下键缩小搜索范围)</li><li>命令补全功能： <code>Tab键</code> ；用 <code>Esc键</code> 删除命令行</li></ul><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><p>Matlab 的操作对象是矩阵</p><ul><li>定义矩阵：<code>直接输入法</code><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = [<span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>; <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>; <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>]<br><span class="hljs-comment">%或者</span><br>A = [<span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>; <br>     <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>; <br>     <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure></li><li>矩阵用方括号 “<code>[ ]</code>” 括起<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">mat = [元素]<br></code></pre></td></tr></table></figure></li><li>矩阵同一行中的元素之间用 <code>空格</code> 或 <code>逗号</code> 分隔<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">mat1 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]; <br>mat2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">%两者意义一样</span><br></code></pre></td></tr></table></figure></li><li>矩阵行与行之间用 分号 分开<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">mat3 =[ 1 2 3; 4, 5, 6];<br></code></pre></td></tr></table></figure></li><li>直接输入法中，分号可以用 回车 代替<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">mat4 = [1 2 3<br>        4 5 6];<br></code></pre></td></tr></table></figure></li><li><strong>利用函数建立数值矩阵</strong>：MATLAB提供了许多生成和操作矩阵的函数。例如: <code>reshape</code> 函数和 <code>diag</code> 函数等。reshape函数用于建立数值矩阵。diag函数用于产生对角阵。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; x = <span class="hljs-number">1</span>:<span class="hljs-number">12</span><br>x =<br>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span>     <span class="hljs-number">8</span>     <span class="hljs-number">9</span>    <span class="hljs-number">10</span>    <span class="hljs-number">11</span>    <span class="hljs-number">12</span><br>&gt;&gt; y = <span class="hljs-built_in">reshape</span>(x,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">% reshape用法</span><br>y =<br>     <span class="hljs-number">1</span>     <span class="hljs-number">4</span>     <span class="hljs-number">7</span>    <span class="hljs-number">10</span><br>     <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>    <span class="hljs-number">11</span><br>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>     <span class="hljs-number">9</span>    <span class="hljs-number">12</span><br><br>&gt;&gt; z = <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>z =<br>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span><br>&gt;&gt; <span class="hljs-built_in">diag</span>(z)   <span class="hljs-comment">% 创建对角矩阵</span><br><span class="hljs-built_in">ans</span> =<br>     <span class="hljs-number">1</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span><br>     <span class="hljs-number">0</span>     <span class="hljs-number">2</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span><br>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">0</span><br>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>转置操作将列向量更改为行向量，反之亦然。转置操作由单引号（’）表示。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A=A&#x27;;<br></code></pre></td></tr></table></figure><h3 id="建立矩阵的函数"><a href="#建立矩阵的函数" class="headerlink" title="建立矩阵的函数"></a>建立矩阵的函数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">eye</span>(<span class="hljs-built_in">size</span>(A))      <span class="hljs-comment">% 产生与A矩阵同阶的单位矩阵</span><br><span class="hljs-built_in">zeros</span>(m,n)        <span class="hljs-comment">% 产生0矩阵</span><br><span class="hljs-built_in">ones</span>(m,n)         <span class="hljs-comment">% 产生幺矩阵</span><br><span class="hljs-built_in">rand</span> (m,n)        <span class="hljs-comment">% 产生随机元素的矩阵</span><br><span class="hljs-built_in">size</span>(a)           <span class="hljs-comment">% 返回包含两个元素的向量。</span><br><span class="hljs-built_in">length</span>(a)         <span class="hljs-comment">% 返回向量的长度。 </span><br>inv(a)<span class="hljs-comment">% 求逆矩阵</span><br></code></pre></td></tr></table></figure><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><ul><li>矩阵A是一个1X2矩阵，第一个元素1，第二个元素2<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">A(1)=1;<br>A(2)=2;<br></code></pre></td></tr></table></figure></li><li>大矩阵可以把小矩阵作为其元素<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">A = [A ; 3 4];<br></code></pre></td></tr></table></figure></li></ul><h2 id="矩阵元素提取引用操作"><a href="#矩阵元素提取引用操作" class="headerlink" title="矩阵元素提取引用操作"></a>矩阵元素提取引用操作</h2><p>单个元素的引用；利用小括弧和元素所在的位置(下标)<br><code>A(1)</code> 引用A的第一个元素；<br><code>A(i)</code>：向量 A 中的第 i 个元素；<br><code>A(i,j)</code>：矩阵 A 中的第 i 行，第 j 列元素；多个元素的引用：<br>冒号的特殊用法；<code>a:b:c</code> %产生一个由等差序列组成的向量； a 是首项，b 是公差，c 确定最后一项；若 b&#x3D;1，则 b 可以省略。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">5</span>;<br>x = <span class="hljs-number">2</span>:<span class="hljs-number">5</span>; <span class="hljs-comment">%省略</span><br>x = <span class="hljs-number">10</span>:<span class="hljs-number">-3</span>:<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>矩阵元素的引用<br><code>A(i:j, m:n)</code> 表示由矩阵 A 的第 i 到第 j 行和第 m 到第 n 列交叉线上的元素组成的子矩阵。可利用冒号提取矩阵的整行或整列</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">A(1, :)<br>A(:, 1:3)<br>A(:, :)<br></code></pre></td></tr></table></figure><h2 id="MATLAB-向量操作"><a href="#MATLAB-向量操作" class="headerlink" title="MATLAB 向量操作"></a>MATLAB 向量操作</h2><h3 id="MATLAB-向量追加"><a href="#MATLAB-向量追加" class="headerlink" title="MATLAB 向量追加"></a>MATLAB 向量追加</h3><p>MATLAB 允许您将向量附加到一起来创建新的向量。</p><p>如果您有两个包含n和m个元素的行向量r1和r2，则要创建一个包含n个元素和m个元素的行向量r，通过添加这些向量，您可以编写-</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">r = [<span class="hljs-built_in">r1</span>,<span class="hljs-built_in">r2</span>]<br></code></pre></td></tr></table></figure><p>您还可以通过添加这两个向量来创建矩阵r，向量r2将是矩阵的第二行-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">r</span> <span class="hljs-operator">=</span> [r1<span class="hljs-comment">;r2]</span><br></code></pre></td></tr></table></figure><h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>（1） 数组的加和减 （2） 数组的乘和除 （3） 数组的乘方  </p><p><a href="https://zhuanlan.zhihu.com/p/140031962">石头：matlab入门4：基本运算19 赞同 · 0 评论文章</a></p><p>1、行列式计算；</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">det([<span class="hljs-number">1</span> <span class="hljs-number">2</span> ;<span class="hljs-number">3</span> <span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p>2、求解线性方程组；</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">x = A\b<br></code></pre></td></tr></table></figure><p>3、解特征值问题</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">eig(A)<br></code></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>MATLAB 不需要任何类型声明或维度语句。每当 MATLAB 遇到一个新的变量名，它就创建变量并分配适当的内存空间。</p><p>如果变量已经存在，那么MATLAB将用新内容替换原始内容，并在必要时分配新的存储空间。</p><p>例如，</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Total</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>上面的语句创建一个名为“ Total”的1比1矩阵，并将值42存储在其中。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>MATLAB提供了用于将值从一种数据类型转换为另一种数据的各种函数。下表显示了数据类型转换函数-</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">转换为字符数组（字符串）</td></tr><tr><td align="center">int2str</td><td align="center">将整数数据转换为字符串</td></tr><tr><td align="center">mat2str</td><td align="center">将矩阵转换为字符串</td></tr><tr><td align="center">num2str</td><td align="center">将数字转换为字符串</td></tr><tr><td align="center">str2double</td><td align="center">将字符串转换为双精度值</td></tr><tr><td align="center">str2num</td><td align="center">将字符串转换为数字</td></tr><tr><td align="center">native2unicode</td><td align="center">将数字字节转换为 Unicode 字符</td></tr><tr><td align="center">unicode2native</td><td align="center">将Unicode字符转换为数字字节</td></tr><tr><td align="center">base2dec</td><td align="center">将N进制数字符串转换为十进制数</td></tr><tr><td align="center">bin2dec</td><td align="center">将二进制数字符串转换为十进制数</td></tr><tr><td align="center">dec2base</td><td align="center">将十进制数转换为字符串中的N进制数</td></tr><tr><td align="center">dec2bin</td><td align="center">将十进制转换为字符串中的二进制数</td></tr><tr><td align="center">dec2hex</td><td align="center">将字符串中的十进制数转换为十六进制数</td></tr><tr><td align="center">hex2dec</td><td align="center">将十六进制数字字符串转换为十进制数字</td></tr><tr><td align="center">hex2num</td><td align="center">将十六进制数字字符串转换为双精度数字</td></tr><tr><td align="center">num2hex</td><td align="center">将单精度和双精度转换为IEEE十六进制字符串</td></tr><tr><td align="center">cell2mat</td><td align="center">将单元格数组转换为数值数组</td></tr><tr><td align="center">cell2struct</td><td align="center">将单元数组转换为结构数组</td></tr><tr><td align="center">cellstr</td><td align="center">从字符数组创建字符串的单元格数组</td></tr><tr><td align="center">mat2cell</td><td align="center">将数组转换为单元格大小可能不同的单元格</td></tr><tr><td align="center">num2cell</td><td align="center">将数组转换为大小一致的单元格数组</td></tr><tr><td align="center">struct2cell</td><td align="center">将结构转换为单元格数组</td></tr></tbody></table><h2 id="数据类型的确定"><a href="#数据类型的确定" class="headerlink" title="数据类型的确定"></a>数据类型的确定</h2><p>MATLAB提供了各种功能来识别变量的数据类型。</p><p>下表提供了确定变量的数据类型的功能-</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">is</td><td align="center">检测状态</td></tr><tr><td align="center">isa</td><td align="center">确定输入是否为指定类的对象</td></tr><tr><td align="center">iscell</td><td align="center">确定输入是否为单元格数组</td></tr><tr><td align="center">iscellstr</td><td align="center">确定输入是否为字符串的单元格数组</td></tr><tr><td align="center">ischar</td><td align="center">确定项目是否为字符数组</td></tr><tr><td align="center">isfield</td><td align="center">确定输入是否为结构数组字段</td></tr><tr><td align="center">isfloat</td><td align="center">确定输入是否为浮点数组</td></tr><tr><td align="center">ishghandle</td><td align="center">适用于处理图形对象句柄</td></tr><tr><td align="center">isinteger</td><td align="center">确定输入是否为整数数组</td></tr><tr><td align="center">isjava</td><td align="center">确定输入是否为Java对象</td></tr><tr><td align="center">islogical</td><td align="center">确定输入是否为逻辑数组</td></tr><tr><td align="center">isnumeric</td><td align="center">确定输入是否为数值数组</td></tr><tr><td align="center">isobject</td><td align="center">确定输入是否为MATLAB对象</td></tr><tr><td align="center">isreal</td><td align="center">检查输入是否为实数数组</td></tr><tr><td align="center">isscalar</td><td align="center">确定输入是否为标量</td></tr><tr><td align="center">isstr</td><td align="center">确定输入是否为字符数组</td></tr><tr><td align="center">isstruct</td><td align="center">确定输入是否为结构数组</td></tr><tr><td align="center">isvector</td><td align="center">确定输入是否为向量</td></tr><tr><td align="center">class</td><td align="center">确定对象的类别</td></tr><tr><td align="center">validateattributes</td><td align="center">检查数组的有效性</td></tr><tr><td align="center">whos</td><td align="center">列出工作空间中的变量，包括大小和类型</td></tr></tbody></table><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h2 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h2><p>按位运算符对位进行运算并执行逐位运算。＆，|和^的真值表如下-</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p＆q</th><th align="center">p | q</th><th align="center">p ^ Q</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">bitand(a, b)</td><td align="center">整数 a 和 b 的位与</td></tr><tr><td align="center">bitcmp(a)</td><td align="center">a的逐位补码</td></tr><tr><td align="center">bitget(a,pos)</td><td align="center">在整数数组a的指定位置获取位</td></tr><tr><td align="center">bitor(a, b)</td><td align="center">整数a和b的位或</td></tr><tr><td align="center">bitset(a, pos)</td><td align="center">将bit设置为a的特定位置pos</td></tr><tr><td align="center">bitshift(a, k)</td><td align="center">返回<em>一个</em>由向左移动<em>ķ</em>比特，相当于乘以2 ķ。k的负值对应于右移位或除以2 | k | 并朝负无穷大四舍五入到最接近的整数。任何溢出位都将被截断。</td></tr><tr><td align="center">bitxor(a, b)</td><td align="center">整数 a 和 b 的位异或</td></tr><tr><td align="center">swapbytes</td><td align="center">整数 a 和 b 的位异或</td></tr></tbody></table><h1 id="冒号表示法"><a href="#冒号表示法" class="headerlink" title="冒号表示法"></a>冒号表示法</h1><p><strong>colon(:)<strong>是在MATLAB中最有用的运算符之一。它用于创建向量，下标数组和</strong>指定迭代</strong>。</p><p>如果要创建包含1到10的整数的行向量，请编写-</p><p>示例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>MATLAB执行该语句并返回包含1到10的整数的行向量-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ans</span> =                                                                           <br>                                                                                <br>   <span class="hljs-attribute">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>    <span class="hljs-number">5</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>    <span class="hljs-number">8</span>    <span class="hljs-number">9</span>   <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>如果要指定一个增量值而不是一个值，例如-</p><p>示例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">100</span>: -<span class="hljs-number">5</span>: <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>MATLAB执行该语句并返回以下结果-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ans</span> =<br>   <span class="hljs-attribute">100</span>    <span class="hljs-number">95</span>    <span class="hljs-number">90</span>    <span class="hljs-number">85</span>    <span class="hljs-number">80</span>    <span class="hljs-number">75</span>    <span class="hljs-number">70</span>    <span class="hljs-number">65</span>    <span class="hljs-number">60</span>    <span class="hljs-number">55</span>    <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>可以使用冒号运算符创建索引向量，以选择行，列或数组元素。</p><p>下表描述了它的用途（让我们有一个矩阵A）-</p><table><thead><tr><th align="center">格式</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center"><strong>A(:,j)</strong></td><td align="center">是A的第j列。</td></tr><tr><td align="center"><strong>A(i,:)</strong></td><td align="center">是A的第i行。</td></tr><tr><td align="center"><strong>A(:,:)</strong></td><td align="center">是等效的二维数组。对于矩阵，这与A相同。</td></tr><tr><td align="center"><strong>A(j:k)</strong></td><td align="center">is A(j), A(j+1),…,A(k).</td></tr><tr><td align="center"><strong>A(:,j:k)</strong></td><td align="center">是A（：，j），A（：，j + 1），…，A（：，k）。</td></tr><tr><td align="center"><strong>A(:,:,k)</strong></td><td align="center">是第k个三维阵列A的页</td></tr><tr><td align="center"><strong>A(i,j,k,:)</strong></td><td align="center">是三维数组A中的向量。向量包括A(i,j,k,1)，A(i,j,k,2)，A(i,j,k,3)等。</td></tr><tr><td align="center"><strong>A(:)</strong></td><td align="center">是A的所有元素，被视为一个单独的列。在赋值语句的左侧，A（:)填充了A，并保留了之前的形状。在这种情况下，右侧必须包含与A相同数量的元素。</td></tr></tbody></table><h1 id="matlab图像可视化"><a href="#matlab图像可视化" class="headerlink" title="matlab图像可视化"></a>matlab图像可视化</h1><h2 id="二维平面图形与坐标系"><a href="#二维平面图形与坐标系" class="headerlink" title="二维平面图形与坐标系"></a>二维平面图形与坐标系</h2><ol><li>线性坐标曲线 <code>plot</code> 函数命令，它可以生成线段、曲线和参数方程曲线的函数图形。命令格式: <code>plot(X,Y)</code> ; <code>plot(x1,y1,x2,y2,…)</code></li><li>用命令 <code>plot(x,y)</code>绘制 <code>y=cos(x)</code>在一个周期内的图形。</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>;   <br>y=<span class="hljs-built_in">cos</span>(x);   <br><span class="hljs-built_in">plot</span>(x,y)<br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-c642641f7253ef0c74e66ea0b3cf2108_1440w.jpg"></p><ol><li>在同一图形窗口中用命令 <code>plot(x,y)</code>绘出正弦余弦函数的图形。</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>;   <br>y=[<span class="hljs-built_in">sin</span>(x);<span class="hljs-built_in">cos</span>(x)];   <br><span class="hljs-built_in">plot</span>(x,y) <br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-3bf257199c194a2fbe8dd9c99f7f4143_1440w.jpg"></p><ol><li>plot 函数可以设置曲线的线段类型、定点标记和线段颜色。 <strong><code>调用格式：plot(x,y,s) ，s 为类型说明参数，是字符串</code>。</strong> s 字符串可以是三种类型的符号之一，也可以是线型与颜色和定点标记与颜色的组合。用 <code>hold on</code> 命令在一个坐标系中增加新的图形对象。</li></ol><ul><li>图形窗口的分割: 实现在同一个窗口中同时显示多个图像的命令<code>subplot</code>。 使用格式为：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subplot(m，n，<span class="hljs-built_in">i</span>)<br></code></pre></td></tr></table></figure><p>其含义为 ：<code>把图形窗口分割为 m 行 n 列子窗口，然后选定第 i 个窗口为当前窗口。 subplot 命令不仅用于二维图形，对三维图形一样适用。其本质是将 figure 窗口分为几个区域，再在每个区域内分别绘图</code><strong>。</strong></p><ul><li>用 subplot 函数把两种不同的图形综合在一个图形窗口中。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>t=<span class="hljs-number">0.1</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>;<br>y=<span class="hljs-built_in">sin</span>(t);<br>semilogx(t,y,<span class="hljs-string">&#x27;linewidth&#x27;</span>,<span class="hljs-number">2</span>)<br>grid on<br>set(gca,<span class="hljs-string">&#x27;FontSize&#x27;</span>,<span class="hljs-number">15</span>)<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>;<br>y=<span class="hljs-built_in">sin</span>(t);<br><span class="hljs-built_in">plot</span>(t,y,<span class="hljs-string">&#x27;linewidth&#x27;</span>,<span class="hljs-number">2</span>)<br>set(gca,<span class="hljs-string">&#x27;FontSize&#x27;</span>,<span class="hljs-number">15</span>)<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>x=<span class="hljs-number">1</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">5</span>;<br>y=<span class="hljs-built_in">exp</span>(x);<br><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&#x27;linewidth&#x27;</span>,<span class="hljs-number">2</span>)<br>set(gca,<span class="hljs-string">&#x27;FontSize&#x27;</span>,<span class="hljs-number">15</span>)<br><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>x=<span class="hljs-number">1</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">10</span>;<br>y=<span class="hljs-built_in">sqrt</span>(x);<br><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-string">&#x27;linewidth&#x27;</span>,<span class="hljs-number">2</span>)<br>set(gca,<span class="hljs-string">&#x27;FontSize&#x27;</span>,<span class="hljs-number">15</span>)<br>axis tight<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-47600540cfeccac3187f6074ddb3b38b_1440w.jpg"></p><ol><li>坐标系的调整 实现坐标系的调整的命令是 axis 函数。 调用格式为：<code>axis([xmin,xmax,ymin,ymax,zmin,zmax])</code><br>坐标的最小值（ xmin,ymin,zmin）必须小于相应的最大值（ xmax,ymax,zmax）.</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab">subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>; <br>y=<span class="hljs-built_in">sin</span>(t); <br><span class="hljs-built_in">plot</span>(t,y)  <br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <br>t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>; <br>y=<span class="hljs-built_in">sin</span>(t); <br><span class="hljs-built_in">plot</span>(t,y) <br>axis([<span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>(t),<span class="hljs-built_in">min</span>(y),<span class="hljs-built_in">max</span>(y)]) <br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-32d2fb27b4646eda53b6535c9da2975c_1440w.jpg"></p><h2 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h2><p>绘图命令 plot3. 其调用格式为：<code>plot3(X1,Y1,Z1,s1,X2,Y2,Z2,s2,…)</code></p><p>参数的含义如下： X1, Y1,Z1：第一到三维数据，是尺寸相等的向量&#x2F;矩阵； s、s1、s2：是字符串，用来设置线型、颜色、数据点标记。 x、y、z 是向量时，plot3 命令的使用</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab">t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">8</span>*<span class="hljs-built_in">pi</span>; <br><span class="hljs-built_in">plot3</span>(<span class="hljs-built_in">sin</span>(t),<span class="hljs-built_in">cos</span>(t),t)<br>title(<span class="hljs-string">&#x27;绘制螺旋线&#x27;</span>) <br><span class="hljs-comment">%用命令 title 对图形主题进行标注 </span><br>xlabel(<span class="hljs-string">&#x27;sin(t)&#x27;</span>)         <br>ylabel(<span class="hljs-string">&#x27;cos(t)&#x27;</span>) <br>zlabel(<span class="hljs-string">&#x27;t&#x27;</span>)     <br><span class="hljs-comment">%命令 zlabel 用来指定 z 轴的数据名称 </span><br>grid on<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-5ad2d5beeb0449c505b2d5541a40f8fb_1440w.jpg"></p><p>x、y、z 都是矩阵时，plot3 命令的使用</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[X,Y]=<span class="hljs-built_in">meshgrid</span>(-<span class="hljs-built_in">pi</span>:<span class="hljs-number">0.1</span>:<span class="hljs-built_in">pi</span>);<br>Z=<span class="hljs-built_in">sin</span>(X)+<span class="hljs-built_in">cos</span>(Y); <br><span class="hljs-built_in">plot3</span>(X,Y,Z) <br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-cfa2d6fa9fb719522606ea0b56cb9259_1440w.jpg"></p><ul><li><p>三维曲面绘图命令 ：首先是平面网格点的生成 函数命令meshgrid 用来生成 x-y 平面上的网格点矩阵。 调用形式为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[X,Y]</span>=<span class="hljs-built_in">meshgrid</span>(<span class="hljs-attribute">x</span>,y)  <br><span class="hljs-selector-attr">[X,Y]</span>=<span class="hljs-built_in">meshgrid</span>(<span class="hljs-attribute">x</span>) 等价于[X,Y]=<span class="hljs-built_in">meshgrid</span>(x,x)<br></code></pre></td></tr></table></figure></li></ul><p>参数含义如下： <code>x：是区间[x0,xm]上分划的向量； y：是区间[y0,yn]上分划的向量； X，Y：输出变量矩阵，矩阵 X 的行向量都是向量 x，矩阵 Y 的列向量都是向量 y。 函数 meshgrid 将由两个向量决定的区域转换为对应的网格点矩阵</code><strong>。</strong></p><ul><li>三维网格命令 mesh 利用函数mesh生成网格曲面。 调用格式为：  <ol><li>mesh(X，Y，Z，C)：X、Y、Z、C 是同维数的矩阵，X、Y、Z 对应空间上的网格点，网格线颜色由C决定；  </li><li>mesh(X，Y，Z)：相当于上面的 C&#x3D;Z 的情况；  </li><li>mesh(x，y，Z，C)：x 和 y 是向量，Z 和 C 是同维数的矩阵，网格曲面的网格顶点是（ x(j)，y(i)，Z(i,j)），网格线的颜色由矩阵 C 决定；</li></ol></li><li>三维表面命令 surf 函数：surf 命令的调用格式与 mesh 相同。 利用三维网格表面命令 surf 绘制图形。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">z=peaks;      <span class="hljs-comment">%绘制山峰的图像，将函数值赋予变量z </span><br>surf(z)          <span class="hljs-comment">%对山峰的图像进行着色处理</span><br>shading interp  <span class="hljs-comment">%函数 shading 改变着色方式 </span><br></code></pre></td></tr></table></figure><ul><li>柱面的表达cylinder cylinder命令中，柱面的轴线定义为 z 轴，只要给出母线的描述就可完成一个柱面。 调用格式为：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[X,Y,Z] = cylinder(R,N)；<br>[X,Y,Z] = cylinder(R)：缺省值 N=<span class="hljs-number">20</span>； <br>[X,Y,Z] = cylinder：缺省值 N=<span class="hljs-number">20</span>，R=[<span class="hljs-number">1</span>，<span class="hljs-number">1</span>]。 <br></code></pre></td></tr></table></figure><p>R：是一描述柱面母线的向量； N：是旋转柱面上的分割线条数； [X,Y,Z] ：是返回的x,y,z坐标向量。 绘制一个柱面。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">t=<span class="hljs-built_in">pi</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">3</span>*<span class="hljs-built_in">pi</span>; <br>r=<span class="hljs-built_in">sin</span>(t)+t; <br>cylinder(r,<span class="hljs-number">30</span>) <br>shading interp<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-dba1b071db4491d54530e52051f1810d_1440w.jpg"></p><ul><li>球面的表达sphere 调用格式为：<br>[X,Y,Z]&#x3D;sphere(N)：产生一个（ N+1）×（ N+1）的矩阵，然后用函数 surf 命令绘制一个单位的球面，N 为设置分割线的条数；<br>[X,Y,Z] &#x3D; sphere：缺省 N &#x3D; 20。</li></ul><p>画一个球面。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[X,Y,Z]=sphere;<br>surf(X,Y,Z)<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-fccddd4fbbe9082cacc922c09d2b8167_1440w.jpg"></p><h2 id="图像标注修饰"><a href="#图像标注修饰" class="headerlink" title="图像标注修饰"></a><strong>图像标注修饰</strong></h2><ul><li>图形标注：坐标轴和图形标题标注; 标注坐标轴 x、y 和 z 的命令函数为 <code>xlabel、ylabel 和 zlabel</code> 调用格式为：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">xlabel(<span class="hljs-string">&#x27;text&#x27;</span>) <br>xlabel(<span class="hljs-string">&#x27;text&#x27;</span>,<span class="hljs-string">&#x27;Property1&#x27;</span>,PropertyValue1,<span class="hljs-string">&#x27;Property2&#x27;</span>,PropertyValue2,...)<br></code></pre></td></tr></table></figure><p>图例的标注 legend命令实现不同图例的说明。其调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">legend</span>(string1,string2,string3, ...)   <br><span class="hljs-built_in">legend</span>(string1,string2,string3,...,Pos)   <br></code></pre></td></tr></table></figure><p>按顺序把字符串添加到相应的曲线线型符号之后；Pos对图例的位置作出设置和调整：</p><p><code>0 = 自动把图例置于最佳位置（ 和图中曲线重复最少）</code>； <code>1 = 置于图形窗口的右上角（ 缺省值）</code>； <code>2 = 置于图形窗口的左上角</code>； <code>3 = 置于图形窗口的左下角</code>； <code>4 = 置于图形窗口的右下角</code>； <code>-1 = 置于图形窗口的右侧（ 外部）</code>。</p><ul><li>控制分格线 对二维和三维图形都适用。 有三种用法：<code>grid on</code>：打开分格线控制开关，以后绘制的图形都带有分格线； <code>grid off</code>：关闭分格线控制开关，以后绘制的图形都不带分格线； <code>grid</code>：用于实现分格线绘制切换。绘制图形，并用函数 <code>xlabel、title 和 legend</code> 命令进行标注。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">t=<span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>; <br>y=<span class="hljs-built_in">sin</span>(t); <br>y1=<span class="hljs-built_in">cos</span>(t); <br><span class="hljs-built_in">plot</span>(t,y,<span class="hljs-string">&#x27;:&#x27;</span>,t,y1,<span class="hljs-string">&#x27;r*&#x27;</span>) <br>xlabel(<span class="hljs-string">&#x27;x 轴  (0--4\pi)&#x27;</span>,<span class="hljs-string">&#x27;fontsize&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;fontweight&#x27;</span>,<span class="hljs-string">&#x27;bold&#x27;</span>) <br>ylabel(<span class="hljs-string">&#x27;y 轴&#x27;</span>,<span class="hljs-string">&#x27;fontsize&#x27;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;fontweight&#x27;</span>,<span class="hljs-string">&#x27;bold&#x27;</span>) <br>title(<span class="hljs-string">&#x27;绘制正弦波和余弦波      Pos=1&#x27;</span>,<span class="hljs-string">&#x27;fontsize&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;fontweight&#x27;</span>,<span class="hljs-string">&#x27;bold&#x27;</span>,<span class="hljs-string">&#x27;fontangle&#x27;</span>,<span class="hljs-string">&#x27;italic&#x27;</span>) <br>text(<span class="hljs-built_in">pi</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;\leftarrowsin(\pi)=0&#x27;</span>) <br>text(<span class="hljs-built_in">pi</span>,<span class="hljs-number">-1</span>,<span class="hljs-string">&#x27;\leftarrowcos(\pi)=-1&#x27;</span>)<br>text(<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>,<span class="hljs-number">0.9</span>,[<span class="hljs-string">&#x27;\uparrowsin(\pi/2)=&#x27;</span>,num2str(<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>))]) <br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;正弦波&#x27;</span>,<span class="hljs-string">&#x27;余弦波&#x27;</span>) <br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>) <br><span class="hljs-built_in">plot</span>(t,y,<span class="hljs-string">&#x27;:&#x27;</span>,t,y1,<span class="hljs-string">&#x27;r*&#x27;</span>) <br>title(<span class="hljs-string">&#x27;绘制正弦波和余弦波    Pos=0&#x27;</span>,<span class="hljs-string">&#x27;fontsize&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;fontweight&#x27;</span>,<span class="hljs-string">&#x27;bold&#x27;</span>,<span class="hljs-string">&#x27;fontangle&#x27;</span>,<span class="hljs-string">&#x27;italic&#x27;</span>) <br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;正弦波&#x27;</span>,<span class="hljs-string">&#x27;余弦波&#x27;</span>,<span class="hljs-number">0</span>) <br>grid on <br><span class="hljs-built_in">figure</span>(<span class="hljs-number">3</span>) <br><span class="hljs-built_in">plot</span>(t,y,<span class="hljs-string">&#x27;:&#x27;</span>,t,y1,<span class="hljs-string">&#x27;r*&#x27;</span>) <br>title(<span class="hljs-string">&#x27;绘制正弦波和余弦波  Pos=-1&#x27;</span>,<span class="hljs-string">&#x27;fontsize&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;fontweight&#x27;</span>,<span class="hljs-string">&#x27;bold&#x27;</span>,<span class="hljs-string">&#x27;fontangle&#x27;</span>,<span class="hljs-string">&#x27;italic&#x27;</span>) <br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-3012da6903960352c21fe2af8ce61dd3_1440w.jpg"></p><h1 id="matlab符号运算"><a href="#matlab符号运算" class="headerlink" title="matlab符号运算"></a>matlab符号运算</h1><h2 id="符号对象的建立：sym-和-syms"><a href="#符号对象的建立：sym-和-syms" class="headerlink" title="符号对象的建立：sym 和 syms"></a>符号对象的建立：<code>sym 和 syms</code></h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">符号变量 = sym(A)<br></code></pre></td></tr></table></figure><p><code>syms</code> 符号变量1 符号变量2 … 符号变量n</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms a b c<br></code></pre></td></tr></table></figure><p>查找符号表达式中的符号变量：<code>findsym(expr)</code> %按字母顺序列出符号表达式 expr 中的所有符号变量；findsym(expr, N)%按顺序列出 expr 中离 x 最近的 N 个符号变量；用给定的数据替换符号表达式中的指定的符号变量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">subs(f,x,a) <br></code></pre></td></tr></table></figure><p>用 a 替换字符函数 f 中的字符变量 x</p><ul><li>因式分解</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x;<br>f=x^<span class="hljs-number">6</span>+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">factor</span>(f)<br></code></pre></td></tr></table></figure><ul><li>函数展开</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x; <br>f=(x+<span class="hljs-number">1</span>)^<span class="hljs-number">6</span>;<br>expand(f)<br></code></pre></td></tr></table></figure><ul><li>合并同类项</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">collect(f,v) %按指定变量 v 进行合并<br></code></pre></td></tr></table></figure><ul><li>函数简化</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[How,y]=simple(f):   y 为 f  的最简短形式，How 中记录的为简化过程中使用的方法。<br></code></pre></td></tr></table></figure><ul><li>计算极限</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">limit(f,x,a): 计算<br>limit(f,a): 当默认变量趋向于 a 时的极限<br>limit(f): 计算 a=<span class="hljs-number">0</span> 时的极限<br>limit(f,x,a,<span class="hljs-string">&#x27;right&#x27;</span>): 计算右极限<br>limit(f,x,a,<span class="hljs-string">&#x27;left&#x27;</span>): 计算左极限<br></code></pre></td></tr></table></figure><ul><li>计算导数</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">g=diff(f,v)：求符号表达式  f 关于 v 的导数<br>g=diff(f)：求符号表达式  f 关于默认变量的导数<br>g=diff(f,v,n)：求  f 关于 v 的 n 阶导数<br></code></pre></td></tr></table></figure><ul><li>计算积分</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">int(f,v,a,b): 计算定积分<br>int(f,a,b): 计算关于默认变量的定积分<br>int(f,v): 计算不定积分<br>int(f): 计算关于默认变量的不定积分<br></code></pre></td></tr></table></figure><ul><li>符号求和</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">symsum(f,v,a,b)<br></code></pre></td></tr></table></figure><ul><li>代数方程求解 <code>solve(f,v)</code>：求方程关于指定自变量的解</li><li>微分方程求解</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">y=dsolve(<span class="hljs-string">&#x27;eq1&#x27;</span>,<span class="hljs-string">&#x27;eq2&#x27;</span>, ... ,<span class="hljs-string">&#x27;cond1&#x27;</span>,<span class="hljs-string">&#x27;cond2&#x27;</span>, ... ,<span class="hljs-string">&#x27;v&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中 y 为输出的解， eq1、eq2、. . . 为微分方程，cond1、cond2、…为初值条件， v 为自变量</p><h1 id="matlab-程序设计"><a href="#matlab-程序设计" class="headerlink" title="matlab 程序设计"></a>matlab 程序设计</h1><h2 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h2><p><code>用MATLAB语言编写的程序，称为M文件</code>。 M文件有两类：</p><p><code>命令文件和函数文件。</code> 命令文件：没有输入参数，也不返回输出参数。</p><p>函数文件：可以输入参数，也可返回输出参数。</p><ul><li><code>input</code>函数： 用于向计算机输入一个参数;</li><li><code>pause</code>函数：暂停程序的执行;</li><li><code>disp</code>函数：命令窗口输出函数。</li></ul><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p><strong>- for语句：</strong>格式：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> 循环变量=表达式<span class="hljs-number">1</span>:表达式<span class="hljs-number">2</span>:表达式<span class="hljs-number">3</span><br>    循环体语句<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>注：其中表达式1的值为循环变量的初值，表达式2的值为步长，表达式3的值为循环变量的终值。步长为1时，表达式2可以省略</p><ul><li>while语句: 格式为：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">while</span> (条件)<br>    循环体语句<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是一起执行任务的一组语句。在MATLAB中，函数是在单独的文件中定义的。文件名和函数名应该相同。</p><p>函数在其自己的工作空间（也称为本地工作空间）中对变量进行操作，与在MATLAB命令提示符下访问的工作空间（称为基本工作空间）不同。</p><p>函数可以接受多个输入参数，并且可以返回多个输出参数。</p><p>函数语句的语法是-</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">function</span> [<span class="hljs-keyword">out</span><span class="hljs-number">1</span>,<span class="hljs-keyword">out</span><span class="hljs-number">2</span>, ..., outN] = myfun(<span class="hljs-keyword">in</span><span class="hljs-number">1</span>,<span class="hljs-keyword">in</span><span class="hljs-number">2</span>,<span class="hljs-keyword">in</span><span class="hljs-number">3</span>, ..., inN)<br></code></pre></td></tr></table></figure><p>注：<code>其中函数名的命名规则与变量名相同。输入形参为函数的输入参数，输出形参为函数的输出参数。当输出形参多于1个时，则应该用方括号括起来</code>。</p><p>编写函数文件求小于任意自然数n的Fibonacci数列各项。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>=<span class="hljs-title">ffib</span><span class="hljs-params">(n)</span></span><br>   <span class="hljs-comment">%用于求Fibonacci数列的函数文件</span><br>   f=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>];<br>   <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span> f(<span class="hljs-built_in">i</span>)+f(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>)&lt;n<br>      f(<span class="hljs-built_in">i</span>+<span class="hljs-number">2</span>)=f(<span class="hljs-built_in">i</span>)+f(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br>      <span class="hljs-built_in">i</span>=<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>函数调用： <code>[输出实参表]=函数名(输入实参表)</code></li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数就像传统编程语言中的内联函数一样，是在单个MATLAB语句中定义的。它由一个MATLAB表达式以及任意数量的输入和输出参数组成。</p><p>您可以直接在MATLAB命令行或在函数或脚本中定义匿名函数。</p><p>这样，您可以创建简单的功能，而不必为其创建文件。</p><p>从表达式创建匿名函数的语法是</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">f</span> = @(arglist)expression<br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在此示例中，我们将编写一个名为power的匿名函数，该函数将两个数字作为输入，并将第一个数字提高为第二个数字的幂。</p><p>创建一个脚本文件并在其中键入以下代码-</p><p>示例</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">power = @(x, n) x.^n;<br>result1 = power(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>)<br>result2 = power(<span class="hljs-number">49</span>, <span class="hljs-number">0.5</span>)<br>result3 = power(<span class="hljs-number">10</span>, <span class="hljs-number">-10</span>)<br>result4 = power (<span class="hljs-number">4.5</span>, <span class="hljs-number">1.5</span>)<br></code></pre></td></tr></table></figure><p>运行文件时，它显示-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">result1 =  <span class="hljs-number">343</span><br>result2 =  <span class="hljs-number">7</span><br>result3 =  <span class="hljs-number">1.0000e-10</span><br>result4 =  <span class="hljs-number">9.5459</span><br></code></pre></td></tr></table></figure><h2 id="主和子函数"><a href="#主和子函数" class="headerlink" title="主和子函数"></a>主和子函数</h2><p><strong>必须在文件中定义除匿名函数以外的任何函数</strong>。每个函数文件都包含一个首先出现的必需主函数，以及在主函数之后并由其使用的任意数量的可选子函数。</p><p>可以从定义主文件的文件外部（从命令行或其他函数）调用主函数，但是不能从命令行或其他函数在功能文件外部调用子函数。</p><p>子函数仅对主函数和定义它们的函数文件中的其他子函数可见。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>让我们写一个名为quadratic的函数来计算一个二次方程的根。该函数包含三个输入：二次系数、线性系数和常数项。它将回归根。</p><p>函数文件quadratic.m将包含主函数quadratic和子函数disc，后者计算判别式。</p><p>创建一个函数文件 quadratic.m 并在其中输入以下代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[x1,x2]</span> = <span class="hljs-title">quadratic</span><span class="hljs-params">(a,b,c)</span></span><br><br><span class="hljs-comment">%此函数返回</span><br><span class="hljs-comment">%二次方程。</span><br><span class="hljs-comment">%它需要3个输入参数</span><br><span class="hljs-comment">%x2，x和</span><br><span class="hljs-comment">%常数项</span><br><span class="hljs-comment">%它返回根</span><br>d = disc(a,b,c); <br>x1 = (-b + d) / (<span class="hljs-number">2</span>*a);<br>x2 = (-b - d) / (<span class="hljs-number">2</span>*a);<br><span class="hljs-keyword">end</span>   <span class="hljs-comment">% end of quadratic</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dis</span> = <span class="hljs-title">disc</span><span class="hljs-params">(a,b,c)</span> </span><br><span class="hljs-comment">%函数计算判别式</span><br>dis = <span class="hljs-built_in">sqrt</span>(b^<span class="hljs-number">2</span> - <span class="hljs-number">4</span>*a*c);<br><span class="hljs-keyword">end</span>   <span class="hljs-comment">% end of sub-function</span><br></code></pre></td></tr></table></figure><p>您可以从命令提示符处调用上述功能，如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">quadratic</span>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.7321</span><br></code></pre></td></tr></table></figure><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>您可以在另一个函数的主体内定义函数。这些称为嵌套函数。嵌套函数包含任何其他函数的任何或所有组件。</p><p>嵌套函数在另一个函数的范围内定义，它们共享对包含函数的工作区的访问。</p><p>嵌套函数遵循以下语法-</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">function</span> x = A(<span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span>)<br><span class="hljs-symbol">...</span><br>B(<span class="hljs-built_in">p2</span>)<br>   <span class="hljs-meta">function</span> y = B(<span class="hljs-built_in">p3</span>)<br>   ...<br>   <span class="hljs-meta">end</span><br><span class="hljs-symbol">...</span><br><span class="hljs-symbol">end</span><br></code></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>让我们重写前面实例中的<em>quadratic</em>函数，不过，这次disc函数将是一个嵌套函数。</p><p>创建一个函数文件<em>quadratic2.m，</em>并在其中输入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[x1,x2]</span> = <span class="hljs-title">quadratic2</span><span class="hljs-params">(a,b,c)</span></span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disc</span>  %嵌套函数</span><br>d = <span class="hljs-built_in">sqrt</span>(b^<span class="hljs-number">2</span> - <span class="hljs-number">4</span>*a*c);<br><span class="hljs-keyword">end</span>   <span class="hljs-comment">% 结束函数disc</span><br><br>disc;<br>x1 = (-b + d) / (<span class="hljs-number">2</span>*a);<br>x2 = (-b - d) / (<span class="hljs-number">2</span>*a);<br><span class="hljs-keyword">end</span>   <span class="hljs-comment">%结束函数 quadratic2</span><br></code></pre></td></tr></table></figure><p>您可以从命令提示符处调用上述函数，如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">quadratic2</span>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span>  <span class="hljs-number">0.73205</span><br></code></pre></td></tr></table></figure><h2 id="私有函数"><a href="#私有函数" class="headerlink" title="私有函数"></a>私有函数</h2><p>私有函数是仅对有限的一组其他函数可见的主函数。如果不想公开函数function(s)的实现，可以将它们创建为私有函数。</p><p>私有函数位于具有特殊名称 Private 的子文件夹中。</p><p>它们仅对父文件夹中的函数可见。</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>让我们重写<em>quadratic</em>函数。不过，这一次，disc函数计算判别式，将是一个私有函数。</p><p>在工作目录文件夹中创建一个名为 private 的子文件夹，在其中存储以下函数文件 disc.m</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dis</span> = <span class="hljs-title">disc</span><span class="hljs-params">(a,b,c)</span> </span><br><span class="hljs-comment">%函数计算判别式</span><br>dis = <span class="hljs-built_in">sqrt</span>(b^<span class="hljs-number">2</span> - <span class="hljs-number">4</span>*a*c);<br><span class="hljs-keyword">end</span>      <span class="hljs-comment">%子函数结束</span><br></code></pre></td></tr></table></figure><p>在您的工作目录中创建一个函数 quadratic3.m ，并在其中输入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[x1,x2]</span> = <span class="hljs-title">quadratic3</span><span class="hljs-params">(a,b,c)</span></span><br><br><span class="hljs-comment">% 这个函数返回</span><br><span class="hljs-comment">% 一元二次方程。</span><br>它需要<span class="hljs-number">3</span>个输入参数<br><span class="hljs-comment">% 它们是 x2，x 和</span><br><span class="hljs-comment">% 常数项</span><br><span class="hljs-comment">% 它返回根</span><br>d = disc(a,b,c); <br><br>x1 = (-b + d) / (<span class="hljs-number">2</span>*a);<br>x2 = (-b - d) / (<span class="hljs-number">2</span>*a);<br><span class="hljs-keyword">end</span>      <span class="hljs-comment">%结束 quadratic3</span><br></code></pre></td></tr></table></figure><p>您可以从命令提示符处调用上述函数，如下所示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">quadratic3</span>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>MATLAB将执行上述语句并返回以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ans</span> <span class="hljs-operator">=</span>  <span class="hljs-number">0.73205</span><br></code></pre></td></tr></table></figure><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量可以由多个函数共享。为此，您需要在所有函数中将变量声明为全局变量。</p><p>如果要从基本工作空间访问该变量，请在命令行中声明该变量。</p><p>全局声明必须在变量实际在函数中使用之前发生。最好将大写字母用作全局变量的名称，以将其与其他变量区分开。</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>让我们创建一个名为average.m的函数文件，并在其中输入以下代码-</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scilab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">avg</span> = <span class="hljs-title">average</span><span class="hljs-params">(nums)</span></span><br><span class="hljs-keyword">global</span> TOTAL<br>avg = <span class="hljs-built_in">sum</span>(nums)/TOTAL;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>创建一个脚本文件并在其中键入以下代码-</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">global</span> TOTAL;<br><span class="hljs-attribute">TOTAL</span> = <span class="hljs-number">10</span>;<br><span class="hljs-attribute">n</span> = [<span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">25</span>, <span class="hljs-number">45</span>, <span class="hljs-number">33</span>, <span class="hljs-number">19</span>, <span class="hljs-number">40</span>, <span class="hljs-number">34</span>, <span class="hljs-number">38</span>, <span class="hljs-number">42</span>];<br><span class="hljs-attribute">av</span> = average(n)<br></code></pre></td></tr></table></figure><p>运行文件时，它将显示以下结果-</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">av</span> <span class="hljs-operator">=</span>  <span class="hljs-number">35.500</span><br></code></pre></td></tr></table></figure><h1 id="matlab数据"><a href="#matlab数据" class="headerlink" title="matlab数据"></a>matlab数据</h1><h2 id="MATLAB-数据导入（ImportData）"><a href="#MATLAB-数据导入（ImportData）" class="headerlink" title="MATLAB 数据导入（ImportData）"></a>MATLAB 数据导入（ImportData）</h2><p>在MATLAB中导入数据意味着从外部文件加载数据。该<strong>importdata</strong>功能允许加载不同格式的各种数据文件。它具有以下五种形式-</p><table><thead><tr><th align="left">序号</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">*<em>A &#x3D; importdata(filename)*<em>从</em>filename*表示的</em>文件*中将数据加载到数组A中。</td></tr><tr><td align="left">2</td><td align="center">**A &#x3D; importdata(‘-pastespecial’)**从系统剪贴板而不是文件加载数据。</td></tr><tr><td align="left">3</td><td align="center">**A &#x3D; importdata(___, delimiterIn)**将 delimiterIn 解释为 ASCII 文件、文件名或剪贴板数据中的列分隔符。可以对上述语法中的任何输入参数使用 delimiterIn。</td></tr><tr><td align="left">4</td><td align="center">**A &#x3D; importdata(___, delimiterIn, headerlinesIn)*<em>从ASCII文件，文件名或剪贴板中加载数据，并从行</em>headerlinesIn + 1*开始读取数字数据。</td></tr><tr><td align="left">5</td><td align="center">**[A, delimiterOut, headerlinesOut] &#x3D; importdata(___)**使用前面语法中的任何输入参数，返回delimiterOut中输入ASCII文件的检测到的分隔符字符和headerlinesOut中检测到的头行数。</td></tr></tbody></table><blockquote><p>默认情况下，Octave不支持该*importdata()*功能，因此您必须搜索并安装此软件包才能使以下示例适用于Octave安装。</p></blockquote><h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><p>让我们加载并显示图像文件。创建一个脚本文件并在其中键入以下代码-</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">filename</span> = <span class="hljs-string">&#x27;smile.jpg&#x27;</span>;<br>A = importdata(<span class="hljs-keyword">filename</span>);<br>image(A);<br></code></pre></td></tr></table></figure><p>运行文件时，MATLAB将显示图像文件。但是，必须将其存储在当前目录中。</p><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><p>在此示例中，我们导入一个文本文件并指定Delimiter和Column Header。让我们创建一个以空格分隔的ASCII文件，其中包含标题为<em>weeklydata.txt的</em>列标题。</p><p>我们的文本文件weeklydata.txt看起来像这样-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SunDay</span>  MonDay  TuesDay  WednesDay  ThursDay  FriDay  SaturDay<br><span class="hljs-attribute">95</span>.<span class="hljs-number">01</span>   <span class="hljs-number">76</span>.<span class="hljs-number">21</span>   <span class="hljs-number">61</span>.<span class="hljs-number">54</span>    <span class="hljs-number">40</span>.<span class="hljs-number">57</span>       <span class="hljs-number">55</span>.<span class="hljs-number">79</span>    <span class="hljs-number">70</span>.<span class="hljs-number">28</span>   <span class="hljs-number">81</span>.<span class="hljs-number">53</span><br><span class="hljs-attribute">73</span>.<span class="hljs-number">11</span>   <span class="hljs-number">45</span>.<span class="hljs-number">65</span>   <span class="hljs-number">79</span>.<span class="hljs-number">19</span>    <span class="hljs-number">93</span>.<span class="hljs-number">55</span>       <span class="hljs-number">75</span>.<span class="hljs-number">29</span>    <span class="hljs-number">69</span>.<span class="hljs-number">87</span>   <span class="hljs-number">74</span>.<span class="hljs-number">68</span><br><span class="hljs-attribute">60</span>.<span class="hljs-number">68</span>   <span class="hljs-number">41</span>.<span class="hljs-number">85</span>   <span class="hljs-number">92</span>.<span class="hljs-number">18</span>    <span class="hljs-number">91</span>.<span class="hljs-number">69</span>       <span class="hljs-number">81</span>.<span class="hljs-number">32</span>    <span class="hljs-number">90</span>.<span class="hljs-number">38</span>   <span class="hljs-number">74</span>.<span class="hljs-number">51</span><br><span class="hljs-attribute">48</span>.<span class="hljs-number">60</span>   <span class="hljs-number">82</span>.<span class="hljs-number">14</span>   <span class="hljs-number">73</span>.<span class="hljs-number">82</span>    <span class="hljs-number">41</span>.<span class="hljs-number">03</span>       <span class="hljs-number">0</span>.<span class="hljs-number">99</span>     <span class="hljs-number">67</span>.<span class="hljs-number">22</span>   <span class="hljs-number">93</span>.<span class="hljs-number">18</span><br><span class="hljs-attribute">89</span>.<span class="hljs-number">13</span>   <span class="hljs-number">44</span>.<span class="hljs-number">47</span>   <span class="hljs-number">57</span>.<span class="hljs-number">63</span>    <span class="hljs-number">89</span>.<span class="hljs-number">36</span>       <span class="hljs-number">13</span>.<span class="hljs-number">89</span>    <span class="hljs-number">19</span>.<span class="hljs-number">88</span>   <span class="hljs-number">46</span>.<span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>创建一个脚本文件并在其中键入以下代码-</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;weeklydata.txt&#x27;</span>;<br>delimiterIn = <span class="hljs-string">&#x27; &#x27;</span>;<br>headerlinesIn = <span class="hljs-number">1</span>;<br>A = importdata(filename,delimiterIn,headerlinesIn);<br><br><span class="hljs-comment">% View data</span><br><span class="hljs-keyword">for</span> k = [<span class="hljs-number">1</span>:<span class="hljs-number">7</span>]<br>   <span class="hljs-built_in">disp</span>(A.colheaders&#123;<span class="hljs-number">1</span>, k&#125;)<br>   <span class="hljs-built_in">disp</span>(A.data(:, k))<br>   <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SunDay</span><br>   <span class="hljs-attribute">95</span>.<span class="hljs-number">0100</span><br>   <span class="hljs-attribute">73</span>.<span class="hljs-number">1100</span><br>   <span class="hljs-attribute">60</span>.<span class="hljs-number">6800</span><br>   <span class="hljs-attribute">48</span>.<span class="hljs-number">6000</span><br>   <span class="hljs-attribute">89</span>.<span class="hljs-number">1300</span><br> <br><span class="hljs-attribute">MonDay</span><br>   <span class="hljs-attribute">76</span>.<span class="hljs-number">2100</span><br>   <span class="hljs-attribute">45</span>.<span class="hljs-number">6500</span><br>   <span class="hljs-attribute">41</span>.<span class="hljs-number">8500</span><br>   <span class="hljs-attribute">82</span>.<span class="hljs-number">1400</span><br>   <span class="hljs-attribute">44</span>.<span class="hljs-number">4700</span><br> <br><span class="hljs-attribute">TuesDay</span><br>   <span class="hljs-attribute">61</span>.<span class="hljs-number">5400</span><br>   <span class="hljs-attribute">79</span>.<span class="hljs-number">1900</span><br>   <span class="hljs-attribute">92</span>.<span class="hljs-number">1800</span><br>   <span class="hljs-attribute">73</span>.<span class="hljs-number">8200</span><br>   <span class="hljs-attribute">57</span>.<span class="hljs-number">6300</span><br><br><span class="hljs-attribute">WednesDay</span><br>   <span class="hljs-attribute">40</span>.<span class="hljs-number">5700</span><br>   <span class="hljs-attribute">93</span>.<span class="hljs-number">5500</span><br>   <span class="hljs-attribute">91</span>.<span class="hljs-number">6900</span><br>   <span class="hljs-attribute">41</span>.<span class="hljs-number">0300</span><br>   <span class="hljs-attribute">89</span>.<span class="hljs-number">3600</span><br> <br><span class="hljs-attribute">ThursDay</span><br>   <span class="hljs-attribute">55</span>.<span class="hljs-number">7900</span><br>   <span class="hljs-attribute">75</span>.<span class="hljs-number">2900</span><br>   <span class="hljs-attribute">81</span>.<span class="hljs-number">3200</span><br>   <span class="hljs-attribute">0</span>.<span class="hljs-number">9900</span><br>   <span class="hljs-attribute">13</span>.<span class="hljs-number">8900</span><br> <br><span class="hljs-attribute">FriDay</span><br>   <span class="hljs-attribute">70</span>.<span class="hljs-number">2800</span><br>   <span class="hljs-attribute">69</span>.<span class="hljs-number">8700</span><br>   <span class="hljs-attribute">90</span>.<span class="hljs-number">3800</span><br>   <span class="hljs-attribute">67</span>.<span class="hljs-number">2200</span><br>   <span class="hljs-attribute">19</span>.<span class="hljs-number">8800</span><br><br><span class="hljs-attribute">SaturDay</span><br>   <span class="hljs-attribute">81</span>.<span class="hljs-number">5300</span><br>   <span class="hljs-attribute">74</span>.<span class="hljs-number">6800</span><br>   <span class="hljs-attribute">74</span>.<span class="hljs-number">5100</span><br>   <span class="hljs-attribute">93</span>.<span class="hljs-number">1800</span><br>   <span class="hljs-attribute">46</span>.<span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><h3 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h3><p>在此示例中，让我们从剪贴板导入数据。</p><p>将以下行复制到剪贴板-</p><p><strong>Mathematics is simple</strong></p><p>创建一个脚本文件并输入以下代码-</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">A</span> = importdata(<span class="hljs-string">&#x27;-pastespecial&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">A = <br>   <span class="hljs-symbol">&#x27;Mathematics</span> <span class="hljs-keyword">is</span> simple&#x27;<br></code></pre></td></tr></table></figure><h2 id="底层文件I-O"><a href="#底层文件I-O" class="headerlink" title="底层文件I &#x2F; O"></a>底层文件I &#x2F; O</h2><p>importdata函数是一个高级函数。MATLAB中的底层文件I&#x2F;O函数允许对文件的读写数据进行最大程度的控制。但是，这些函数需要更详细的文件信息才能有效地工作。</p><p>MATLAB为字节或字符级别的读写操作提供以下函数-</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">fclose</td><td align="center">关闭一个或所有打开的文件</td></tr><tr><td align="center">feof</td><td align="center">文件结尾测试</td></tr><tr><td align="center">ferror</td><td align="center">有关文件I&#x2F;O错误的信息</td></tr><tr><td align="center">fgetl</td><td align="center">从文件中读取行，删除换行符</td></tr><tr><td align="center">fgets</td><td align="center">从文件中读取行，保留换行符</td></tr><tr><td align="center">fopen</td><td align="center">打开文件，或获取有关打开文件的信息</td></tr><tr><td align="center">fprintf</td><td align="center">将数据写入文本文件</td></tr><tr><td align="center">fread</td><td align="center">从二进制文件读取数据</td></tr><tr><td align="center">frewind</td><td align="center">将文件位置指示器移动到打开文件的开头</td></tr><tr><td align="center">fscanf</td><td align="center">从文本文件读取数据</td></tr><tr><td align="center">fseek</td><td align="center">移动到文件中的指定位置</td></tr><tr><td align="center">ftell</td><td align="center">在打开文件中的位置</td></tr><tr><td align="center">fwrite</td><td align="center">将数据写入二进制文件</td></tr></tbody></table><h3 id="导入具有底层I-O的文本数据文件"><a href="#导入具有底层I-O的文本数据文件" class="headerlink" title="导入具有底层I &#x2F; O的文本数据文件"></a>导入具有底层I &#x2F; O的文本数据文件</h3><p>MATLAB提供以下功能用于文本数据文件的底层导入-</p><ul><li><strong>fscanf</strong>函数读取文本或ASCII文件中的格式化数据。</li><li><strong>fgetl</strong>和<strong>fgets</strong>的时间，其中，一个换行字符的每一行分离功能读取的文件的一行。</li><li><strong>fread</strong>函数读取字节或位级别的数据流。</li></ul><h2 id="MATLAB-数据输出"><a href="#MATLAB-数据输出" class="headerlink" title="MATLAB 数据输出"></a>MATLAB 数据输出</h2><p>数据导出(或输出)在 MATLAB 的意思是写入文件。MATLAB 允许您在另一个读取 ASCII 文件的应用程序中使用您的数据。为此，MATLAB 提供了几个数据导出选项。</p><p>您可以创建以下类型的文件-</p><ul><li>数组中的矩形、分隔的ASCII数据文件。</li><li>击键的日记（或日志）文件和结果文本输出。</li><li>使用底层函数（如fprintf）的专用ASCII文件。</li><li>MEX文件，用于访问以特定文本文件格式写入的C &#x2F; C ++或Fortran例程。</li></ul><p>除此之外，您还可以将数据导出到电子表格。</p><p>有两种方法可以将数字数组导出为定界的ASCII数据文件-</p><ul><li>使用<strong>save</strong>函数并指定**-ascii**限定符</li><li>使用<strong>dlmwrite</strong>函数</li></ul><p>使用save函数的语法是-</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">save</span> my_data.<span class="hljs-keyword">out</span> num_array -ascii<br></code></pre></td></tr></table></figure><p>其中，<em>my_data.out</em>是创建的带分隔符的ASCII数据文件，<em>num_array</em>是数字数组，并且  <strong>−ascii</strong>是说明符。</p><p>使用<strong>dlmwrite</strong>函数的语法是-</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dlmwrite</span><span class="hljs-params">(<span class="hljs-string">&#x27;my_data.out&#x27;</span>, num_array, <span class="hljs-string">&#x27;dlm_char&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>其中，<em>my_data.out</em>是创建的带分隔符的ASCII数据文件，<em>num_array</em>是数字数组，  <em>dlm_char</em>是分隔符。</p><h3 id="在线示例"><a href="#在线示例" class="headerlink" title="在线示例"></a>在线示例</h3><p>下面的示例演示了该概念。创建一个脚本文件并输入以下代码-</p><p>示例</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">num_array = [ <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> ; <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>; <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span>];<br>save array_data1.<span class="hljs-keyword">out</span> num_array -ascii;<br><span class="hljs-keyword">type</span> array_data1.<span class="hljs-keyword">out</span><br>dlmwrite(<span class="hljs-string">&#x27;array_data2.out&#x27;</span>, num_array, <span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">type</span> array_data2.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">1</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">2</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">3</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">4</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span><br>   <span class="hljs-attribute">4</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">5</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">6</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">7</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span><br>   <span class="hljs-attribute">7</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">8</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">9</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0000000</span>e+<span class="hljs-number">00</span><br><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>请注意，save -ascii命令和dlmwrite函数不适用于作为输入的单元格数组。要从单元格数组的内容创建定界的ASCII文件，您可以</p><ul><li>使用<strong>cell2mat</strong>函数将单元格数组转换为矩阵</li><li>或使用底层文件I &#x2F; O功能导出单元数组。</li></ul><p>如果使用<strong>save</strong>函数将字符数组写入ASCII文件，则它将等效于字符的ASCII写入文件。</p><p>例如，让我们将单词“ hello”写到文件中-</p><p>示例</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">h = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>savetextdata.outh -ascii<br><span class="hljs-keyword">type</span> textdata.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>MATLAB执行以上语句并显示以下结果。这是8位ASCII格式的字符串“ hello”的字符。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">0400000</span>e+<span class="hljs-number">02</span>   <span class="hljs-number">1</span>.<span class="hljs-number">0100000</span>e+<span class="hljs-number">02</span>   <span class="hljs-number">1</span>.<span class="hljs-number">0800000</span>e+<span class="hljs-number">02</span>   <span class="hljs-number">1</span>.<span class="hljs-number">0800000</span>e+<span class="hljs-number">02</span>   <span class="hljs-number">1</span>.<span class="hljs-number">1100000</span>e+<span class="hljs-number">02</span><br></code></pre></td></tr></table></figure><h3 id="写入日记文件"><a href="#写入日记文件" class="headerlink" title="写入日记文件"></a>写入日记文件</h3><p>日记文件是您的MATLAB会话的活动日志。日记功能可以在磁盘文件中创建会话的精确副本，但不包括图形。</p><p>要打开日记函数，请输入-</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">diary</span><br></code></pre></td></tr></table></figure><p>（可选）您可以提供日志文件的名称，例如-</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">diary logdata.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>关闭日记函数-</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">diary</span> <span class="hljs-literal">off</span><br></code></pre></td></tr></table></figure><p>您可以在文本编辑器中打开日记文件。</p><h3 id="使用底层I-O将数据导出到文本数据文件"><a href="#使用底层I-O将数据导出到文本数据文件" class="headerlink" title="使用底层I &#x2F; O将数据导出到文本数据文件"></a>使用底层I &#x2F; O将数据导出到文本数据文件</h3><p>到目前为止，我们已经导出了数字数组。但是，您可能需要创建其他文本文件，包括数字和字符数据的组合，非矩形输出文件或具有非ASCII编码方案的文件。为此，MATLAB提供了底层<strong>fprintf</strong>函数。</p><p>与在底层I &#x2F; O文件活动中一样，在导出之前，您需要使用<strong>fopen</strong>函数打开或创建文件并获取文件标识符。默认情况下，fopen打开文件以进行只读访问。您应指定写入或追加的权限，例如“ w”或“ a”。</p><p>处理完文件后，需要使用**fclose(fid)**函数将其关闭。</p><p>以下示例演示了概念-</p><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p>创建一个脚本文件并在其中键入以下代码-</p><p>示例</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">%创建一个包含两行的矩阵y<br>x = <span class="hljs-number">0</span>:<span class="hljs-number">10</span>:<span class="hljs-number">100</span>;<br>y = [x; <span class="hljs-keyword">log</span>(x)];<br> <br>%打开文件进行写入<br>fid = <span class="hljs-keyword">fopen</span>(<span class="hljs-string">&#x27;logtable.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>);<br> <br>%表格标题<br>fprintf(fid, <span class="hljs-string">&#x27;Log     Function\n\n&#x27;</span>);<br> <br>%按列顺序打印值<br>%文件的每一行上显示两个值<br>fprintf(fid, <span class="hljs-string">&#x27;%f    %f\n&#x27;</span>, y);<br><span class="hljs-keyword">fclose</span>(fid);<br><br>%显示创建的文件<br>type logtable.txt<br></code></pre></td></tr></table></figure><p>运行文件时，它显示以下结果-</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Log</span>         Function<br><br><span class="hljs-attribute">0</span>.<span class="hljs-number">000000</span>    -Inf<br><span class="hljs-attribute">10</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">2</span>.<span class="hljs-number">302585</span><br><span class="hljs-attribute">20</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">2</span>.<span class="hljs-number">995732</span><br><span class="hljs-attribute">30</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">3</span>.<span class="hljs-number">401197</span><br><span class="hljs-attribute">40</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">3</span>.<span class="hljs-number">688879</span><br><span class="hljs-attribute">50</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">3</span>.<span class="hljs-number">912023</span><br><span class="hljs-attribute">60</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">4</span>.<span class="hljs-number">094345</span><br><span class="hljs-attribute">70</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">4</span>.<span class="hljs-number">248495</span><br><span class="hljs-attribute">80</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">4</span>.<span class="hljs-number">382027</span><br><span class="hljs-attribute">90</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">4</span>.<span class="hljs-number">499810</span><br><span class="hljs-attribute">100</span>.<span class="hljs-number">000000</span>    <span class="hljs-number">4</span>.<span class="hljs-number">605170</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/Blogs/2025/08/28/Python/"/>
    <url>/Blogs/2025/08/28/Python/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># print absolute value of an integer:</span><br>a = <span class="hljs-number">100</span><br><span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(a)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(-a)<br></code></pre></td></tr></table></figure><p>Python程序是大小写敏感的，如果写错了大小写，程序会报错</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="输出print"><a href="#输出print" class="headerlink" title="输出print()"></a>输出<code>print()</code></h4><p>在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出<code>&#39;hello, world&#39;</code>，用代码实现如下：<code>print()</code>函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：<code>print()</code>也可以打印整数，或者计算结果：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello, world&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The quick brown fox&#x27;</span>, <span class="hljs-string">&#x27;jumps over&#x27;</span>, <span class="hljs-string">&#x27;the lazy dog&#x27;</span>)</span><br>The quick brown fox jumps over the lazy dog<br></code></pre></td></tr></table></figure><p><code>print()</code>会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1017032122300544/l" alt="print-explain"></p><p>如何输出格式化的字符串。我们经常会输出类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式</p><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-string">&#x27;Hello, world&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hi, %s, you have $%d.&#x27;</span> % (<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">1000000</span>)<br><span class="hljs-string">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></code></pre></td></tr></table></figure><p>你可能猜到了，<code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p><p>常见的占位符有：</p><table><thead><tr><th align="left">占位符</th><th align="left">替换内容</th></tr></thead><tbody><tr><td align="left">%d</td><td align="left">整数</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%s</td><td align="left">字符串</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数</p><p><code>%s</code>永远起作用，它会把任何数据类型转换为字符串：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">&gt;&gt;&gt; <span class="hljs-symbol">&#x27;Age</span>: %s. Gender: %s&#x27; % (<span class="hljs-number">25</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-symbol">&#x27;Age</span>: <span class="hljs-number">25</span>. Gender: <span class="hljs-literal">True</span>&#x27;<br></code></pre></td></tr></table></figure><p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">&gt;&gt;&gt; <span class="hljs-string">&#x27;growth rate: %d %%&#x27;</span> <span class="hljs-comment">% 7</span><br><span class="hljs-string">&#x27;growth rate: 7 %&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h5><p>另一种格式化字符串的方法是使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……，不过这种方式写起来比%要麻烦得多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<br><span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h5><p>最后一种格式化字符串的方法是使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>&#123;xxx&#125;</code>，就会以对应的变量替换：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">r = <span class="hljs-number">2.5</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">s = <span class="hljs-number">3.14</span> * r ** <span class="hljs-number">2</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;The area of a circle with radius <span class="hljs-subst">&#123;r&#125;</span> is <span class="hljs-subst">&#123;s:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)</span><br>The area of a circle with radius 2.5 is 19.62<br></code></pre></td></tr></table></figure><p>上述代码中，<code>&#123;r&#125;</code>被变量<code>r</code>的值替换，<code>&#123;s:.2f&#125;</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>&#123;s:.2f&#125;</code>的替换结果是<code>19.62</code>。</p><h4 id="输入input"><a href="#输入input" class="headerlink" title="输入input()"></a>输入<code>input()</code></h4><p>Python提供了一个<code>input()</code>，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name = <span class="hljs-built_in">input</span>()</span><br>Michael<br></code></pre></td></tr></table></figure><p>当你输入<code>name = input()</code>并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。</p><p>输入完成后，不会有任何提示，Python交互式命令行又回到<code>&gt;&gt;&gt;</code>状态了。那我们刚才输入的内容到哪去了？答案是存放到<code>name</code>变量里了。可以直接输入<code>name</code>查看变量内容：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">&gt;&gt;&gt; <span class="hljs-keyword">name</span><br><span class="hljs-string">&#x27;Michael&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="判断字符串方法"><a href="#判断字符串方法" class="headerlink" title="判断字符串方法"></a>判断字符串方法</h4><p>使用内建的<code>isinstance</code>函数可以判断一个变量是不是字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>y = <span class="hljs-number">123</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(x, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(y, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>Python允许在数字中间以<code>_</code>分隔，因此，写成<code>10_000_000_000</code>和<code>10000000000</code>是完全一样的。十六进制数也可以写成<code>0xa1b2_c3d4</code></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p><p>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-symbol">&#x27;I</span>\<span class="hljs-symbol">&#x27;m</span> \<span class="hljs-string">&quot;OK\&quot;</span>!&#x27;<br></code></pre></td></tr></table></figure><p>表示的字符串内容是：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">I<span class="hljs-symbol">&#x27;m</span> <span class="hljs-string">&quot;OK&quot;</span>!<br></code></pre></td></tr></table></figure><p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>，可以在Python的交互式命令行用<code>print()</code>打印字符串看看：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I\&#x27;m ok.&#x27;</span>)</span><br>I&#x27;m ok.<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I\&#x27;m learning\nPython.&#x27;</span>)</span><br>I&#x27;m learning<br>Python.<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\n\\&#x27;</span>)</span><br>\<br>\<br></code></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)</span><br>\       \<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>)</span><br>\\\t\\<br></code></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">line2</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-string">line3&#x27;&#x27;&#x27;</span>)</span><br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;包含中文的str&#x27;</span>)<br>包含中文的<span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;A&#x27;</span>)</span><br><span class="hljs-number">65</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">ord</span></span>(<span class="hljs-string">&#x27;中&#x27;</span>)</span><br><span class="hljs-number">20013</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">chr</span>(<span class="hljs-number">66</span>)</span><br><span class="hljs-string">&#x27;B&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">chr</span>(<span class="hljs-number">25991</span>)</span><br><span class="hljs-string">&#x27;文&#x27;</span><br></code></pre></td></tr></table></figure><p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">&gt;&gt;&gt; <span class="hljs-string">&#x27;<span class="hljs-char escape_">\u</span>4e2d<span class="hljs-char escape_">\u</span>6587&#x27;</span><br><span class="hljs-string">&#x27;中文&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> &gt; <span class="hljs-number">5</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p><code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> &gt; <span class="hljs-number">3</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>布尔值经常用在条件判断中，比如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">age</span> &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;adult&#x27;</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;teenager&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><h4 id="变量-静态语言"><a href="#变量-静态语言" class="headerlink" title="变量(静态语言)"></a>变量(静态语言)</h4><blockquote><p>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，<strong>同一个变量可以反复赋值，而且可以是不同类型的变量</strong></p></blockquote><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头</p><p>这种变量本身类型不固定的语言称之为<em>动态语言</em>，与之对应的是<em>静态语言</em>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（&#x2F;&#x2F; 表示注释）：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a <span class="hljs-operator">=</span> <span class="hljs-number">123</span><span class="hljs-comment">; // a是整数类型变量</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span><span class="hljs-comment">; // 错误：不能把字符串赋给整型变量</span><br></code></pre></td></tr></table></figure><p>和静态语言相比，动态语言更灵活，就是这个原因</p><h4 id="常量（Python无常量）"><a href="#常量（Python无常量）" class="headerlink" title="常量（Python无常量）"></a>常量（Python无常量）</h4><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265359</span><br></code></pre></td></tr></table></figure><p>但事实上<code>PI</code>仍然是一个变量，Python根本没有任何机制保证<code>PI</code>不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量<code>PI</code>的值，也没人能拦住你。</p><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><h4 id="bytes类型的数据用带b前缀的单引号或双引号表示"><a href="#bytes类型的数据用带b前缀的单引号或双引号表示" class="headerlink" title="bytes类型的数据用带b前缀的单引号或双引号表示"></a><code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = b<span class="hljs-string">&#x27;ABC&#x27;</span><br></code></pre></td></tr></table></figure><p>要注意区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</p><h4 id="以Unicode表示的str通过encode-方法可以编码为指定的bytes"><a href="#以Unicode表示的str通过encode-方法可以编码为指定的bytes" class="headerlink" title="以Unicode表示的str通过encode()方法可以编码为指定的bytes"></a>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code></h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-string">&#x27;ABC&#x27;</span>.encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>b<span class="hljs-string">&#x27;ABC&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;中文&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>b<span class="hljs-string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br>&gt;&gt;&gt; <span class="hljs-string">&#x27;中文&#x27;</span>.encode(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br>Traceback (most recent <span class="hljs-keyword">call</span> last):<br>  File &quot;&lt;stdin&gt;&quot;, <span class="hljs-type">line</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>UnicodeEncodeError: <span class="hljs-string">&#x27;ascii&#x27;</span> codec can<span class="hljs-string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span><br></code></pre></td></tr></table></figure><p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</p><p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code></p><h4 id="把bytes变为str，就需要用decode-方法："><a href="#把bytes变为str，就需要用decode-方法：" class="headerlink" title="把bytes变为str，就需要用decode()方法："></a>把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&gt;&gt;&gt; b<span class="hljs-string">&#x27;ABC&#x27;</span>.<span class="hljs-built_in">decode</span>(<span class="hljs-string">&#x27;ascii&#x27;</span>)<br><span class="hljs-string">&#x27;ABC&#x27;</span><br>&gt;&gt;&gt; b<span class="hljs-string">&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>.<span class="hljs-built_in">decode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-string">&#x27;中文&#x27;</span><br></code></pre></td></tr></table></figure><p>如果<code>bytes</code>中包含无法解码的字节，<code>decode()</code>方法会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&gt;&gt;&gt; <span class="hljs-string">b&#x27;<span class="hljs-char escape_">\x</span>e4<span class="hljs-char escape_">\x</span>b8<span class="hljs-char escape_">\x</span>ad<span class="hljs-char escape_">\x</span>ff&#x27;</span>.<span class="hljs-title function_ invoke__">decode</span>(<span class="hljs-symbol">&#x27;utf</span>-<span class="hljs-number">8</span><span class="hljs-string">&#x27;)</span><br><span class="hljs-string">Traceback (most recent call last):</span><br><span class="hljs-string">  ...</span><br><span class="hljs-string">UnicodeDecodeError: &#x27;</span>utf-<span class="hljs-number">8</span><span class="hljs-string">&#x27; codec can&#x27;</span>t decode byte <span class="hljs-number">0xff</span> <span class="hljs-keyword">in</span> position <span class="hljs-number">3</span>: invalid start byte<br></code></pre></td></tr></table></figure><p>如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">&gt;&gt;&gt; <span class="hljs-string">b&#x27;<span class="hljs-char escape_">\x</span>e4<span class="hljs-char escape_">\x</span>b8<span class="hljs-char escape_">\x</span>ad<span class="hljs-char escape_">\x</span>ff&#x27;</span>.<span class="hljs-title function_ invoke__">decode</span>(<span class="hljs-symbol">&#x27;utf</span>-<span class="hljs-number">8</span><span class="hljs-string">&#x27;, errors=&#x27;</span>ignore<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">&#x27;</span>中<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="用len-函数要计算str包含多少个字符"><a href="#用len-函数要计算str包含多少个字符" class="headerlink" title="用len()函数要计算str包含多少个字符"></a>用<code>len()</code>函数要计算<code>str</code>包含多少个字符</h4><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)</span><br>3<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;中文&#x27;</span>)</span><br>2<br></code></pre></td></tr></table></figure><p><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(<span class="hljs-string">b&#x27;ABC&#x27;</span>)</span><br>3<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(<span class="hljs-string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br>6<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;中文&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))</span><br>6<br></code></pre></td></tr></table></figure><p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p><h4 id="python开头注释"><a href="#python开头注释" class="headerlink" title="python开头注释"></a>python开头注释</h4><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/env python3</span><br># -*- coding: utf-<span class="hljs-number">8</span> -*-<br></code></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux&#x2F;OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Python 3的字符串使用Unicode，直接支持多语言。</p><p>当<code>str</code>和<code>bytes</code>互相转换时，需要指定编码。最常用的编码是<code>UTF-8</code>。Python当然也支持其他编码方式，比如把Unicode编码成<code>GB2312</code>：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt; &#x27;中文&#x27;.encode<span class="hljs-punctuation">(</span>&#x27;gb<span class="hljs-number">2312</span>&#x27;<span class="hljs-punctuation">)</span><br>b&#x27;\xd6\xd0\xce\xc4&#x27;<br></code></pre></td></tr></table></figure><p>但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用<code>UTF-8</code>编码。</p><p>格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。</p><h3 id="List-Tuple"><a href="#List-Tuple" class="headerlink" title="List &amp; Tuple"></a>List &amp; Tuple</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>List像是C语言中数组的进阶版，主要区别在于可以存储不同的数据类型，并且有<code>append()</code>,<code>pop()</code>,<code>insert()</code>等函数，并且可以用<code>list[-1]</code>来倒序抽取元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## list</span><br>classmates = [<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>]<br><span class="hljs-comment"># 用索引来访问list中每一个位置的元素，记得索引是从0开始的：</span><br>classmates[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</span><br>classmates[-<span class="hljs-number">1</span>]<br><span class="hljs-comment"># &#x27;Tracy&#x27;</span><br><span class="hljs-comment"># list是一个可变的有序表，所以，可以往list中追加元素到末尾：</span><br>classmates.append(<span class="hljs-string">&#x27;Adam&#x27;</span>)<br><span class="hljs-comment"># 可以把元素插入到指定的位置，比如索引号为1的位置：</span><br>classmates.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>)<br><span class="hljs-comment"># 要删除list末尾的元素，用pop()方法：</span><br>classmates.pop()<br><span class="hljs-comment"># 要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</span><br>classmates.pop(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</span><br>classmates[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;Sarah&#x27;</span><br><span class="hljs-comment"># list里面的元素的数据类型也可以不同，比如：</span><br>L = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-literal">True</span>]<br><span class="hljs-comment"># list元素也可以是另一个list，比如：</span><br>s = [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>, [<span class="hljs-string">&#x27;asp&#x27;</span>, <span class="hljs-string">&#x27;php&#x27;</span>], <span class="hljs-string">&#x27;scheme&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><p>tuple和list非常类似，但是tuple一旦初始化就不能修改，也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用<code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p><p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## tuple</span><br><span class="hljs-comment"># tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</span><br>classmates = (<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>)<br><span class="hljs-comment"># 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</span><br><span class="hljs-comment"># 要定义一个只有1个元素的tuple，如果你这么定义：</span><br>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-comment"># 这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</span><br><span class="hljs-comment"># 所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</span><br></code></pre></td></tr></table></figure><h2 id="判断，循环"><a href="#判断，循环" class="headerlink" title="判断，循环"></a>判断，循环</h2><h3 id="判断语句（if）"><a href="#判断语句（if）" class="headerlink" title="判断语句（if）"></a>判断语句（if）</h3><p><code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code>，所以<code>if</code>语句的完整形式就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> &lt;条件判断<span class="hljs-number">1</span>&gt;:<br>    &lt;执行<span class="hljs-number">1</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">2</span>&gt;:<br>    &lt;执行<span class="hljs-number">2</span>&gt;<br><span class="hljs-keyword">elif</span> &lt;条件判断<span class="hljs-number">3</span>&gt;:<br>    &lt;执行<span class="hljs-number">3</span>&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;执行<span class="hljs-number">4</span>&gt;<br></code></pre></td></tr></table></figure><p><code>if</code>语句执行有个特点，它是从上往下判断，如果在某个判断上是<code>True</code>，把该判断对应的语句执行后，就忽略掉剩下的<code>elif</code>和<code>else</code></p><p><code>if</code>判断条件还可以简写，比如写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">if <span class="hljs-attribute">x</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;True&#x27;</span>)<br></code></pre></td></tr></table></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>跟C基本一样，但是可以循环数组（for in）</p><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">names = [<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>]<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>    <span class="hljs-built_in">print</span>(name)<br></code></pre></td></tr></table></figure><p>执行这段代码，会依次打印<code>names</code>的每一个元素</p><p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>n = <span class="hljs-number">99</span><br><span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n<br>    n = n - <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><p>在循环内部变量<code>n</code>不断自减，直到变为<code>-1</code>时，不再满足while条件，循环退出</p><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>在循环中，如果要提前结束循环，可以用<code>break</code>语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">100</span>:<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">10</span>: <span class="hljs-comment"># 当n = 11时，条件满足，执行break语句</span><br>        <span class="hljs-keyword">break</span> <span class="hljs-comment"># break语句会结束当前循环</span><br>    <span class="hljs-built_in">print</span>(n)<br>    n = n + <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行上面的代码可以看到，打印出1~10后，紧接着打印<code>END</code>，程序结束</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环</p><p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用<code>continue</code>语句跳过某些循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">10</span>:<br>    n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>: <span class="hljs-comment"># 如果n是偶数，执行continue语句</span><br>        <span class="hljs-keyword">continue</span> <span class="hljs-comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span><br>    <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="dict-和set"><a href="#dict-和set" class="headerlink" title="dict 和set"></a>dict 和set</h3><h3 id="Dict查找对应值"><a href="#Dict查找对应值" class="headerlink" title="Dict查找对应值"></a>Dict查找对应值</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;Michael&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>: <span class="hljs-number">85</span>&#125;<br>d[<span class="hljs-string">&#x27;Michael&#x27;</span>]<br></code></pre></td></tr></table></figure><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;Adam&#x27;</span>] = <span class="hljs-number">67</span><br></code></pre></td></tr></table></figure><p>多次对一个key放入value，后面的值会把前面的值冲掉</p><p>如果key不存在，dict就会报错</p><h4 id="避免key不存在的错误"><a href="#避免key不存在的错误" class="headerlink" title="避免key不存在的错误"></a>避免key不存在的错误</h4><p>有两种办法，一是通过<code>in</code>判断key是否存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Thomas&#x27;</span> <span class="hljs-keyword">in</span> d<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d.get(<span class="hljs-string">&#x27;Thomas&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d.get(<span class="hljs-string">&#x27;Thomas&#x27;</span>, -<span class="hljs-number">1</span>)<br>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d.pop(<span class="hljs-string">&#x27;Bob&#x27;</span>)<br><span class="hljs-number">75</span><br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key</p><p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>&#123;1, 2, 3&#125;</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p><p>重复元素在set中自动被过滤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s.add(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>通过<code>remove(key)</code>方法可以删除元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s.remove(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>上面我们讲了，str是不变对象，而list是可变对象。</p><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.sort()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>而对于不可变对象，比如str，对str进行操作呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>)<br><span class="hljs-string">&#x27;Abc&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><p>要始终牢记的是，<code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───┐                  ┌───────┐<br>│ a │─────────────────&gt;│ &#x27;abc&#x27; │<br>└───┘                  └───────┘<br></code></pre></td></tr></table></figure><p>当我们调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌───┐                  ┌───────┐<br>│ a │─────────────────&gt;│ &#x27;abc&#x27; │<br>└───┘                  └───────┘<br>┌───┐                  ┌───────┐<br>│ b │─────────────────&gt;│ &#x27;Abc&#x27; │<br>└───┘                  └───────┘<br></code></pre></td></tr></table></figure><p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题</p><p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数<code>abs</code>，只有一个参数。可以直接从Python的官方网站查看文档：</p><p><a href="http://docs.python.org/3/library/functions.html#abs">http://docs.python.org/3/library/functions.html#abs</a></p><p>也可以在交互式命令行通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abs</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> -x<br></code></pre></td></tr></table></figure><p>请注意，函数体内部的语句在执行时，一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p><p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">&gt;&gt;&gt; my_abs(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>TypeError: my_abs() takes <span class="hljs-number">1</span> positional <span class="hljs-keyword">argument</span> but <span class="hljs-number">2</span> were given<br></code></pre></td></tr></table></figure><h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>函数可以返回多个值吗？答案是肯定的。</p><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">x, y, step, angle=<span class="hljs-number">0</span></span>):<br>    nx = x + step * math.cos(angle)<br>    ny = y - step * math.sin(angle)<br>    <span class="hljs-keyword">return</span> nx, ny<br></code></pre></td></tr></table></figure><p><code>import math</code>语句表示导入<code>math</code>包，并允许后续代码引用<code>math</code>包里的<code>sin</code>、<code>cos</code>等函数。</p><p>然后，我们就可以同时获得返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = move(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">60</span>, math.pi / <span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(x, y)<br><span class="hljs-number">151.96152422706632</span> <span class="hljs-number">70.0</span><br></code></pre></td></tr></table></figure><p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = move(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">60</span>, math.pi / <span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(r)<br>(<span class="hljs-number">151.96152422706632</span>, <span class="hljs-number">70.0</span>)<br></code></pre></td></tr></table></figure><p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">def <span class="hljs-built_in">power</span>(x, <span class="hljs-built_in">n</span>=<span class="hljs-number">2</span>)<span class="hljs-symbol">:</span><br>    s = <span class="hljs-number">1</span><br>    while <span class="hljs-built_in">n</span> &gt; <span class="hljs-symbol">0:</span><br>        <span class="hljs-built_in">n</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span><br>        s = s * x<br>    return s<br></code></pre></td></tr></table></figure><p>这样，当我们调用<code>power(5)</code>时，相当于调用<code>power(5, 2)</code></p><p>设置默认参数时，有几点要注意：</p><p>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</p><p>二是如何设置默认参数。</p><p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p><p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象！</strong></p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">def calc(*numbers)<span class="hljs-symbol">:</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    for <span class="hljs-built_in">n</span> in numbe<span class="hljs-symbol">rs:</span><br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + <span class="hljs-built_in">n</span> * <span class="hljs-built_in">n</span><br>    return <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p><p>Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">calc(*nums)</span><br>14<br></code></pre></td></tr></table></figure><p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见</p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br></code></pre></td></tr></table></figure><p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">30</span>)<br>name: Michael age: <span class="hljs-number">30</span> other: &#123;&#125;<br></code></pre></td></tr></table></figure><p>也可以传入任意个数的关键字参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">35</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class="hljs-number">35</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">45</span>, gender=<span class="hljs-string">&#x27;M&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>name: Adam age: <span class="hljs-number">45</span> other: &#123;<span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><p>比如定义一个函数，包含上述若干种参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">a, b, c=<span class="hljs-number">0</span>, *args, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a =&#x27;</span>, a, <span class="hljs-string">&#x27;b =&#x27;</span>, b, <span class="hljs-string">&#x27;c =&#x27;</span>, c, <span class="hljs-string">&#x27;args =&#x27;</span>, args, <span class="hljs-string">&#x27;kw =&#x27;</span>, kw)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">a, b, c=<span class="hljs-number">0</span>, *, d, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a =&#x27;</span>, a, <span class="hljs-string">&#x27;b =&#x27;</span>, b, <span class="hljs-string">&#x27;c =&#x27;</span>, c, <span class="hljs-string">&#x27;d =&#x27;</span>, d, <span class="hljs-string">&#x27;kw =&#x27;</span>, kw)在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>a = <span class="hljs-number">1</span> b = <span class="hljs-number">2</span> c = <span class="hljs-number">0</span> args = () kw = &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>f1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, c=<span class="hljs-number">3</span>)<br>a = <span class="hljs-number">1</span> b = <span class="hljs-number">2</span> c = <span class="hljs-number">3</span> args = () kw = &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>f1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>a = <span class="hljs-number">1</span> b = <span class="hljs-number">2</span> c = <span class="hljs-number">3</span> args = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) kw = &#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>f1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, x=<span class="hljs-number">99</span>)<br>a = <span class="hljs-number">1</span> b = <span class="hljs-number">2</span> c = <span class="hljs-number">3</span> args = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) kw = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">99</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>f2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, d=<span class="hljs-number">99</span>, ext=<span class="hljs-literal">None</span>)<br>a = <span class="hljs-number">1</span> b = <span class="hljs-number">2</span> c = <span class="hljs-number">0</span> d = <span class="hljs-number">99</span> kw = &#123;<span class="hljs-string">&#x27;ext&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p><p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p><p>要注意定义可变参数和关键字参数的语法：</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><h4 id="普通递归"><a href="#普通递归" class="headerlink" title="普通递归"></a>普通递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p><p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试<code>fact(1000)</code>：</p><h4 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h4><p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>上面的<code>fact(n)</code>函数由于<code>return n * fact(n - 1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> fact_iter(n, <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact_iter</span>(<span class="hljs-params">num, product</span>):<br>    <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> product<br>    <span class="hljs-keyword">return</span> fact_iter(num - <span class="hljs-number">1</span>, num * product)<br></code></pre></td></tr></table></figure><p>可以看到，<code>return fact_iter(num - 1, num * product)</code>仅返回递归函数本身，<code>num - 1</code>和<code>num * product</code>在函数调用前就会被计算，不影响函数调用。</p><p>[[C++速转Python]]</p><p>[[Python进阶]]</p><p>[[Python爬虫]]</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 网络爬虫学习</title>
    <link href="/Blogs/2025/08/28/Python3%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    <url>/Blogs/2025/08/28/Python3%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>以下是<a href="https://cuiqingcai.com/17777.html">学习框架</a></p><h2 id="爬虫基础入门"><a href="#爬虫基础入门" class="headerlink" title="爬虫基础入门"></a>爬虫基础入门</h2><ol><li><a href="https://cuiqingcai.com/202211.html">什么是爬虫？</a></li><li><a href="https://cuiqingcai.com/202212.html">HTTP 基本原理</a></li><li><a href="https://cuiqingcai.com/202213.html">Web 网页基础</a></li><li><a href="https://cuiqingcai.com/202214.html">Session 和 Cookie</a></li><li><a href="https://cuiqingcai.com/202221.html">urllib 爬虫初体验</a></li><li><a href="https://cuiqingcai.com/202222.html">方便好用的 requests</a></li><li><a href="https://cuiqingcai.com/202223.html">强大灵活的正则表达式</a></li><li><a href="https://cuiqingcai.com/202224.html">基础爬虫案例爬取实战</a></li></ol><h2 id="页面解析和数据存储"><a href="#页面解析和数据存储" class="headerlink" title="页面解析和数据存储"></a><a href="https://cuiqingcai.com/17777.html#%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8" title="页面解析和数据存储"></a>页面解析和数据存储</h2><ol><li><a href="https://cuiqingcai.com/202231.html">网页解析利器 XPath 初体验</a></li><li><a href="https://cuiqingcai.com/202232.html">新兴网页解析利器 parsel</a> </li><li><a href="https://cuiqingcai.com/202241.html">简易的 TXT 纯文本文件存储</a></li><li><a href="https://cuiqingcai.com/202242.html">方便灵活的 JSON 文本文件存储</a></li><li><a href="https://cuiqingcai.com/202243.html">高效实用的 MongoDB 文档存储</a></li><li><a href="https://cuiqingcai.com/202244.html">关系型数据库 MySQL 存储</a></li><li><a href="https://cuiqingcai.com/202245.html">当爬虫遇见 RabbitMQ 消息队列</a></li><li><a href="https://cuiqingcai.com/202246.html">便于高效检索的 Elasticsearch 存储</a></li></ol><h2 id="Ajax-分析和动态渲染页面爬取"><a href="#Ajax-分析和动态渲染页面爬取" class="headerlink" title="Ajax 分析和动态渲染页面爬取"></a><a href="https://cuiqingcai.com/17777.html#Ajax-%E5%88%86%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%88%AC%E5%8F%96" title="Ajax 分析和动态渲染页面爬取"></a>Ajax 分析和动态渲染页面爬取</h2><ol><li><a href="https://cuiqingcai.com/202251.html">什么是 Ajax？</a></li><li><a href="https://cuiqingcai.com/202252.html">Ajax 分析方法</a></li><li><a href="https://cuiqingcai.com/202253.html">Ajax 案例爬取实战</a></li><li><a href="https://cuiqingcai.com/202261.html">经典动态渲染工具 Selenium 的使用</a></li><li><a href="https://cuiqingcai.com/202262.html">新兴动态渲染工具 Playwright 的使用</a></li></ol><h2 id="异步爬虫和模拟登录"><a href="#异步爬虫和模拟登录" class="headerlink" title="异步爬虫和模拟登录"></a><a href="https://cuiqingcai.com/17777.html#%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95" title="异步爬虫和模拟登录"></a>异步爬虫和模拟登录</h2><ol><li><a href="https://cuiqingcai.com/202271.html">协程的基本原理</a></li><li><a href="https://cuiqingcai.com/202272.html">aiohttp 的基本使用</a></li><li><a href="https://cuiqingcai.com/202281.html">模拟登录的基本原理</a></li><li><a href="https://cuiqingcai.com/202282.html">Session + Cookie 模拟登录爬取实战</a></li></ol><h2 id="验证码的处理"><a href="#验证码的处理" class="headerlink" title="验证码的处理"></a><a href="https://cuiqingcai.com/17777.html#%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86" title="验证码的处理"></a>验证码的处理</h2><ol><li><a href="https://cuiqingcai.com/202291.html">OCR 识别验证码</a></li><li><a href="https://cuiqingcai.com/202292.html">OpenCV 图像匹配识别滑动验证码缺口</a></li><li><a href="https://cuiqingcai.com/202293.html">深度学习识别滑动验证码缺口</a></li></ol><h2 id="代理的使用"><a href="#代理的使用" class="headerlink" title="代理的使用"></a><a href="https://cuiqingcai.com/17777.html#%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8" title="代理的使用"></a>代理的使用</h2><ol><li><a href="https://cuiqingcai.com/2022101.html">代理的基本原理</a></li><li><a href="https://cuiqingcai.com/2022102.html">代理的基本使用</a></li><li><a href="https://cuiqingcai.com/2022103.html">高效代理池的维护</a></li><li><a href="https://cuiqingcai.com/2022104.html">ADSL 拨号代理的使用</a></li></ol><h2 id="JavaScript-混淆、逆向技术"><a href="#JavaScript-混淆、逆向技术" class="headerlink" title="JavaScript 混淆、逆向技术"></a><a href="https://cuiqingcai.com/17777.html#JavaScript-%E6%B7%B7%E6%B7%86%E3%80%81%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF" title="JavaScript 混淆、逆向技术"></a>JavaScript 混淆、逆向技术</h2><ol><li><a href="https://cuiqingcai.com/2022111.html">JavaScript 网站加密和混淆技术简介</a></li><li><a href="https://cuiqingcai.com/2022112.html">JavaScript 逆向调试技巧</a></li><li><a href="https://cuiqingcai.com/2022113.html">JavaScript Hook 的用法</a></li><li><a href="https://cuiqingcai.com/2022114.html">Python 模拟执行 JavaScript</a></li></ol><h2 id="App-爬虫和安卓逆向"><a href="#App-爬虫和安卓逆向" class="headerlink" title="App 爬虫和安卓逆向"></a><a href="https://cuiqingcai.com/17777.html#App-%E7%88%AC%E8%99%AB%E5%92%8C%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91" title="App 爬虫和安卓逆向"></a>App 爬虫和安卓逆向</h2><h2 id="页面智能解析"><a href="#页面智能解析" class="headerlink" title="页面智能解析"></a><a href="https://cuiqingcai.com/17777.html#%E9%A1%B5%E9%9D%A2%E6%99%BA%E8%83%BD%E8%A7%A3%E6%9E%90" title="页面智能解析"></a>页面智能解析</h2><h2 id="Scrapy-框架和分布式爬虫"><a href="#Scrapy-框架和分布式爬虫" class="headerlink" title="Scrapy 框架和分布式爬虫"></a><a href="https://cuiqingcai.com/17777.html#Scrapy-%E6%A1%86%E6%9E%B6%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB" title="Scrapy 框架和分布式爬虫"></a>Scrapy 框架和分布式爬虫</h2><h2 id="爬虫的部署、维护、监控"><a href="#爬虫的部署、维护、监控" class="headerlink" title="爬虫的部署、维护、监控"></a><a href="https://cuiqingcai.com/17777.html#%E7%88%AC%E8%99%AB%E7%9A%84%E9%83%A8%E7%BD%B2%E3%80%81%E7%BB%B4%E6%8A%A4%E3%80%81%E7%9B%91%E6%8E%A7" title="爬虫的部署、维护、监控"></a>爬虫的部署、维护、监控</h2>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3 网络爬虫学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/Blogs/2025/08/28/Python%E7%88%AC%E8%99%AB/"/>
    <url>/Blogs/2025/08/28/Python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-爬取进击的巨人漫画date-2020-02-23-15-13-57lang-zh-Hanstags-Pythoncategories-技术"><a href="#title-爬取进击的巨人漫画date-2020-02-23-15-13-57lang-zh-Hanstags-Pythoncategories-技术" class="headerlink" title="title: 爬取进击的巨人漫画date: 2020-02-23 15:13:57lang: zh-Hanstags:- Pythoncategories: 技术"></a>title: 爬取进击的巨人漫画<br>date: 2020-02-23 15:13:57<br>lang: zh-Hans<br>tags:<br>- Python<br>categories: 技术</h2><p>[[0Python3 网络爬虫学习]]</p><p>[[1爬虫简介]]</p><p>[[2爬虫原理]]</p><p>[[3爬虫编程基础]]</p><p>[[5Ajax内容爬取]]</p><p>[[6异步爬虫和模拟登录]]</p><p>[[7javascript逆向简介]]</p><p>[[8javascript逆向实战]]</p><p>[[信息安全：网页运作原理]]</p><h1 id="使用Scrapy爬取进击的巨人漫画"><a href="#使用Scrapy爬取进击的巨人漫画" class="headerlink" title="使用Scrapy爬取进击的巨人漫画"></a>使用Scrapy爬取进击的巨人漫画</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​自己看到网上有两个大牛分别爬取了<strong>合法</strong>(Naruto)与<strong>非法</strong>(<del>你懂的</del>)的漫画，十分感叹，便也想借鉴借鉴，结果大牛的的代码在博主的电脑上运行不了(<del>丧尽天良</del>),所以就只有自己写了一个算是结合版的代码，爬取了这个<a href="https://www.fzdm.com/">网站</a>。在此分享给大家，授人以both🐟。</p><p>​代码已经挂在GitHub上面了，想下漫画的可以滑到最下面观看下载方法，这个方法不仅可以下载进击的巨人，整个网站的漫画都可以爬，建议大家别乱改我设置的延迟，爬的太快了可能会被网站锁IP。</p><span id="more"></span><h2 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h2><p>博主的环境如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mavericks</span>-MacBook-Pro:~ maverick$<br><span class="hljs-attribute">Python</span> <span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">10</span> (default, Feb <span class="hljs-number">22</span> <span class="hljs-number">2019</span>, <span class="hljs-number">21</span>:<span class="hljs-number">55</span>:<span class="hljs-number">15</span>) <br><span class="hljs-attribute">Scrapy</span> <span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span> - no active project<br></code></pre></td></tr></table></figure><p>在这里我默认大家都已经安装好了scrapy，<a href="https://www.osgeo.cn/scrapy/intro/install.html#intro-install">传送门</a></p><p>不知道大家会遇到什么麻烦，博主只用了这一句代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> Scrapy<br></code></pre></td></tr></table></figure><h2 id="三、基础准备"><a href="#三、基础准备" class="headerlink" title="三、基础准备"></a>三、基础准备</h2><h3 id="Scrapy简介（大牛的文章）"><a href="#Scrapy简介（大牛的文章）" class="headerlink" title="Scrapy简介（大牛的文章）"></a>Scrapy简介（<a href="https://blog.csdn.net/c406495762/article/details/72858983">大牛的文章</a>）</h3><pre><code class="hljs">  Scrapy Engine(Scrapy核心) 负责数据流在各个组件之间的流。Spiders(爬虫)发出Requests请求，经由Scrapy Engine(Scrapy核心) 交给Scheduler(调度器)，Downloader(下载器)Scheduler(调度器) 获得Requests请求，然后根据Requests请求，从网络下载数据。Downloader(下载器)的Responses响应再传递给Spiders进行分析。根据需求提取出Items，交给Item Pipeline进行下载。Spiders和Item Pipeline是需要用户根据响应的需求进行编写的。除此之外，还有两个中间件，Downloaders Mddlewares和Spider Middlewares，这两个中间件为用户提供方面，通过插入自定义代码扩展Scrapy的功能，例如去重等。</code></pre><p><img src="https://s1.ax1x.com/2020/04/02/GGY3Ct.png" alt="Scrapy"></p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>注意！这篇文章并不是official文章，一切还以<a href="https://www.osgeo.cn/scrapy/intro/tutorial.html">官方教程</a>为准。这里只讲本次操作用到的知识。</p><ul><li>创建一个Scrapy项目；</li><li>定义提取的Item；</li><li>编写爬取网站的 spider 并提取 Item；</li><li>利用python自带的request库莱下载漫画</li></ul><h2 id="四、第二次准备"><a href="#四、第二次准备" class="headerlink" title="四、第二次准备"></a>四、第二次准备</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scrapy startproject Titan</span><br></code></pre></td></tr></table></figure><p>然后我们可以观察项目内涉及的文件</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">____Titan</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">____.DS_Store</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string">____scrapy.cfg</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|____Titan<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____.DS_Store</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|____spiders<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____titan_spider.py</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">______init__.py</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|______pycache__<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">______init__.cpython-38.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____titan_spider.cpython-38.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____titan_spider.cpython-37.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">______init__.cpython-37.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">______init__.py</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|______pycache__<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">______init__.cpython-38.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____settings.cpython-38.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____settings.cpython-37.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">______init__.cpython-37.pyc</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____middlewares.py</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____settings.py</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____items.py</span><br><span class="hljs-string"></span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____pipelines.py</span><br></code></pre></td></tr></table></figure><p>大部分都没啥用，重点是我们要在spider里面添加一个自己编写的python文件，可以是任意名字，像我就叫他巨人蜘蛛</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">titan_spider.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><h3 id="创建spider类"><a href="#创建spider类" class="headerlink" title="创建spider类"></a>创建spider类</h3><p>创建一个用来实现具体爬取功能的类，我们所有的处理实现都会在这个类中进行，它必须为 <code>scrapy.Spider</code> 的子类。</p><p>在 <code>Titan/spiders</code> 文件路径下创建 <code>titan_spider.py</code> 文件。在里面就开始我们蜘蛛（<del>只猪</del>）的初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment">#上面code是为了让其支持中文</span><br><span class="hljs-keyword">import</span> scrapy<span class="hljs-comment">#scrapy本尊</span><br><span class="hljs-keyword">import</span> re<span class="hljs-comment">#保存文件的library</span><br><span class="hljs-keyword">import</span> time<span class="hljs-comment">#设置延时</span><br><span class="hljs-keyword">import</span> requests<span class="hljs-comment">#从网络下载图片</span><br><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlretrieve<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TitanSpider</span>(scrapy.Spider):<br>name = <span class="hljs-string">&quot;titan&quot;</span><span class="hljs-comment">#定义spider的名字</span><br>start_urls = [<span class="hljs-string">&#x27;https://manhua.fzdm.com/132/&#x27;</span>]<span class="hljs-comment">#起始页面</span><br>allowed_domains = [<span class="hljs-string">&#x27;https://manhua.fzdm.com&#x27;</span>,<span class="hljs-string">&#x27;http://p2.manhuapan.com/&#x27;</span>]<span class="hljs-comment">#允许范围</span><br>  <span class="hljs-comment">#上面的名字都是official的名字千万别改</span><br></code></pre></td></tr></table></figure><h3 id="shell分析"><a href="#shell分析" class="headerlink" title="shell分析"></a>shell分析</h3><p>在command line里面输入</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">scrapy <span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-string">&#x27;https://manhua.fzdm.com/39&#x27;</span></span><br></code></pre></td></tr></table></figure><p>然后你会得到这一堆东西（别🐦它）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2020</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">47</span> <span class="hljs-selector-attr">[scrapy.utils.log]</span> INFO: Scrapy <span class="hljs-number">1.8</span>.<span class="hljs-number">0</span> started (bot: scrapybot)<br><span class="hljs-number">2020</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">47</span> <span class="hljs-selector-attr">[scrapy.utils.log]</span> INFO: Versions: lxml <span class="hljs-number">4.4</span>.<span class="hljs-number">2.0</span>, libxml2 <span class="hljs-number">2.9</span>.<span class="hljs-number">4</span>, cssselect <span class="hljs-number">1.1</span>.<span class="hljs-number">0</span>, parsel <span class="hljs-number">1.5</span>.<span class="hljs-number">2</span>, w3lib <span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>, Twisted <span class="hljs-number">19.10</span>.<span class="hljs-number">0</span>, Python <span class="hljs-number">3.8</span>.<span class="hljs-number">1</span> (v3.<span class="hljs-number">8.1</span>:<span class="hljs-number">1</span>b293b6006, Dec <span class="hljs-number">18</span> <span class="hljs-number">2019</span>, <span class="hljs-number">14</span>:<span class="hljs-number">08</span>:<span class="hljs-number">53</span>) - <span class="hljs-selector-attr">[Clang 6.0 (clang-600.0.57)]</span>, pyOpenSSL <span class="hljs-number">19.1</span>.<span class="hljs-number">0</span> (OpenSSL <span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>d  <span class="hljs-number">10</span> Sep <span class="hljs-number">2019</span>), cryptography <span class="hljs-number">2.8</span>, Platform macOS-<span class="hljs-number">10.14</span>.<span class="hljs-number">6</span>-x86_64-i386-<span class="hljs-number">64</span>bit<br><span class="hljs-number">2020</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">47</span> <span class="hljs-selector-attr">[scrapy.crawler]</span> INFO: Overridden settings: &#123;<span class="hljs-string">&#x27;DUPEFILTER_CLASS&#x27;</span>: <span class="hljs-string">&#x27;scrapy.dupefilters.BaseDupeFilter&#x27;</span>, <span class="hljs-string">&#x27;LOGSTATS_INTERVAL&#x27;</span>: <span class="hljs-number">0</span>&#125;<br><span class="hljs-number">2020</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">47</span> <span class="hljs-selector-attr">[scrapy.extensions.telnet]</span> INFO: Telnet Password: e3528447494d6c3d<br><span class="hljs-number">2020</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">47</span> <span class="hljs-selector-attr">[scrapy.middleware]</span> INFO: Enabled extensions:<br>...中间省略...<br><span class="hljs-selector-attr">[s]</span> Available Scrapy objects:<br><span class="hljs-selector-attr">[s]</span>   scrapy     scrapy module (contains scrapy<span class="hljs-selector-class">.Request</span>, scrapy<span class="hljs-selector-class">.Selector</span>, etc)<br><span class="hljs-selector-attr">[s]</span>   crawler    &lt;scrapy<span class="hljs-selector-class">.crawler</span><span class="hljs-selector-class">.Crawler</span> <span class="hljs-selector-tag">object</span> at <span class="hljs-number">0</span>x10d0cd760&gt;<br><span class="hljs-selector-attr">[s]</span>   item       &#123;&#125;<br><span class="hljs-selector-attr">[s]</span>   request    &lt;GET https:<span class="hljs-comment">//manhua.fzdm.com/39&gt;</span><br><span class="hljs-selector-attr">[s]</span>   response   &lt;<span class="hljs-number">200</span> https:<span class="hljs-comment">//manhua.fzdm.com/39//&gt;</span><br><span class="hljs-selector-attr">[s]</span>   settings   &lt;scrapy<span class="hljs-selector-class">.settings</span><span class="hljs-selector-class">.Settings</span> <span class="hljs-selector-tag">object</span> at <span class="hljs-number">0</span>x10d0cd460&gt;<br><span class="hljs-selector-attr">[s]</span>   spider     &lt;DefaultSpider <span class="hljs-string">&#x27;default&#x27;</span> at <span class="hljs-number">0</span>x10d573400&gt;<br><span class="hljs-selector-attr">[s]</span> Useful shortcuts:<br><span class="hljs-selector-attr">[s]</span>   <span class="hljs-built_in">fetch</span>(url<span class="hljs-selector-attr">[, redirect=True]</span>) Fetch URL and update local objects (by default, redirects are followed)<br><span class="hljs-selector-attr">[s]</span>   <span class="hljs-built_in">fetch</span>(req)                  Fetch <span class="hljs-selector-tag">a</span> scrapy<span class="hljs-selector-class">.Request</span> and update local objects <br><span class="hljs-selector-attr">[s]</span>   <span class="hljs-built_in">shelp</span>()           Shell help (print this help)<br><span class="hljs-selector-attr">[s]</span>   <span class="hljs-built_in">view</span>(response)    View response <span class="hljs-keyword">in</span> <span class="hljs-selector-tag">a</span> browser<br>&gt;&gt;&gt; <br></code></pre></td></tr></table></figure><p>然后我们就要使用xpath或者是css去寻找指定的页面内容（<del>奥利给干它</del>）</p><p>博主也学习了一些时间，建议各位去康康这个<a href="https://www.jianshu.com/p/489c5d21cdc7">教程</a>(<del>求作者给广告费恰饭</del>)</p><p>理清思路，现在我们要找到各话的url，通过观察发现这些url都在<a>标签下</p><p>观察方法：鼠标右键然后点击inspect，再点一下左上角的选择器就可以查看页面元素的所在位置了</p><p><img src="https://s1.ax1x.com/2020/04/02/GGNf91.png" alt="Inspect"></p><p>于是输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">response<span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//li/a[1]/@href&#x27;</span>)<span class="hljs-selector-class">.extract</span>()<br></code></pre></td></tr></table></figure><p>获取到所有符合这种特征的herf</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; response<span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//li/a[1]/@href&#x27;</span>)<span class="hljs-selector-class">.extract</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;//www.fzdm.com&#x27;</span>, <span class="hljs-string">&#x27;//news.fzdm.com&#x27;</span>, <span class="hljs-string">&#x27;//manhua.fzdm.com&#x27;</span>, <span class="hljs-string">&#x27;126/&#x27;</span>, <span class="hljs-string">&#x27;125/&#x27;</span>, <span class="hljs-string">&#x27;124/&#x27;</span>, <span class="hljs-string">&#x27;123/&#x27;</span>, <span class="hljs-string">&#x27;122/&#x27;</span>, <span class="hljs-string">&#x27;121/&#x27;</span>, <span class="hljs-string">&#x27;120/&#x27;</span>, <span class="hljs-string">&#x27;119/&#x27;</span>, <span class="hljs-string">&#x27;118/&#x27;</span>, <span class="hljs-string">&#x27;117/&#x27;</span>, <span class="hljs-string">&#x27;116/&#x27;</span>, <span class="hljs-string">&#x27;qc65/&#x27;</span>, <span class="hljs-string">&#x27;115/&#x27;</span>, <span class="hljs-string">&#x27;qc64/&#x27;</span>, <span class="hljs-string">&#x27;114/&#x27;</span>, <span class="hljs-string">&#x27;qc63/&#x27;</span>, <span class="hljs-string">&#x27;113/&#x27;</span>, <span class="hljs-string">&#x27;qc62/&#x27;</span>, <span class="hljs-string">&#x27;112/&#x27;</span>, <span class="hljs-string">&#x27;前传61/&#x27;</span>, <span class="hljs-string">&#x27;111/&#x27;</span>, <span class="hljs-string">&#x27;前传60/&#x27;</span>, <span class="hljs-string">&#x27;110/&#x27;</span>, <span class="hljs-string">&#x27;前传59/&#x27;</span>, <span class="hljs-string">&#x27;109/&#x27;</span>, <span class="hljs-string">&#x27;108/&#x27;</span>, <span class="hljs-string">&#x27;前传57/&#x27;</span>, <span class="hljs-string">&#x27;107/&#x27;</span>, <span class="hljs-string">&#x27;前传56/&#x27;</span>, <span class="hljs-string">&#x27;106/&#x27;</span>, <span class="hljs-string">&#x27;前传55/&#x27;</span>, <span class="hljs-string">&#x27;105/&#x27;</span>, <span class="hljs-string">&#x27;前传54/&#x27;</span>, <span class="hljs-string">&#x27;104/&#x27;</span>, <span class="hljs-string">&#x27;103/&#x27;</span>, <span class="hljs-string">&#x27;102/&#x27;</span>, <span class="hljs-string">&#x27;qz51/&#x27;</span>, <span class="hljs-string">&#x27;101/&#x27;</span>, <span class="hljs-string">&#x27;100/&#x27;</span>, <span class="hljs-string">&#x27;qz49/&#x27;</span>, <span class="hljs-string">&#x27;99/&#x27;</span>, <span class="hljs-string">&#x27;qz48/&#x27;</span>, <span class="hljs-string">&#x27;98/&#x27;</span>, <span class="hljs-string">&#x27;qz47/&#x27;</span>, <span class="hljs-string">&#x27;97/&#x27;</span>, <span class="hljs-string">&#x27;thf46/&#x27;</span>, <span class="hljs-string">&#x27;096/&#x27;</span>, <span class="hljs-string">&#x27;wp45/&#x27;</span>, <span class="hljs-string">&#x27;95/&#x27;</span>, <span class="hljs-string">&#x27;qz44/&#x27;</span>, <span class="hljs-string">&#x27;94/&#x27;</span>, <span class="hljs-string">&#x27;qz43/&#x27;</span>, <span class="hljs-string">&#x27;93/&#x27;</span>, <span class="hljs-string">&#x27;qz42/&#x27;</span>, <span class="hljs-string">&#x27;92/&#x27;</span>, <span class="hljs-string">&#x27;qz41/&#x27;</span>, <span class="hljs-string">&#x27;91/&#x27;</span>, <span class="hljs-string">&#x27;qz40/&#x27;</span>, <span class="hljs-string">&#x27;qz40/&#x27;</span>, <span class="hljs-string">&#x27;qz39/&#x27;</span>, <span class="hljs-string">&#x27;qz38/&#x27;</span>, <span class="hljs-string">&#x27;90/&#x27;</span>, <span class="hljs-string">&#x27;89/&#x27;</span>, <span class="hljs-string">&#x27;88/&#x27;</span>, <span class="hljs-string">&#x27;qz37/&#x27;</span>, <span class="hljs-string">&#x27;87/&#x27;</span>, <span class="hljs-string">&#x27; before-the-fall-36/&#x27;</span>, <span class="hljs-string">&#x27;86/&#x27;</span>, <span class="hljs-string">&#x27;85/&#x27;</span>, <span class="hljs-string">&#x27;84/&#x27;</span>, <span class="hljs-string">&#x27;83/&#x27;</span>, <span class="hljs-string">&#x27;82/&#x27;</span>, <span class="hljs-string">&#x27;81/&#x27;</span>, <span class="hljs-string">&#x27;80/&#x27;</span>, <span class="hljs-string">&#x27;079/&#x27;</span>, <span class="hljs-string">&#x27;078/&#x27;</span>, <span class="hljs-string">&#x27;77/&#x27;</span>, <span class="hljs-string">&#x27;76/&#x27;</span>, <span class="hljs-string">&#x27;75/&#x27;</span>, <span class="hljs-string">&#x27;d74/&#x27;</span>, <span class="hljs-string">&#x27;73/&#x27;</span>, <span class="hljs-string">&#x27;72/&#x27;</span>, <span class="hljs-string">&#x27;71/&#x27;</span>, <span class="hljs-string">&#x27;70/&#x27;</span>, <span class="hljs-string">&#x27;69/&#x27;</span>, <span class="hljs-string">&#x27;d68/&#x27;</span>, <span class="hljs-string">&#x27;67/&#x27;</span>, <span class="hljs-string">&#x27;66/&#x27;</span>, <span class="hljs-string">&#x27;dxj52/&#x27;</span>, <span class="hljs-string">&#x27;65/&#x27;</span>, <span class="hljs-string">&#x27;64/&#x27;</span>, <span class="hljs-string">&#x27;63/&#x27;</span>, <span class="hljs-string">&#x27;62/&#x27;</span>, <span class="hljs-string">&#x27;61/&#x27;</span>, <span class="hljs-string">&#x27;60/&#x27;</span>, <span class="hljs-string">&#x27;59/&#x27;</span>, <span class="hljs-string">&#x27;wc08/&#x27;</span>, <span class="hljs-string">&#x27;58/&#x27;</span>, <span class="hljs-string">&#x27;wc07/&#x27;</span>, <span class="hljs-string">&#x27;qc07/&#x27;</span>, <span class="hljs-string">&#x27;57/&#x27;</span>, <span class="hljs-string">&#x27;wc06/&#x27;</span>, <span class="hljs-string">&#x27;56/&#x27;</span>, <span class="hljs-string">&#x27;qc06/&#x27;</span>, <span class="hljs-string">&#x27;55/&#x27;</span>, <span class="hljs-string">&#x27;54/&#x27;</span>, <span class="hljs-string">&#x27;wc04/&#x27;</span>, <span class="hljs-string">&#x27;53/&#x27;</span>, <span class="hljs-string">&#x27;wc02/&#x27;</span>, <span class="hljs-string">&#x27;52/&#x27;</span>, <span class="hljs-string">&#x27;wc01/&#x27;</span>, <span class="hljs-string">&#x27;51/&#x27;</span>, <span class="hljs-string">&#x27;50/&#x27;</span>, <span class="hljs-string">&#x27;wc00/&#x27;</span>, <span class="hljs-string">&#x27;49/&#x27;</span>, <span class="hljs-string">&#x27;xz/&#x27;</span>, <span class="hljs-string">&#x27;qc01/&#x27;</span>, <span class="hljs-string">&#x27;48/&#x27;</span>, <span class="hljs-string">&#x27;fwp/&#x27;</span>, <span class="hljs-string">&#x27;47/&#x27;</span>, <span class="hljs-string">&#x27;sgp/&#x27;</span>, <span class="hljs-string">&#x27;46/&#x27;</span>, <span class="hljs-string">&#x27;45/&#x27;</span>, <span class="hljs-string">&#x27;44/&#x27;</span>, <span class="hljs-string">&#x27;fwp02/&#x27;</span>, <span class="hljs-string">&#x27;fwp01/&#x27;</span>, <span class="hljs-string">&#x27;043/&#x27;</span>, <span class="hljs-string">&#x27;042/&#x27;</span>, <span class="hljs-string">&#x27;041/&#x27;</span>, <span class="hljs-string">&#x27;040/&#x27;</span>, <span class="hljs-string">&#x27;039/&#x27;</span>, <span class="hljs-string">&#x27;038/&#x27;</span>, <span class="hljs-string">&#x27;037/&#x27;</span>, <span class="hljs-string">&#x27;036/&#x27;</span>, <span class="hljs-string">&#x27;035/&#x27;</span>, <span class="hljs-string">&#x27;034/&#x27;</span>, <span class="hljs-string">&#x27;033/&#x27;</span>, <span class="hljs-string">&#x27;032/&#x27;</span>, <span class="hljs-string">&#x27;031/&#x27;</span>, <span class="hljs-string">&#x27;030/&#x27;</span>, <span class="hljs-string">&#x27;029/&#x27;</span>, <span class="hljs-string">&#x27;028/&#x27;</span>, <span class="hljs-string">&#x27;027/&#x27;</span>, <span class="hljs-string">&#x27;026/&#x27;</span>, <span class="hljs-string">&#x27;025/&#x27;</span>, <span class="hljs-string">&#x27;024/&#x27;</span>, <span class="hljs-string">&#x27;023/&#x27;</span>, <span class="hljs-string">&#x27;022/&#x27;</span>, <span class="hljs-string">&#x27;021/&#x27;</span>, <span class="hljs-string">&#x27;020/&#x27;</span>, <span class="hljs-string">&#x27;019/&#x27;</span>, <span class="hljs-string">&#x27;018/&#x27;</span>, <span class="hljs-string">&#x27;017/&#x27;</span>, <span class="hljs-string">&#x27;016/&#x27;</span>, <span class="hljs-string">&#x27;015/&#x27;</span>, <span class="hljs-string">&#x27;014/&#x27;</span>, <span class="hljs-string">&#x27;013/&#x27;</span>, <span class="hljs-string">&#x27;012/&#x27;</span>, <span class="hljs-string">&#x27;011/&#x27;</span>, <span class="hljs-string">&#x27;010/&#x27;</span>, <span class="hljs-string">&#x27;009/&#x27;</span>, <span class="hljs-string">&#x27;008/&#x27;</span>, <span class="hljs-string">&#x27;007/&#x27;</span>, <span class="hljs-string">&#x27;006/&#x27;</span>, <span class="hljs-string">&#x27;005/&#x27;</span>, <span class="hljs-string">&#x27;004/&#x27;</span>, <span class="hljs-string">&#x27;003/&#x27;</span>, <span class="hljs-string">&#x27;002/&#x27;</span>, <span class="hljs-string">&#x27;001/&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>我们发现又有几个浑水<strong>摸鱼</strong>的url混了进来，不过咱们先把这个放在一边，等会在python里面用字符串操作把它们给筛掉（<del>博主不会一步找到正确url的方法qaq</del>），如果有更好的方法请大神指出（带我带我！）</p><p> 使用ctrl+d退出之前的shell，分析章节页面。这次我们需要找到图片的url以及下一页的url</p><h3 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h3><p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/%E7%88%AC%E5%8F%96%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA%E6%BC%AB%E7%94%BB/Inspect2.png" alt="Inspect"></p><p>手动@风车动漫的广告商到我这里来把广告费结一下，【手动狗头】</p><p>这次我们找一下下一页的url（这个网站他图片的url放的比较日怪）</p><p>在command line里面输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">scrapy</span> shell &#x27;https://manhua.fzdm.com/<span class="hljs-number">39</span>//<span class="hljs-number">126</span>/&#x27;<br></code></pre></td></tr></table></figure><p>然后我们需要再次找到 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;index_0.html&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;pure-button button-success&quot;</span>&gt;第1页&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>然后老套路</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; response<span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//a[contains(@href, &quot;index&quot;)]/@href&#x27;</span>)<span class="hljs-selector-class">.extract</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;index_0.html&#x27;</span>, <span class="hljs-string">&#x27;index_1.html&#x27;</span>, <span class="hljs-string">&#x27;index_2.html&#x27;</span>, <span class="hljs-string">&#x27;index_3.html&#x27;</span>, <span class="hljs-string">&#x27;index_4.html&#x27;</span>, <span class="hljs-string">&#x27;index_5.html&#x27;</span>, <span class="hljs-string">&#x27;index_6.html&#x27;</span>, <span class="hljs-string">&#x27;index_1.html&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>我们知道最后一个url就是咱们的next page了</p><p><strong>但是！！！</strong></p><p>我们这么才能知道这一章什么时候结束呢？</p><p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/%E7%88%AC%E5%8F%96%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA%E6%BC%AB%E7%94%BB/Inspect3.png" alt="Inspect"></p><p>这是我们的最后一页的代码，看起来从url上一点头绪都没有，但是从旁边的文字上我们又有了新的线索，一般它会给出如：下一页这样的信息，最后一页则没有这样的信息，只要我们知道是否有“下一页”，我们就能知道是否为最后一页</p><p><img src="https://s1.ax1x.com/2020/04/02/GGN2N9.png" alt="Inspect"></p><p>所以要获取上面的文字，使用如下方法：</p><p>请看第一页与最后一页的对比</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; response<span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//a[contains(@href, &quot;index&quot;)]/text()&#x27;</span>)<span class="hljs-selector-class">.extract</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;第1页&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;下一页&#x27;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; response<span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//a[contains(@href, &quot;index&quot;)]/text()&#x27;</span>)<span class="hljs-selector-class">.extract</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;上一页&#x27;</span>, <span class="hljs-string">&#x27;40&#x27;</span>, <span class="hljs-string">&#x27;41&#x27;</span>, <span class="hljs-string">&#x27;42&#x27;</span>, <span class="hljs-string">&#x27;43&#x27;</span>, <span class="hljs-string">&#x27;44&#x27;</span>, <span class="hljs-string">&#x27;第45页&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>然后既然我们已经知道了判断下一页的方法，接下来就是获取图片链接了</p><h3 id="获取图片链接"><a href="#获取图片链接" class="headerlink" title="获取图片链接"></a>获取图片链接</h3><p><img src="https://raw.githubusercontent.com/MaverickTang/Images/master/%E7%88%AC%E5%8F%96%E8%BF%9B%E5%87%BB%E7%9A%84%E5%B7%A8%E4%BA%BA%E6%BC%AB%E7%94%BB/pic.png" alt="Inspect"></p><p>再次选择我们找到了图片的url</p><p><strong>但是</strong>。。。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; response<span class="hljs-selector-class">.xpath</span>(<span class="hljs-string">&#x27;//img/@src&#x27;</span>)<span class="hljs-selector-class">.extract</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;https://static.fzdm.com/css/logo.png&#x27;</span>, <span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/fzdm/st@75839ec8feb53ac89fe52134fc648a17bd1bd31f/img/loading.gif&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>woc居然找不到图片的url？？？</p><p><img src="https://s1.ax1x.com/2020/04/02/GGNsnU.jpg" alt="Inspect"></p><p>于是康康这个蜘蛛获取到的整个html代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;&gt;&gt; response.body<br>b&#x27;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Language&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=Edge,chrome=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;x-dns-prefetch-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//www.fzdm.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//manhua.fzdm.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//p1.manhuapan.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//p2.manhuapan.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//p5.manhuapan.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//p17.manhuapan.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;all&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>\xe8\xbf\x9b\xe5\x87\xbb\xe7\x9a\x84\xe5\xb7\xa8\xe4\xba\xba126\xe8\xaf\x9d <br>……以下省略<br></code></pre></td></tr></table></figure><p>我们复制之后打开任意代码编译器然后<code>Command+f</code>寻找这个“2020&#x2F;02&#x2F;08055441539556.jpg”url在哪里。</p><p><img src="https://s1.ax1x.com/2020/04/02/GGN7He.png" alt="Inspect"></p><p>我们发现这个url放在javascript里面，使用<code>document.write()</code>。。。</p><p>你以为我有什么骚操作？？？</p><p><img src="https://s1.ax1x.com/2020/04/02/GGUpDS.gif" alt="Inspect"></p><p>我还真没有。。。</p><p>找到script</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&gt;&gt;&gt;</span> response.xpath(&#x27;<span class="hljs-comment">//script/text()&#x27;).extract()</span><br>[<span class="hljs-string">&quot;if (&#x27;serviceWorker&#x27; in navigator) &#123;<span class="hljs-subst">\n</span>      navigator.serviceWorker.register(&#x27;/sw.js&#x27;, &#123; scope: &#x27;/&#x27; &#125;).then(function (registration) &#123;<span class="hljs-subst">\n</span>        // registration.unregister().then(function(boolean) &#123;<span class="hljs-subst">\n</span>        // if boolean = true, unregister is successful<span class="hljs-subst">\n</span>        // &#125;);<span class="hljs-subst">\n</span>        // 注册成功<span class="hljs-subst">\n</span>        /*<span class="hljs-subst">\n</span>      var serviceWorker;<span class="hljs-subst">\n</span>      if (registration.installing) &#123;<span class="hljs-subst">\n</span>        console.log(&#x27;installing&#x27;);<span class="hljs-subst">\n</span>      &#125; else if (registration.waiting) &#123;<span class="hljs-subst">\n</span>        console.log(&#x27;waiting&#x27;);<span class="hljs-subst">\n</span>      &#125; else if (registration.active) &#123;<span class="hljs-subst">\n</span>        console.log(&#x27;active&#x27;);<span class="hljs-subst">\n</span>      &#125;<span class="hljs-subst">\n</span>      */<span class="hljs-subst">\n</span>        console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);<span class="hljs-subst">\n</span>      &#125;).catch(function (err) &#123;<span class="hljs-subst">\n</span>        // 注册失败 :(<span class="hljs-subst">\n</span>        console.log(&#x27;ServiceWorker registration failed: &#x27;, err);<span class="hljs-subst">\n</span>        let refreshing = false<span class="hljs-subst">\n</span>        navigator.serviceWorker.addEventListener(&#x27;controllerchange&#x27;, () =&gt; &#123;<span class="hljs-subst">\n</span>          if (refreshing) &#123;<span class="hljs-subst">\n</span>            return<span class="hljs-subst">\n</span></span><br><span class="hljs-string">……以下省略</span><br></code></pre></td></tr></table></figure><p>于是我们获得了一个很大的array which有我们需要的url</p><p>博主是个铁憨憨，强行用python的正则表达式找到了这个url</p><p>正则表达式不会的可以走<a href="https://www.runoob.com/python/python-reg-expressions.html">这里</a></p><p>在编程的时候，我们就先记录下这些script，然后再继续操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pre_img_url = response.xpath(<span class="hljs-string">&#x27;//script/text()&#x27;</span>).extract()<span class="hljs-comment">#记录script</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pre_img_url)):<span class="hljs-comment">#记录的时候是以array存储的</span><br>matchObj = re.search( <span class="hljs-string">r&#x27;url=\&quot;()\s*(.*)jpg&#x27;</span>, pre_img_url[i], re.M|re.I)<span class="hljs-comment">#正则表达式寻找</span><br><span class="hljs-keyword">if</span> matchObj:<br>ppreimgurl = matchObj.group()<span class="hljs-comment">#里面就包含了我们要找的url（本例是“2020/02/08055441539556.jpg”）</span><br>img_url= <span class="hljs-string">&#x27;http://p2.manhuapan.com/&#x27;</span> + ppreimgurl[<span class="hljs-number">5</span>:<span class="hljs-built_in">len</span>(ppreimgurl)]<span class="hljs-comment">#在前面加上存储图片的网址</span><br></code></pre></td></tr></table></figure><h2 id="五、开始编写"><a href="#五、开始编写" class="headerlink" title="五、开始编写"></a>五、开始编写</h2><p>还记得我们最开始的<code>parse()</code>吗？我们现在给他添加一点东西</p><p>解释都在代码里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>link_urls = response.xpath(<span class="hljs-string">&#x27;//li/a[1]/@href&#x27;</span>).extract()<span class="hljs-comment">#找到各话的url</span><br>names = response.xpath(<span class="hljs-string">&#x27;//li/a[1]/@title&#x27;</span>).extract()<span class="hljs-comment">#找到各话的名字，方便命名文件夹</span><br>    <span class="hljs-comment"># 下面的variable可以不管</span><br>x=-<span class="hljs-number">1</span><br>h=<span class="hljs-number">0</span><br>comics_url_list = []<br>rnames = []<br>base = <span class="hljs-string">&#x27;https://manhua.fzdm.com/132/&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(link_urls)):<br>h=<span class="hljs-built_in">bool</span>(re.search(<span class="hljs-string">r&#x27;\d&#x27;</span>, link_urls[i]))<br><span class="hljs-keyword">if</span>(h==<span class="hljs-literal">True</span>):<br>x=x+<span class="hljs-number">1</span><br>name=names[x]<br>url=base + link_urls[i]<span class="hljs-comment">#它的url只有base后面的部分，所以要把base加上</span><br>rnames.append(name)<span class="hljs-comment">#将各话的名字加入一个新的array</span><br>comics_url_list.append(url)<span class="hljs-comment">#将url加入array</span><br><span class="hljs-comment">#print(&quot;%s :https://www.manhuadui.com %s&quot;%(names[4+x],link_urls[i]))</span><br><span class="hljs-comment">#print(&quot;%s : %s&quot;%(rnames[x],comics_url_list[x]))</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; current page comics list &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#x27;</span>)<br><span class="hljs-built_in">print</span>(comics_url_list)<br><br><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> comics_url_list:<br><span class="hljs-keyword">yield</span> scrapy.Request(url=url, callback=<span class="hljs-variable language_">self</span>.comics_parse, dont_filter=<span class="hljs-literal">True</span>)<span class="hljs-comment">#通过特殊的scrapy传递将url传到下一个函数对下一层网页进行爬取</span><br>      <span class="hljs-comment">#一定要加入dont_filter=True，不然会出bug（不进入下个函数）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  parse comics:&#x27;</span> + url)<br></code></pre></td></tr></table></figure><p>接下来我们编写<code>comics_parse(self, response)</code>函数来处理各话的url</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">comics_parse</span>(<span class="hljs-params">self, response</span>):<span class="hljs-comment">#另一个函数爬取下层页面</span><br>pre_img_url = response.xpath(<span class="hljs-string">&#x27;//script/text()&#x27;</span>).extract()<span class="hljs-comment">#获取script</span><br>img_url = <span class="hljs-string">&#x27;&#x27;</span><br>ptitle=response.xpath(<span class="hljs-string">&#x27;//title/text()&#x27;</span>).extract()<span class="hljs-comment">#获取章节名称</span><br>prepage_num=response.xpath(<span class="hljs-string">&#x27;//a[contains(@href, &quot;index&quot;)]/text()&#x27;</span>).extract()<span class="hljs-comment">#获取页面名字</span><br>page_num=<span class="hljs-string">&#x27;&#x27;</span><br>a=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prepage_num)):<span class="hljs-comment">#寻找page number来作为文件名</span><br><span class="hljs-keyword">for</span> _char <span class="hljs-keyword">in</span> prepage_num[j]:<span class="hljs-comment">#判断中文字符来找到当前页码（它会是“第n页”）</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;\u4e00&#x27;</span> &lt;= _char &lt;= <span class="hljs-string">&#x27;\u9fa5&#x27;</span>:<br>page_num=prepage_num[j]<br><span class="hljs-keyword">if</span> page_num == <span class="hljs-string">&#x27;下一页&#x27;</span>:<span class="hljs-comment">#如果是‘下一页’叫表示它漏过了‘第一页’</span><br>page_num=<span class="hljs-string">&#x27;第1页&#x27;</span><br>a=<span class="hljs-number">1</span><br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>):<br><span class="hljs-keyword">break</span> <br>t=ptitle[<span class="hljs-number">0</span>]<br>index=ptitle[<span class="hljs-number">0</span>].find(<span class="hljs-string">&#x27;话&#x27;</span>)<span class="hljs-comment">#通过找到‘话’来找到章节的名字</span><br>title=t[<span class="hljs-number">0</span>:(index+<span class="hljs-number">1</span>)]<span class="hljs-comment">#截取章节名字</span><br><span class="hljs-comment">#matchObj = re.search( r&#x27;url=\&quot;()\s*(.*)jpg&#x27;, line, re.M|re.I)</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pre_img_url)):<span class="hljs-comment">#记录的时候是以array存储的      </span><br>   matchObj = re.search( <span class="hljs-string">r&#x27;url=\&quot;()\s*(.*)jpg&#x27;</span>, pre_img_url[i], re.M|re.I)<span class="hljs-comment">#正则表达式寻找      </span><br>    <span class="hljs-keyword">if</span> matchObj:        <br>      ppreimgurl = matchObj.group()<span class="hljs-comment">#里面就包含了我们要找的url（本例是“2020/02/08055441539556.jpg”）        img_url= &#x27;http://p2.manhuapan.com/&#x27; + ppreimgurl[5:len(ppreimgurl)]#在前面加上存储图片的网址</span><br><span class="hljs-variable language_">self</span>.log(<span class="hljs-string">&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始下载&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#x27;</span>)<br><span class="hljs-comment">#self.save_img(page_num[len(page_num)], title, img_url)</span><br>document = <span class="hljs-string">&#x27;/Users/maverick/Desktop/test/One punch&#x27;</span><br>comics_path = document + <span class="hljs-string">&#x27;/&#x27;</span> + title<br>exists = os.path.exists(comics_path)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exists:<span class="hljs-comment">#如果没有创建过文件夹</span><br><span class="hljs-comment">#self.log(&#x27;create document: &#x27; + title)</span><br>os.makedirs(comics_path)<br>pic_name = comics_path + <span class="hljs-string">&#x27;/&#x27;</span> + page_num + <span class="hljs-string">&#x27;.jpg&#x27;</span><br>exists = os.path.exists(pic_name)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exists:<br>time.sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment">#延时防止锁ip</span><br>urlretrieve(img_url, pic_name)<span class="hljs-comment">#下载图片</span><br><span class="hljs-keyword">break</span><br>pages_urls = response.xpath(<span class="hljs-string">&#x27;//a[contains(@href, &quot;index&quot;)]/@href&#x27;</span>).extract()<span class="hljs-comment">#找到下一页的url</span><br>page_situation = response.xpath(<span class="hljs-string">&#x27;//a[contains(@href, &quot;index&quot;)]/text()&#x27;</span>).extract()<span class="hljs-comment">#与是否为最后一页有关</span><br>ans=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _char <span class="hljs-keyword">in</span> page_situation[<span class="hljs-built_in">len</span>(page_situation)-<span class="hljs-number">1</span>]:<span class="hljs-comment">#还是通过中文来判断是否为最后一页</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-string">&#x27;\u4e00&#x27;</span> &lt;= _char &lt;= <span class="hljs-string">&#x27;\u9fa5&#x27;</span>:<br>ans=<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>):<br>premyfront = response.request.url<span class="hljs-comment">#找到当前页面的url，再通过字符串操作得到基础页</span><br>fenge = premyfront.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br>myfont=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>myfont=myfont+fenge[i]+<span class="hljs-string">&#x27;/&#x27;</span><br>next_page = myfont+pages_urls[<span class="hljs-built_in">len</span>(pages_urls)-<span class="hljs-number">1</span>]<span class="hljs-comment">#得到下一页</span><br><span class="hljs-variable language_">self</span>.log(next_page)<br><span class="hljs-keyword">yield</span> scrapy.Request(next_page, callback=<span class="hljs-variable language_">self</span>.comics_parse, dont_filter=<span class="hljs-literal">True</span>)<span class="hljs-comment">#递归自己</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-variable language_">self</span>.log(<span class="hljs-string">&#x27;parse comics:&#x27;</span> + title + <span class="hljs-string">&#x27;finished.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们就可以欣赏它爬取的漫画了。因为整个网站的机制是一样的，所以我们只需要修改url地址，就可以任意爬取自己想看的漫画了。</p><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a>五、后记</h2><p>如果是自己想用的话，代码已经在<a href="https://github.com/MaverickTang/Attack-on-titan-download">GitHub</a>上面了，下载下来就可以直接用。</p><p>不仅是巨人，这个爬虫还可以爬取整个网站上的其他漫画，比如：</p><p>一拳超人，火影忍者，海贼王,鬼灭之刃等。</p><p>请求星星✨</p><p>使用terminalcd到根目录然后运行以下代码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scrapy crawl titan</span><br></code></pre></td></tr></table></figure><p>记得把保存的本机地址还有想爬取的漫画地址改一下</p><p>当然只要编程的速度够快，这种下载速度绝对比某网盘快得多，最关键的是方便并且可以装B。。。</p><p><img src="https://s1.ax1x.com/2020/04/02/GGNvgP.gif" alt="Inspect"></p><p>放上自己爬到的兵长帅照哈哈哈哈哈</p><p><img src="https://s1.ax1x.com/2020/04/02/GGNX9I.jpg" alt="Inspect"></p><h2 id="六、参考链接及版权说明"><a href="#六、参考链接及版权说明" class="headerlink" title="六、参考链接及版权说明"></a>六、参考链接及版权说明</h2><p>博主是第一次写博客，如果侵权请联系我删除，还有对两个大佬写的博客表示诚挚感谢，链接第一与第二个为两个大佬的博客。</p><p>参考链接：</p><p>1(合法).<a href="https://blog.csdn.net/c406495762/article/details/72858983">https://blog.csdn.net/c406495762/article/details/72858983</a></p><p>2(非法).<a href="https://moshuqi.github.io/2016/09/27/Python%E7%88%AC%E8%99%AB-Scrapy%E6%A1%86%E6%9E%B6/">https://moshuqi.github.io/2016/09/27/Python%E7%88%AC%E8%99%AB-Scrapy%E6%A1%86%E6%9E%B6/</a></p><p>3(正则表达式).<a href="https://www.runoob.com/python/python-reg-expressions.html">https://www.runoob.com/python/python-reg-expressions.html</a></p><p>4(xpath与css学习).<a href="https://www.jianshu.com/p/489c5d21cdc7">https://www.jianshu.com/p/489c5d21cdc7</a></p><p>5(下载图片方法).<a href="https://morvanzhou.github.io/tutorials/data-manipulation/scraping/3-02-download/">https://morvanzhou.github.io/tutorials/data-manipulation/scraping/3-02-download/</a></p><p>6(进击的巨人在线观看).<a href="https://manhua.fzdm.com/39/">https://manhua.fzdm.com/39/</a></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI</title>
    <link href="/Blogs/2025/08/28/SPI/"/>
    <url>/Blogs/2025/08/28/SPI/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SPI是串行外设接口（Serial Peripheral Interface）的缩写，是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，是一种高速、全双工、同步通信总线，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M&#x2F;bps。</p><p>SPI有主、从两种模式，通常由一个主模块和一个或多个从模块组成（SPI不支持多主机），主模块选择一个从模块进行同步通信，从而完成数据的交换。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起，当存在多个从设备时，通过各自的片选信号进行管理。</p><h1 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h1><p>SPI主设备和从设备都有一个串行移位寄存器，主设备通过向它的SPI串行寄存器写入一个字节来发起一次传输。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SPI通信原理很简单，需要至少4根线，单向传输时3根线，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）和CS&#x2F;SS（片选）：</p><p>MISO（ Master Input Slave Output）：主设备数据输入，从设备数据输出；<br>MOSI（Master Output Slave Input）：主设备数据输出，从设备数据输入；<br>SCLK（Serial Clock）：时钟信号，由主设备产生；<br>CS&#x2F;SS（Chip Select&#x2F;Slave Select）：从设备使能信号，由主设备控制，一主多从时，CS&#x2F;SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。</p><p>一主设备一从设备模式</p><p>一主设备多从设备模式</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、主设备发起信号，将CS&#x2F;SS拉低，启动通信。</p><p>2、主设备通过发送时钟信号，来告诉从设备进行写数据或者读数据操作（采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低），因为SPI有四种模式，后面会讲到），它将立即读取数据线上的信号，这样就得到了一位数据（1bit）。</p><p>3、主机（Master）将要发送的数据写到发送数据缓存区（Menory），缓存区经过移位寄存器（缓存长度不一定，看单片机配置），串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。</p><p>4、从机（Slave）也将自己的串行移位寄存器（缓存长度不一定，看单片机配置）中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。</p><p>例如，下图示例中简单模拟SPI通信流程，主机拉低NSS片选信号，启动通信，并且产生时钟信号，上升沿触发边沿信号，主机在MOSI线路一位一位发送数据0X53，在MISO线路一位一位接收数据0X46，如下图所示：</p><p>这里有一点需要着重说明一下：SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。若只进行写操作，主机只需忽略接收到的字节（虚拟数据）；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。 </p><h1 id="通信特性"><a href="#通信特性" class="headerlink" title="通信特性"></a>通信特性</h1><h2 id="设备选择"><a href="#设备选择" class="headerlink" title="设备选择"></a>设备选择</h2><p>SPI是单主设备（Single Master）通信协议，只有一支主设备能发起通信，当SPI主设备想读&#x2F;写从设备时，它首先拉低从设备对应的SS线（SS是低电平有效）。接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，主设备把信号发到MOSI实现“写”，同时可对MISO采样而实现“读”。如下图所示：</p><h2 id="设备时钟"><a href="#设备时钟" class="headerlink" title="设备时钟"></a>设备时钟</h2><p>SPI时钟特点主要包括：时钟速率、时钟极性和时钟相位三方面。</p><h3 id="时钟速率"><a href="#时钟速率" class="headerlink" title="时钟速率"></a>时钟速率</h3><p>SPI总线上的主设备必须在通信开始时候配置并生成相应的时钟信号。从理论上讲，只要实际可行，时钟速率就可以是你想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的SPI传输速率。</p><h3 id="时钟极性"><a href="#时钟极性" class="headerlink" title="时钟极性"></a>时钟极性</h3><p>根据硬件制造商的命名规则不同，时钟极性通常写为CKP或CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据。</p><p>CKP可以配置为1或0。这意味着你可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。你必须参考设备的数据手册才能正确设置CKP和CKE。</p><p>CKP &#x3D; 0：时钟空闲IDLE为低电平 0；<br>CKP &#x3D; 1：时钟空闲IDLE为高电平1。<br>3.2.3、时钟相位</p><p>根据硬件制造商的不同，时钟相位通常写为CKE或CPHA。顾名思义，时钟相位&#x2F;边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；</p><p>CKE &#x3D; 0：在时钟信号SCK的第一个跳变沿采样；<br>CKE &#x3D; 1：在时钟信号SCK的第二个跳变沿采样。</p><h3 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h3><p>根据SPI的时钟极性和时钟相位特性可以设置4种不同的SPI通信操作模式，它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低），详情如下所示：</p><p>Mode0：CKP&#x3D;0，CKE &#x3D;0：当空闲态时，SCK处于低电平，数据采样是在第1个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在上升沿（准备数据），（发送数据）数据发送是在下降沿。<br>Mode1：CKP&#x3D;0，CKE&#x3D;1：当空闲态时，SCK处于低电平，数据发送是在第2个边沿，也就是SCK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。<br>Mode2：CKP&#x3D;1，CKE&#x3D;0：当空闲态时，SCK处于高电平，数据采集是在第1个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。<br>Mode3：CKP&#x3D;1，CKE&#x3D;1：当空闲态时，SCK处于高电平，数据发送是在第2个边沿，也就是SCK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。</p><p>黑线为采样数据的时刻，蓝线为SCK时钟信号</p><p>举个例子，下图是SPI Mode0读&#x2F;写时序，可以看出SCK空闲状态为低电平，主机数据在第一个跳变沿被从机采样，数据输出同理。</p><p>下图是SPI Mode3读&#x2F;写时序，SCK空闲状态为高电平，主机数据在第二个跳变沿被从机采样，数据输出同理。</p><h1 id="多从机模式"><a href="#多从机模式" class="headerlink" title="多从机模式"></a>多从机模式</h1><p>有两种方法可以将多个从设备连接到主设备：多片选和菊花链。</p><p>通常，每个从机都需要一条单独的SS线。如果要和特定的从机进行通讯，可以将相应的NSS信号线拉低，并保持其他SS信号线的状态为高电平；如果同时将两个SS信号线拉低，则可能会出现乱码，因为从机可能都试图在同一条MISO线上传输数据，最终导致接收数据乱码。</p><p>菊花链的最大缺点是信号串行传输，一旦数据链路中的某设备发生故障的时候，它下面优先级较低的设备就不可能得到服务了。另一方面，距离主机越远的从机，获得服务的优先级越低，所以需要安排好从机的优先级，并且设置总线检测器，如果某个从机超时，则对该从机进行短路，防止单个从机损坏造成整个链路崩溃的情况。</p><h1 id="SPI优缺点"><a href="#SPI优缺点" class="headerlink" title="SPI优缺点"></a>SPI优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>无起始位和停止位，因此数据位可以连续传输而不会被中断；<br>没有像I2C这样复杂的从设备寻址系统；<br>数据传输速率比I2C更高（几乎快两倍）；<br>分离的MISO和MOSI信号线，因此可以同时发送和接收数据；<br>极其灵活的数据传输，不限于8位，它可以是任意大小的字；<br>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>使用四根信号线（I2C和UART使用两根信号线）；<br>无法确认是否已成功接收数据（I2C拥有此功能）；<br>没有任何形式的错误检查，如UART中的奇偶校验位；<br>只允许一个主设备；<br>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；<br>没有定义硬件级别的错误检查协议；<br>与RS-232和CAN总线相比，只能支持非常短的距离；</p><p>————————————————<br>版权声明：本文为CSDN博主「不脱发的程序猿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/m0_38106923/article/details/124364676">https://blog.csdn.net/m0_38106923/article/details/124364676</a></p><h1 id="SPI（Serial-Peripheral-interface）"><a href="#SPI（Serial-Peripheral-interface）" class="headerlink" title="SPI（Serial Peripheral interface）"></a>SPI（Serial Peripheral interface）</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="Definatipn"><a href="#Definatipn" class="headerlink" title="Definatipn"></a>Definatipn</h3><p>SPI 是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口。是Motorola(摩托罗拉)首先在其MC68HCXX系列处理器上定义的。</p><p>SPI，是一种<strong>高速的，全双工，同步的通信总线</strong>，并且在芯片的管脚上<strong>只占用四根线</strong>，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。</p><p>特别之处：数据能在没有中断的情况下传输（transport without interruption）</p><p>The Serial Peripheral Interface Bus or SPI bus is <strong>a synchronous serial data link standard（同步串行数据链路标准）</strong> named by Motorola that operates in Full duplex mode.</p><p>Devices communicate in master&#x2F;slave mode where the master device initiates the data frame. <strong>Multiple slave devices are allowed with individual slave select (chip select) lines</strong>.</p><p>During a data transfer the master always sends <strong>8 to 16 bits of data to the slave</strong>, and the slave always sends <strong>a byte of data to the master</strong>.</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>SPI is a common communication protocol used by many different devices. For example, <strong>SD card reader modules, RFID card reader modules, and 2.4 GHz wireless transmitter&#x2F;receivers</strong> all use SPI to communicate with microcontrollers.</p><p>One <strong>unique benefit</strong> of SPI is the fact that <strong>data can be transferred without interruption</strong>.</p><p><strong>Any number of bits</strong> can be sent or received <strong>in a continuous stream</strong>.</p><p>With I2C and UART, data is sent in packets, limited to a specific number of bits. Start and stop conditions define the beginning and end of each packet</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>Peripheral devices in embedded systems &#x3D;&gt; parallel address and data bus &#x3D;&gt; lots of wiring and requires number of pins &#x3D;&gt; additional decoding logic required.</p><p><strong>To reduce the pins and wiring</strong> &#x3D;&gt; cost &#x3D;&gt; Serial bus protocol &#x3D;&gt; SPI (4-wire) &amp; I2C (2-wire).</p><p>Penalty &#x3D;&gt; Slower communication</p><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><h3 id="SPI主从模式"><a href="#SPI主从模式" class="headerlink" title="SPI主从模式"></a>SPI主从模式</h3><p>SPI<strong>分为主、从两种模式</strong>，一个SPI通讯系统<strong>需要包含一个（且只能是一个）主设备，一个或多个从设备</strong>。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</p><p>SPI是全双工且SP<strong>I没有定义速度限制</strong>，一般的实现通常能达到甚至超过10 Mbps</p><p>硬件上为4根线。</p><h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><p>具有寄存数据功能的逻辑电路称为寄存器。移位寄存器是指寄存器中所存的代码能够在移位脉冲的作用下依次左移或右移。</p><p>根据存取信息的方式不同，移位寄存器可分为：串入串出、串入并出、并入串出、并入并出四种形式。</p><p>The master and slave both contain shift registers, and the SPI bus connects them together to make one long, distributed shift register.</p><p>In operation, data to be sent is loaded into the master shift register (for a write) or the slave shift register (for a read), and the SPI controller issues enough clock pulses to shift all data bits out of one shift register and into the other. Typically, the MSB is shifted out first.</p><p>Because the SPI bus creates one long shift register that is partly in the master and partly in the slave, <strong>data is rotated through both devices</strong>.</p><p><strong>To read data from an SPI device, you must shift data out of the slave and in to the master</strong>, and at the same time shift data out of the master and in to the slave - even if there is no useful data to send to the slave.In fact it is often the case that an SPI-connected device (like a sensor) produces, but does not consume data - in this case, MOSI data is irrelevant (a don’t care), and either 1’s or 0’s can be shifted. At any point, the master or slave can overwrite data in their local shift registers. It is possible to use a <strong>daisy-chain arrangement</strong> to make one long shift register.</p><h3 id="SPI信号线"><a href="#SPI信号线" class="headerlink" title="SPI信号线"></a>SPI信号线</h3><p>SPI接口一般使用四条信号线通信：<br>SDI（数据输入），SDO（数据输出），SCK（时钟），CS（片选）</p><h4 id="MISO"><a href="#MISO" class="headerlink" title="MISO"></a>MISO</h4><p>主设备输入&#x2F;从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。</p><h4 id="MOSI"><a href="#MOSI" class="headerlink" title="MOSI"></a>MOSI</h4><p> 主设备输出&#x2F;从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。</p><h4 id="SCLK"><a href="#SCLK" class="headerlink" title="SCLK"></a>SCLK</h4><p>串行时钟信号，由主设备产生。</p><p>The SPI used clock signal to synchronize the transfer of data across the SPI interface.</p><p>The SCK is always driven by the master and received by the slave, The clock is programmable to be active <em>high or active low</em>.</p><p>The SCK is only active during a data transfer. Any other time, it is in its inactive state.</p><ul><li>The SPI used clock signal to <strong>synchronize</strong> the transfer of data across the SPI interface.</li><li>The SCK is <strong>always driven by the master</strong> and received by the slave, The clock is <strong>programmable</strong> to be active <em>high or active low</em>.</li></ul><h4 id="CS-SS-Slave-signal"><a href="#CS-SS-Slave-signal" class="headerlink" title="CS&#x2F;SS(Slave signal)"></a>CS&#x2F;SS(Slave signal)</h4><p>从设备片选信号，由主设备控制。它的功能是用来作为“片选引脚”，也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</p><p>Pin Name : SS </p><p>Type <strong>:</strong> <strong>Input</strong></p><p>The SPI slave select signal is an active low signal that indicates which <strong>slave</strong> is currently selected to participate in a data transfer.</p><p>Each slave has its own unique slave select signal input.</p><p>The SS must be <strong>low</strong> before data transactions begin and normally stays low for the duration of the transaction.</p><p>If the SS signal goes high any time during a data transfer, the transfer is considered to be aborted.</p><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>SPI一对一</p><p><img src="https://img-blog.csdnimg.cn/20200429141530267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>SPI一对多</p><p><img src="https://img-blog.csdnimg.cn/20200429141618139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>Daisy-chained SPI bus</p><p>If only <strong>one</strong> slave select pin is available, the slaves can be daisy-chained like this</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/9/97/SPI_three_slaves_daisy_chained.svg"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="SPI设备选择"><a href="#SPI设备选择" class="headerlink" title="SPI设备选择"></a>SPI设备选择</h4><p>SPI是<strong>单主设备（ single-master)通信协议</strong>，这意味着总线中的只有一支中心设备能发起通信。当SPI主设备想读&#x2F;写［从设备］时，它<strong>首先拉低［从设备］对应的SS线</strong>（SS是低电平有效），接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，［<strong>主设备］把信号发到MOSI实现“写”</strong>，同时可对<strong>MISO采样而实现“读”</strong></p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="SPI数据发送接收"><a href="#SPI数据发送接收" class="headerlink" title="SPI数据发送接收"></a>SPI数据发送接收</h3><p>SPI主机和从机都有一个串行<strong>移位寄存器</strong>，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。</p><ol><li>首先拉低对应SS信号线，表示与该设备进行通信。The master outputs the clock signal</li><li>主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据。（这里要注意，SCLK时钟信号可能是低电平有效，也可能是高电平有效，因为SPI有四种模式，这个我们在下面会介绍The master switches the SS&#x2F;CS pin to a low voltage state, which activates the slave(<strong>注意ppt这里第一步和第二步与网站资料不一样</strong>)</li><li>主机(Master)将要发送的数据写到发送数据缓存区(Menory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。The master sends the data one bit at a time to the slave along the MOSI line. The slave reads the bits as they are received</li><li>从机(Slave)也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，两个移位寄存器中的内容就被交换。If a response is needed, the slave returns data one bit at a time to the master along the MISO line. The master reads the bits as they are received :</li></ol><p><img src="https://img-blog.csdnimg.cn/20200429143110758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>SPI<strong>只有主模式和从模式之分，没有读和写的说法</strong>，外设的写操作和读操作是同步完成的。</p><p>如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p><h3 id="SPI通信的四种模式"><a href="#SPI通信的四种模式" class="headerlink" title="SPI通信的四种模式"></a>SPI通信的四种模式</h3><blockquote><p> SPI的四种模式，简单地讲就是设置SCLK时钟信号线的那种信号为有效信号</p></blockquote><p>SPI通信有4种不同的操作模式，<strong>不同的从设备可能在出厂是就是配置为某种模式</strong>，这是不能改变的；但我们的通信双方必须是工作在同一模式下，所以我们可以对我们的主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式，具体如下：</p><ul><li>时钟极性(CPOL)定义了时钟空闲状态电平：</li></ul><p>CPOL&#x3D;0，表示当SCLK&#x3D;0时处于空闲态，所以有效状态就是SCLK处于高电平时<br>CPOL&#x3D;1，表示当SCLK&#x3D;1时处于空闲态，所以有效状态就是SCLK处于低电平时</p><ul><li>时钟相位(CPHA)定义数据的采集时间。</li></ul><p>CPHA&#x3D;0，在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样。，在第2个边沿发送数据<br>CPHA&#x3D;1，在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样。，在第1个边沿发送数据</p><p>例如：</p><p>Mode0：CPOL&#x3D;0，CPHA&#x3D;0：此时空闲态时，SCLK处于低电平，数据采样是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在上升沿(准备数据），（发送数据）数据发送是在下降沿。</p><p>Mode1：CPOL&#x3D;0，CPHA&#x3D;1：此时空闲态时，SCLK处于低电平，数据发送是在第1个边沿，也就是SCLK由低电平到高电平的跳变，所以数据采样是在下降沿，数据发送是在上升沿。</p><p>Mode2：CPOL&#x3D;1，CPHA&#x3D;0：此时空闲态时，SCLK处于高电平，数据采集是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在下降沿，数据发送是在上升沿。</p><p>Mode3：CPOL&#x3D;1，CPHA&#x3D;1：此时空闲态时，SCLK处于高电平，数据发送是在第1个边沿，也就是SCLK由高电平到低电平的跳变，所以数据采集是在上升沿，数据发送是在下降沿。</p><p>它们的区别是定义了在时钟脉冲的哪条边沿转换（toggles）输出信号，哪条边沿采样输入信号，还有时钟脉冲的稳定电平值（就是时钟信号无效时是高还是低）。每种模式由一对参数刻画，它们称为时钟极（clock polarity）CPOL与时钟期（clock phase）CPHA</p><h3 id="三种工作模式"><a href="#三种工作模式" class="headerlink" title="三种工作模式"></a>三种工作模式</h3><p>SPI工作在3中模式下，分别是运行、等待和停止。</p><p>运行模式（Run Mode）</p><ul><li>这是基本的操作模式</li></ul><p>等待模式（Wait Mode）</p><ul><li>SPI工作在等待模式是一种可配置的低功耗模式，可以通过SPICR2寄存器的SPISWAI位进行控制。在等待模式下，如果SPISWAI位清0，SPI操作类似于运行模式。如果SPISWAI位置1，SPI进入低功耗状态，并且SPI时钟将关闭。如果SPI配置为主机，所有的传输将停止，但是会在CPU进入运行模式后重新开始。如果SPI配置为从机，会继续接收和传输一个字节，这样就保证从机与主机同步。</li></ul><p>停止模式（Stop Mode）</p><ul><li>为了降低功耗，SPI在停止模式是不活跃的。如果SPI配置为主机，正在进行的传输会停止，但是在CPU进入运行模式后会重新开始。如果SPI配置为从机，会继续接受和发送一个字节，这样就保证了从机与主机同步。</li></ul><h3 id="Clock-Polarity-and-Phase"><a href="#Clock-Polarity-and-Phase" class="headerlink" title="Clock Polarity and Phase"></a>Clock Polarity and Phase</h3><p>In addition to setting the clock frequency, the <strong>master</strong> must also configure the <strong>clock</strong> with respect to the <strong>data</strong>.</p><p>These two options are: </p><ul><li>clock polarity (CPOL) </li><li>clock phase (CPHA)</li></ul><p>The clock signal in SPI can be modified using the properties of <strong>clock polarity</strong> <strong>and</strong> <strong>clock phase</strong>. These two properties work together to define when the <em>bits are output and when they are sampled</em>.</p><ul><li><strong>Clock polarity</strong> can be set by the master to allow for bits to be output and sampled on either the rising or falling edge of the clock cycle.</li><li><strong>Clock phase</strong> can be set for output and sampling to occur on either the <em>first edge or second edge of the clock cycle</em>, regardless of whether it is rising or falling</li></ul><p>SPI串行同步时钟可以设置为不同的极性（Clock Polarity ，CPOL）与相位（Clock Phase ，CPHA）。</p><p>时钟的极性（CPOL）用来<strong>决定在总线空闲时，同步时钟（SCK）信号线上的电位是高电平还是低电平</strong>。当时钟极性为0时（CPOL&#x3D;0），SCK信号线在空闲时为低电平；当时钟极性为1时（CPOL&#x3D;1），SCK信号线在空闲时为高电平；</p><p>时钟的相位（CPHA）用来<strong>决定何时进行信号采样</strong>。</p><p>当时钟相位为1时（CPHA&#x3D;1），在SCK信号线的第二个跳变沿进行采样；这里的跳变沿究竟是上升沿还是下降沿？取决于时钟的极性。当时钟<strong>极性为0时，取下降沿</strong>；当时钟极性为1时，取上升沿；如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-1141b7036cf151564818cc6cb676d275_720w.webp" alt="img"></p><p>当时钟相位为0时（CPHA&#x3D;0），在SCK信号线的第一个跳变沿进行采样。跳变沿同样与时钟极性有关：当时钟<strong>极性为0时，取上升沿</strong>；当时钟极性为1时，取下降沿；如下图： </p><p><img src="https://pic2.zhimg.com/80/v2-e69e8be0703f70f3e6eb781fa86fee05_720w.webp" alt="img"></p><h2 id="Pros-Cons"><a href="#Pros-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul><li><p>Full duplex communication </p></li><li><p>Higher throughput than I2C</p></li><li><p>Complete protocol flexibility for the bits transferred</p><ul><li><p>Not limited to 8-bit words</p></li><li><p>Arbitrary choice of message size, content, &amp; purpose</p></li></ul></li><li><p>No start and stop bits, so the data can be streamed continuously without interruption</p></li><li><p>No complicated slave addressing system like I2C</p></li><li><p>Higher data transfer rate than I2C (almost twice as fast)</p></li><li><p>Separate MISO and MOSI lines, so data can be sent and received at the same time</p></li></ul><p>* Typically lower power requirements than I2C due to less circuitry</p><p>No arbitration or associated failure modes * Slaves use the master’s clock, and don’t need precision oscillators</p><h3 id="Disadvantage"><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h3><ul><li>Uses four wires (I2C and UARTs use two)</li><li>No acknowledgement that the data has been successfully received (I2C has this)</li></ul><ul><li>No form of error checking like the parity bit in UART</li><li>Only allows for a single master</li></ul><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>SPI is used to talk to a variety of peripherals, such as:</p><p><strong>Sensors:</strong> Temperature, pressure, ADC, touch-screens <strong>Control devices</strong>: audio codecs, digital potentiometers, DAC Real-time clocks, LCD displays, sometimes even for managing image data, Any SD card</p><p><a href="https://blog.csdn.net/as480133937/article/details/105764119">https://blog.csdn.net/as480133937/article/details/105764119</a></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Semiconductor</title>
    <link href="/Blogs/2025/08/28/Semiconductor/"/>
    <url>/Blogs/2025/08/28/Semiconductor/</url>
    
    <content type="html"><![CDATA[<p>[[半导体物理]]</p><h1 id="Semiconductors"><a href="#Semiconductors" class="headerlink" title="Semiconductors"></a>Semiconductors</h1><table><thead><tr><th align="center">Characteristics</th><th align="center">Conductors导电体</th><th align="center">Semiconductors半导体</th><th align="center">Insulators绝缘体</th></tr></thead><tbody><tr><td align="center">Resistivity</td><td align="center">10^-5</td><td align="center">10^-5~10^6</td><td align="center">10^6</td></tr><tr><td align="center">Temp-Coefficient</td><td align="center">Positive</td><td align="center">Negative</td><td align="center">Negative</td></tr><tr><td align="center">最外层电子数</td><td align="center">1-3</td><td align="center">4</td><td align="center">2*n^2</td></tr></tbody></table><h2 id="能带"><a href="#能带" class="headerlink" title="能带"></a>能带</h2><p>固体根据导电性可划分为导体、半导体和绝缘体，其划分和其能带电子填充情况有关。在形成固体材料前，孤立原子外围电子受原子核势场的影响，在原子能级上规律排布，形成电子轨道。当原子逐渐靠近形成固体时，原子间电子轨道逐渐交叠，单个电子能级将被分裂成多个电子能级形成能带，原子间距离越近，能级分裂越严重。</p><p><img src="https://img-blog.csdnimg.cn/20200106150714850.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbXVjYWw=,size_16,color_FFFFFF,t_70" alt="原子能级分裂为能带的示意图"></p><p>从示意图中可以看到，分裂后的能带对应于不同的电子轨道，原子内层电子轨道对应能量低的能带，电子首先填满能量低的能级，被电子填满的能带称为满带或价带，无电子填充的能带称为空带或导带，价带与导带之间无能级分布区域称为禁带。下图为热力学温度为零时三种材料能带示意图。</p><p><img src="https://img-blog.csdnimg.cn/20200106150726725.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbXVjYWw=,size_16,color_FFFFFF,t_70" alt="半导体的能带示意图"></p><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><ul><li>An <strong>Intrinsic semiconductor</strong> is a pure semiconductor crystal in which the electron and hole concentrations are equal. By pure we mean virtually no impurities in the crystal.</li><li>Germanium (Ge) and Silicon (Si) are the most common type of intrinsic semiconductor elements.</li><li>Intrinsic type of semiconductor material is made up of only a single type of element.</li></ul><h3 id="Intrinsic"><a href="#Intrinsic" class="headerlink" title="Intrinsic"></a>Intrinsic</h3><p>Pure Form of Ge,Si.</p><h3 id="Extrinsic"><a href="#Extrinsic" class="headerlink" title="Extrinsic"></a>Extrinsic</h3><p>N-type:Pentavalent impurity(五价杂质)</p><p>P-type: Trivalent impurity（三价杂质）</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>Semiconductor acts like an insulator at Zero Kelvin. On increasing the temperature, it works as a conductor.</li><li>The resistance of semiconductor materials decreases with the increase in temperature and vice-versa.</li><li>Semiconductors are smaller in size and possess less weight. Their resistivity is higher than conductors but lesser than insulators.</li><li>Semiconductors can be modified by doping*(掺杂) to make semiconductor devices suitable for energy conversion, integrated chips, diodes and transistors.</li></ul><h2 id="Intrinsic（i-type）"><a href="#Intrinsic（i-type）" class="headerlink" title="Intrinsic（i-type）"></a>Intrinsic（i-type）</h2><ul><li>An <strong>Intrinsic semiconductor</strong> is a pure semiconductor crystal in which the electron and hole concentrations are equal. By pure we mean virtually no impurities in the crystal.</li><li>Germanium (Ge) and Silicon (Si) are the most common type of intrinsic semiconductor elements.</li><li>Intrinsic type of semiconductor material is made up of <strong>only a single type of element</strong>.</li><li>They have <strong>four valence electrons (tetravalent)</strong>.</li><li>The number of excited electrons is equal to the number of holes;（n &#x3D; p）. They are also termed as undoped semiconductors or i-type semiconductors.</li></ul><h2 id="Extrinsic-1"><a href="#Extrinsic-1" class="headerlink" title="Extrinsic"></a>Extrinsic</h2><p>By introducing small amounts of impurities into an otherwise pure Si crystal is called Extrinsic semiconductor.</p><p>• The conductivity of semiconductors can be greatly improved by introducing a small number of suitable replacement atoms called <strong>Impurities</strong>. The process of adding impurity atoms to the pure semiconductor is called <strong>Doping</strong>.</p><h3 id="N-TYPE-DOPING-Negative"><a href="#N-TYPE-DOPING-Negative" class="headerlink" title="N-TYPE DOPING (Negative)"></a>N-TYPE DOPING (Negative)</h3><p>When a pure semiconductor is doped by <strong>pentavalent impurity</strong>（+5价） (Phosphorus <strong>P</strong>, Arsenic <strong>As</strong>, Antimony <strong>Sb</strong>, Bismuth <strong>Bi</strong>)</p><p><strong>n型半导体</strong>（n-type semiconductor）又称<strong>电子型半导体</strong>，因掺有“施主杂质”使其原子的电子密度与空穴密度不平衡，导电的电子密度超过流动的空穴密度（产生超额的电子），导电性则由这些多数<a href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B5%81%E5%AD%90">载流子</a>为带负电荷的电子来决定。</p><p>概而言之，就是在<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93#%E6%99%B6%E4%BD%93%E7%BA%AF%E5%87%80%E5%BA%A6">纯净晶体</a>的半导体（<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%BE%81%E5%8D%8A%E5%AF%BC%E4%BD%93">本征半导体</a>，如硅晶体或锗晶体）中，掺入少量的五价元素杂质（如<a href="https://zh.wikipedia.org/wiki/%E7%A3%B7">磷</a>、<a href="https://zh.wikipedia.org/wiki/%E9%94%91">锑</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A0%B7">砷</a>），由于半导体原子（如硅原子）被杂质原子取代，五价元素的杂质（以磷为例）会和纯半导体作用，磷原子的五个<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%96%E5%B1%82%E7%94%B5%E5%AD%90&action=edit&redlink=1">外层电子</a>中的四个与周围的半导体原子形成<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BB%B7%E9%94%AE">共价键</a>，多出的一个电子几乎不受束缚，较易成为<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E9%9B%BB%E5%AD%90">自由电子</a>。于是，n型半导体就成为了<strong>含自由电子浓度较高</strong>的半导体，其导电性主要是因为自由电子导电。</p><h3 id="P-type-（Positive）"><a href="#P-type-（Positive）" class="headerlink" title="P-type （Positive）"></a><strong>P-type</strong> （Positive）</h3><p>When a pure semiconductor is doped with a <strong>trivalent impurity</strong> （+3价）(Boron <strong>B</strong>, Aluminium <strong>Al</strong>, Indium <strong>In</strong>, Gallium <strong>Ga</strong>)</p><p><strong>p型半导体</strong>（p-type semiconductor）又称<strong>空穴型半导体</strong>，因掺有“受主杂质”使其原子的电子密度与空穴密度不平衡，流动的空穴密度超过导电的电子密度，导电性则由这些多数<a href="https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B5%81%E5%AD%90">载流子</a>为带正电荷的空穴（电洞）来决定。</p><p>概而言之，就是在<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93#%E6%99%B6%E4%BD%93%E7%BA%AF%E5%87%80%E5%BA%A6">纯净晶体</a>的半导体（<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%BE%81%E5%8D%8A%E5%AF%BC%E4%BD%93">本征半导体</a>，如硅晶体或锗晶体）中，掺入少量的三价元素杂质（如<a href="https://zh.wikipedia.org/wiki/%E7%A1%BC">硼</a>、<a href="https://zh.wikipedia.org/wiki/%E9%93%9D">铝</a>、<a href="https://zh.wikipedia.org/wiki/%E9%95%93">镓</a>、<a href="https://zh.wikipedia.org/wiki/%E9%93%9F">铟</a>），由于半导体原子（如硅原子）被杂质原子取代，三价元素的杂质（以硼为例）会和纯半导体作用，硼原子的三个<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%96%E5%B1%82%E7%94%B5%E5%AD%90&action=edit&redlink=1">外层电子</a>与周围的半导体原子形成<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BB%B7%E9%94%AE">共价键</a>的时候，会产生一个“空穴”（电洞），这个空穴可能吸引<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9D%9F%E7%BC%9A%E7%94%B5%E5%AD%90&action=edit&redlink=1">束缚电子</a>来“填充”，使得硼原子成为带负电的离子。这样，这类半导体由于含有较高浓度的“空穴”（“相当于”正电荷），成为能够导电的物质。</p><table><thead><tr><th align="center"><strong>Intrinsic Semiconductor</strong></th><th align="center"><strong>Extrinsic Semiconductor</strong></th></tr></thead><tbody><tr><td align="center"><strong>Pure</strong> semiconductor</td><td align="center">Impure semiconductor</td></tr><tr><td align="center">Density of electrons <strong>&#x3D;</strong> Density of holes</td><td align="center">Density of electrons &#x3D;̸ Density of holes</td></tr><tr><td align="center"><strong>Low</strong> electrical conductivity</td><td align="center">High electrical conductivity</td></tr><tr><td align="center"><strong>Only</strong> temperature dependence</td><td align="center">Dependence on temperature as well as on the amount of impurity</td></tr><tr><td align="center"><strong>No</strong> impurities</td><td align="center">Trivalent impurity, Pentavalent impurity</td></tr></tbody></table><h1 id="PN-Junction"><a href="#PN-Junction" class="headerlink" title="PN Junction"></a>PN Junction</h1><p>A pn junction is a type of semiconductor device that is formed by joining together two different types of semiconductors, a p-type semiconductor and an n-type semiconductor.</p><blockquote><p> 一塊半導體晶體一側<a href="https://zh.wikipedia.org/wiki/%E6%8E%BA%E6%9D%82_(%E5%8D%8A%E5%AF%BC%E4%BD%93)">摻雜</a>成p型半導體，另一側摻雜成n型半導體，中間二者相連的<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E9%9D%A2">接觸面</a>间有一个过渡层，稱為<strong>pn结</strong>、<strong>p-n结</strong>、<strong>pn接面</strong>（p-n junction）。pn结是<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF">電子技術</a>中許多元件，例如半導體<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%A5%B5%E7%AE%A1">二極管</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%9E%81%E6%80%A7%E6%99%B6%E4%BD%93%E7%AE%A1">雙極性晶體管</a>的物质基础。</p></blockquote><p><img src="https://bkimg.cdn.bcebos.com/pic/9c16fdfaaf51f3de072a57d997eef01f3b2979f7?x-bce-process=image/resize,m_lfit,w_536,limit_1" alt="PN结"></p><ul><li>A pn junction is <strong>an interface or a boundary between two semiconductor material types</strong>, namely the p-type and the n-type, inside a semiconductor.</li><li>There is an discontinuity between the p- and n-regions, which we also call the <strong>metallurgical junction (M)</strong>.</li><li>The fixed (immobile) ionized donors and the free electrons (in the conduction band, CB) in the n-region and fixed ionized acceptors and holes (in the valence band, VB) in the p-region.</li><li>Due to the hole concentration gradient from the p-side, holes diffuse toward the right.</li><li>The electron concentration gradient drives the electrons by diffusion toward the left.</li><li>Holes diffusing and entering the n-side recombine with the electrons in the n-side near the junction.</li><li>Electrons diffusing and entering the p-side recombine with holes in the p-side near the junction.</li><li>Consequently the junction region becomes depleted of free carriers (electron or hole) in comparison with the bulk p- and n-regions far away from the junction.</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>There are two types of electron flow:</p><ul><li>-  The flow due to diffusion ( P➔N)</li><li>-  The flow due to electric filed (P《—N)</li></ul><p>The depletion region offer resistance to the electric current because consist of mainly immobile ions (there is no charge carriers).</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Pn-junction-equilibrium-graphs.png" alt="undefined"></p><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><p>Total three biasing conditions for the <em>pn</em> junction, and this is based on the voltage applied:</p><p>• <strong>Zerobias</strong>: No external voltage is applied to the <em>p-n</em> junction.<br> • <strong>Forward bias</strong>: The positive terminal of the voltage potential is connected to the p-type while the negative terminal is connected to the n-type.<br> • <strong>Reverse bias</strong>: The negative terminal of the voltage potential is connected to the p-type and the positive is connected to the n-type.</p><h3 id="Forward-bias"><a href="#Forward-bias" class="headerlink" title="Forward bias"></a>Forward bias</h3><p>施加在p區的電壓高於n區的電壓，称为正向偏置（forward bias）</p><p>二极管可以导通正向大电流</p><ul><li>A battery is connected across a PN junction so that the +ive terminal is attached to p-side and the -ive terminal to n-side (Forward-biased).</li><li>In forward biased, the built-in electric field at the pn junction and the applied electric field are in opposite directions. This results in a less resistive and thinner depletion region.</li><li>Regions outside the depletion width have high conductivities due to plenty of majority carriers in the bulk, in comparison with the depletion region in which there are mainly immobile ions.</li><li>The depletion region resistance becomes negligible when the applied voltage is large.</li><li>At the voltage &gt; built-in potential, the resistance of the depletion region becomes negligible, and the current flows.</li></ul><h3 id="Reverse-bias"><a href="#Reverse-bias" class="headerlink" title="Reverse bias"></a>Reverse bias</h3><p>施加在n區的電壓高於p區的電壓，这种状态称为pn结<strong>反向偏置</strong>（reverse bias）</p><p>多数载流子扩散过pn结的势垒增大，pn结的电阻变大，宏观看二极管成为绝缘体。</p><ul><li>When the p-type is connected to the battery’s negative terminal and the n-type is connected to the positive side, the pn junction is reverse biased.</li><li>In this case, the built-in electric field and the applied electric field are in the same direction.</li><li>When the two fields are added, the resultant electric field is in the same direction as the built-in electric field, creating a more resistive, thicker depletion region.</li></ul><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><table><thead><tr><th><strong>Products&#x2F;components made</strong></th></tr></thead><tbody><tr><td>Bipolar transistors</td></tr><tr><td>Diodes</td></tr><tr><td>Field-effect transistors</td></tr><tr><td>Integrated circuits</td></tr><tr><td>Light-emitting diodes (LEDs)</td></tr><tr><td><strong>Metal-oxide semiconductor field-effect transistors (MOSFETs)</strong></td></tr><tr><td>Silicon-controlled rectifiers</td></tr></tbody></table><h1 id="MOSFET（Metal-Oxide-Silicon-Field-Effect-Transistors）"><a href="#MOSFET（Metal-Oxide-Silicon-Field-Effect-Transistors）" class="headerlink" title="MOSFET（Metal Oxide Silicon Field Effect Transistors）"></a>MOSFET（Metal Oxide Silicon Field Effect Transistors）</h1><p>used to switch or amplify voltages in circuits. It is a voltage-controlled device and is constructed by three terminals.</p><p>The terminals of MOSFET are named as follows: </p><ul><li>Source (S) </li><li>Gate (G) </li><li>Drain (D) </li><li>Body (B)</li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><ul><li>The p-type semiconductor forms the base of the MOSFET.</li><li>The two types of the base are highly doped with an n-type impurity which is marked as n+ in the diagram.</li><li>The layer of the substrate is coated with a layer of silicon dioxide for insulation.</li><li>A thin insulated metallic plate is kept on top of the silicon dioxide.</li><li>The gate terminal is brought out from the thin metallic plate.</li><li>A DC circuit is then formed by connecting a voltage source between these two n-type regions.</li></ul><h2 id="N-channel-MOSFET"><a href="#N-channel-MOSFET" class="headerlink" title="N-channel MOSFET"></a>N-channel MOSFET</h2><p>MOSFETs can be built as either NMOS or PMOS transistors, depending on the polarities of the bulk, source and drain regions</p><p>The N-channel MOSFETs are abbreviated as NMOS and are represented as figure as shown in Figure.</p><p>The majority of carriers in NMOS devices are electrons.</p><h1 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h1><p>CMOS是Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）的缩写。它是指制造大规模<a href="https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%8A%AF%E7%89%87/4872662?fromModule=lemma_inlink">集成电路芯片</a>用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的<a href="https://baike.baidu.com/item/RAM/144481?fromModule=lemma_inlink">RAM</a>芯片。因为可读写的特性，所以在电脑主板上用来保存BIOS设置完<a href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6/165440?fromModule=lemma_inlink">电脑硬件</a>参数后的数据，这个芯片仅仅是用来存放数据的</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Semiconductor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VR与元宇宙</title>
    <link href="/Blogs/2025/08/28/VR%E4%B8%8E%E5%85%83%E5%AE%87%E5%AE%99/"/>
    <url>/Blogs/2025/08/28/VR%E4%B8%8E%E5%85%83%E5%AE%87%E5%AE%99/</url>
    
    <content type="html"><![CDATA[<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>本质其实是下代互联网，从平面到立体。表现形式上，可以是（隔绝现实世界的）VR也可以是（和现实融合在一起的）AR，但一定都是立体的，沉浸式的</p><p>把建设元宇宙作为直接目标并不是建成元宇宙的最好方法，应该落实到具体的硬件产品上，解决应用问题，让其更普及，就像互联网公司完善自己的网站软件服务后，自然而然就形成了互联网</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>VR与大部分计算机应用一样，本质是计算<br>两个镜片，于是需要对同一个视频计算得到左右眼视觉<br>对立体的物品，要根据近大远小的原理计算<br>3D模型最外层是贴图，内层其实是由一个个微小的多边形组成，多边形越多，图形越精细越逼真<br>对虚拟世界的模拟精细度的提高源于算法与算力</p><h2 id="双刃剑"><a href="#双刃剑" class="headerlink" title="双刃剑"></a>双刃剑</h2><p>沉浸式，但终究不是现实世界，就像野生动物园，动物在回归野外中会出现问题，元宇宙就像是人类文明的野生动物园，如果呆久了，无法适应外面，动物园又出问题了，文明就只能被残酷的野外环境吞噬了</p><pre><code class="hljs">    The discussion about the metaverse has become hotter and hotter, and more and more started to have an interest in it. But what exactly is the metaverse and how does it work? The metaverse is a network in which people interact with each other using three-dimensional figures, immersive and solid. Its foundations are virtual reality and Augmented reality. The virtual reality headset uses two screens simulating one&#39;s vision. The basis of every computer game is calculating data. VR application requires computers to calculate a lot of data. A 3D model is a mixture of thousands of polygons. The more polygons a subject has, the more delicate it becomes. Computers&#39; tasks are calculating the polygons of the object, and sending video to the user in real-time. To have a more delicate model, we have to increase the computer&#39;s ability to calculate and design better algorithms to calculate. Like many other technologies, VR is also a double-edged sword. For its immersive feature and imaginary design, people are likely to be addicted to it. Moreover, there is also privacy concern about the metaverse. Especially there are rape cases that happened in a virtual platform last year.To develop the metaverse into a better place that benefits humanity, serval measures need to be done to make sure VR is developing in a fast and safe way. Regulations, in the first place, should be made. And faster algorithms and better computers should be produced so that it engages more people in it. The more people use it, the stronger it gets.</code></pre>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>新概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VR与元宇宙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg</title>
    <link href="/Blogs/2025/08/28/ffmpeg/"/>
    <url>/Blogs/2025/08/28/ffmpeg/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-ffmpegdate-2021-01-01-20-01-01tags-工具categories-技术"><a href="#title-ffmpegdate-2021-01-01-20-01-01tags-工具categories-技术" class="headerlink" title="title: ffmpegdate: 2021-01-01 20:01:01tags:- 工具categories: 技术"></a>title: ffmpeg<br>date: 2021-01-01 20:01:01<br>tags:<br>- 工具<br>categories: 技术</h2><p>2021年开年第一个博客</p><p>正好剪这个<a href="https://www.bilibili.com/video/BV1ni4y1F79U">视频</a>的时候</p><p>需要转码（从mkv到mov）</p><p>在网上找了好多解决方案，最后就选择了这个最“程序员的”</p><p>写一篇关于这个ffmpeg小工具的吧</p><span id="more"></span><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="PRO"><a href="#PRO" class="headerlink" title="PRO"></a>PRO</h2><p><strong>FFmpeg：Fast Forward Moving Picture Experts Group</strong></p><p><code>FFmpeg</code>是一套可以用来<code>记录</code>、<code>转换数字音频</code>、<code>视频</code>，并能将其转化为<code>流</code>的开源计算机<code>程序</code>。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频&#x2F;视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多codec都是从头开发的。 ffmpeg项目由以下几部分组成: 1.ffmpeg 视频文件转换命令行工具,也支持经过实时电视卡抓取和编码成视频文件. 2.ffserver 基于HTTP、RTSP用于实时广播的多媒体服务器.也支持时间平移 3.ffplay 用 SDL和FFmpeg库开发的一个简单的媒体播放器 4.libavcodec 一个包含了所有FFmpeg音视频编解码器的库.为了保证最优性能和高可复用性,大多数编解码器从头开发的. 5.libavformat 一个包含了所有的普通音视格式的解析器和产生器的库</p><!--more--><h2 id="说人话："><a href="#说人话：" class="headerlink" title="说人话："></a>说人话：</h2><p>一个完整的，跨平台的音视频记录，转换，流传输的解决方案</p><p>具体就是帮你转换<strong>媒体的格式</strong>，<strong>播放视频</strong>，<strong>拼接视频</strong>，<strong>转换gif</strong>等</p><p>太多了不一一枚举</p><p>详细的可以跳到功能实践去看</p><p><img src="https://s3.ax1x.com/2021/01/02/sSGdlF.md.png" alt="ffmpeg1"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里以Macos系统为主进行介绍</p><p>点击上面图片的Download<img src="https://s3.ax1x.com/2021/01/02/sSGwy4.png" alt="ffmpeg2"></p><p>找到苹果的图标，下载这个Static builds for macOS 64-bit（Source Code我们用不着</p><p>下载下来减压后是一个exe文件</p><p>点击运行后会打开终端，然后自行就安装完了</p><p><img src="https://s3.ax1x.com/2021/01/02/sSG0OJ.png" alt="ffmpeg3"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><del>不要听我瞎逼逼</del>，英语好的建议直接去<a href="https://ffmpeg.org/ffmpeg.html#toc-Synopsis">官网</a></p><p>在前面我会介绍案例让程序员之外的人能够理解，后面就是程序内容了</p><p>希望大家各取所需</p><h2 id="大纲（Synopsis"><a href="#大纲（Synopsis" class="headerlink" title="大纲（Synopsis)"></a>大纲（Synopsis)</h2><p>ffmpeg [global_options] {[input_file_options] -i input_url} … {[output_file_options] output_url} …</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><h3 id="主要参数，不必强记，结合后面的示例理解"><a href="#主要参数，不必强记，结合后面的示例理解" class="headerlink" title="主要参数，不必强记，结合后面的示例理解"></a>主要参数，不必强记，结合后面的示例理解</h3><p><code>-i</code>——设置输入档名。<br><code> -f</code>——设置输出格式。<br><code> -y</code>——若输出文件已存在时则覆盖文件。<br><code> -fs</code>——超过指定的文件大小时则结束转换。<br> <code>-ss</code>——从指定时间开始转换。<br> <code>-t</code>从-ss时间开始转换（如-ss 00:00:01.00 -t 00:00:10.00即从00:00:01.00开始到00:00:11.00）。<br><code> -title</code>——设置标题。<br><code> -timestamp</code>——设置时间戳。<br> <code>-vsync</code>——增减Frame使影音同步。</p><h3 id="视频参数"><a href="#视频参数" class="headerlink" title="视频参数"></a>视频参数</h3><p> <code>-b:v</code>——设置视频流量，默认为200Kbit&#x2F;秒。（单位请引用下方注意事项）<br> <code>-r</code>——设置帧率值，默认为25。<br> <code>-s</code>——设置画面的宽与高。<br> <code>-aspect</code>——设置画面的比例。<br><code> -vn</code>——不处理视频，于仅针对声音做处理时使用。<br> <code>-vcodec( -c:v )</code>——设置视频视频编解码器，未设置时则使用与输入文件相同之编解码器。</p><h3 id="声音参数"><a href="#声音参数" class="headerlink" title="声音参数"></a>声音参数</h3><p> <code>-b:a</code>——设置每Channel（最近的SVN版为所有Channel的总合）的流量。（单位请引用下方注意事项）<br><code> -ar</code>——设置采样率。<br> <code>-ac</code>——设置声音的Channel数。<br><code>-acodec ( -c:a )</code>——设置声音编解码器，未设置时与视频相同，使用与输入文件相同之编解码器。<br> <code>-an</code>——不处理声音，于仅针对视频做处理时使用。<br> <code>-vol</code>——设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。）</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p> 以-b:v及-b:a首选项流量时，根据使用的ffmpeg版本，须注意单位会有kbits&#x2F;sec与bits&#x2F;sec的不同。（可用ffmpeg -h显示说明来确认单位。）<br> 例如，单位为bits&#x2F;sec的情况时，欲指定流量64kbps时需输入 -b:a 64k；单位为kbits&#x2F;sec的情况时则需输入 -b:a 64。<br> 以-acodec及-vcodec所指定的编解码器名称，会根据使用的ffmpeg版本而有所不同。例如使用AAC编解码器时，会有输入aac与libfaac的情况。此外，编解码器有分为仅供解码时使用与仅供编码时使用，因此一定要利用ffmpeg -formats确认输入的编解码器是否能运作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在这里假设输入文件都为 input.avi，并且默认路径已经在要转换的文件上</p><h3 id="直接转换视频格式"><a href="#直接转换视频格式" class="headerlink" title="直接转换视频格式"></a>直接转换视频格式</h3><p>这里直接在后面写转化后的格式以及名字就好</p><p>可以通过这个将视频转化为gif</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ffmpeg -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.avi</span> output.mp4<br></code></pre></td></tr></table></figure><h3 id="将视频中一部分转化为gif"><a href="#将视频中一部分转化为gif" class="headerlink" title="将视频中一部分转化为gif"></a>将视频中一部分转化为gif</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// 从视频中第二秒开始，截取时长为3秒的片段转化为 gif</span><br>ffmpeg -t <span class="hljs-number">3</span> -ss <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">02</span> -i <span class="hljs-keyword">small</span>.mp<span class="hljs-number">4</span> <span class="hljs-keyword">small</span>-clip.gif<br><span class="hljs-comment">// 默认转化是中等质量模式，若要转化出高质量的 gif，可以修改比特率</span><br>ffmpeg -i <span class="hljs-keyword">small</span>.mp<span class="hljs-number">4</span> -b <span class="hljs-number">2048k</span> <span class="hljs-keyword">small</span>.gif<br></code></pre></td></tr></table></figure><h3 id="加倍速播放视频"><a href="#加倍速播放视频" class="headerlink" title="加倍速播放视频"></a>加倍速播放视频</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">ffmpeg -i <span class="hljs-keyword">input</span>.<span class="hljs-keyword">mov</span> -filter:v <span class="hljs-string">&quot;setpts=0.5*PTS&quot;</span> output.<span class="hljs-keyword">mov</span><br><span class="hljs-comment">//慢速就是2.0</span><br></code></pre></td></tr></table></figure><h3 id="定义帧率-16fps"><a href="#定义帧率-16fps" class="headerlink" title="定义帧率 16fps:"></a>定义帧率 16fps:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ffmpeg -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.mov</span> -<span class="hljs-attribute">r</span> <span class="hljs-number">16</span> -<span class="hljs-attribute">filter</span>:v <span class="hljs-string">&quot;setpts=0.125*PTS&quot;</span> -an output.mov<br></code></pre></td></tr></table></figure><h3 id="静音视频（移除视频中的音频）"><a href="#静音视频（移除视频中的音频）" class="headerlink" title="静音视频（移除视频中的音频）"></a>静音视频（移除视频中的音频）</h3><p>-an 就是禁止音频输出</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">ffmpeg -i <span class="hljs-keyword">input</span>.<span class="hljs-keyword">mov</span> -<span class="hljs-keyword">an</span> mute-output.<span class="hljs-keyword">mov</span><br></code></pre></td></tr></table></figure><h3 id="视频提取帧"><a href="#视频提取帧" class="headerlink" title="视频提取帧"></a>视频提取帧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将视频提取10帧</span><br>ffmpeg -i index.mp4 -r <span class="hljs-number">10</span> %<span class="hljs-number">03</span>d.jpg;<br></code></pre></td></tr></table></figure><h3 id="将输出文件的视频比特率设置为64-kbit-s"><a href="#将输出文件的视频比特率设置为64-kbit-s" class="headerlink" title="将输出文件的视频比特率设置为64 kbit &#x2F; s:"></a>将输出文件的视频比特率设置为64 kbit &#x2F; s:</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ffmpeg -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.avi</span> -<span class="hljs-selector-tag">b</span>:v <span class="hljs-number">64</span>k -bufsize <span class="hljs-number">64</span>k output.avi<br></code></pre></td></tr></table></figure><h3 id="将输出文件的帧速率强制为24-fps"><a href="#将输出文件的帧速率强制为24-fps" class="headerlink" title="将输出文件的帧速率强制为24 fps:"></a>将输出文件的帧速率强制为24 fps:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ffmpeg -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.avi</span> -<span class="hljs-attribute">r</span> <span class="hljs-number">24</span> output<span class="hljs-selector-class">.avi</span><br></code></pre></td></tr></table></figure><h3 id="将输入文件的帧速率（仅对原始格式有效）强制为1-fps，将输出文件的帧速率强制为24-fps"><a href="#将输入文件的帧速率（仅对原始格式有效）强制为1-fps，将输出文件的帧速率强制为24-fps" class="headerlink" title="将输入文件的帧速率（仅对原始格式有效）强制为1 fps，将输出文件的帧速率强制为24 fps:"></a>将输入文件的帧速率（仅对原始格式有效）强制为1 fps，将输出文件的帧速率强制为24 fps:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ffmpeg -<span class="hljs-attribute">r</span> <span class="hljs-number">1</span> -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.m2v</span> -<span class="hljs-attribute">r</span> <span class="hljs-number">24</span> output<span class="hljs-selector-class">.avi</span><br></code></pre></td></tr></table></figure><h3 id="两路-多路视频拼接，同时播放"><a href="#两路-多路视频拼接，同时播放" class="headerlink" title="两路&#x2F;多路视频拼接，同时播放"></a>两路&#x2F;多路视频拼接，同时播放</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">ffmpeg -i input1.avi -i input2.avi -filter_complex <span class="hljs-string">&quot;<span class="hljs-subst">[0:v]</span>pad=iw*2:ih<span class="hljs-subst">[a]</span>;<span class="hljs-subst">[a]</span><span class="hljs-subst">[1:v]</span>overlay=w:0&quot;</span> -pix_fmt yuv420p -y output_result.mp4<br></code></pre></td></tr></table></figure><p><code>-filter_complex &quot;[0:v]pad=iw*2:ih[a];[a][1:v]overlay=w:0&quot;</code>指的是复杂滤波器的设置。其中<code>[0:v] [1:v]</code>表示输入的第一个和第二个编号。<code>pad </code>用于边界扩充，iw&#x2F;ih分别是输入视频的宽度和高度。<code>[0:v]pad=iw*2:ih[a] </code>表示将第一个输入视频边界扩充，并将扩充好的命名为 [a]，方便后续操作。<code>[a][1:v]overlay=w*1</code> 中的<code>[a][1:v]</code>表示将 [1:v] 叠加到 [a] 上去，并且位置从 w 开始，默认是 <code>width=w</code> 处，h 未写表示 0。</p><h3 id="从输入视频中裁剪一部分输出"><a href="#从输入视频中裁剪一部分输出" class="headerlink" title="从输入视频中裁剪一部分输出"></a>从输入视频中裁剪一部分输出</h3><p>利用 ffmpeg 中的 video filter功能，设置指定的裁剪开始位置和裁剪的宽度和高度即可</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">ffmpeg -i ffmpeg<span class="hljs-number">_</span>test.mp<span class="hljs-number">4</span> -vf <span class="hljs-string">&quot;crop=w:h:x:y&quot;</span> -y ffmpeg<span class="hljs-number">_</span>test<span class="hljs-number">_</span><span class="hljs-keyword">out</span>.mp<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>其中 -i 指定输入视频数据</p><p><code>-vf</code> 是<code>-filter:v</code>的缩略形式告诉 ffmpeg 使用视频滤波器进行次操作</p><p><code>crop=w:h:x:y</code> 中 <code>w</code> 是输出视频的宽，<code>h </code>是输出视频的高，<code>x </code>和<code>y</code>是裁剪开始的坐标值，以左上为坐标原点，向右为 x 方向，向下为 y 方向</p><h3 id="在给定视频指定位置添加水印"><a href="#在给定视频指定位置添加水印" class="headerlink" title="在给定视频指定位置添加水印"></a>在给定视频指定位置添加水印</h3><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">ffmpeg -i ctest.mp4 -vf <span class="hljs-string">&quot;drawtext=fontfile=simhei.ttf: text=&#x27;Original&#x27;:x=620:y=500:fontsize=72:fontcolor=blue:shadowy=2&quot;</span> -<span class="hljs-variable language_">y</span> test_dst.mp4<br></code></pre></td></tr></table></figure><p>其中：</p><p><code>fontfile </code>表示字体类型，要确保存在对应的字体库</p><p><code>text </code>表示要添加的字符串形式的文字内容</p><p><code>fontsize </code>用来设置字体大小，默认大小为 16</p><p><code>fontcolor </code>用来设置字体颜色，默认为 Black</p><p><code>x=620:y=1920</code> 表示文字水印放置的位置</p><p>效果如下</p><p><img src="https://s3.ax1x.com/2021/01/02/sSU0aj.gif" alt="show"></p><h3 id="将视频拆分成图像序列"><a href="#将视频拆分成图像序列" class="headerlink" title="将视频拆分成图像序列"></a>将视频拆分成图像序列</h3><p>直接输入需要分解的视频名，并指定输出图像的格式即可</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">ffmpeg -i video.mpg <span class="hljs-keyword">image</span>%d.jpg<br>ffmpeg -i scene2frame1.mov frame%d.png<br>ffmpeg -i src.mp4 -vframes <span class="hljs-number">200</span> bmp_images/camera_01/%04d.bmp<br>ffmpeg -i src.mp4 -vf <span class="hljs-keyword">scale</span>=<span class="hljs-number">1920</span>:<span class="hljs-number">1080</span> -vframes <span class="hljs-number">200</span> bmp_resize/camera_01/%04d.bmp<br><span class="hljs-comment">//vframes 用于设置提取的帧数。</span><br><span class="hljs-comment">//vf scale 用于设置提取帧之后输出的分辨率，可用于对提取帧进行 resize 处理。</span><br></code></pre></td></tr></table></figure><h1 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h1><h2 id="主要组成"><a href="#主要组成" class="headerlink" title="主要组成"></a>主要组成</h2><p>这部分直接引用自雷神的博客：<a href="https://blog.csdn.net/leixiaohua1020/article/details/11693997">FFMPEG中最关键的结构体之间的关系</a></p><p>FFMPEG中结构体很多。最关键的结构体可以分成以下几类：</p><p>a) 解协议（http,rtsp,rtmp,mms）</p><p>AVIOContext，URLProtocol，URLContext主要存储视音频使用的协议的类型以及状态。URLProtocol存储输入视音频使用的封装格式。每种协议都对应一个URLProtocol结构。（注意：FFMPEG中文件也被当做一种协议“file”）</p><p>b) 解封装（flv,avi,rmvb,mp4）</p><p>AVFormatContext主要存储视音频封装格式中包含的信息；AVInputFormat存储输入视音频使用的封装格式。每种视音频封装格式都对应一个AVInputFormat 结构。</p><p>c) 解码（h264,mpeg2,aac,mp3）</p><p>每个AVStream存储一个视频&#x2F;音频流的相关数据；每个AVStream对应一个AVCodecContext，存储该视频&#x2F;音频流使用解码方式的相关数据；每个AVCodecContext中对应一个AVCodec，包含该视频&#x2F;音频对应的解码器。每种解码器都对应一个AVCodec结构。</p><p>d) 存数据</p><p>视频的话，一般每个 AVPacket 是一帧；音频可能有好几帧</p><p>解码前数据：AVPacket(h264, aac)<br>解码后数据：AVFrame(yuv, pcm)</p><h2 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h2><p>AVUtil：核心工具库，最基础的模块之一，其它模块经常依赖该库做一些基本的音视频处理操作，比如 av_image_fill_arrays（填充原始图像数据到 AVFrame）、av_image_get_buffer_size（根据图像宽高、格式获取填充该图像需要的字节数）、av_get_pix_fmt_name（获取像素格式的名称） 等等。</p><p>AVFormat：文件格式和协议库，最重要的模块之一，封装了 Protocol 层和 Demuxer、Muxer 层。常用于读写文件及文件信息，比如 avformat_write_header（写文件头）、av_write_trailer（写文件尾）、av_read_frame （从文件中读取一帧编码后的图像&#x2F;音频数据）、av_write_frame（往文件中写一帧编码后的图像&#x2F;音频数据）、av_seek_frame（给定一个时间戳，移动读指针到对应位置）等等。</p><p>AVCodec：编解码库，最重要的模块之一。FFmpeg 默认不会添加 libx264、FDK-AAC 等库，但 FFmpeg 可以像一个平台一样，将其它第三方的 Codec 以插件的形式添加进来，并为开发者提供统一的接口。编解码需要用到的函数基本都在该库中，比如 avcodec_find_decoder（找到对应的第三方解码器）、avcodec_decode_video2（使用对应的解码器解码一帧图像&#x2F;音频数据）。</p><p>AVFilter：滤镜库。该模块提供了包括音频特效和视频特效的处理，比如把 “drawbox&#x3D;10:20:200:60:<a href="mailto:&#114;&#101;&#x64;&#64;&#x30;&#x2e;&#x35;">&#114;&#101;&#x64;&#64;&#x30;&#x2e;&#x35;</a>” 这条命令，传递给函数 avfilter_graph_parse() 解析，并传递原始图像数据到该 filter 中，就能在图像坐标为 (10, 20) 的点上生成一个宽高为 (200, 60) 、透明度为 0.5 的红色矩形。</p><p>以上是 FFmpeg 最常用的四个库，此外还有 AVDevice（输入输出设备库）、SwrResample（音频重采样，可转换音频的声道数、数据格式、采样率等格式）、SWScale（可用于处理像素格式转换的库）等就不一一介绍了，实际上，到对应的 FFmpeg 源代码对应的头文件看看都提供了什么函数，就大致能了解该库的作用了。</p><p>在 FFmpeg 中，还有一个类型的 filter 为 bit stream filter，顾名思义，该 filter 处理的是流数据，主要用于某些格式的封装转换行为。比如 AAC 编码，常见的有两种封装格式，一种是 ADTS 的流，一种是封装在 MPEG4 里面的格式，这种格式会在每一帧前面拼接一个由声道、采样率等信息组成的头，该 filter 中的一个类型，名为 aac_adtstoasc，可以很方便地把 ADTS 转换为另一种格式，常用于编码过程中。与之相对应的，H264 也有两种封装格式，一种是 MP4 封装的格式，一种是裸的 H264 格式（一般称为 annexb 封装格式），用于转换的 filter 名为 h264_mp4toannexb。若要使用这两个 filter，需要在编译 ffmpeg 的时候开启：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">--enable-bsf</span>=aac_adtstoasc<br><span class="hljs-attribute">--enable-bsf</span>=h264_mp4toannexb<br>12<br></code></pre></td></tr></table></figure><h2 id="常用-API-分析"><a href="#常用-API-分析" class="headerlink" title="常用 API 分析"></a>常用 API 分析</h2><h3 id="通用-API"><a href="#通用-API" class="headerlink" title="通用 API"></a>通用 API</h3><ol><li>av_register_all</li></ol><p>编译配置（–enable、–disable） FFmpeg 的时候，会生成两个文件：<a href="http://config.mk/">config.mk</a>、config.h。<a href="http://config.mk/">config.mk</a> 会实际上就是 makefile 文件需要包含进去的子模块，会作用在编译阶段，帮助开发者编译出正确的库；而 config.h 是作用在运行阶段，这一阶段将确保需要注册哪些容器以及编解码格式到 FFmpeg 框架中。所以该函数的内部实现会先调用 avcodec_register_all 来注册所有 config.h 里面开放的编解码器，然后会注册所有的 Muxer 和 Demuxer，最后注册所有的 Protocol。如此，在 config 的过程中，enable、disable 的选项就作用到了运行时，该函数的源码分析涉及的源文件包括 url.c、alformats.c、mux.c、format.c 等文件。</p><ol><li>av_find_codec</li></ol><p>在 avcodec_register_all 函数里面已经把编码器和解码器都存放到了一个链表中，因此都是从该链表进行遍历查找</p><ol><li>avcodec_open2 分析</li></ol><p>打开编解码其的时候就会用到该函数，参数有三个，第一个是 AVCodecContext，如果想要传入私有参数，比如 preset、tune、profile，则可以为设置到 priv_data 参数中。具体到函数实现时，它会找到对应的实现文件，比如，如果打开的是 libx264 编码器，那么实际上的 Codec 为 libx264.c 中的 ff_libx264_encoder，Codec 的生命周期方法就会委托给该结构体对应的函数指针所指向的函数。open 对应的就是 init 函数指针所指向的函数，该函数会调用具体的编码库的 API，并以对应的 AVCodecContext 中的 priv_data 来填充对应第三方库所需要的私有参数。</p><ol><li>av_codec_close 分析</li></ol><p>和 open 类似，找到对应的实现文件中的 close 函数指针所指向的函数，然后该函数会调用对应第三方库的 API 来关闭掉对应编码库。</p><p>其实 FFmpeg 所做的事情就是透明化所有的编码库，用自己的封装来为开发者提供统一的接口，开发者只需要在打开编解码库时指定编解码器的 ID 即可，之后编码、解码、关闭资源都会找到对应的实现文件去做具体的事情。</p><h3 id="解码时用到的-API"><a href="#解码时用到的-API" class="headerlink" title="解码时用到的 API"></a>解码时用到的 API</h3><ol><li>avformat_open_input</li></ol><p>该函数会根据提供的的文件路径判断文件的格式，继而决定使用哪一个 Demuxer。比如，如果是 flv 文件，那么 Demuxer 就会使用对应的 ff_flv_demuxer，之后关键的生命周期方法 read_header、read_packet、read_seek、read_close 都会使用 ff_flv_demuxer 中函数指针指定的函数。read_header 函数会将 AVStream 结构体构造好。</p><ol><li>avformat_find_stream_info</li></ol><p>这个函数非常重要，该方法的作用是将所有 Stream 的 MetaData 信息填充好，方法内部会先查找对应的解码器，并打开，紧接着利用 Demuxer 中的 read_packet 函数读取一段数据进行解码，解码数据越多，分析出的流数据就会越准确，本地资源会比较快，网络资源则较慢。该函数提供了几个参数可以控制读取数据的长度，分别为：probe_size、max_analyze、fps_probe_size，这几个参数的值越小，读取速度越快，信息则相对不够准确。</p><ol><li>av_read_frame</li></ol><p>该方法读取出来的数据是 AVPacket，该函数的实现首先会委托到 Demuxer 的 read_packet 方法，然后在该函数中把未处理完的压缩数据进行缓存处理。</p><ol><li>avcodec_decode</li></ol><p>如果要解码 H264，会找到 ff_h264_decoder，其中最重要的三个声明周期方法为 init、decode、close。</p><h3 id="编码时用到的-API"><a href="#编码时用到的-API" class="headerlink" title="编码时用到的 API"></a>编码时用到的 API</h3><ol><li>avformat_alloc_output_context</li></ol><p>和 avformat_open_input 类似，该函数最终会找到对应的格式复制给 AVFormatContext 中的 oformat。</p><ol><li>avio_open2</li></ol><p>该方法首先调用函数 ffurl_open，构造除 URLContext，这个结构体包含了 URLProtocol，接着调用 avio_alloc_context 方法，分配除 AVIOContext 结构体，并将上一步构造出来的 URLProtocol 传递进来，然后复制给 AVFormatContext 的属性。</p><p>编码步骤其实是解码的一个逆过程，解码过程中的 av_find_stream_info 对应到编码就是 avformat_new_stream 和 av_format_write_header，该步骤会将音频流或视频流的信息填充好，分配出 AVStream 结构体。read_header 则对应于 av_write_header，再之后是 av_write_frame、av_write_tailer，注意，av_write_header 和 av_write_tailer 必须成对出现。avcodec_encode 等函数就不一一介绍了。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li>PTS 和 DTS</li></ol><p>DTS（Decoding Time Stamp）：解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧图像</p><p>PTS（Presentation Time Stamp）：显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧图像</p><p>DTS、PTS 是在编码的时候由编码器生成的，当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序一致。但如果有 B 帧时，解码顺序和播放顺序就有区别了。</p><p>比如一个视频中，帧的显示顺序是：I B B P，现在我们需要在解码 B 帧时知道 P 帧中信息，因此这几帧在视频流中的顺序可能是：I P B B，这时候就体现出 DTS 和 PTS 的作用了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。顺序大概如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PTS</span>: <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">DTS</span>: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Stream</span>: I P B B<br><span class="hljs-attribute">123</span><br></code></pre></td></tr></table></figure><ol><li>time_base</li></ol><p>时间单位，比如帧率为 30帧&#x2F;s 的视频，time_base 就等于 1&#x2F;30，此时 pts * time_base 就等于当前帧显示的时间</p><ol><li>音视频的同步</li></ol><p>音频也有 DTS、PTS 的概念，但是音频没有 B 帧，不需要双向预测，所以音频帧的 DTS、PTS 顺序是一致的。</p><p>音视频同步的方式一般有三种：同步视频到音频、同步音频到视频、同步音频和视频到外部时钟。 因为音频帧的 DTS、PTS 顺序一致，因此一般情况下，都采用同步视频到音频的方式。</p><ol><li>gop</li></ol><p>group of picture，可以认为是两个 I 帧之间的间隔，通常设置为帧率的两倍即可</p><ol><li>参考帧</li></ol><p>最多可以设置为 16 个， 通常，该值越大，压缩率越高，但大于6后对压缩率的贡献很低，推荐默认值 6。</p><ol><li>align</li></ol><p>很多图像相关的函数中都有这个参数，是 YUV 通道对齐时的字节单位，如果不确定，可以设为 1，但效率可能不太高。</p><p>参考：<a href="https://stackoverflow.com/questions/35678041/what-is-linesize-alignment-meaning">what is ‘linesize alignment’ meaning?</a></p><h2 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h2><p>主要参考：<a href="https://trac.ffmpeg.org/wiki/Encode/H.264">H.264 Video Encoding Guide</a></p><p>在 x264 中，码率控制方式主要有（通常只推荐 CRF、Two-Pass ABR 两种）：</p><ol><li>CQP（Constant Quantization Parameter ）。值越大，压缩率越大，质量越低。使用方法（虽然这里使用的是命令行的形式，但在编写代码时也有参考价值）：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">ffmpeg -i <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span> -c:v libx264 -qp 23 <span class="hljs-tag">&lt;<span class="hljs-name">output</span>&gt;</span><br>ffmpeg -i <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span> -c:v libx265 -x265-params qp=23 <span class="hljs-tag">&lt;<span class="hljs-name">output</span>&gt;</span><br>12<br></code></pre></td></tr></table></figure><p>仅适用于视频编码研究，除非确切知道自己在做什么，否则不要使用这种模式。</p><ol><li>ABR（Average Bitrate）。使用方法：</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">fmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx264 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M <span class="hljs-symbol">&lt;output&gt;</span><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx265 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M <span class="hljs-symbol">&lt;output&gt;</span><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libvpx-vp9 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M <span class="hljs-symbol">&lt;output&gt;</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>避免使用这种模式！x264 开发者甚至说永远不要用它，因为质量不可控。</p><ol><li>CBR（Constant BitRate）。</li></ol><p>使用：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx264 -x264-params <span class="hljs-string">&quot;nal-hrd=cbr:force-cfr=1&quot;</span> -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -minrate <span class="hljs-number">1</span>M -maxrate <span class="hljs-number">1</span>M -bufsize <span class="hljs-number">2</span>M <span class="hljs-symbol">&lt;output&gt;</span><br>// VP9<br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libvpx-vp9 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -maxrate <span class="hljs-number">1</span>M -minrate <span class="hljs-number">1</span>M <span class="hljs-symbol">&lt;output&gt;</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>输出文件需要是 .ts 文件，因为 MP4 不支持 NAL 填充，如果输入文件易于编码，使用这种方式会浪费带宽，适用于视频直播。</p><ol><li>CRF（Constant Rate Factor）。</li></ol><p>使用方法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx264 -crf <span class="hljs-number">23</span> <span class="hljs-symbol">&lt;output&gt;</span><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx265 -crf <span class="hljs-number">28</span> <span class="hljs-symbol">&lt;output&gt;</span><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libvpx-vp9 -crf <span class="hljs-number">30</span> -<span class="hljs-variable">b:v</span> <span class="hljs-number">0</span> <span class="hljs-symbol">&lt;output&gt;</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>x264 默认值是 23（推荐 17 ~ 28），x265 是28（推荐 24 ~ 34），可用值是 0 到 51。值越小编码质量越好，码率越高（每 -6，比特率加倍），值等于 0 时则为无损编码。注意：如果不是基于 ffmpeg 的播放器，可能无法解码无损压缩的视频。</p><p>很方便，但比特率、文件大小不好控制 ，适用于文件存储或需要实现最好的质量的场景；不适用于流媒体。</p><p>在代码中使用时，通过 av_dict_set 设置到 AVDictionary 中，并作为参数传递给 avcodec_open2 即可</p><ol><li>Two-Pass ABR</li></ol><p>用于限制输出文件的大小，比如预期视频文件有 10min(600s)，200 MB：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">200 </span>* <span class="hljs-number">8192</span> / <span class="hljs-number">600</span> = ~<span class="hljs-number">2730</span> Kb<br><span class="hljs-symbol">2730 </span>- <span class="hljs-number">128</span>(音频常用的比特率) = <span class="hljs-number">2602</span> kb<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>那么：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ffmpeg -<span class="hljs-attribute">y</span> -i input -c:v libx264 -b:v <span class="hljs-number">2600</span>k -pass <span class="hljs-number">1</span> -c:a aac -b:a <span class="hljs-number">128</span>k -f mp4 /dev/null &amp;&amp; \<br>ffmpeg -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span> -c:v libx264 -<span class="hljs-selector-tag">b</span>:v <span class="hljs-number">2600</span>k -pass <span class="hljs-number">2</span> -c:<span class="hljs-selector-tag">a</span> aac -<span class="hljs-selector-tag">b</span>:<span class="hljs-selector-tag">a</span> <span class="hljs-number">128</span>k output<span class="hljs-selector-class">.mp4</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>如果是 Windows 环境， &#x2F;dev&#x2F;null 换为 NUL，\ 换为 ^</p><p>但我一直不知道在代码中应该怎么使用这种模式，如果有了解的请指教。</p><ol><li>VBV（Video Buffer Verifier）</li></ol><p>可以确保最大码率限制在一个范围里，对于流式传输非常有用，可以配合到 （2-Pass）ABR 或 CRF 模式一起使用，使用方法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">// crf &amp; vbv<br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx264 -crf <span class="hljs-number">23</span> -maxrate <span class="hljs-number">1</span>M -bufsize <span class="hljs-number">2</span>M <span class="hljs-symbol">&lt;output&gt;</span><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx265 -crf <span class="hljs-number">28</span> -x265-params vbv-maxrate=<span class="hljs-number">1000</span>:vbv-bufsize=<span class="hljs-number">2000</span> <span class="hljs-symbol">&lt;output&gt;</span><br><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libvpx-vp9 -crf <span class="hljs-number">30</span> -<span class="hljs-variable">b:v</span> <span class="hljs-number">2</span>M <span class="hljs-symbol">&lt;output&gt;</span><br><br>// <span class="hljs-number">2</span>-pass abr &amp; vbv<br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx264 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -maxrate <span class="hljs-number">1</span>M -bufsize <span class="hljs-number">2</span>M -pass <span class="hljs-number">1</span> -<span class="hljs-keyword">f</span> mp4 /dev/null<br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx264 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -maxrate <span class="hljs-number">1</span>M -bufsize <span class="hljs-number">2</span>M -pass <span class="hljs-number">2</span> <span class="hljs-symbol">&lt;output&gt;</span><br><br><br><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx265 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -x265-params pass=<span class="hljs-number">1</span>:vbv-maxrate=<span class="hljs-number">1000</span>:vbv-bufsize=<span class="hljs-number">2000</span> -<span class="hljs-keyword">f</span> mp4 /dev/null<br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libx265 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -x265-params pass=<span class="hljs-number">2</span>:vbv-maxrate=<span class="hljs-number">1000</span>:vbv-bufsize=<span class="hljs-number">2000</span> <span class="hljs-symbol">&lt;output&gt;</span><br><br><br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libvpx-vp9 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -maxrate <span class="hljs-number">1</span>M -bufsize <span class="hljs-number">2</span>M -pass <span class="hljs-number">1</span> -<span class="hljs-keyword">f</span> webm /dev/null<br>ffmpeg -i <span class="hljs-symbol">&lt;input&gt;</span> -<span class="hljs-keyword">c</span>:v libvpx-vp9 -<span class="hljs-variable">b:v</span> <span class="hljs-number">1</span>M -maxrate <span class="hljs-number">1</span>M -bufsize <span class="hljs-number">2</span>M -pass <span class="hljs-number">2</span> <span class="hljs-symbol">&lt;output&gt;</span><br><span class="hljs-number">123456789101112131415161718</span><br></code></pre></td></tr></table></figure><p>编写代码的话，指定 AVCodecContext 的 rc_max_rate 和 rc_buffer_size 即可。bufsize 根据你希望比特率获得多大的可变性而设置，默认为 maxrate 的两倍，如果想限制流的比特率，可以设置为 maxrate 的一半。</p><p>配合 CRF 模式使用的时候，如果设置的 crf 值过低，视频码率可能超出 -maxrate 的时候，编码器会自动调整 crf，避免出现较大的码率波动。然而，x264 不会严格控制你指定的最大码率，除非使用 2 pass 模式。</p><ol><li>preset、tune</li></ol><p>如果参数的设置有些复杂，可以使用 preset、tune 参数（编写代码时可以通过 av_dict_set 设置），preset 是一个用于控制编码速度压缩比的选项集合，编码速度越慢，压缩率越高。可选值有：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs llvm">ultrafast<br>superfast<br>veryfast<br>faster<br><span class="hljs-keyword">fast</span><br>medium – <span class="hljs-keyword">default</span> preset<br>slow<br>slower<br>veryslow<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><p>编码速度对比：</p><p><img src="https://s3.ax1x.com/2021/01/02/sStw6S.png" alt="preset 编码速度对比"></p><p>tune 可根据输入情况（不同的视频类型等）调整设置（比如对画面作出一些优化），可选值有：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">film        – use for high quality movie content<span class="hljs-comment">; lowers deblocking</span><br>animation   – good for cartoons<span class="hljs-comment">; uses higher deblocking and more reference frames</span><br>grain       – preserves the grain structure in old, grainy film material（纹理调整）<br>stillimage  – good for slideshow-like content（适用于 ppt 等内容）<br>fastdecode  – allows faster decoding <span class="hljs-keyword">by </span><span class="hljs-keyword">disabling </span>certain filters<br>zerolatency – good for fast encoding <span class="hljs-keyword">and </span>low-latency streaming（适用于快速编码及低延迟流）<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1.<a href="https://www.cnblogs.com/phillee/p/12244970.html">https://www.cnblogs.com/phillee/p/12244970.html</a></p><p>2.<a href="https://ffmpeg.org/ffmpeg.html#toc-Synopsis">https://ffmpeg.org/ffmpeg.html#toc-Synopsis</a></p><p>3.<a href="https://blog.csdn.net/u011330638/article/details/82392268?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&spm=1001.2101.3001.4242">https://blog.csdn.net/u011330638/article/details/82392268?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&amp;spm=1001.2101.3001.4242</a></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶</title>
    <link href="/Blogs/2025/08/28/Python%E8%BF%9B%E9%98%B6/"/>
    <url>/Blogs/2025/08/28/Python%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片 :"></a>切片 <code>:</code></h2><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作</p><p>取前3个元素，用一行代码就可以完成切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>L[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br>[<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;Sarah&#x27;</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素。</p><ul><li><p>如果第一个索引是<code>0</code>，还可以省略</p></li><li><p>什么都不写，只写<code>[:]</code>就可以原样复制一个list</p></li></ul><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)[:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>前10个数，每两个取一个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">L[:<span class="hljs-number">10</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个<code>list</code>或<code>tuple</code>，我们可以通过<code>for</code>循环来遍历这个<code>list</code>或<code>tuple</code>，这种遍历我们称为迭代（Iteration）</p><p>Python的<code>for</code>循环抽象程度要高于C的<code>for</code>循环，因为Python的<code>for</code>循环不仅可以用在<code>list</code>或<code>tuple</code>上，还可以作用在其他可迭代对象上。</p><p><code>list</code>这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如<code>dict</code>就可以迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(key)<br></code></pre></td></tr></table></figure><p>判断一个对象是可迭代对象呢？方法是通过<code>collections.abc</code>模块的<code>Iterable</code>类型判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable) <span class="hljs-comment"># str是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], Iterable) <span class="hljs-comment"># list是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable) <span class="hljs-comment"># 整数是否可迭代</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式</p><p>生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br></code></pre></td></tr></table></figure><p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来</p><h3 id="if形式"><a href="#if形式" class="headerlink" title="if形式"></a>if形式</h3><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">64</span>, <span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure><h3 id="if-else-写法"><a href="#if-else-写法" class="headerlink" title="if else 写法"></a>if else 写法</h3><p>因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br></code></pre></td></tr></table></figure><h3 id="两重循环"><a href="#两重循环" class="headerlink" title="两重循环"></a>两重循环</h3><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[m + n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABC&#x27;</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;XYZ&#x27;</span>]<br>[<span class="hljs-string">&#x27;AX&#x27;</span>, <span class="hljs-string">&#x27;AY&#x27;</span>, <span class="hljs-string">&#x27;AZ&#x27;</span>, <span class="hljs-string">&#x27;BX&#x27;</span>, <span class="hljs-string">&#x27;BY&#x27;</span>, <span class="hljs-string">&#x27;BZ&#x27;</span>, <span class="hljs-string">&#x27;CX&#x27;</span>, <span class="hljs-string">&#x27;CY&#x27;</span>, <span class="hljs-string">&#x27;CZ&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="特殊技巧"><a href="#特殊技巧" class="headerlink" title="特殊技巧"></a>特殊技巧</h3><p>运用列表生成式，可以写出非常简洁的代码。</p><h4 id="列出当前目录下的所有文件和目录名"><a href="#列出当前目录下的所有文件和目录名" class="headerlink" title="列出当前目录下的所有文件和目录名"></a>列出当前目录下的所有文件和目录名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os <span class="hljs-comment"># 导入os模块，模块的概念后面讲到</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[d <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)] <span class="hljs-comment"># os.listdir可以列出文件和目录</span><br>[<span class="hljs-string">&#x27;.emacs.d&#x27;</span>, <span class="hljs-string">&#x27;.ssh&#x27;</span>, <span class="hljs-string">&#x27;.Trash&#x27;</span>, <span class="hljs-string">&#x27;Adlm&#x27;</span>, <span class="hljs-string">&#x27;Applications&#x27;</span>, <span class="hljs-string">&#x27;Desktop&#x27;</span>, <span class="hljs-string">&#x27;Documents&#x27;</span>, <span class="hljs-string">&#x27;Downloads&#x27;</span>, <span class="hljs-string">&#x27;Library&#x27;</span>, <span class="hljs-string">&#x27;Movies&#x27;</span>, <span class="hljs-string">&#x27;Music&#x27;</span>, <span class="hljs-string">&#x27;Pictures&#x27;</span>, <span class="hljs-string">&#x27;Public&#x27;</span>, <span class="hljs-string">&#x27;VirtualBox VMs&#x27;</span>, <span class="hljs-string">&#x27;Workspace&#x27;</span>, <span class="hljs-string">&#x27;XCode&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="列表生成式也可以使用两个变量来生成list："><a href="#列表生成式也可以使用两个变量来生成list：" class="headerlink" title="列表生成式也可以使用两个变量来生成list："></a>列表生成式也可以使用两个变量来生成list：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span> &#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>[k + <span class="hljs-string">&#x27;=&#x27;</span> + v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()]<br>[<span class="hljs-string">&#x27;y=B&#x27;</span>, <span class="hljs-string">&#x27;x=A&#x27;</span>, <span class="hljs-string">&#x27;z=C&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="把一个list中所有的字符串变成小写："><a href="#把一个list中所有的字符串变成小写：" class="headerlink" title="把一个list中所有的字符串变成小写："></a>把一个list中所有的字符串变成小写：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>L = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>, <span class="hljs-string">&#x27;IBM&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[s.lower() <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> L]<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;ibm&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><p>要创建一个generator，有很多种方法。</p><h3 id="第一种方法把一个列表生成式的-改成"><a href="#第一种方法把一个列表生成式的-改成" class="headerlink" title="第一种方法把一个列表生成式的[]改成()"></a>第一种方法把一个列表生成式的<code>[]</code>改成<code>()</code></h3><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">L = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">L</span><br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">g</span><br>&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;<br></code></pre></td></tr></table></figure><p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个generator。</p><p>可以通过<code>next()</code>函数获得generator的下一个返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>使用<code>for</code>循环迭代，因为generator也是可迭代对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h3 id="第二种方法（在函数定义中包含yield关键字"><a href="#第二种方法（在函数定义中包含yield关键字" class="headerlink" title="第二种方法（在函数定义中包含yield关键字"></a>第二种方法（在函数定义中包含<code>yield</code>关键字</h3><p>把<code>fib</code>函数变成generator函数，只需要把<code>print(b)</code>改为<code>yield b</code>就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):<br>    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-built_in">max</span>:<br>        <span class="hljs-keyword">yield</span> b<br>        a, b = b, a + b<br>        n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br></code></pre></td></tr></table></figure><p>这就是定义generator的另一种方法。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator函数，调用一个generator函数将返回一个generator：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = fib(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>这里，最难理解的就是generator函数和普通函数的执行流程不一样。普通函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>举个简单的例子，定义一个generator函数，依次返回数字1，3，5</p><p>注意</p><blockquote><p>调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。</p><p>不能每次都这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">next</span>(odd())<br></code></pre></td></tr></table></figure></blockquote><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>变量可以指向函数</p><p>比如<code>abs(-10)</code>是函数调用，而<code>abs</code>是函数本身</p><p>要获得函数调用结果，我们可以把结果赋值给变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-built_in">abs</span>(-<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>如果把函数本身赋值给变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">abs</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f(-<span class="hljs-number">10</span>)<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p><h3 id="函数名也是变量（要点）"><a href="#函数名也是变量（要点）" class="headerlink" title="函数名也是变量（要点）"></a>函数名也是变量（要点）</h3><p>那么函数名是什么呢？函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p><p>如果把<code>abs</code>指向其他对象，会有什么情况发生？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span> = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(-<span class="hljs-number">10</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span><br></code></pre></td></tr></table></figure><p>把<code>abs</code>指向<code>10</code>后，就无法通过<code>abs(-10)</code>调用该函数了！因为<code>abs</code>这个变量已经不指向求绝对值函数而是指向一个整数<code>10</code>！</p><p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复<code>abs</code>函数，请重启Python交互环境。</p><p>注：由于<code>abs</code>函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改<code>abs</code>变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code>。</p><h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><p>一个最简单的高阶函数：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">def add(<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, f):<br>    <span class="hljs-keyword">return</span> f(<span class="hljs-variable language_">x</span>) + f(<span class="hljs-variable language_">y</span>)<br></code></pre></td></tr></table></figure><p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，根据函数定义，我们可以推导计算过程为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = -<span class="hljs-number">5</span><br>y = <span class="hljs-number">6</span><br>f = <span class="hljs-built_in">abs</span><br>f(x) + f(y) ==&gt; <span class="hljs-built_in">abs</span>(-<span class="hljs-number">5</span>) + <span class="hljs-built_in">abs</span>(<span class="hljs-number">6</span>) ==&gt; <span class="hljs-number">11</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lazy_sum</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>():<br>        ax = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args:<br>            ax = ax + n<br>        <span class="hljs-keyword">return</span> ax<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><p>当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f1 = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f2 = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f1==f2</span><br>False<br></code></pre></td></tr></table></figure><p><code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>注意到返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。我们来看一个例子：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> <span class="hljs-keyword">count</span>():<br>    fs = []<br>    <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">def</span> f():<br>             <span class="hljs-keyword">return</span> i*i<br>        fs.<span class="hljs-keyword">append</span>(f)<br>    <span class="hljs-keyword">return</span> fs<br><br>f1, f2, f3 = <span class="hljs-keyword">count</span>()<br></code></pre></td></tr></table></figure><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p><p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">f1</span>()</span><br><span class="hljs-number">9</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">f2</span>()</span><br><span class="hljs-number">9</span><br>&gt;&gt;&gt; <span class="hljs-function"><span class="hljs-title">f3</span>()</span><br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>全部都是<code>9</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p><p> 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><h3 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h3><p>使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>():<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>        <span class="hljs-comment"># 仅读取x的值:</span><br>        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> fn<br><br>f = inc()<br><span class="hljs-built_in">print</span>(f()) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(f()) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><p>但是，如果对外层变量赋值，由于Python解释器会把<code>x</code>当作函数<code>fn()</code>的局部变量，它会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>        <span class="hljs-comment"># nonlocal x</span><br>        x = x + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">return</span> fn<br><br>f = inc()<br><span class="hljs-built_in">print</span>(f()) <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-keyword">lambda</span> x: x * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>f<br>&lt;function &lt;<span class="hljs-keyword">lambda</span>&gt; at <span class="hljs-number">0x101c6ef28</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">5</span>)<br><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>通过对比可以看出，匿名函数<code>lambda x: x * x</code>实际上就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。</p><p>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p><p>本质上，decorator就是一个返回函数的高阶函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call %s():&#x27;</span> % func.__name__)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-comment"># 我们要借助Python的@语法，把decorator置于函数的定义处</span><br><span class="hljs-comment"># 相当于执行了语句：now = log(now)</span><br><span class="hljs-meta">@log</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">now</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2023-7-8&#x27;</span>)<br><span class="hljs-comment"># 函数对象有一个__name__属性（注意：是前后各两个下划线），可以拿到函数的名字：</span><br>now.__name__<br>now()<br></code></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">int2</span>(<span class="hljs-params">x, base=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x, base)<br></code></pre></td></tr></table></figure><p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> functools<br><span class="hljs-meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>int2(<span class="hljs-string">&#x27;1000000&#x27;</span>)<br><span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p><p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">int2 = functools.<span class="hljs-keyword">partial</span>(<span class="hljs-built_in">int</span>, <span class="hljs-keyword">base</span>=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>实际上固定了int()函数的关键字参数<code>base</code>，也就是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">int2</span><span class="hljs-params">(<span class="hljs-string">&#x27;10010&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kw = &#123; <span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">2</span> &#125;<br><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-string">&#x27;10010&#x27;</span>, **kw)</span></span><br></code></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行<code>import abc</code>，若成功则说明系统存在此模块。</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>最大的好处是大大提高了代码的可维护性</strong>。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</p><p>使用模块还可以<strong>避免函数名和变量名冲突</strong>。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点<a href="http://docs.python.org/3/library/functions.html">这里</a>查看Python的所有内置函数。</p><p>你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了<strong>按目录来组织模块的方法，称为包（Package）</strong>。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p><p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code>。</p><p>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">mycompany<br> ├─ web<br> │  ├─ __init__.py<br> │  ├─ utils.py<br> │  └─ www.py<br> ├─ __init__.py<br> ├─ abc.py<br> └─ utils.py<br></code></pre></td></tr></table></figure><p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p><p> 自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块</p><h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><h3 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h3><p>编写一个<code>hello</code>的模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&#x27; a test module &#x27;</span><br><br>__author__ = <span class="hljs-string">&#x27;Michael Liao&#x27;</span><br><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    args = sys.argv<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args)==<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(args)==<span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % args[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Too many arguments!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><p>第1行和第2行是标准注释，第1行注释可以让这个<code>hello.py</code>文件直接在Unix&#x2F;Linux&#x2F;Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</p><p>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</p><p>第6行使用<code>__author__</code>变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；</p><p>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p><p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><p>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_private_1</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, %s&#x27;</span> % name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_private_2</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hi, %s&#x27;</span> % name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greeting</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &gt; <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> _private_1(name)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> _private_2(name)<br></code></pre></td></tr></table></figure><p>我们在模块里公开<code>greeting()</code>函数，而把内部逻辑用private函数隐藏起来了，这样，调用<code>greeting()</code>函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</p><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>使用<code>sys</code>模块的第一步，就是导入该模块：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sys<br></code></pre></td></tr></table></figure><p>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。</p><p><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p><p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;]</code>；</p><p>最后，注意到这两行代码：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">__name__</span>==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">test</span>()</span><br></code></pre></td></tr></table></figure><p>当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>调用<code>hello.test()</code>时，才能打印出<code>Hello, word!</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>hello.test()<br></code></pre></td></tr></table></figure><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>一般来说，第三方库都会在Python官方的<a href="https://pypi.python.org/">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫<a href="https://pypi.python.org/pypi/Pillow/">Pillow</a>，因此，安装Pillow的命令就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install Pillow<br></code></pre></td></tr></table></figure><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&gt;&gt;&gt; <span class="hljs-keyword">import</span> mymodule<br>Traceback (most recent <span class="hljs-keyword">call</span> last):<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;<br>ImportError: No <span class="hljs-keyword">module</span> <span class="hljs-keyword">named</span> mymodule<br></code></pre></td></tr></table></figure><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">&gt;&gt;&gt;</span> <span class="hljs-keyword">import</span> sys<br><span class="hljs-operator">&gt;&gt;&gt;</span> sys.path<br>[&#x27;&#x27;, &#x27;<span class="hljs-regexp">/Library/</span><span class="hljs-type">Frameworks</span><span class="hljs-regexp">/Python.framework/</span><span class="hljs-type">Versions</span><span class="hljs-regexp">/3.6/</span>lib<span class="hljs-regexp">/python36.zip&#x27;, &#x27;/</span><span class="hljs-type">Library</span><span class="hljs-regexp">/Frameworks/</span><span class="hljs-type">Python</span>.framework<span class="hljs-regexp">/Versions/</span><span class="hljs-number">3.6</span><span class="hljs-regexp">/lib/</span>python3.<span class="hljs-number">6</span>&#x27;, <span class="hljs-operator">...</span>, &#x27;<span class="hljs-regexp">/Library/</span><span class="hljs-type">Frameworks</span><span class="hljs-regexp">/Python.framework/</span><span class="hljs-type">Versions</span><span class="hljs-regexp">/3.6/</span>lib<span class="hljs-regexp">/python3.6/</span>site<span class="hljs-operator">-</span>packages&#x27;]<br></code></pre></td></tr></table></figure><p>如果我们要添加自己的搜索目录，有两种方法：</p><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> sys</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">sys.path.append(<span class="hljs-string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>这种方法是在运行时修改，运行结束后失效。</p><p>第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="OOP思想"><a href="#OOP思想" class="headerlink" title="OOP思想"></a>OOP思想</h2><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p><h2 id="OOP思想与面向过程思想对比"><a href="#OOP思想与面向过程思想对比" class="headerlink" title="OOP思想与面向过程思想对比"></a>OOP思想与面向过程思想对比</h2><h3 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h3><p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br></code></pre></td></tr></table></figure><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (std[<span class="hljs-string">&#x27;name&#x27;</span>], std[<span class="hljs-string">&#x27;score&#x27;</span>]))<br></code></pre></td></tr></table></figure><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><p>如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.name, <span class="hljs-variable language_">self</span>.score))<br></code></pre></td></tr></table></figure><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><h2 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">pass</span><br></code></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，创建实例是通过类名+()实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart<br>&lt;__main__.Student <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a67a590</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>Student<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Student&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p><p>可以自由地给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个<code>name</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart.name = <span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>初始化Student对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart&#x27;</span>, <span class="hljs-number">59</span>)<br><br><span class="hljs-built_in">print</span>(lisa.name, lisa.get_grade())<br></code></pre></td></tr></table></figure><h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.__name = name<br>        <span class="hljs-variable language_">self</span>.__score = score<br></code></pre></td></tr></table></figure><p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__name&#x27;</span><br></code></pre></td></tr></table></figure><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart._Student__name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当我们需要编写<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span>(<span class="hljs-symbol">Animal</span>):<br>    <span class="hljs-symbol">pass</span><br></code></pre></td></tr></table></figure><p>当然，也可以对子类增加一些方法，比如Dog类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Eating meat...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。</p><p>这就是著名的“开闭”原则：</p><ul><li><p>对扩展开放：允许新增<code>Animal</code>子类；</p></li><li><p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p></li></ul><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>(object):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(<span class="hljs-string">&#x27;Start...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type"></a>使用<code>type</code></h3><p>首先，我们来判断对象类型，使用<code>type()</code>函数：</p><p>基本类型都可以用<code>type()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;str&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)<br>&lt;<span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>) <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>判断基本数据类型可以直接写<code>int</code>，<code>str</code>等，但如果要判断一个对象是否是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> types<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(fn)==types.FunctionType<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用<code>isinstance()</code></h3><p>对于class的继承关系来说，使用<code>type()</code>就很不方便。我们要判断class的类型，可以使用<code>isinstance()</code>函数。</p><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用<code>dir()</code></h3><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&gt;&gt;&gt; <span class="hljs-string">&#x27;ABC&#x27;</span>.<span class="hljs-built_in">lower</span>()<br><span class="hljs-string">&#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="getatttr-等"><a href="#getatttr-等" class="headerlink" title="getatttr()等"></a><code>getatttr()</code>等</h3><p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-meta">... </span>        <span class="hljs-variable language_">self</span>.x = <span class="hljs-number">9</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">self</span>):<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.x * <span class="hljs-variable language_">self</span>.x<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>obj = MyObject()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;x&#x27;吗？</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.x<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;y&#x27;吗？</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">19</span>) <span class="hljs-comment"># 设置一个属性&#x27;y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;y&#x27;吗？</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 获取属性&#x27;y&#x27;</span><br><span class="hljs-number">19</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.y <span class="hljs-comment"># 获取属性&#x27;y&#x27;</span><br><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>一个正确的用法的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">readImage</span>(<span class="hljs-params">fp</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(fp, <span class="hljs-string">&#x27;read&#x27;</span>):<br>        <span class="hljs-keyword">return</span> readData(fp)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。<code>hasattr()</code>就派上了用场。</p><p>请注意，在Python这类动态语言中，根据鸭子类型，有<code>read()</code>方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要<code>read()</code>方法返回的是有效的图像数据，就不影响读取图像的功能。</p><h2 id="实例属性与类属性"><a href="#实例属性与类属性" class="headerlink" title="实例属性与类属性"></a>实例属性与类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p><p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>s = Student(<span class="hljs-string">&#x27;Bob&#x27;</span>)<br>s.score = <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br></code></pre></td></tr></table></figure><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">... </span>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student() <span class="hljs-comment"># 创建实例s</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 打印类的name属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Michael&#x27;</span> <span class="hljs-comment"># 给实例绑定name属性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br>Michael<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 但是类属性并未消失，用Student.name仍然可以访问</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> s.name <span class="hljs-comment"># 如果删除实例的name属性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br>Student<br></code></pre></td></tr></table></figure><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h1 id="错误、调试和测试错误处理"><a href="#错误、调试和测试错误处理" class="headerlink" title="错误、调试和测试错误处理"></a>错误、调试和测试错误处理</h1><p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数<code>open()</code>，成功时返回文件描述符（就是一个整数），出错时返回<code>-1</code>。</p><p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    r = some_function()<br>    <span class="hljs-keyword">if</span> r==(-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">return</span> (-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># do something</span><br>    <span class="hljs-keyword">return</span> r<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>    r = foo()<br>    <span class="hljs-keyword">if</span> r==(-<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="try-except-finally-的错误处理机制"><a href="#try-except-finally-的错误处理机制" class="headerlink" title="try...except...finally...的错误处理机制"></a><code>try...except...finally...</code>的错误处理机制</h2><h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><p>让我们用一个例子来看看<code>try</code>的机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try...&#x27;</span>)<br>    r = <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result:&#x27;</span>, r)<br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;except:&#x27;</span>, e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p><p>上面的代码在计算<code>10 / 0</code>时会产生一个除法运算错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>...<br><span class="hljs-keyword">except</span>: division by zero<br><span class="hljs-keyword">finally</span>...<br>END<br></code></pre></td></tr></table></figure><p>如果把除数<code>0</code>改成<code>2</code>，则执行结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>...<br>result: <span class="hljs-number">5</span><br><span class="hljs-keyword">finally</span>...<br>END<br></code></pre></td></tr></table></figure><p>错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。没错，可以有多个<code>except</code>来捕获不同类型的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try...&#x27;</span>)<br>    r = <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result:&#x27;</span>, r)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError:&#x27;</span>, e)<br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ZeroDivisionError:&#x27;</span>, e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p><p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>bar()</code>，<code>bar()</code>调用<code>foo()</code>，结果<code>foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看<code>err.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># err.py:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br><br>main()<br></code></pre></td></tr></table></figure><p>执行，结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python3 err.py<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">11</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    main()<br>  File <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> main<br>    bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>  File <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> bar<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br>  File <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> foo<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></table></figure><p>解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：</p><p>错误信息第1行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Traceback</span> (most recent call <span class="hljs-literal">last</span>):<br></code></pre></td></tr></table></figure><p>告诉我们这是错误的跟踪信息。</p><p>第2~3行：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">File</span> <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">11</span>, in &lt;<span class="hljs-keyword">module</span>&gt;<br>  <span class="hljs-built_in">main</span>()<br></code></pre></td></tr></table></figure><p>调用<code>main()</code>出错了，在代码文件<code>err.py</code>的第11行代码，但原因是第9行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">File <span class="hljs-string">&quot;err.py&quot;</span>, <span class="hljs-selector-tag">line</span> <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> <span class="hljs-selector-tag">main</span><br>  <span class="hljs-built_in">bar</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>调用<code>bar(&#39;0&#39;)</code>出错了，在代码文件<code>err.py</code>的第9行代码，但原因是第6行：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">File</span> <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">6</span>, <span class="hljs-function">in bar</span><br><span class="hljs-function">  <span class="hljs-keyword">return</span> <span class="hljs-title">foo</span><span class="hljs-params">(s)</span> * 2</span><br></code></pre></td></tr></table></figure><p>原因是<code>return foo(s) * 2</code>这个语句出错了，但这还不是最终原因，继续往下看：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">File</span> <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">3</span>, in foo<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br></code></pre></td></tr></table></figure><p>原因是<code>return 10 / int(s)</code>这个语句出错了，这是错误产生的源头，因为下面打印了：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">ZeroDivisionError:</span> integer <span class="hljs-keyword">division </span><span class="hljs-keyword">or </span>modulo <span class="hljs-keyword">by </span><span class="hljs-built_in">zero</span><br></code></pre></td></tr></table></figure><p>根据错误类型<code>ZeroDivisionError</code>，我们判断，<code>int(s)</code>本身并没有出错，但是<code>int(s)</code>返回<code>0</code>，在计算<code>10 / 0</code>时出错，至此，找到错误源头</p><h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># err_logging.py</span><br><br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        logging.exception(e)<br><br>main()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出</p><p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查</p><h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p><p>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># err_raise.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> FooError(<span class="hljs-string">&#x27;invalid value: %s&#x27;</span> % s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br>foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行，可以最后跟踪到我们自己定义的错误：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python3</span> err_raise.<span class="hljs-keyword">py</span> <br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;err_throw.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">11</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br>  File <span class="hljs-string">&quot;err_throw.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">8</span>, in foo<br>    raise FooError(<span class="hljs-string">&#x27;invalid value: %s&#x27;</span> % s)<br>__main__.FooError: invalid value: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="断言assert"><a href="#断言assert" class="headerlink" title="断言assert"></a>断言assert</h3><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">assert</span> n != <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;n is zero!&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>断言的开关“-O”是英文大写字母O，不是数字0</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python</span> err.<span class="hljs-keyword">py</span><br>Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  ...<br>AssertionError: n <span class="hljs-keyword">is</span> zero!<br></code></pre></td></tr></table></figure><p>程序中如果到处充斥着<code>assert</code>，和<code>print()</code>相比也好不到哪去。不过，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python</span> -O err.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>logging.info(<span class="hljs-string">&#x27;n = %d&#x27;</span> % n)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure><p><code>logging.info()</code>就可以输出一段文本。运行，发现除了<code>ZeroDivisionError</code>，没有任何信息。怎么回事？</p><p>别急，在<code>import logging</code>之后添加一行配置再试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br></code></pre></td></tr></table></figure><p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h3 id="pbd"><a href="#pbd" class="headerlink" title="pbd"></a>pbd</h3><p>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># err.py</span><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure><p>然后启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python -m pdb err.py</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">s = <span class="hljs-string">&#x27;0&#x27;</span></span><br></code></pre></td></tr></table></figure><p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码<code>-&gt; s = &#39;0&#39;</code>。输入命令<code>l</code>来查看代码：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">(Pdb) l<br> <span class="hljs-number"> 1 </span>    <span class="hljs-comment"># err.py</span><br> <span class="hljs-number"> 2 </span> -&gt; s = &#x27;0&#x27;<br> <span class="hljs-number"> 3 </span>    n = int(s)<br> <span class="hljs-number"> 4 </span>    print(10 / n)<br></code></pre></td></tr></table></figure><p>输入命令<code>n</code>可以单步执行代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">(Pdb) n<br>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span>&lt;<span class="hljs-title">module</span>&gt;<span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> n = int(s)<br>(Pdb) n<br>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">4</span>)</span>&lt;<span class="hljs-title">module</span>&gt;<span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> <span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure><p>任何时候都可以输入命令<code>p 变量名</code>来查看变量：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(Pdb) <span class="hljs-selector-tag">p</span> s<br><span class="hljs-string">&#x27;0&#x27;</span><br>(Pdb) <span class="hljs-selector-tag">p</span> n<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输入命令<code>q</code>结束调试，退出程序：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(Pdb) <span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure><p>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</p><h3 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h3><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># err.py</span><br><span class="hljs-keyword">import</span> pdb<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>pdb.set_trace() <span class="hljs-comment"># 运行到这里会自动暂停</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure><p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作</p><p>如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。</p><p>单元测试通过后有什么意义呢？如果我们对<code>abs()</code>函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对<code>abs()</code>函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p><p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p><p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-comment"># 编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承</span><br><span class="hljs-keyword">from</span> mydict <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDict</span>(unittest.TestCase):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_init</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>(a=<span class="hljs-number">1</span>, b=<span class="hljs-string">&#x27;test&#x27;</span>)<br>        <span class="hljs-comment"># 断言函数返回的结果与1相等</span><br>        <span class="hljs-variable language_">self</span>.assertEqual(d.a, <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">self</span>.assertEqual(d.b, <span class="hljs-string">&#x27;test&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.assertTrue(<span class="hljs-built_in">isinstance</span>(d, <span class="hljs-built_in">dict</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_key</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        d[<span class="hljs-string">&#x27;key&#x27;</span>] = <span class="hljs-string">&#x27;value&#x27;</span><br>        <span class="hljs-variable language_">self</span>.assertEqual(d.key, <span class="hljs-string">&#x27;value&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_attr</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        d.key = <span class="hljs-string">&#x27;value&#x27;</span><br>        <span class="hljs-variable language_">self</span>.assertTrue(<span class="hljs-string">&#x27;key&#x27;</span> <span class="hljs-keyword">in</span> d)<br>        <span class="hljs-variable language_">self</span>.assertEqual(d[<span class="hljs-string">&#x27;key&#x27;</span>], <span class="hljs-string">&#x27;value&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_keyerror</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        <span class="hljs-comment"># 期待抛出指定类型的Error，比如通过d[&#x27;empty&#x27;]访问不存在的key时，断言会抛出KeyError</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.assertRaises(KeyError):<br>            value = d[<span class="hljs-string">&#x27;empty&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_attrerror</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.assertRaises(AttributeError):<br>            value = d.empty<br><br>    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>        unittest.main()<br></code></pre></td></tr></table></figure><h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">if <span class="hljs-strong">__name__</span> == &#x27;<span class="hljs-strong">__main__</span>&#x27;:<br><span class="hljs-code">    unittest.main()</span><br></code></pre></td></tr></table></figure><p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">python</span> mydict_test.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">$ python -m unittest mydict_test<br><span class="hljs-section">.....</span><br><span class="hljs-section">----------------------------------------------------------------------</span><br>Ran 5 tests in 0.000s<br><br>OK<br></code></pre></td></tr></table></figure><p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试</p><h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><p>当我们编写注释时，如果写上这样的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    Function to get absolute value of number.</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Example:</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &gt;&gt;&gt; abs(1)</span><br><span class="hljs-string">    1</span><br><span class="hljs-string">    &gt;&gt;&gt; abs(-1)</span><br><span class="hljs-string">    1</span><br><span class="hljs-string">    &gt;&gt;&gt; abs(0)</span><br><span class="hljs-string">    0</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">return</span> n <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (-n)<br></code></pre></td></tr></table></figure><p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p><p>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>IO在计算机中指Input&#x2F;Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口</p><p>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题</p><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为<strong>同步IO</strong>；</p><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为<strong>异步IO</strong>。</p><p>同步和异步的区别就在于是否等待IO执行的结果</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br></code></pre></td></tr></table></figure><p>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p><p>如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/notfound.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>FileNotFoundError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;/Users/michael/notfound.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f.read()<br><span class="hljs-string">&#x27;Hello, world!&#x27;</span><br></code></pre></td></tr></table></figure><p>最后一步是调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f.close()<br></code></pre></td></tr></table></figure><p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/path/to/file&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(f.read())<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> f:<br>        f.close()<br></code></pre></td></tr></table></figure><p>但是每次都这么写实在太繁琐，所以，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/path/to/file&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br></code></pre></td></tr></table></figure><p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p><p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p><p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>    <span class="hljs-built_in">print</span>(line.strip()) <span class="hljs-comment"># 把末尾的&#x27;\n&#x27;删掉</span><br></code></pre></td></tr></table></figure><h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p><p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p><h3 id="二进制文件rb"><a href="#二进制文件rb" class="headerlink" title="二进制文件rb"></a>二进制文件<code>rb</code></h3><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>&#39;rb&#39;</code>模式打开文件即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>f.read()<br><span class="hljs-string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="hljs-comment"># 十六进制表示的字节</span><br></code></pre></td></tr></table></figure><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.read()</span><br>&#x27;测试&#x27;<br></code></pre></td></tr></table></figure><p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; f = open(<span class="hljs-string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-attribute">encoding</span>=<span class="hljs-string">&#x27;gbk&#x27;</span>, <span class="hljs-attribute">errors</span>=<span class="hljs-string">&#x27;ignore&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.write(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.close()</span><br></code></pre></td></tr></table></figure><p>你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用<code>with</code>语句来得保险：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。</p><p>细心的童鞋会发现，以<code>&#39;w&#39;</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>&#39;a&#39;</code>以追加（append）模式写入。</p><h2 id="StringIO-和ByteIO"><a href="#StringIO-和ByteIO" class="headerlink" title="StringIO 和ByteIO"></a>StringIO 和ByteIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p><p>StringIO顾名思义就是在内存中读写str。</p><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><span class="hljs-meta">&gt;&gt;&gt; </span>f = StringIO()<br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27;world!&#x27;</span>)<br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(f.getvalue())<br>hello world!<br></code></pre></td></tr></table></figure><p><code>getvalue()</code>方法用于获得写入后的str。</p><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><span class="hljs-meta">&gt;&gt;&gt; </span>f = StringIO(<span class="hljs-string">&#x27;Hello!\nHi!\nGoodbye!&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">... </span>    s = f.readline()<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;&#x27;</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">break</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(s.strip())<br>...<br>Hello!<br>Hi!<br>Goodbye!<br></code></pre></td></tr></table></figure><h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><span class="hljs-meta">&gt;&gt;&gt; </span>f = BytesIO()<br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27;中文&#x27;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(f.getvalue())<br><span class="hljs-string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br></code></pre></td></tr></table></figure><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><span class="hljs-meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="hljs-string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>f.read()<br><span class="hljs-string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><h3 id="初始化os指令"><a href="#初始化os指令" class="headerlink" title="初始化os指令"></a>初始化os指令</h3><p>打开Python交互式命令行，我们来看看如何使用<code>os</code>模块的基本功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.name <span class="hljs-comment"># 操作系统类型</span><br><span class="hljs-string">&#x27;posix&#x27;</span><br></code></pre></td></tr></table></figure><p>如果是<code>posix</code>，说明系统是<code>Linux</code>、<code>Unix</code>或<code>Mac OS X</code>，如果是<code>nt</code>，就是<code>Windows</code>系统。</p><p>要获取详细的系统信息，可以调用<code>uname()</code>函数</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个变量中，可以直接查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.environ<br>environ(&#123;<span class="hljs-string">&#x27;VERSIONER_PYTHON_PREFER_32_BIT&#x27;</span>: <span class="hljs-string">&#x27;no&#x27;</span>, <span class="hljs-string">&#x27;TERM_PROGRAM_VERSION&#x27;</span>: <span class="hljs-string">&#x27;326&#x27;</span>, <span class="hljs-string">&#x27;LOGNAME&#x27;</span>: <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;PATH&#x27;</span>: <span class="hljs-string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span>, ...&#125;)<br></code></pre></td></tr></table></figure><p>要获取某个环境变量的值，可以调用<code>os.environ.get(&#39;key&#39;)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.environ.get(<span class="hljs-string">&#x27;PATH&#x27;</span>)<br><span class="hljs-string">&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.environ.get(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>)<br><span class="hljs-string">&#x27;default&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看当前目录的绝对路径:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-string">&#x27;/Users/michael&#x27;</span><br><span class="hljs-comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.join(<span class="hljs-string">&#x27;/Users/michael&#x27;</span>, <span class="hljs-string">&#x27;testdir&#x27;</span>)<br><span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span><br><span class="hljs-comment"># 然后创建一个目录:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.mkdir(<span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span>)<br><span class="hljs-comment"># 删掉一个目录:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.rmdir(<span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span>)<br></code></pre></td></tr></table></figure><p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符</p><p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;&gt;&gt; <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)<br>(<span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="hljs-string">&#x27;file.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="hljs-string">&#x27;/path/to/file.txt&#x27;</span>)<br>(<span class="hljs-string">&#x27;/path/to/file&#x27;</span>, <span class="hljs-string">&#x27;.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对文件重命名:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.rename(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;test.py&#x27;</span>)<br><span class="hljs-comment"># 删掉文件:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.remove(<span class="hljs-string">&#x27;test.py&#x27;</span>)<br></code></pre></td></tr></table></figure><p>列出当前目录下的所有目录，只需要一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">if</span> os.path.isdir(x)]<br>[<span class="hljs-string">&#x27;.lein&#x27;</span>, <span class="hljs-string">&#x27;.local&#x27;</span>, <span class="hljs-string">&#x27;.m2&#x27;</span>, <span class="hljs-string">&#x27;.npm&#x27;</span>, <span class="hljs-string">&#x27;.ssh&#x27;</span>, <span class="hljs-string">&#x27;.Trash&#x27;</span>, <span class="hljs-string">&#x27;.vim&#x27;</span>, <span class="hljs-string">&#x27;Applications&#x27;</span>, <span class="hljs-string">&#x27;Desktop&#x27;</span>, ...]<br></code></pre></td></tr></table></figure><p>要列出所有的<code>.py</code>文件，也只需一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">if</span> os.path.isfile(x) <span class="hljs-keyword">and</span> os.path.splitext(x)[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.py&#x27;</span>]<br>[<span class="hljs-string">&#x27;apis.py&#x27;</span>, <span class="hljs-string">&#x27;config.py&#x27;</span>, <span class="hljs-string">&#x27;models.py&#x27;</span>, <span class="hljs-string">&#x27;pymonitor.py&#x27;</span>, <span class="hljs-string">&#x27;test_db.py&#x27;</span>, <span class="hljs-string">&#x27;urls.py&#x27;</span>, <span class="hljs-string">&#x27;wsgiapp.py&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</p><p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p><p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p><p>Python提供了<code>pickle</code>模块来实现序列化。</p><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>首先，我们尝试把一个对象序列化并写入文件：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> pickle</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">d = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;Bob&#x27;</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">pickle.dumps(d)</span><br>b&#x27;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&#x27;<br></code></pre></td></tr></table></figure><p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;dump.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">pickle.dump(d, f)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">f.close()</span><br></code></pre></td></tr></table></figure><p>看看写入的<code>dump.txt</code>文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。</p><p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;dump.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = pickle.load(f)<br><span class="hljs-meta">&gt;&gt;&gt; </span>f.close()<br><span class="hljs-meta">&gt;&gt;&gt; </span>d<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p><table><thead><tr><th align="left">JSON类型</th><th align="left">Python类型</th></tr></thead><tbody><tr><td align="left">{}</td><td align="left">dict</td></tr><tr><td align="left">[]</td><td align="left">list</td></tr><tr><td align="left">“string”</td><td align="left">str</td></tr><tr><td align="left">1234.56</td><td align="left">int或float</td></tr><tr><td align="left">true&#x2F;false</td><td align="left">True&#x2F;False</td></tr><tr><td align="left">null</td><td align="left">None</td></tr></tbody></table><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;Bob&#x27;</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>json.dumps(d)<br><span class="hljs-string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p><p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>json_str = <span class="hljs-string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>json.loads(json_str)<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的<code>str</code>与JSON的字符串之间转换。</p><h3 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h3><p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>&#123;&#125;</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.score = score<br><br>s = Student(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">88</span>)<br><span class="hljs-built_in">print</span>(json.dumps(s))<br></code></pre></td></tr></table></figure><p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  ...<br>TypeError: &lt;__main__.Student <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10603cc50</span>&gt; <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> JSON serializable<br></code></pre></td></tr></table></figure><p>错误的原因是<code>Student</code>对象不是一个可序列化为JSON的对象。</p><p>如果连<code>class</code>的实例对象都无法序列化为JSON，这肯定不合理！</p><p>别急，我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数：</p><p><a href="https://docs.python.org/3/library/json.html#json.dumps">https://docs.python.org/3/library/json.html#json.dumps</a></p><p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>&#123;&#125;</code>对象。</p><p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">student2dict</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: std.name,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: std.age,<br>        <span class="hljs-string">&#x27;score&#x27;</span>: std.score<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为JSON：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;&gt;&gt; <span class="hljs-title function_">print</span>(<span class="hljs-params">json.dumps(s, <span class="hljs-keyword">default</span>=student2dict)</span>)<br>&#123;<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为JSON。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(json.dumps(s, default=<span class="hljs-keyword">lambda</span> obj: obj.__dict__))<br></code></pre></td></tr></table></figure><h1 id="进阶（可选）"><a href="#进阶（可选）" class="headerlink" title="进阶（可选）"></a>进阶（可选）</h1><h2 id="高级特性（已完成）"><a href="#高级特性（已完成）" class="headerlink" title="高级特性（已完成）"></a>高级特性（已完成）</h2><h2 id="函数式编程（已完成）"><a href="#函数式编程（已完成）" class="headerlink" title="函数式编程（已完成）"></a>函数式编程（已完成）</h2><h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><h2 id="IO编程-1"><a href="#IO编程-1" class="headerlink" title="IO编程"></a>IO编程</h2><h2 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h2><h1 id="浏览"><a href="#浏览" class="headerlink" title="浏览"></a>浏览</h1><p>粗略看下，知道有什么就好，需要用的时候再学。</p><ul><li><code>§ 常用内建模块</code></li><li><code>§ 正则表达式</code></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><code>§ 图形界面</code> 之后的暂时不用学习，需要的时候再来。</p><h2 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h2><h3 id="ASCIL"><a href="#ASCIL" class="headerlink" title="ASCIL"></a>ASCIL</h3><p>计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到<code>Shift_JIS</code>里，韩国把韩文编到<code>Euc-kr</code>里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode 字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p><p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>&#39;0&#39;</code>和整数<code>0</code>是不同的；</p><p>汉字<code>中</code>已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p><p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><table><thead><tr><th align="left">字符</th><th align="left">ASCII</th><th align="left">Unicode</th><th align="left">UTF-8</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">01000001</td><td align="left">00000000 01000001</td><td align="left">01000001</td></tr><tr><td align="left">中</td><td align="left">x</td><td align="left">01001110 00101101</td><td align="left">11100100 10111000 10101101</td></tr></tbody></table><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</p><p><img src="https://www.liaoxuefeng.com/files/attachments/923923787018816/0" alt="rw-file-utf-8"></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/923923759189600/0" alt="web-utf-8"></p><p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h3><p>如果遇到<code>SyntaxError</code>，表示输入的Python代码有语法错误，最常见的一种语法错误是使用了中文标点，例如使用了中文括号<code>（</code>和<code>）</code>,或者使用了中文引号<code>“</code>和<code>”</code>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&gt;&gt;&gt; <span class="hljs-keyword">print</span>（<span class="hljs-string">&#x27;hello&#x27;</span>）<br>  <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">print</span>（<span class="hljs-string">&#x27;hello&#x27;</span>）<br>         ^<br>SyntaxError: invalid character <span class="hljs-string">&#x27;（&#x27;</span> (U+FF08)<br></code></pre></td></tr></table></figure><p>出错时，务必阅读错误原因。对于上述<code>SyntaxError</code>，解释器会明确指出错误原因是无法识别的字符<code>“</code>：<code>invalid character &#39;“&#39;</code>。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git分支管理与标签</title>
    <link href="/Blogs/2025/08/28/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E4%B8%8E%E6%A0%87%E7%AD%BE/"/>
    <url>/Blogs/2025/08/28/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E4%B8%8E%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                  HEAD<br>                    │<br>                    │<br>                    ▼<br>                 master<br>                    │<br>                    │<br>                    ▼<br>┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘<br></code></pre></td></tr></table></figure><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                 master<br>                    │<br>                    │<br>                    ▼<br>┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘<br>                    ▲<br>                    │<br>                    │<br>                   dev<br>                    ▲<br>                    │<br>                    │<br>                  HEAD<br></code></pre></td></tr></table></figure><p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                 master<br>                    │<br>                    │<br>                    ▼<br>┌───┐    ┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘    └───┘<br>                             ▲<br>                             │<br>                             │<br>                            dev<br>                             ▲<br>                             │<br>                             │<br>                           HEAD<br></code></pre></td></tr></table></figure><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                           HEAD<br>                             │<br>                             │<br>                             ▼<br>                          master<br>                             │<br>                             │<br>                             ▼<br>┌───┐    ┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘    └───┘<br>                             ▲<br>                             │<br>                             │<br>                            dev<br></code></pre></td></tr></table></figure><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                           HEAD<br>                             │<br>                             │<br>                             ▼<br>                          master<br>                             │<br>                             │<br>                             ▼<br>┌───┐    ┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘    └───┘<br></code></pre></td></tr></table></figure><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b dev<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="git-checkout-切换分支"><a href="#git-checkout-切换分支" class="headerlink" title="git checkout &lt;name&gt;切换分支"></a><code>git checkout &lt;name&gt;</code>切换分支</h3><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>命令加上<code>-b</code>参数表示创建并切换</p><p>相当于以下两条命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git branch dev<br><span class="hljs-variable">$ </span>git checkout dev<br><span class="hljs-title class_">Switched</span> to branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="用git-branch命令查看当前分支"><a href="#用git-branch命令查看当前分支" class="headerlink" title="用git branch命令查看当前分支"></a>用<code>git branch</code>命令查看当前分支</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* dev</span><br>  master<br></code></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick.<br></code></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git commit -m <span class="hljs-string">&quot;branch test&quot;</span><br>[<span class="hljs-meta">dev b17d20e</span>] branch test<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022533080576/0" alt="git-br-on-master"></p><h3 id="git-merge命令用于合并指定分支到当前分支"><a href="#git-merge命令用于合并指定分支到当前分支" class="headerlink" title="git merge命令用于合并指定分支到当前分支"></a><code>git merge</code>命令用于合并指定分支到当前分支</h3><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git merge dev<br><span class="hljs-function"><span class="hljs-title">Updating</span></span> d46f35e..b17d20e<br>Fast-forward<br> readme.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$ </span>git branch -d dev<br>Deleted branch dev (was b17d20e).<br></code></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-keyword">switch</span> -c feature1<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;feature1&#x27;</span><br></code></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick AND simple.<br></code></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">add</span> readme.txt<br><br>$ git commit -m <span class="hljs-string">&quot;AND simple&quot;</span><br>[feature1 14096d0] <span class="hljs-keyword">AND</span> simple<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+), 1 deletio<span class="hljs-meta">n</span>(-)<br></code></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git switch master<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch <span class="hljs-keyword">is</span> ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> <span class="hljs-keyword">commit</span>.<br>  (use &quot;git push&quot; <span class="hljs-keyword">to</span> publish your <span class="hljs-keyword">local</span> commits)<br></code></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick &amp; simple.<br></code></pre></td></tr></table></figure><p>提交：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git commit -m <span class="hljs-string">&quot;&amp; simple&quot;</span><br>[master 5dc6824] &amp; simple<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+), 1 deletio<span class="hljs-meta">n</span>(-)<br></code></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                            HEAD<br>                              │<br>                              │<br>                              ▼<br>                           master<br>                              │<br>                              │<br>                              ▼<br>                            ┌───┐<br>                         ┌─▶│   │<br>┌───┐    ┌───┐    ┌───┐  │  └───┘<br>│   │───▶│   │───▶│   │──┤<br>└───┘    └───┘    └───┘  │  ┌───┐<br>                         └─▶│   │<br>                            └───┘<br>                              ▲<br>                              │<br>                              │<br>                          feature1<br></code></pre></td></tr></table></figure><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git merge feature1<br>Auto-merging readme.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> readme.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Your branch is ahead of &#x27;origin/master&#x27; <span class="hljs-keyword">by</span> 2 commits.<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-keyword">local</span> commits)<br><br>You have unmerged paths.<br>  (fix conflicts and <span class="hljs-keyword">run</span> <span class="hljs-string">&quot;git commit&quot;</span>)<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git merge --abort&quot;</span> to abort the <span class="hljs-keyword">merge</span>)<br><br>Unmerged paths:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to <span class="hljs-keyword">mark</span> resolution)<br><br>both modified:   readme.txt<br><br><span class="hljs-keyword">no</span> changes added to commit (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">Git <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> distributed <span class="hljs-keyword">version</span> control <span class="hljs-built_in">system</span>.<br>Git <span class="hljs-keyword">is</span> free software distributed under the GPL.<br>Git <span class="hljs-built_in">has</span> <span class="hljs-keyword">a</span> mutable <span class="hljs-built_in">index</span> called stage.<br>Git tracks <span class="hljs-keyword">changes</span> of <span class="hljs-keyword">files</span>.<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick &amp; simple.<br>=======<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick and simple.<br></code></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git <span class="hljs-keyword">commit</span> -m &quot;conflict fixed&quot;<br>[master cf810e4] <span class="hljs-keyword">conflict</span> fixed<br></code></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                                     HEAD<br>                                       │<br>                                       │<br>                                       ▼<br>                                    master<br>                                       │<br>                                       │<br>                                       ▼<br>                            ┌───┐    ┌───┐<br>                         ┌─▶│   │───▶│   │<br>┌───┐    ┌───┐    ┌───┐  │  └───┘    └───┘<br>│   │───▶│   │───▶│   │──┤             ▲<br>└───┘    └───┘    └───┘  │  ┌───┐      │<br>                         └─▶│   │──────┘<br>                            └───┘<br>                              ▲<br>                              │<br>                              │<br>                          feature1<br></code></pre></td></tr></table></figure><h3 id="用带参数的git-log可以看到分支的合并情况"><a href="#用带参数的git-log可以看到分支的合并情况" class="headerlink" title="用带参数的git log可以看到分支的合并情况"></a>用带参数的<code>git log</code>可以看到分支的合并情况</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br><span class="hljs-comment">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br>|\  <br>| * <span class="hljs-number">14096</span>d0 (feature1) <span class="hljs-keyword">AND</span> simple<br><span class="hljs-comment">* | 5dc6824 &amp; simple</span><br>|/  <br><span class="hljs-comment">* b17d20e branch test</span><br><span class="hljs-comment">* d46f35e (origin/master) remove test.txt</span><br><span class="hljs-comment">* b84166e add test.txt</span><br><span class="hljs-comment">* 519219b git tracks changes</span><br><span class="hljs-comment">* e43a48b understand how stage works</span><br><span class="hljs-comment">* 1094adb append GPL</span><br><span class="hljs-comment">* e475afc add distributed</span><br><span class="hljs-comment">* eaadf4e wrote a readme file</span><br></code></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><h3 id="git-merge-no-ff-m-merge-with-no-ff-dev用普通模式合并"><a href="#git-merge-no-ff-m-merge-with-no-ff-dev用普通模式合并" class="headerlink" title="git merge --no-ff -m &quot;merge with no-ff&quot; dev用普通模式合并"></a><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>用普通模式合并</h3><p>合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">merge</span> --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> dev<br><span class="hljs-keyword">Merge</span> made <span class="hljs-keyword">by</span> the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> readme.txt | 1 +<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+)<br></code></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --pretty=oneline --abbrev-commit</span><br>*   e1e9c68 (HEAD -&gt; master) <span class="hljs-built_in">merge</span> <span class="hljs-keyword">with</span> no-ff<br>|\  <br>| * f52c633 (dev) <span class="hljs-built_in">add</span> <span class="hljs-built_in">merge</span><br>|/  <br>*   cf810e4 conflict fixed<br>...<br></code></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode"></p><h3 id="团队合作中"><a href="#团队合作中" class="headerlink" title="团队合作中"></a>团队合作中</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023260793600/0" alt="git-br-policy"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><h3 id="git-stash保存工作现场"><a href="#git-stash保存工作现场" class="headerlink" title="git stash保存工作现场"></a><code>git stash</code>保存工作现场</h3><p>在bug修复后继续工作</p><p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">$ git stash<br>Saved working directory and index <span class="hljs-keyword">state</span> WIP <span class="hljs-keyword">on</span> dev: f52c633 add merge<br></code></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">$ git stash<br>Saved working directory and index <span class="hljs-keyword">state</span> WIP <span class="hljs-keyword">on</span> dev: f52c633 add merge<br></code></pre></td></tr></table></figure><h3 id="git-checkout-b-issue-101在主分支上创建修复用的临时分支"><a href="#git-checkout-b-issue-101在主分支上创建修复用的临时分支" class="headerlink" title="git checkout -b issue-101在主分支上创建修复用的临时分支"></a><code>git checkout -b issue-101</code>在主分支上创建修复用的临时分支</h3><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">6</span> commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>$ git checkout -b issue<span class="hljs-number">-101</span><br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;issue-101&#x27;</span><br></code></pre></td></tr></table></figure><p>现在修复bug，然后提交：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git commit -m <span class="hljs-string">&quot;fix bug 101&quot;</span><br>[issue-101 4c805e2] fix bug 101<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+), 1 deletio<span class="hljs-meta">n</span>(-)<br></code></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">6</span> commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>$ git <span class="hljs-built_in">merge</span> <span class="hljs-comment">--no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> readme.txt | <span class="hljs-number">2</span> +-<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+), <span class="hljs-number">1</span> deletion(-)<br></code></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git switch dev<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br><br>$ git status<br><span class="hljs-keyword">On</span> branch dev<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git stash <span class="hljs-keyword">list</span><br>stash@&#123;0&#125;: WIP <span class="hljs-keyword">on</span> dev: f52c633 <span class="hljs-keyword">add</span> <span class="hljs-keyword">merge</span><br></code></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git stash <span class="hljs-keyword">pop</span><br>On branch dev<br>Changes <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>:   hello.<span class="hljs-keyword">py</span><br><br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br>Dropped refs/stash@&#123;<span class="hljs-number">0</span>&#125; (<span class="hljs-number">5</span>d677e2ee266f39ea296182fb2354265b91b3b2a)<br></code></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git stash list<br></code></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ git stash apply <span class="hljs-symbol">stash@</span>&#123;<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><h3 id="git-cherry-pick复制特定的提交到当前分支"><a href="#git-cherry-pick复制特定的提交到当前分支" class="headerlink" title="git cherry-pick复制特定的提交到当前分支"></a><code>git cherry-pick</code>复制特定的提交到当前分支</h3><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git cherry-pick <span class="hljs-number">4</span>c805e2<br>[<span class="hljs-keyword">master</span> <span class="hljs-title">1d4b803</span>] fix bug <span class="hljs-number">101</span><br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> insertion(+), <span class="hljs-number">1</span> deletion(-)<br></code></pre></td></tr></table></figure><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动</p><h2 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h2><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-keyword">switch</span> -c feature-vulcan<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;feature-vulcan&#x27;</span><br></code></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git <span class="hljs-built_in">add</span> vulcan.<span class="hljs-keyword">py</span><br><br>$ git status<br>On branch feature-vulcan<br>Changes <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>:   vulcan.<span class="hljs-keyword">py</span><br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;add feature vulcan&quot;</span><br>[feature-vulcan <span class="hljs-number">287773</span><span class="hljs-keyword">e</span>] <span class="hljs-built_in">add</span> feature vulcan<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">2</span> insertions(+)<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> vulcan.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-keyword">switch</span> dev<br></code></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><h3 id="git-branch-D-branchname强行删除未提交分支"><a href="#git-branch-D-branchname强行删除未提交分支" class="headerlink" title="git branch -D branchname强行删除未提交分支"></a><code>git branch -D branchname</code>强行删除未提交分支</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ git branch -d feature-vulcan<br><span class="hljs-keyword">error: </span>The branch &#x27;feature-vulcan&#x27; is not fully merged.<br>If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.<br></code></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ git branch -D <span class="hljs-built_in">feature</span>-vulcan<br>Deleted branch <span class="hljs-built_in">feature</span>-vulcan (was <span class="hljs-number">287773</span>e).<br></code></pre></td></tr></table></figure><p>终于删除成功！</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><h3 id="用git-remote查看远程库的信息"><a href="#用git-remote查看远程库的信息" class="headerlink" title="用git remote查看远程库的信息"></a>用<code>git remote</code>查看远程库的信息</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote<br>origin<br></code></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learngit.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learngit.git (push)<br></code></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="git-push-origin-name推送分支"><a href="#git-push-origin-name推送分支" class="headerlink" title="git push origin name推送分支"></a><code>git push origin name</code>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> dev<br></code></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><h4 id="git-clone-git-github-com-michaelliao-learngit-git抓取克隆"><a href="#git-clone-git-github-com-michaelliao-learngit-git抓取克隆" class="headerlink" title="git clone git@github.com:michaelliao/learngit.git抓取克隆"></a><code>git clone git@github.com:michaelliao/learngit.git</code>抓取克隆</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git clone git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learngit.git<br>Cloning into <span class="hljs-string">&#x27;learngit&#x27;</span>...<br><span class="hljs-attribute">remote</span>: Counting <span class="hljs-attribute">objects</span>: <span class="hljs-number">40</span>, done.<br><span class="hljs-attribute">remote</span>: Compressing <span class="hljs-attribute">objects</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">21</span>/<span class="hljs-number">21</span>), done.<br><span class="hljs-attribute">remote</span>: Total <span class="hljs-number">40</span> (delta <span class="hljs-number">14</span>), reused <span class="hljs-number">40</span> (delta <span class="hljs-number">14</span>), pack-reused <span class="hljs-number">0</span><br>Receiving <span class="hljs-attribute">objects</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">40</span>/<span class="hljs-number">40</span>), done.<br>Resolving <span class="hljs-attribute">deltas</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">14</span>/<span class="hljs-number">14</span>), done.<br></code></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><h4 id="git-checkout-b-dev-origin-dev抓取多个分支"><a href="#git-checkout-b-dev-origin-dev抓取多个分支" class="headerlink" title="git checkout -b dev origin/dev抓取多个分支"></a><code>git checkout -b dev origin/dev</code>抓取多个分支</h4><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ git checkout -b <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><h3 id="同步分支"><a href="#同步分支" class="headerlink" title="同步分支"></a>同步分支</h3><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$ </span>git add env.txt<br><br><span class="hljs-string">$ </span>git commit -m <span class="hljs-string">&quot;add env&quot;</span><br>[dev <span class="hljs-number">7</span>a5e5dd] add env<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> insertion(+)<br> create mode <span class="hljs-number">100644</span> env.txt<br><br><span class="hljs-string">$ </span>git push origin dev<br>Counting objects: <span class="hljs-number">3</span>, done.<br>Delta compression using up to <span class="hljs-number">4</span> threads.<br>Compressing objects: <span class="hljs-number">100</span><span class="hljs-comment">% (2/2), done.</span><br>Writing objects: <span class="hljs-number">100</span><span class="hljs-comment">% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br>Total <span class="hljs-number">3</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br>   f52c633..<span class="hljs-number">7</span>a5e5dd  dev -&gt; dev<br></code></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git pull<br>There <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> tracking information <span class="hljs-keyword">for</span> the current branch.<br>Please specify which branch you want <span class="hljs-keyword">to</span> merge with.<br>See git-pull(<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> details.<br><br>    git pull <span class="hljs-symbol">&lt;remote&gt;</span> <span class="hljs-symbol">&lt;branch&gt;</span><br><br>If you wish <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> tracking information <span class="hljs-keyword">for</span> this branch you can <span class="hljs-keyword">do</span> <span class="hljs-keyword">so</span> with:<br><br>    git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/<span class="hljs-symbol">&lt;branch&gt;</span> dev<br></code></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git branch <span class="hljs-attribute">--set-upstream-to</span>=origin/dev dev<br>Branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-built_in">set</span> up <span class="hljs-keyword">to</span> track remote branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git pull<br>Auto-merging env.txt<br><span class="hljs-keyword">CONFLICT</span> (<span class="hljs-keyword">add</span>/<span class="hljs-keyword">add</span>): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> env.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">commit</span> -m &quot;fix env conflict&quot;<br>[dev <span class="hljs-number">57</span>c53ab] fix env <span class="hljs-keyword">conflict</span><br><br>$ git push origin dev<br>Counting objects: <span class="hljs-number">6</span>, done.<br>Delta compression <span class="hljs-keyword">using</span> up <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> threads.<br>Compressing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">4</span>/<span class="hljs-number">4</span>), done.<br>Writing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">6</span>/<span class="hljs-number">6</span>), <span class="hljs-number">621</span> bytes | <span class="hljs-number">621.00</span> KiB/s, done.<br>Total <span class="hljs-number">6</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br><span class="hljs-keyword">To</span> github.com:michaelliao/learngit.git<br>   <span class="hljs-number">7</span>a5e5dd.<span class="hljs-number">.57</span>c53ab  dev -&gt; dev<br></code></pre></td></tr></table></figure><h3 id="git-rebase把本地未push的分叉提交历史整理成直线"><a href="#git-rebase把本地未push的分叉提交历史整理成直线" class="headerlink" title="git rebase把本地未push的分叉提交历史整理成直线"></a><code>git rebase</code>把本地未push的分叉提交历史整理成直线</h3><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git rebase<br>First, rewinding head <span class="hljs-keyword">to</span> replay your work <span class="hljs-keyword">on</span> top of it...<br>Applying: <span class="hljs-built_in">add</span> comment<br>Using <span class="hljs-built_in">index</span> info <span class="hljs-keyword">to</span> reconstruct <span class="hljs-keyword">a</span> base tree...<br>Mhello.<span class="hljs-keyword">py</span><br>Falling back <span class="hljs-keyword">to</span> patching base <span class="hljs-built_in">and</span> <span class="hljs-number">3</span>-way merge...<br>Auto-merging hello.<span class="hljs-keyword">py</span><br>Applying: <span class="hljs-built_in">add</span> author<br>Using <span class="hljs-built_in">index</span> info <span class="hljs-keyword">to</span> reconstruct <span class="hljs-keyword">a</span> base tree...<br>Mhello.<span class="hljs-keyword">py</span><br>Falling back <span class="hljs-keyword">to</span> patching base <span class="hljs-built_in">and</span> <span class="hljs-number">3</span>-way merge...<br>Auto-merging hello.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git log --graph --pretty=oneline --abbrev-commit<br>* <span class="hljs-number">7</span>e61ed4 (HEAD -&gt; master) add author<br>* <span class="hljs-number">3611</span>cfe add comment<br>* f005ed4 (origin/master) set <span class="hljs-keyword">exit</span>=<span class="hljs-number">1</span><br>* d1be385 init hello<br>...<br></code></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mac</span>:~/learngit michael$ git push origin master<br><span class="hljs-attribute">Counting</span> objects: <span class="hljs-number">6</span>, done.<br><span class="hljs-attribute">Delta</span> compression using up to <span class="hljs-number">4</span> threads.<br><span class="hljs-attribute">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), done.<br><span class="hljs-attribute">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">6</span>/<span class="hljs-number">6</span>), <span class="hljs-number">576</span> bytes | <span class="hljs-number">576</span>.<span class="hljs-number">00</span> KiB/s, done.<br><span class="hljs-attribute">Total</span> <span class="hljs-number">6</span> (delta <span class="hljs-number">2</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br><span class="hljs-attribute">remote</span>: Resolving deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">2</span>/<span class="hljs-number">2</span>), completed with <span class="hljs-number">1</span> local object.<br><span class="hljs-attribute">To</span> github.com:michaelliao/learngit.git<br>   <span class="hljs-attribute">f005ed4</span>..<span class="hljs-number">7</span>e61ed4  master -&gt; master<br></code></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git log --graph --pretty=oneline --abbrev-commit<br>* <span class="hljs-number">7</span>e61ed4 (HEAD -&gt; master, origin/master) add author<br>* <span class="hljs-number">3611</span>cfe add comment<br>* f005ed4 set <span class="hljs-keyword">exit</span>=<span class="hljs-number">1</span><br>* d1be385 init hello<br>...<br></code></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><blockquote><p>标签是指向commit的<strong>死指针</strong>，分支是指向commit的<strong>活指针</strong></p><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p></blockquote><h2 id="git-tag-创建标签"><a href="#git-tag-创建标签" class="headerlink" title="git tag &lt;name&gt;创建标签"></a><code>git tag &lt;name&gt;</code>创建标签</h2><p>首先，切换到需要打标签的分支上：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">log</span> <span class="hljs-comment">--pretty=oneline --abbrev-commit</span><br><span class="hljs-number">12</span>a631b (HEAD -&gt; master, tag: v1<span class="hljs-number">.0</span>, origin/master) merged bug fix <span class="hljs-number">101</span><br><span class="hljs-number">4</span>c805e2 fix bug <span class="hljs-number">101</span><br>e1e9c68 merge <span class="hljs-keyword">with</span> <span class="hljs-keyword">no</span>-ff<br>f52c633 <span class="hljs-keyword">add</span> merge<br>cf810e4 <span class="hljs-keyword">conflict</span> fixed<br><span class="hljs-number">5</span>dc6824 &amp; simple<br><span class="hljs-number">14096</span>d0 <span class="hljs-keyword">AND</span> simple<br>b17d20e branch test<br>d46f35e remove test.txt<br>b84166e <span class="hljs-keyword">add</span> test.txt<br><span class="hljs-number">519219</span>b git tracks changes<br>e43a48b understand how stage works<br><span class="hljs-number">1094</span>adb append GPL<br>e475afc <span class="hljs-keyword">add</span> distributed<br>eaadf4e wrote a readme file<br></code></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">9</span> f52c633<br></code></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v0</span>.<span class="hljs-number">9</span><br>v1.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span> v0<span class="hljs-number">.9</span><br><span class="hljs-keyword">commit</span> f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0<span class="hljs-number">.9</span>)<br>Author: Michael Liao <span class="hljs-operator">&lt;</span>askxuefeng<span class="hljs-variable">@gmail</span>.com<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">56</span>:<span class="hljs-number">54</span> <span class="hljs-number">2018</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">merge</span><br><br>diff <span class="hljs-comment">--git a/readme.txt b/readme.txt</span><br>...<br></code></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v0.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git show v0.<span class="hljs-number">1</span><br><span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">1</span><br>Tagger: Michael Liao <span class="hljs-tag">&lt;askxuefeng@gmail.com&gt;</span><br><span class="hljs-keyword">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">22</span>:<span class="hljs-number">48</span>:<span class="hljs-number">43</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br><span class="hljs-keyword">version</span> <span class="hljs-number">0.1</span> released<br><br>commit <span class="hljs-number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (<span class="hljs-keyword">tag</span>: v0.<span class="hljs-number">1</span>)<br>Author: Michael Liao <span class="hljs-tag">&lt;askxuefeng@gmail.com&gt;</span><br><span class="hljs-keyword">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    append GPL<br><br>diff --git a/readme.txt b/readme.txt<br>...<br></code></pre></td></tr></table></figure><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，也可以删除：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">1</span><br>Deleted <span class="hljs-keyword">tag</span> <span class="hljs-title">&#x27;v0</span>.<span class="hljs-number">1</span>&#x27; (was f15b0dd)<br></code></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> v1<span class="hljs-number">.0</span><br>Total <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br> * [<span class="hljs-built_in">new</span> tag]         v1<span class="hljs-number">.0</span> -&gt; v1<span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br>Total <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br> * [<span class="hljs-built_in">new</span> tag]         v0<span class="hljs-number">.9</span> -&gt; v0<span class="hljs-number">.9</span><br></code></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">9</span><br>Deleted <span class="hljs-keyword">tag</span> <span class="hljs-title">&#x27;v0</span>.<span class="hljs-number">9</span>&#x27; (was f52c633)<br></code></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git push origin <span class="hljs-symbol">:refs/tags/v0</span>.<span class="hljs-number">9</span><br><span class="hljs-title class_">To</span> <span class="hljs-symbol">github.com:</span>michaelliao/learngit.git<br> - [deleted]         v0.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
      <category>git学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git分支管理与标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git本地库操作</title>
    <link href="/Blogs/2025/08/28/git%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/Blogs/2025/08/28/git%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="对本地版本库"><a href="#对本地版本库" class="headerlink" title="对本地版本库"></a>对本地版本库</h1><h2 id="创建仓库git-init"><a href="#创建仓库git-init" class="headerlink" title="创建仓库git init"></a>创建仓库<code>git init</code></h2><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ git <span class="hljs-keyword">init</span><br><span class="hljs-type">Initialized</span> empty <span class="hljs-type">Git</span> repository <span class="hljs-keyword">in</span> <span class="hljs-regexp">/Users/</span>michael<span class="hljs-regexp">/learngit/</span>.git<span class="hljs-operator">/</span><br></code></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><h2 id="仓库中加入文件"><a href="#仓库中加入文件" class="headerlink" title="仓库中加入文件"></a>仓库中加入文件</h2><h3 id="Git-add添加文件到仓库"><a href="#Git-add添加文件到仓库" class="headerlink" title="Git add添加文件到仓库"></a><code>Git add</code>添加文件到仓库</h3><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> readme.txt<br></code></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><h3 id="git-commit把文件提交到仓库"><a href="#git-commit把文件提交到仓库" class="headerlink" title="git commit把文件提交到仓库"></a><code>git commit</code>把文件提交到仓库</h3><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br>[<span class="hljs-keyword">master</span> <span class="hljs-title">(root-commit</span>) eaadf4e] wrote a readme file<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">2</span> insertions(+)<br> create mode <span class="hljs-number">100644</span> readme.txt<br></code></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> file1.txt<br>$ git <span class="hljs-built_in">add</span> file2.txt file3.txt<br>$ git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br></code></pre></td></tr></table></figure><h2 id="仓库中文件改变"><a href="#仓库中文件改变" class="headerlink" title="仓库中文件改变"></a>仓库中文件改变</h2><h3 id="git-status命令看看结果"><a href="#git-status命令看看结果" class="headerlink" title="git status命令看看结果"></a><code>git status</code>命令看看结果</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用### <code>git diff</code>查看修改内容</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff">$ git diff readme.txt <br><span class="hljs-comment">diff --git a/readme.txt b/readme.txt</span><br><span class="hljs-comment">index 46d49bf..9247db6 100644</span><br><span class="hljs-comment">--- a/readme.txt</span><br><span class="hljs-comment">+++ b/readme.txt</span><br><span class="hljs-meta">@@ -1,2 +1,2 @@</span><br><span class="hljs-deletion">-Git is a version control system.</span><br><span class="hljs-addition">+Git is a distributed version control system.</span><br> Git is free software.<br></code></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步</p><h2 id="查看git历史记录"><a href="#查看git历史记录" class="headerlink" title="查看git历史记录"></a>查看git历史记录</h2><p>在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log<br>commit <span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master)<br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> <span class="hljs-number">+0800</span><br><br>    append GPL<br><br>commit e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2018</span> <span class="hljs-number">+0800</span><br><br>    <span class="hljs-keyword">add</span> distributed<br><br>commit eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">18</span> <span class="hljs-number">2018</span> <span class="hljs-number">+0800</span><br><br>    wrote a readme file<br></code></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919019707114272/0" alt="git-log-timeline"></p><h2 id="运用HEAD回退版本"><a href="#运用HEAD回退版本" class="headerlink" title="运用HEAD回退版本"></a>运用HEAD回退版本</h2><h3 id="git-log查看提交历史"><a href="#git-log查看提交历史" class="headerlink" title="git log查看提交历史"></a><code>git log</code>查看提交历史</h3><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919019707114272/0" alt="git-log-timeline"></p><h3 id="git-reflog查看命令历史，以便确定要回到未来的哪个版本"><a href="#git-reflog查看命令历史，以便确定要回到未来的哪个版本" class="headerlink" title="git reflog查看命令历史，以便确定要回到未来的哪个版本"></a><code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</h3><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br>e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br>eaadf4e HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme file<br></code></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h3 id="git-reset-hard-commit-id版本控制操作"><a href="#git-reset-hard-commit-id版本控制操作" class="headerlink" title="git reset --hard commit_id版本控制操作"></a><code>git reset --hard commit_id</code>版本控制操作</h3><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at e475afc <span class="hljs-keyword">add</span> distributed<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h3 id="git-checkout-file丢弃工作区的修改"><a href="#git-checkout-file丢弃工作区的修改" class="headerlink" title="git checkout -- file丢弃工作区的修改"></a><code>git checkout -- file</code>丢弃工作区的修改</h3><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset <span class="hljs-title class_">HEAD</span> readme.txt<br><span class="hljs-title class_">Unstaged</span> changes <span class="hljs-keyword">after</span> <span class="hljs-symbol">reset:</span><br>Mreadme.txt<br></code></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to <span class="hljs-keyword">update</span> what will be committed)<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to <span class="hljs-keyword">discard</span> changes <span class="hljs-keyword">in</span> working directory)<br><br>modified:   readme.txt<br></code></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git checkout <span class="hljs-comment">-- readme.txt</span><br><br>$ git status<br><span class="hljs-keyword">On</span> branch master<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><h2 id="删除文件git-rm删掉，并且git-commit"><a href="#删除文件git-rm删掉，并且git-commit" class="headerlink" title="删除文件git rm删掉，并且git commit"></a>删除文件<code>git rm</code>删掉，并且<code>git commit</code></h2><p>确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">test</span>.txt<br><span class="hljs-keyword">rm</span> &#x27;<span class="hljs-keyword">test</span>.txt&#x27;<br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;remove test.txt&quot;</span><br>[master d46f35e] remove <span class="hljs-keyword">test</span>.txt<br> 1 <span class="hljs-keyword">file</span> changed, 1 deletion(-)<br> delete mode 100644 <span class="hljs-keyword">test</span>.txt<br></code></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
      <category>git学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git本地库操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git远程库操作</title>
    <link href="/Blogs/2025/08/28/git%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/Blogs/2025/08/28/git%E8%BF%9C%E7%A8%8B%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h1><h2 id="配置远程库（以github为例）"><a href="#配置远程库（以github为例）" class="headerlink" title="配置远程库（以github为例）"></a>配置远程库（以github为例）</h2><p>git使用SSH配置， 初始需要以下三个步骤</p><ul><li><p>使用秘钥生成工具生成rsa秘钥和公钥</p></li><li><p>将rsa公钥添加到代码托管平台</p></li><li><p>将rsa秘钥添加到ssh-agent中，为ssh client指定使用的秘钥文件</p></li></ul><h3 id="检查本地主机是否已经存在ssh-key"><a href="#检查本地主机是否已经存在ssh-key" class="headerlink" title="检查本地主机是否已经存在ssh key"></a>检查本地主机是否已经存在ssh key</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br><span class="hljs-keyword">ls</span><br><span class="hljs-string">//</span>看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key<br></code></pre></td></tr></table></figure><p>如果存在，直接跳到第三步</p><h3 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h3><p>如果不存在ssh key，使用如下命令生成</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ssh<span class="hljs-punctuation">-</span>keygen <span class="hljs-punctuation">-</span>t rsa <span class="hljs-punctuation">-</span>C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br><span class="hljs-comment">//执行后一直回车即可</span><br></code></pre></td></tr></table></figure><p>生成完以后再用第二步命令，查看ssh key</p><h3 id="获取ssh-key公钥内容（id-rsa-pub）"><a href="#获取ssh-key公钥内容（id-rsa-pub）" class="headerlink" title="获取ssh key公钥内容（id_rsa.pub）"></a>获取ssh key公钥内容（id_rsa.pub）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br><span class="hljs-built_in">cat</span> id_rsa.pub<br></code></pre></td></tr></table></figure><p>如下图所示，复制该内容</p><h3 id="Github账号上添加公钥"><a href="#Github账号上添加公钥" class="headerlink" title="Github账号上添加公钥"></a>Github账号上添加公钥</h3><p>进入Settings设置</p><p>添加ssh key，把刚才复制的内容粘贴上去保存即可</p><h3 id="验证是否设置成功"><a href="#验证是否设置成功" class="headerlink" title="验证是否设置成功"></a>验证是否设置成功</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>先在github创建远程库，然后在本地进行操作</p><h3 id="git-remote-add-origin-git-server-name-path-repo-name-git关联远程库"><a href="#git-remote-add-origin-git-server-name-path-repo-name-git关联远程库" class="headerlink" title="git remote add origin git@server-name:path/repo-name.git关联远程库"></a><code>git remote add origin git@server-name:path/repo-name.git</code>关联远程库</h3><p>在本地的<code>learngit</code>仓库下运行命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>michaelliao/learngit.git<br></code></pre></td></tr></table></figure><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><h3 id="git-push-u-origin-master第一次推送master分支的所有内容"><a href="#git-push-u-origin-master第一次推送master分支的所有内容" class="headerlink" title="git push -u origin master第一次推送master分支的所有内容"></a><code>git push -u origin master</code>第一次推送master分支的所有内容</h3><p>把本地库的所有内容推送到远程库上：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">$ git push -u origin master<br><span class="hljs-type">Counting</span> objects: <span class="hljs-number">20</span>, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Delta</span> compression using up <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> threads.<br><span class="hljs-type">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">15</span>/<span class="hljs-number">15</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">20</span>/<span class="hljs-number">20</span>), <span class="hljs-number">1.64</span> <span class="hljs-type">KiB</span> | <span class="hljs-number">560.00</span> <span class="hljs-type">KiB</span>/s, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Total</span> <span class="hljs-number">20</span> (delta <span class="hljs-number">5</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>remote: <span class="hljs-type">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">To</span> github.com:michaelliao/learngit.git<br> * [<span class="hljs-keyword">new</span> branch]      master -&gt; master<br><span class="hljs-type">Branch</span> <span class="hljs-symbol">&#x27;master&#x27;</span> set up <span class="hljs-keyword">to</span> track remote branch <span class="hljs-symbol">&#x27;master&#x27;</span> from <span class="hljs-symbol">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p><strong>注意</strong>：如果出现</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>src refspec master does not match any error: failed to push<br></code></pre></td></tr></table></figure><p>则需要查看master分支是否创建，<a href="https://www.freecodecamp.org/chinese/news/error-src-refspec-master-does-not-match-any-how-to-fix-in-git/">传送门</a></p><h3 id="github实例"><a href="#github实例" class="headerlink" title="github实例"></a>github实例</h3><h4 id="Create-a-new-repository-on-the-command-line"><a href="#Create-a-new-repository-on-the-command-line" class="headerlink" title="Create a new repository on the command line"></a>Create a new repository on the command line</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">echo</span> <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> README.md<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-symbol">git</span> branch -M main<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/MaverickTang/test.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin main<br></code></pre></td></tr></table></figure><h4 id="Push-an-existing-repository-from-the-command-line"><a href="#Push-an-existing-repository-from-the-command-line" class="headerlink" title="Push an existing repository from the command line"></a>Push an existing repository from the command line</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/MaverickTang/test.git</span><br><span class="hljs-symbol">git</span> branch -M main<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin main<br></code></pre></td></tr></table></figure><h3 id="git-remote-rm-删除远程库"><a href="#git-remote-rm-删除远程库" class="headerlink" title="git remote rm &lt;name&gt;删除远程库"></a><code>git remote rm &lt;name&gt;</code>删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (push)<br></code></pre></td></tr></table></figure><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p><code>git pull</code>同步本地与远程库</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h2 id="git-clone从远程库克隆"><a href="#git-clone从远程库克隆" class="headerlink" title="git clone从远程库克隆"></a><code>git clone</code>从远程库克隆</h2><p>用命令<code>git clone</code>克隆一个本地库：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git clone git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/gitskills.git<br>Cloning into <span class="hljs-string">&#x27;gitskills&#x27;</span>...<br><span class="hljs-attribute">remote</span>: Counting <span class="hljs-attribute">objects</span>: <span class="hljs-number">3</span>, done.<br><span class="hljs-attribute">remote</span>: Total <span class="hljs-number">3</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">3</span><br>Receiving <span class="hljs-attribute">objects</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">3</span>/<span class="hljs-number">3</span>), done.<br></code></pre></td></tr></table></figure><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> gitskills<br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>README.md<br></code></pre></td></tr></table></figure><h1 id="Bug修复"><a href="#Bug修复" class="headerlink" title="Bug修复"></a>Bug修复</h1><p><a href="https://www.jianshu.com/p/c3aac5024877">push origin 失败</a>：改成ssh链接，或者关闭代理</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
      <category>git学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git远程库操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="/Blogs/2025/08/28/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/Blogs/2025/08/28/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>自动帮忙记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Git是分布式版本控制系统</p><h2 id="git的基本概念"><a href="#git的基本概念" class="headerlink" title="git的基本概念"></a>git的基本概念</h2><p>git 将代码保存的位置分为工作区(Working Directory，你能看到的目录)，暂存区(stage，index，cache)和版本库(Repository) </p><ul><li>正常写代码和文档时修改的是工作区</li><li>git add 命令将工作区的改动提交到暂存区，并在暂存区中形成一次完整的<strong>待提交版本</strong>，其中包 含对<strong>多个</strong>文件的增删或改动</li><li>git commit 命令将待提交的版本保存在<strong>版本库</strong>，版本库是<strong>只读</strong>的，一旦提交不能更改，确保代码 不被误改动</li><li>版本库中的每一个提交的版本都有一个指向<strong>前一次提交</strong>的指针，从而形成一个<strong>版本链条</strong>，从而使 代码的改动历史可以追溯</li></ul><p>在多人协作的场景下git分为<strong>本地仓库</strong>和<strong>远程仓库</strong>(两个仓库都包含几乎全部提交)，本地仓库用来管理 自己的代码，需要和其他人写作时，需要将远程仓库的修改pull到本地仓库，再将本地仓库的push到远 程仓库</p><h1 id="底层概念"><a href="#底层概念" class="headerlink" title="底层概念"></a>底层概念</h1><h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919021113952544/0" alt="working-dir"></p><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>先对<code>readme.txt</code>做个修改，比如加上一行内容：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mercury">Git <span class="hljs-keyword">is</span> a distributed version control system.<br>Git <span class="hljs-keyword">is</span> free software distributed under the GPL.<br>Git has a <span class="hljs-keyword">mutable</span> index called stage.<br></code></pre></td></tr></table></figure><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br>Untracked <span class="hljs-keyword">files</span>:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> include in what will <span class="hljs-keyword">be</span> committed)<br><br>LICENSE<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Changes <span class="hljs-keyword">to</span> be committed:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>:   LICENSE<br>modified:   readme.txt<br></code></pre></td></tr></table></figure><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020074026336/0" alt="git-stage"></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git commit -m <span class="hljs-string">&quot;understand how stage works&quot;</span><br>[<span class="hljs-keyword">master</span> <span class="hljs-title">e43a48b</span>] understand how stage works<br> <span class="hljs-number">2</span> files changed, <span class="hljs-number">2</span> insertions(+)<br> create mode <span class="hljs-number">100644</span> LICENSE<br></code></pre></td></tr></table></figure><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git status<br><span class="hljs-keyword">On</span> branch master<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020100829536/0" alt="git-stage-after-commit"></p><h1 id="对本地版本库"><a href="#对本地版本库" class="headerlink" title="对本地版本库"></a>对本地版本库</h1><p>[[1.git本地库操作]]</p><h2 id="创建仓库git-init"><a href="#创建仓库git-init" class="headerlink" title="创建仓库git init"></a>创建仓库<code>git init</code></h2><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ git <span class="hljs-keyword">init</span><br><span class="hljs-type">Initialized</span> empty <span class="hljs-type">Git</span> repository <span class="hljs-keyword">in</span> <span class="hljs-regexp">/Users/</span>michael<span class="hljs-regexp">/learngit/</span>.git<span class="hljs-operator">/</span><br></code></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><h2 id="仓库中加入文件"><a href="#仓库中加入文件" class="headerlink" title="仓库中加入文件"></a>仓库中加入文件</h2><h3 id="Git-add添加文件到仓库"><a href="#Git-add添加文件到仓库" class="headerlink" title="Git add添加文件到仓库"></a><code>Git add</code>添加文件到仓库</h3><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> readme.txt<br></code></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><h3 id="git-commit把文件提交到仓库"><a href="#git-commit把文件提交到仓库" class="headerlink" title="git commit把文件提交到仓库"></a><code>git commit</code>把文件提交到仓库</h3><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br>[<span class="hljs-keyword">master</span> <span class="hljs-title">(root-commit</span>) eaadf4e] wrote a readme file<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">2</span> insertions(+)<br> create mode <span class="hljs-number">100644</span> readme.txt<br></code></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> file1.txt<br>$ git <span class="hljs-built_in">add</span> file2.txt file3.txt<br>$ git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br></code></pre></td></tr></table></figure><h2 id="仓库中文件改变"><a href="#仓库中文件改变" class="headerlink" title="仓库中文件改变"></a>仓库中文件改变</h2><h3 id="git-status命令看看结果"><a href="#git-status命令看看结果" class="headerlink" title="git status命令看看结果"></a><code>git status</code>命令看看结果</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用### <code>git diff</code>查看修改内容</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs diff">$ git diff readme.txt <br><span class="hljs-comment">diff --git a/readme.txt b/readme.txt</span><br><span class="hljs-comment">index 46d49bf..9247db6 100644</span><br><span class="hljs-comment">--- a/readme.txt</span><br><span class="hljs-comment">+++ b/readme.txt</span><br><span class="hljs-meta">@@ -1,2 +1,2 @@</span><br><span class="hljs-deletion">-Git is a version control system.</span><br><span class="hljs-addition">+Git is a distributed version control system.</span><br> Git is free software.<br></code></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步</p><h2 id="查看git历史记录"><a href="#查看git历史记录" class="headerlink" title="查看git历史记录"></a>查看git历史记录</h2><p>在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log<br>commit <span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master)<br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> <span class="hljs-number">+0800</span><br><br>    append GPL<br><br>commit e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2018</span> <span class="hljs-number">+0800</span><br><br>    <span class="hljs-keyword">add</span> distributed<br><br>commit eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">18</span> <span class="hljs-number">2018</span> <span class="hljs-number">+0800</span><br><br>    wrote a readme file<br></code></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919019707114272/0" alt="git-log-timeline"></p><h2 id="运用HEAD回退版本"><a href="#运用HEAD回退版本" class="headerlink" title="运用HEAD回退版本"></a>运用HEAD回退版本</h2><h3 id="git-log查看提交历史"><a href="#git-log查看提交历史" class="headerlink" title="git log查看提交历史"></a><code>git log</code>查看提交历史</h3><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919019707114272/0" alt="git-log-timeline"></p><h3 id="git-reflog查看命令历史，以便确定要回到未来的哪个版本"><a href="#git-reflog查看命令历史，以便确定要回到未来的哪个版本" class="headerlink" title="git reflog查看命令历史，以便确定要回到未来的哪个版本"></a><code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</h3><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br>e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br>eaadf4e HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme file<br></code></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h3 id="git-reset-hard-commit-id版本控制操作"><a href="#git-reset-hard-commit-id版本控制操作" class="headerlink" title="git reset --hard commit_id版本控制操作"></a><code>git reset --hard commit_id</code>版本控制操作</h3><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at e475afc <span class="hljs-keyword">add</span> distributed<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h3 id="git-checkout-file丢弃工作区的修改"><a href="#git-checkout-file丢弃工作区的修改" class="headerlink" title="git checkout -- file丢弃工作区的修改"></a><code>git checkout -- file</code>丢弃工作区的修改</h3><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset <span class="hljs-title class_">HEAD</span> readme.txt<br><span class="hljs-title class_">Unstaged</span> changes <span class="hljs-keyword">after</span> <span class="hljs-symbol">reset:</span><br>Mreadme.txt<br></code></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to <span class="hljs-keyword">update</span> what will be committed)<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to <span class="hljs-keyword">discard</span> changes <span class="hljs-keyword">in</span> working directory)<br><br>modified:   readme.txt<br></code></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git checkout <span class="hljs-comment">-- readme.txt</span><br><br>$ git status<br><span class="hljs-keyword">On</span> branch master<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><h2 id="删除文件git-rm删掉，并且git-commit"><a href="#删除文件git-rm删掉，并且git-commit" class="headerlink" title="删除文件git rm删掉，并且git commit"></a>删除文件<code>git rm</code>删掉，并且<code>git commit</code></h2><p>确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">test</span>.txt<br><span class="hljs-keyword">rm</span> &#x27;<span class="hljs-keyword">test</span>.txt&#x27;<br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;remove test.txt&quot;</span><br>[master d46f35e] remove <span class="hljs-keyword">test</span>.txt<br> 1 <span class="hljs-keyword">file</span> changed, 1 deletion(-)<br> delete mode 100644 <span class="hljs-keyword">test</span>.txt<br></code></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p><h1 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h1><p>[[2.git远程库操作]]</p><h2 id="配置远程库（以github为例）"><a href="#配置远程库（以github为例）" class="headerlink" title="配置远程库（以github为例）"></a>配置远程库（以github为例）</h2><p>git使用SSH配置， 初始需要以下三个步骤</p><ul><li><p>使用秘钥生成工具生成rsa秘钥和公钥</p></li><li><p>将rsa公钥添加到代码托管平台</p></li><li><p>将rsa秘钥添加到ssh-agent中，为ssh client指定使用的秘钥文件</p></li></ul><h3 id="检查本地主机是否已经存在ssh-key"><a href="#检查本地主机是否已经存在ssh-key" class="headerlink" title="检查本地主机是否已经存在ssh key"></a>检查本地主机是否已经存在ssh key</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span><br><span class="hljs-keyword">ls</span><br><span class="hljs-string">//</span>看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key<br></code></pre></td></tr></table></figure><p>如果存在，直接跳到第三步</p><h3 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h3><p>如果不存在ssh key，使用如下命令生成</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ssh<span class="hljs-punctuation">-</span>keygen <span class="hljs-punctuation">-</span>t rsa <span class="hljs-punctuation">-</span>C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br><span class="hljs-comment">//执行后一直回车即可</span><br></code></pre></td></tr></table></figure><p>生成完以后再用第二步命令，查看ssh key</p><h3 id="获取ssh-key公钥内容（id-rsa-pub）"><a href="#获取ssh-key公钥内容（id-rsa-pub）" class="headerlink" title="获取ssh key公钥内容（id_rsa.pub）"></a>获取ssh key公钥内容（id_rsa.pub）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br><span class="hljs-built_in">cat</span> id_rsa.pub<br></code></pre></td></tr></table></figure><p>如下图所示，复制该内容</p><h3 id="Github账号上添加公钥"><a href="#Github账号上添加公钥" class="headerlink" title="Github账号上添加公钥"></a>Github账号上添加公钥</h3><p>进入Settings设置</p><p>添加ssh key，把刚才复制的内容粘贴上去保存即可</p><h3 id="验证是否设置成功"><a href="#验证是否设置成功" class="headerlink" title="验证是否设置成功"></a>验证是否设置成功</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>先在github创建远程库，然后在本地进行操作</p><h3 id="git-remote-add-origin-git-server-name-path-repo-name-git关联远程库"><a href="#git-remote-add-origin-git-server-name-path-repo-name-git关联远程库" class="headerlink" title="git remote add origin git@server-name:path/repo-name.git关联远程库"></a><code>git remote add origin git@server-name:path/repo-name.git</code>关联远程库</h3><p>在本地的<code>learngit</code>仓库下运行命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>michaelliao/learngit.git<br></code></pre></td></tr></table></figure><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><h3 id="git-push-u-origin-master第一次推送master分支的所有内容"><a href="#git-push-u-origin-master第一次推送master分支的所有内容" class="headerlink" title="git push -u origin master第一次推送master分支的所有内容"></a><code>git push -u origin master</code>第一次推送master分支的所有内容</h3><p>把本地库的所有内容推送到远程库上：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">$ git push -u origin master<br><span class="hljs-type">Counting</span> objects: <span class="hljs-number">20</span>, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Delta</span> compression using up <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> threads.<br><span class="hljs-type">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">15</span>/<span class="hljs-number">15</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">20</span>/<span class="hljs-number">20</span>), <span class="hljs-number">1.64</span> <span class="hljs-type">KiB</span> | <span class="hljs-number">560.00</span> <span class="hljs-type">KiB</span>/s, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Total</span> <span class="hljs-number">20</span> (delta <span class="hljs-number">5</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>remote: <span class="hljs-type">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">To</span> github.com:michaelliao/learngit.git<br> * [<span class="hljs-keyword">new</span> branch]      master -&gt; master<br><span class="hljs-type">Branch</span> <span class="hljs-symbol">&#x27;master&#x27;</span> set up <span class="hljs-keyword">to</span> track remote branch <span class="hljs-symbol">&#x27;master&#x27;</span> from <span class="hljs-symbol">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p><strong>注意</strong>：如果出现</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>src refspec master does not match any error: failed to push<br></code></pre></td></tr></table></figure><p>则需要查看master分支是否创建，<a href="https://www.freecodecamp.org/chinese/news/error-src-refspec-master-does-not-match-any-how-to-fix-in-git/">传送门</a></p><h3 id="github实例"><a href="#github实例" class="headerlink" title="github实例"></a>github实例</h3><h4 id="Create-a-new-repository-on-the-command-line"><a href="#Create-a-new-repository-on-the-command-line" class="headerlink" title="Create a new repository on the command line"></a>Create a new repository on the command line</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">echo</span> <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> README.md<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-symbol">git</span> branch -M main<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/MaverickTang/test.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin main<br></code></pre></td></tr></table></figure><h4 id="Push-an-existing-repository-from-the-command-line"><a href="#Push-an-existing-repository-from-the-command-line" class="headerlink" title="Push an existing repository from the command line"></a>Push an existing repository from the command line</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/MaverickTang/test.git</span><br><span class="hljs-symbol">git</span> branch -M main<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin main<br></code></pre></td></tr></table></figure><h3 id="git-remote-rm-删除远程库"><a href="#git-remote-rm-删除远程库" class="headerlink" title="git remote rm &lt;name&gt;删除远程库"></a><code>git remote rm &lt;name&gt;</code>删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (push)<br></code></pre></td></tr></table></figure><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h2 id="git-clone从远程库克隆"><a href="#git-clone从远程库克隆" class="headerlink" title="git clone从远程库克隆"></a><code>git clone</code>从远程库克隆</h2><p>用命令<code>git clone</code>克隆一个本地库：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git clone git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/gitskills.git<br>Cloning into <span class="hljs-string">&#x27;gitskills&#x27;</span>...<br><span class="hljs-attribute">remote</span>: Counting <span class="hljs-attribute">objects</span>: <span class="hljs-number">3</span>, done.<br><span class="hljs-attribute">remote</span>: Total <span class="hljs-number">3</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">3</span><br>Receiving <span class="hljs-attribute">objects</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">3</span>/<span class="hljs-number">3</span>), done.<br></code></pre></td></tr></table></figure><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> gitskills<br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>README.md<br></code></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>[[3.git分支管理与标签]]</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                  HEAD<br>                    │<br>                    │<br>                    ▼<br>                 master<br>                    │<br>                    │<br>                    ▼<br>┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘<br></code></pre></td></tr></table></figure><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                 master<br>                    │<br>                    │<br>                    ▼<br>┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘<br>                    ▲<br>                    │<br>                    │<br>                   dev<br>                    ▲<br>                    │<br>                    │<br>                  HEAD<br></code></pre></td></tr></table></figure><p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                 master<br>                    │<br>                    │<br>                    ▼<br>┌───┐    ┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘    └───┘<br>                             ▲<br>                             │<br>                             │<br>                            dev<br>                             ▲<br>                             │<br>                             │<br>                           HEAD<br></code></pre></td></tr></table></figure><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                           HEAD<br>                             │<br>                             │<br>                             ▼<br>                          master<br>                             │<br>                             │<br>                             ▼<br>┌───┐    ┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘    └───┘<br>                             ▲<br>                             │<br>                             │<br>                            dev<br></code></pre></td></tr></table></figure><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                           HEAD<br>                             │<br>                             │<br>                             ▼<br>                          master<br>                             │<br>                             │<br>                             ▼<br>┌───┐    ┌───┐    ┌───┐    ┌───┐<br>│   │───▶│   │───▶│   │───▶│   │<br>└───┘    └───┘    └───┘    └───┘<br></code></pre></td></tr></table></figure><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b dev<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="git-checkout-切换分支"><a href="#git-checkout-切换分支" class="headerlink" title="git checkout &lt;name&gt;切换分支"></a><code>git checkout &lt;name&gt;</code>切换分支</h3><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>命令加上<code>-b</code>参数表示创建并切换</p><p>相当于以下两条命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git branch dev<br><span class="hljs-variable">$ </span>git checkout dev<br><span class="hljs-title class_">Switched</span> to branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="用git-branch命令查看当前分支"><a href="#用git-branch命令查看当前分支" class="headerlink" title="用git branch命令查看当前分支"></a>用<code>git branch</code>命令查看当前分支</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* dev</span><br>  master<br></code></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick.<br></code></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git commit -m <span class="hljs-string">&quot;branch test&quot;</span><br>[<span class="hljs-meta">dev b17d20e</span>] branch test<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022533080576/0" alt="git-br-on-master"></p><h3 id="git-merge命令用于合并指定分支到当前分支"><a href="#git-merge命令用于合并指定分支到当前分支" class="headerlink" title="git merge命令用于合并指定分支到当前分支"></a><code>git merge</code>命令用于合并指定分支到当前分支</h3><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git merge dev<br><span class="hljs-function"><span class="hljs-title">Updating</span></span> d46f35e..b17d20e<br>Fast-forward<br> readme.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$ </span>git branch -d dev<br>Deleted branch dev (was b17d20e).<br></code></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-keyword">switch</span> -c feature1<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;feature1&#x27;</span><br></code></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick AND simple.<br></code></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">add</span> readme.txt<br><br>$ git commit -m <span class="hljs-string">&quot;AND simple&quot;</span><br>[feature1 14096d0] <span class="hljs-keyword">AND</span> simple<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+), 1 deletio<span class="hljs-meta">n</span>(-)<br></code></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git switch master<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch <span class="hljs-keyword">is</span> ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> <span class="hljs-keyword">commit</span>.<br>  (use &quot;git push&quot; <span class="hljs-keyword">to</span> publish your <span class="hljs-keyword">local</span> commits)<br></code></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick &amp; simple.<br></code></pre></td></tr></table></figure><p>提交：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git commit -m <span class="hljs-string">&quot;&amp; simple&quot;</span><br>[master 5dc6824] &amp; simple<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+), 1 deletio<span class="hljs-meta">n</span>(-)<br></code></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                            HEAD<br>                              │<br>                              │<br>                              ▼<br>                           master<br>                              │<br>                              │<br>                              ▼<br>                            ┌───┐<br>                         ┌─▶│   │<br>┌───┐    ┌───┐    ┌───┐  │  └───┘<br>│   │───▶│   │───▶│   │──┤<br>└───┘    └───┘    └───┘  │  ┌───┐<br>                         └─▶│   │<br>                            └───┘<br>                              ▲<br>                              │<br>                              │<br>                          feature1<br></code></pre></td></tr></table></figure><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git merge feature1<br>Auto-merging readme.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> readme.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Your branch is ahead of &#x27;origin/master&#x27; <span class="hljs-keyword">by</span> 2 commits.<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-keyword">local</span> commits)<br><br>You have unmerged paths.<br>  (fix conflicts and <span class="hljs-keyword">run</span> <span class="hljs-string">&quot;git commit&quot;</span>)<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git merge --abort&quot;</span> to abort the <span class="hljs-keyword">merge</span>)<br><br>Unmerged paths:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to <span class="hljs-keyword">mark</span> resolution)<br><br>both modified:   readme.txt<br><br><span class="hljs-keyword">no</span> changes added to commit (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">Git <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> distributed <span class="hljs-keyword">version</span> control <span class="hljs-built_in">system</span>.<br>Git <span class="hljs-keyword">is</span> free software distributed under the GPL.<br>Git <span class="hljs-built_in">has</span> <span class="hljs-keyword">a</span> mutable <span class="hljs-built_in">index</span> called stage.<br>Git tracks <span class="hljs-keyword">changes</span> of <span class="hljs-keyword">files</span>.<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick &amp; simple.<br>=======<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Creating a <span class="hljs-keyword">new</span> branch <span class="hljs-keyword">is</span> quick and simple.<br></code></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git <span class="hljs-keyword">commit</span> -m &quot;conflict fixed&quot;<br>[master cf810e4] <span class="hljs-keyword">conflict</span> fixed<br></code></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                                     HEAD<br>                                       │<br>                                       │<br>                                       ▼<br>                                    master<br>                                       │<br>                                       │<br>                                       ▼<br>                            ┌───┐    ┌───┐<br>                         ┌─▶│   │───▶│   │<br>┌───┐    ┌───┐    ┌───┐  │  └───┘    └───┘<br>│   │───▶│   │───▶│   │──┤             ▲<br>└───┘    └───┘    └───┘  │  ┌───┐      │<br>                         └─▶│   │──────┘<br>                            └───┘<br>                              ▲<br>                              │<br>                              │<br>                          feature1<br></code></pre></td></tr></table></figure><h3 id="用带参数的git-log可以看到分支的合并情况"><a href="#用带参数的git-log可以看到分支的合并情况" class="headerlink" title="用带参数的git log可以看到分支的合并情况"></a>用带参数的<code>git log</code>可以看到分支的合并情况</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br><span class="hljs-comment">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br>|\  <br>| * <span class="hljs-number">14096</span>d0 (feature1) <span class="hljs-keyword">AND</span> simple<br><span class="hljs-comment">* | 5dc6824 &amp; simple</span><br>|/  <br><span class="hljs-comment">* b17d20e branch test</span><br><span class="hljs-comment">* d46f35e (origin/master) remove test.txt</span><br><span class="hljs-comment">* b84166e add test.txt</span><br><span class="hljs-comment">* 519219b git tracks changes</span><br><span class="hljs-comment">* e43a48b understand how stage works</span><br><span class="hljs-comment">* 1094adb append GPL</span><br><span class="hljs-comment">* e475afc add distributed</span><br><span class="hljs-comment">* eaadf4e wrote a readme file</span><br></code></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><h3 id="git-merge-no-ff-m-merge-with-no-ff-dev用普通模式合并"><a href="#git-merge-no-ff-m-merge-with-no-ff-dev用普通模式合并" class="headerlink" title="git merge --no-ff -m &quot;merge with no-ff&quot; dev用普通模式合并"></a><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>用普通模式合并</h3><p>合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">merge</span> --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> dev<br><span class="hljs-keyword">Merge</span> made <span class="hljs-keyword">by</span> the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> readme.txt | 1 +<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+)<br></code></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --pretty=oneline --abbrev-commit</span><br>*   e1e9c68 (HEAD -&gt; master) <span class="hljs-built_in">merge</span> <span class="hljs-keyword">with</span> no-ff<br>|\  <br>| * f52c633 (dev) <span class="hljs-built_in">add</span> <span class="hljs-built_in">merge</span><br>|/  <br>*   cf810e4 conflict fixed<br>...<br></code></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023225142304/0" alt="git-no-ff-mode"></p><h3 id="团队合作中"><a href="#团队合作中" class="headerlink" title="团队合作中"></a>团队合作中</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023260793600/0" alt="git-br-policy"></p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><h3 id="git-stash保存工作现场"><a href="#git-stash保存工作现场" class="headerlink" title="git stash保存工作现场"></a><code>git stash</code>保存工作现场</h3><p>在bug修复后继续工作</p><p>Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">$ git stash<br>Saved working directory and index <span class="hljs-keyword">state</span> WIP <span class="hljs-keyword">on</span> dev: f52c633 add merge<br></code></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">$ git stash<br>Saved working directory and index <span class="hljs-keyword">state</span> WIP <span class="hljs-keyword">on</span> dev: f52c633 add merge<br></code></pre></td></tr></table></figure><h3 id="git-checkout-b-issue-101在主分支上创建修复用的临时分支"><a href="#git-checkout-b-issue-101在主分支上创建修复用的临时分支" class="headerlink" title="git checkout -b issue-101在主分支上创建修复用的临时分支"></a><code>git checkout -b issue-101</code>在主分支上创建修复用的临时分支</h3><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">6</span> commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>$ git checkout -b issue<span class="hljs-number">-101</span><br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;issue-101&#x27;</span><br></code></pre></td></tr></table></figure><p>现在修复bug，然后提交：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git <span class="hljs-keyword">add</span> readme.txt <br>$ git commit -m <span class="hljs-string">&quot;fix bug 101&quot;</span><br>[issue-101 4c805e2] fix bug 101<br> 1 <span class="hljs-keyword">file</span> changed, 1 insertio<span class="hljs-meta">n</span>(+), 1 deletio<span class="hljs-meta">n</span>(-)<br></code></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">6</span> commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>$ git <span class="hljs-built_in">merge</span> <span class="hljs-comment">--no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> readme.txt | <span class="hljs-number">2</span> +-<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+), <span class="hljs-number">1</span> deletion(-)<br></code></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git switch dev<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br><br>$ git status<br><span class="hljs-keyword">On</span> branch dev<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">$ git stash <span class="hljs-keyword">list</span><br>stash@&#123;0&#125;: WIP <span class="hljs-keyword">on</span> dev: f52c633 <span class="hljs-keyword">add</span> <span class="hljs-keyword">merge</span><br></code></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git stash <span class="hljs-keyword">pop</span><br>On branch dev<br>Changes <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>:   hello.<span class="hljs-keyword">py</span><br><br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br>Dropped refs/stash@&#123;<span class="hljs-number">0</span>&#125; (<span class="hljs-number">5</span>d677e2ee266f39ea296182fb2354265b91b3b2a)<br></code></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git stash list<br></code></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ git stash apply <span class="hljs-symbol">stash@</span>&#123;<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><h3 id="git-cherry-pick复制特定的提交到当前分支"><a href="#git-cherry-pick复制特定的提交到当前分支" class="headerlink" title="git cherry-pick复制特定的提交到当前分支"></a><code>git cherry-pick</code>复制特定的提交到当前分支</h3><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git cherry-pick <span class="hljs-number">4</span>c805e2<br>[<span class="hljs-keyword">master</span> <span class="hljs-title">1d4b803</span>] fix bug <span class="hljs-number">101</span><br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> insertion(+), <span class="hljs-number">1</span> deletion(-)<br></code></pre></td></tr></table></figure><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动</p><h2 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h2><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-keyword">switch</span> -c feature-vulcan<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;feature-vulcan&#x27;</span><br></code></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git <span class="hljs-built_in">add</span> vulcan.<span class="hljs-keyword">py</span><br><br>$ git status<br>On branch feature-vulcan<br>Changes <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>:   vulcan.<span class="hljs-keyword">py</span><br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;add feature vulcan&quot;</span><br>[feature-vulcan <span class="hljs-number">287773</span><span class="hljs-keyword">e</span>] <span class="hljs-built_in">add</span> feature vulcan<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">2</span> insertions(+)<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> vulcan.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git <span class="hljs-keyword">switch</span> dev<br></code></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><h3 id="git-branch-D-branchname强行删除未提交分支"><a href="#git-branch-D-branchname强行删除未提交分支" class="headerlink" title="git branch -D branchname强行删除未提交分支"></a><code>git branch -D branchname</code>强行删除未提交分支</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ git branch -d feature-vulcan<br><span class="hljs-keyword">error: </span>The branch &#x27;feature-vulcan&#x27; is not fully merged.<br>If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.<br></code></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">$ git branch -D <span class="hljs-built_in">feature</span>-vulcan<br>Deleted branch <span class="hljs-built_in">feature</span>-vulcan (was <span class="hljs-number">287773</span>e).<br></code></pre></td></tr></table></figure><p>终于删除成功！</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><h3 id="用git-remote查看远程库的信息"><a href="#用git-remote查看远程库的信息" class="headerlink" title="用git remote查看远程库的信息"></a>用<code>git remote</code>查看远程库的信息</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote<br>origin<br></code></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learngit.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learngit.git (push)<br></code></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="git-push-origin-name推送分支"><a href="#git-push-origin-name推送分支" class="headerlink" title="git push origin name推送分支"></a><code>git push origin name</code>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> dev<br></code></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><h4 id="git-clone-git-github-com-michaelliao-learngit-git抓取克隆"><a href="#git-clone-git-github-com-michaelliao-learngit-git抓取克隆" class="headerlink" title="git clone git@github.com:michaelliao/learngit.git抓取克隆"></a><code>git clone git@github.com:michaelliao/learngit.git</code>抓取克隆</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git clone git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learngit.git<br>Cloning into <span class="hljs-string">&#x27;learngit&#x27;</span>...<br><span class="hljs-attribute">remote</span>: Counting <span class="hljs-attribute">objects</span>: <span class="hljs-number">40</span>, done.<br><span class="hljs-attribute">remote</span>: Compressing <span class="hljs-attribute">objects</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">21</span>/<span class="hljs-number">21</span>), done.<br><span class="hljs-attribute">remote</span>: Total <span class="hljs-number">40</span> (delta <span class="hljs-number">14</span>), reused <span class="hljs-number">40</span> (delta <span class="hljs-number">14</span>), pack-reused <span class="hljs-number">0</span><br>Receiving <span class="hljs-attribute">objects</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">40</span>/<span class="hljs-number">40</span>), done.<br>Resolving <span class="hljs-attribute">deltas</span>: <span class="hljs-number">100%</span> (<span class="hljs-number">14</span>/<span class="hljs-number">14</span>), done.<br></code></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br></code></pre></td></tr></table></figure><h4 id="git-checkout-b-dev-origin-dev抓取多个分支"><a href="#git-checkout-b-dev-origin-dev抓取多个分支" class="headerlink" title="git checkout -b dev origin/dev抓取多个分支"></a><code>git checkout -b dev origin/dev</code>抓取多个分支</h4><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ git checkout -b <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><h3 id="同步分支"><a href="#同步分支" class="headerlink" title="同步分支"></a>同步分支</h3><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$ </span>git add env.txt<br><br><span class="hljs-string">$ </span>git commit -m <span class="hljs-string">&quot;add env&quot;</span><br>[dev <span class="hljs-number">7</span>a5e5dd] add env<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> insertion(+)<br> create mode <span class="hljs-number">100644</span> env.txt<br><br><span class="hljs-string">$ </span>git push origin dev<br>Counting objects: <span class="hljs-number">3</span>, done.<br>Delta compression using up to <span class="hljs-number">4</span> threads.<br>Compressing objects: <span class="hljs-number">100</span><span class="hljs-comment">% (2/2), done.</span><br>Writing objects: <span class="hljs-number">100</span><span class="hljs-comment">% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br>Total <span class="hljs-number">3</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br>   f52c633..<span class="hljs-number">7</span>a5e5dd  dev -&gt; dev<br></code></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git pull<br>There <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> tracking information <span class="hljs-keyword">for</span> the current branch.<br>Please specify which branch you want <span class="hljs-keyword">to</span> merge with.<br>See git-pull(<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> details.<br><br>    git pull <span class="hljs-symbol">&lt;remote&gt;</span> <span class="hljs-symbol">&lt;branch&gt;</span><br><br>If you wish <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> tracking information <span class="hljs-keyword">for</span> this branch you can <span class="hljs-keyword">do</span> <span class="hljs-keyword">so</span> with:<br><br>    git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/<span class="hljs-symbol">&lt;branch&gt;</span> dev<br></code></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git branch <span class="hljs-attribute">--set-upstream-to</span>=origin/dev dev<br>Branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-built_in">set</span> up <span class="hljs-keyword">to</span> track remote branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git pull<br>Auto-merging env.txt<br><span class="hljs-keyword">CONFLICT</span> (<span class="hljs-keyword">add</span>/<span class="hljs-keyword">add</span>): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> env.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">commit</span> -m &quot;fix env conflict&quot;<br>[dev <span class="hljs-number">57</span>c53ab] fix env <span class="hljs-keyword">conflict</span><br><br>$ git push origin dev<br>Counting objects: <span class="hljs-number">6</span>, done.<br>Delta compression <span class="hljs-keyword">using</span> up <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> threads.<br>Compressing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">4</span>/<span class="hljs-number">4</span>), done.<br>Writing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">6</span>/<span class="hljs-number">6</span>), <span class="hljs-number">621</span> bytes | <span class="hljs-number">621.00</span> KiB/s, done.<br>Total <span class="hljs-number">6</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br><span class="hljs-keyword">To</span> github.com:michaelliao/learngit.git<br>   <span class="hljs-number">7</span>a5e5dd.<span class="hljs-number">.57</span>c53ab  dev -&gt; dev<br></code></pre></td></tr></table></figure><h3 id="git-rebase把本地未push的分叉提交历史整理成直线"><a href="#git-rebase把本地未push的分叉提交历史整理成直线" class="headerlink" title="git rebase把本地未push的分叉提交历史整理成直线"></a><code>git rebase</code>把本地未push的分叉提交历史整理成直线</h3><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git rebase<br>First, rewinding head <span class="hljs-keyword">to</span> replay your work <span class="hljs-keyword">on</span> top of it...<br>Applying: <span class="hljs-built_in">add</span> comment<br>Using <span class="hljs-built_in">index</span> info <span class="hljs-keyword">to</span> reconstruct <span class="hljs-keyword">a</span> base tree...<br>Mhello.<span class="hljs-keyword">py</span><br>Falling back <span class="hljs-keyword">to</span> patching base <span class="hljs-built_in">and</span> <span class="hljs-number">3</span>-way merge...<br>Auto-merging hello.<span class="hljs-keyword">py</span><br>Applying: <span class="hljs-built_in">add</span> author<br>Using <span class="hljs-built_in">index</span> info <span class="hljs-keyword">to</span> reconstruct <span class="hljs-keyword">a</span> base tree...<br>Mhello.<span class="hljs-keyword">py</span><br>Falling back <span class="hljs-keyword">to</span> patching base <span class="hljs-built_in">and</span> <span class="hljs-number">3</span>-way merge...<br>Auto-merging hello.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git log --graph --pretty=oneline --abbrev-commit<br>* <span class="hljs-number">7</span>e61ed4 (HEAD -&gt; master) add author<br>* <span class="hljs-number">3611</span>cfe add comment<br>* f005ed4 (origin/master) set <span class="hljs-keyword">exit</span>=<span class="hljs-number">1</span><br>* d1be385 init hello<br>...<br></code></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mac</span>:~/learngit michael$ git push origin master<br><span class="hljs-attribute">Counting</span> objects: <span class="hljs-number">6</span>, done.<br><span class="hljs-attribute">Delta</span> compression using up to <span class="hljs-number">4</span> threads.<br><span class="hljs-attribute">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), done.<br><span class="hljs-attribute">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">6</span>/<span class="hljs-number">6</span>), <span class="hljs-number">576</span> bytes | <span class="hljs-number">576</span>.<span class="hljs-number">00</span> KiB/s, done.<br><span class="hljs-attribute">Total</span> <span class="hljs-number">6</span> (delta <span class="hljs-number">2</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br><span class="hljs-attribute">remote</span>: Resolving deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">2</span>/<span class="hljs-number">2</span>), completed with <span class="hljs-number">1</span> local object.<br><span class="hljs-attribute">To</span> github.com:michaelliao/learngit.git<br>   <span class="hljs-attribute">f005ed4</span>..<span class="hljs-number">7</span>e61ed4  master -&gt; master<br></code></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git log --graph --pretty=oneline --abbrev-commit<br>* <span class="hljs-number">7</span>e61ed4 (HEAD -&gt; master, origin/master) add author<br>* <span class="hljs-number">3611</span>cfe add comment<br>* f005ed4 set <span class="hljs-keyword">exit</span>=<span class="hljs-number">1</span><br>* d1be385 init hello<br>...<br></code></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><blockquote><p>标签是指向commit的<strong>死指针</strong>，分支是指向commit的<strong>活指针</strong></p><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p></blockquote><h2 id="git-tag-创建标签"><a href="#git-tag-创建标签" class="headerlink" title="git tag &lt;name&gt;创建标签"></a><code>git tag &lt;name&gt;</code>创建标签</h2><p>首先，切换到需要打标签的分支上：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">log</span> <span class="hljs-comment">--pretty=oneline --abbrev-commit</span><br><span class="hljs-number">12</span>a631b (HEAD -&gt; master, tag: v1<span class="hljs-number">.0</span>, origin/master) merged bug fix <span class="hljs-number">101</span><br><span class="hljs-number">4</span>c805e2 fix bug <span class="hljs-number">101</span><br>e1e9c68 merge <span class="hljs-keyword">with</span> <span class="hljs-keyword">no</span>-ff<br>f52c633 <span class="hljs-keyword">add</span> merge<br>cf810e4 <span class="hljs-keyword">conflict</span> fixed<br><span class="hljs-number">5</span>dc6824 &amp; simple<br><span class="hljs-number">14096</span>d0 <span class="hljs-keyword">AND</span> simple<br>b17d20e branch test<br>d46f35e remove test.txt<br>b84166e <span class="hljs-keyword">add</span> test.txt<br><span class="hljs-number">519219</span>b git tracks changes<br>e43a48b understand how stage works<br><span class="hljs-number">1094</span>adb append GPL<br>e475afc <span class="hljs-keyword">add</span> distributed<br>eaadf4e wrote a readme file<br></code></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">9</span> f52c633<br></code></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v0</span>.<span class="hljs-number">9</span><br>v1.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span> v0<span class="hljs-number">.9</span><br><span class="hljs-keyword">commit</span> f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0<span class="hljs-number">.9</span>)<br>Author: Michael Liao <span class="hljs-operator">&lt;</span>askxuefeng<span class="hljs-variable">@gmail</span>.com<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">56</span>:<span class="hljs-number">54</span> <span class="hljs-number">2018</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">merge</span><br><br>diff <span class="hljs-comment">--git a/readme.txt b/readme.txt</span><br>...<br></code></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v0.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git show v0.<span class="hljs-number">1</span><br><span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">1</span><br>Tagger: Michael Liao <span class="hljs-tag">&lt;askxuefeng@gmail.com&gt;</span><br><span class="hljs-keyword">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">22</span>:<span class="hljs-number">48</span>:<span class="hljs-number">43</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br><span class="hljs-keyword">version</span> <span class="hljs-number">0.1</span> released<br><br>commit <span class="hljs-number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (<span class="hljs-keyword">tag</span>: v0.<span class="hljs-number">1</span>)<br>Author: Michael Liao <span class="hljs-tag">&lt;askxuefeng@gmail.com&gt;</span><br><span class="hljs-keyword">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    append GPL<br><br>diff --git a/readme.txt b/readme.txt<br>...<br></code></pre></td></tr></table></figure><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，也可以删除：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">1</span><br>Deleted <span class="hljs-keyword">tag</span> <span class="hljs-title">&#x27;v0</span>.<span class="hljs-number">1</span>&#x27; (was f15b0dd)<br></code></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> v1<span class="hljs-number">.0</span><br>Total <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br> * [<span class="hljs-built_in">new</span> tag]         v1<span class="hljs-number">.0</span> -&gt; v1<span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br>Total <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (<span class="hljs-built_in">delta</span> <span class="hljs-number">0</span>)<br>To github.com:michaelliao/learngit.git<br> * [<span class="hljs-built_in">new</span> tag]         v0<span class="hljs-number">.9</span> -&gt; v0<span class="hljs-number">.9</span><br></code></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v0.<span class="hljs-number">9</span><br>Deleted <span class="hljs-keyword">tag</span> <span class="hljs-title">&#x27;v0</span>.<span class="hljs-number">9</span>&#x27; (was f52c633)<br></code></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git push origin <span class="hljs-symbol">:refs/tags/v0</span>.<span class="hljs-number">9</span><br><span class="hljs-title class_">To</span> <span class="hljs-symbol">github.com:</span>michaelliao/learngit.git<br> - [deleted]         v0.<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><a href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
      <category>git学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript逆向简介</title>
    <link href="/Blogs/2025/08/28/javascript%E9%80%86%E5%90%91%E7%AE%80%E4%BB%8B/"/>
    <url>/Blogs/2025/08/28/javascript%E9%80%86%E5%90%91%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="网站加密技术简介"><a href="#网站加密技术简介" class="headerlink" title="网站加密技术简介"></a>网站加密技术简介</h1><p>随着大数据时代的发展，各个公司的数据保护意识越来越强，大家都在想尽办法保护自家产品的数据不轻易被爬虫爬走。由于网页是提供信息和服务的重要载体，所以对网页上的信息进行保护就成了至关重要的一个环节。</p><p>网页是运行在浏览器端的，当我们浏览一个网页时，其 HTML 代码、 JavaScript 代码都会被下载到浏览器中执行。借助浏览器的开发者工具，我们可以看到网页在加载过程中所有网络请求的详细信息，也能清楚地看到网站运行的 HTML 代码和 JavaScript 代码，这些代码中就包含了网站加载的全部逻辑，如加载哪些资源、请求接口是如何构造的、页面是如何渲染的等等。正因为代码是完全透明的，所以如果我们能够把其中的执行逻辑研究出来，就可以模拟各个网络请求进行数据爬取了。</p><p>然而，事情没有想象得那么简单。随着前端技术的发展，前端代码的打包技术、混淆技术、加密技术也层出不穷，借助于这些技术，各个公司可以在前端对 JavaScript 代码采取一定的保护，比如变量名混淆、执行逻辑混淆、反调试、核心逻辑加密等，这些保护手段使得我们没法很轻易地找出 JavaScript 代码中包含的的执行逻辑。</p><p>在前几章的案例中，我们也试着爬取了各种形式的网站。其中有的网站的数据接口是没有任何验证或加密参数的，我们可以轻松模拟并爬取其中的数据；但有的网站稍显复杂，网站的接口中增加了一些加密参数，同时对 JavaScript 代码采取了上文所述的一些防护措施，当时我们没有直接尝试去破解，而是用 Selenium 等类似工具来实现模拟浏览器执行的方式来进行 “所见即所得 “的爬取。其实对于后者，我们还有另外一种解决方案，那就是直接逆向 JavaScript 代码，找出其中的加密逻辑，从而直接实现该加密逻辑来进行爬取。如果加密逻辑实在过于复杂，我们也可以找出一些关键入口，从而实现对加密逻辑的单独模拟执行和数据爬取。这些方案难度可能很大，比如关键入口很难寻找，或者加密逻辑难以模拟，可是一旦成功找到突破口，我们便可以不用借助于 Selenium 等工具进行整页数据的渲染而实现数据爬取，这样爬取效率会大幅提升。</p><p>本章我们首先会对 JavaScript 防护技术进行介绍，然后介绍一些常用的 JavaScript 逆向技巧，包括浏览器工具的使用、Hook 技术、AST 技术、特殊混淆技术的处理、WebAssembly 技术的处理。了解了这些技术，我们可以更从容地应对 JavaScript 防护技术。</p><h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a><a href="https://cuiqingcai.com/2022111.html#1-%E5%BC%95%E5%85%A5" title="1. 引入"></a>1. 引入</h2><p>我们在爬取网站的时候，会遇到一些情况需要分析一些接口或 URL 信息，在这个过程中，我们会遇到各种各样类似加密的情形，比如说：</p><ul><li>某个网站的 URL 带有一些看不太懂的长串加密参数，要抓取就必须要懂得这些参数是怎么构造的，否则我们连完整的 URL 都构造不出来，更不用说爬取了。</li><li>分析某个网站的 Ajax 接口的时候，可以看到接口的一些参数也是加密的，或者 Request Headers 里面也可能带有一些加密参数，如果不知道这些参数的具体构造逻辑就没法直接用程序来模拟这些 Ajax 请求。</li><li>翻看网站的 JavaScript 源代码，可以发现很多压缩了或者看不太懂的字符，比如 JavaScript 文件名被编码，JavaScript 的文件内容都压缩成几行，JavaScript 变量也被修改成单个字符或者一些十六进制的字符，导致我们不好轻易根据 JavaScript 找出某些接口的加密逻辑。</li></ul><p>这些情况呢，基本上都是网站为了保护其本身的一些数据不被轻易抓取而采取的一些措施，我们可以把它归类为两大类：</p><ul><li>URL&#x2F;API 参数加密</li><li>JavaScript 压缩、混淆和加密</li></ul><p>这一节我们就来了解下这两类技术的基本原理和一些常见的示例。知己知彼，百战不殆，了解了这些技术的实现原理之后，我们才能更好地去逆向其中的逻辑，从而实现数据爬取。</p><h2 id="2-网站数据防护方案"><a href="#2-网站数据防护方案" class="headerlink" title="2. 网站数据防护方案"></a><a href="https://cuiqingcai.com/2022111.html#2-%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E9%98%B2%E6%8A%A4%E6%96%B9%E6%A1%88" title="2. 网站数据防护方案"></a>2. 网站数据防护方案</h2><p>当今大数据时代，数据已经变得越来越重要，网页和 App 现在是主流的数据载体，如果其数据的 API 没有设置任何保护措施，在爬虫工程师解决了一些基本的反爬如封 IP、验证码的问题之后，那么数据还是可以被轻松爬取到的。</p><p>那么，有没有可能在 URL&#x2F;API 层面或 JavaScript 层面也加上一层防护呢？答案是可以。</p><h3 id="URL-API-参数加密"><a href="#URL-API-参数加密" class="headerlink" title="URL&#x2F;API 参数加密"></a><a href="https://cuiqingcai.com/2022111.html#URL-API-%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86" title="URL/API 参数加密"></a>URL&#x2F;API 参数加密</h3><p>网站运营者首先想到防护措施可能是对某些数据接口的参数进行加密，比如说对某些 URL 的一些参数加上校验码或者把一些 id 信息进行编码，使其变得难以阅读或构造；或者对某些 API 请求加上一些 token、sign 等签名，这样这些请求发送到服务器时，服务器会通过客户端发来的一些请求信息以及双方约定好的秘钥等来对当前的请求进行校验，如果校验通过，才返回对应数据结果。</p><p>比如说客户端和服务端约定一种接口校验逻辑，客户端在每次请求服务端接口的时候都会附带一个 sign 参数，这个 sign 参数可能是由当前时间信息、请求的 URL、请求的数据、设备的 ID、双方约定好的秘钥经过一些加密算法构造而成的，客户端会实现这个加密算法构造 sign，然后每次请求服务器的时候附带上这个参数。服务端会根据约定好的算法和请求的数据对 sign 进行校验，如果校验通过，才返回对应的数据，否则拒绝响应。</p><p>当然登录状态的校验也可以看作是此类方案，比如一个 API 的调用必须要传一个 token，这个 token 必须用户登录之后才能获取，如果请求的时候不带该 token，API 就不会返回任何数据。</p><p>倘若没有这种措施，那么基本上 URL 或者 API 接口是完全公开可以访问的，这意味着任何人都可以直接调用来获取数据，几乎是零防护的状态，这样是非常危险的，而且数据也可以被轻易地被爬虫爬取。因此对 URL&#x2F;API 参数一些加密和校验是非常有必要的。</p><h3 id="JavaScript-压缩、混淆和加密"><a href="#JavaScript-压缩、混淆和加密" class="headerlink" title="JavaScript 压缩、混淆和加密"></a><a href="https://cuiqingcai.com/2022111.html#JavaScript-%E5%8E%8B%E7%BC%A9%E3%80%81%E6%B7%B7%E6%B7%86%E5%92%8C%E5%8A%A0%E5%AF%86" title="JavaScript 压缩、混淆和加密"></a>JavaScript 压缩、混淆和加密</h3><p>接口加密技术看起来的确是一个不错的解决方案，但单纯依靠它并不能很好地解决问题。为什么呢？</p><p>对于网页来说，其逻辑是依赖于 JavaScript 来实现的，JavaScript 有如下特点：</p><ul><li>JavaScript 代码运行于客户端，也就是它必须要在用户浏览器端加载并运行。</li><li>JavaScript 代码是公开透明的，也就是说浏览器可以直接获取到正在运行的 JavaScript 的源码。</li></ul><p>由于这两个原因，至使 JavaScript 代码是不安全的，任何人都可以读、分析、复制、盗用，甚至篡改。</p><p>所以说，对于上述情形，客户端 JavaScript 对于某些加密的实现是很容易被找到或模拟的，了解了加密逻辑后，模拟参数的构造和请求也就是轻而易举了，所以如果 JavaScript 没有做任何层面的保护的话，接口加密技术基本上对数据起不到什么防护作用。</p><p>如果你不想让自己的数据被轻易获取，不想他人了解 JavaScript 逻辑的实现，或者想降低被不怀好意的人甚至是黑客攻击。那么就需要用到 JavaScript 压缩、混淆和加密技术了。</p><p>这里压缩、混淆和加密技术简述如下：</p><ul><li><p>代码压缩：即去除 JavaScript 代码中的不必要的空格、换行等内容，使源码都压缩为几行内容，降低代码可读性，当然同时也能提高网站的加载速度。</p></li><li><p>代码混淆：使用变量替换、字符串阵列化、控制流平坦化、多态变异、僵尸函数、调试保护等手段，使代码变地难以阅读和分析，达到最终保护的目的。但这不影响代码原有功能。是理想、实用的 JavaScript 保护方案。</p></li><li><p>代码加密：可以通过某种手段将 JavaScript 代码进行加密，转成人无法阅读或者解析的代码，如借用 WebAssembly 技术，可以直接将 JavaScript 代码用 C&#x2F;C++ 实现，JavaScript 调用其编译后形成的文件来执行相应的功能。</p></li></ul><p>下面我们对上面的技术分别予以介绍。</p><h2 id="3-URL-API-参数加密"><a href="#3-URL-API-参数加密" class="headerlink" title="3. URL&#x2F;API 参数加密"></a><a href="https://cuiqingcai.com/2022111.html#3-URL-API-%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86" title="3. URL/API 参数加密"></a>3. URL&#x2F;API 参数加密</h2><p>现在绝大多数网站的数据一般都是通过服务器提供的 API 来获取的，网站或 App 可以请求某个数据 API 获取到对应的数据，然后再把获取的数据展示出来。但有些数据是比较宝贵或私密的，这些数据肯定是需要一定层面上的保护。所以不同 API 的实现也就对应着不同的安全防护级别，我们这里来总结下。</p><p>为了提升接口的安全性，客户端会和服务端约定一种接口校验方式，一般来说会使用到各种加密和编码算法，如 Base64、Hex 编码，MD5、AES、DES、RSA 等对称或非对称加密。</p><p>举个例子，比如说客户端和服务器双方约定一个 sign 用作接口的签名校验，其生成逻辑是客户端将 URL Path 进行 MD5 加密然后拼接上 URL 的某个参数再进行 Base64 编码，最后得到一个字符串 sign，这个 sign 会通过 Request URL 的某个参数或 Request Headers 发送给服务器。服务器接收到请求后，对 URL Path 同样进行 MD5 加密，然后拼接上 URL 的某个参数，也进行 Base64 编码也得到了一个 sign，然后比对生成的 sign 和客户端发来的 sign 是否是一致的，如果是一致的，那就返回正确的结果，否则拒绝响应。这就是一个比较简单的接口参数加密的实现。如果有人想要调用这个接口的话，必须要定义好 sign 的生成逻辑，否则是无法正常调用接口的。</p><p>当然上面的这个实现思路比较简单，这里还可以增加一些时间戳信息增加时效性判断，或增加一些非对称加密进一步提高加密的复杂程度。但不管怎样，只要客户端和服务器约定好了加密和校验逻辑，任何形式加密算法都是可以的。</p><p>这里要实现接口参数加密就需要用到一些加密算法，客户端和服务器肯定也都有对应的 SDK 实现这些加密算法，如 JavaScript 的 crypto-js，Python 的 hashlib、Crypto 等等。</p><p>但还是如上文所说，如果是网页的话，客户端实现加密逻辑如果是用 JavaScript 来实现，其源代码对用户是完全可见的，如果没有对 JavaScript 做任何保护的话，是很容易弄清楚客户端加密的流程的。</p><p>因此，我们需要对 JavaScript 利用压缩、混淆等方式来对客户端的逻辑进行一定程度上的保护。</p><h2 id="4-JavaScript-压缩"><a href="#4-JavaScript-压缩" class="headerlink" title="4. JavaScript 压缩"></a><a href="https://cuiqingcai.com/2022111.html#4-JavaScript-%E5%8E%8B%E7%BC%A9" title="4. JavaScript 压缩"></a>4. JavaScript 压缩</h2><p>这个非常简单，JavaScript 压缩即去除 JavaScript 代码中的不必要的空格、换行等内容或者把一些可能公用的代码进行处理实现共享，最后输出的结果都压缩为几行内容，代码可读性变得很差，同时也能提高网站加载速度。</p><p>如果仅仅是去除空格换行这样的压缩方式，其实几乎是没有任何防护作用的，因为这种压缩方式仅仅是降低了代码的直接可读性。如果我们有一些格式化工具可以轻松将 JavaScript 代码变得易读，比如利用 IDE、在线工具或 Chrome 浏览器都能还原格式化的代码。</p><p>比如这里举一个最简单的 JavaScript 压缩示例，原来的 JavaScript 代码是这样的：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">echo</span><span class="hljs-params">(stringA, stringB)</span> &#123;  <br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Germey&quot;</span>;  <br>  alert(<span class="hljs-string">&quot;hello &quot;</span> + name);  <br>&#125;<br></code></pre></td></tr></table></figure><p>压缩之后就变成这样子：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">function echo(d, c) &#123;  <span class="hljs-variable">&lt;br&gt;</span>  <span class="hljs-keyword">const</span> e = <span class="hljs-string">&quot;Germey&quot;</span>;  <span class="hljs-variable">&lt;br&gt;</span>  alert(<span class="hljs-string">&quot;hello &quot;</span> + e);  <span class="hljs-variable">&lt;br&gt;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里参数的名称都被简化了，代码中的空格也被去掉了，整个代码也被压缩成了一行，代码的整体可读性降低了。</p><p>目前主流的前端开发技术大多都会利用 Webpack、Rollup 等工具进行打包，Webpack、Rollup 会对源代码进行编译和压缩，输出几个打包好的 JavaScript 文件，其中我们可以看到输出的 JavaScript 文件名带有一些不规则字符串，同时文件内容可能只有几行内容，变量名都是一些简单字母表示。这其中就包含 JavaScript 压缩技术，比如一些公共的库输出成 bundle 文件，一些调用逻辑压缩和转义成冗长的几行代码，这些都属于 JavaScript 压缩。另外其中也包含了一些很基础的 JavaScript 混淆技术，比如把变量名、方法名替换成一些简单字符，降低代码可读性。</p><p>但整体来说，JavaScript 压缩技术只能在很小的程度上起到防护作用，要想真正提高防护效果还得依靠 JavaScript 混淆和加密技术。</p><h2 id="5-JavaScript-混淆"><a href="#5-JavaScript-混淆" class="headerlink" title="5. JavaScript 混淆"></a><a href="https://cuiqingcai.com/2022111.html#5-JavaScript-%E6%B7%B7%E6%B7%86" title="5. JavaScript 混淆"></a>5. JavaScript 混淆</h2><p>JavaScript 混淆是完全是在 JavaScript 上面进行的处理，它的目的就是使得 JavaScript 变得难以阅读和分析，大大降低代码可读性，是一种很实用的 JavaScript 保护方案。</p><p>JavaScript 混淆技术主要有以下几种：</p><ul><li><p>变量混淆：将带有含义的变量名、方法名、常量名随机变为无意义的类乱码字符串，降低代码可读性，如转成单个字符或十六进制字符串。</p></li><li><p>字符串混淆：将字符串阵列化集中放置、并可进行 MD5 或 Base64 加密存储，使代码中不出现明文字符串，这样可以避免使用全局搜索字符串的方式定位到入口点。</p></li><li><p>属性加密：针对 JavaScript 对象的属性进行加密转化，隐藏代码之间的调用关系。</p></li><li><p>控制流平坦化：打乱函数原有代码执行流程及函数调用关系，使代码逻变得混乱无序。</p></li><li><p>无用代码注入：随机在代码中插入不会被执行到的无用代码，进一步使代码看起来更加混乱。</p></li><li><p>调试保护：基于调试器特性，对当前运行环境进行检验，加入一些强制调试 debugger 语句，使其在调试模式下难以顺利执行 JavaScript 代码。</p></li><li><p>多态变异：使 JavaScript 代码每次被调用时，将代码自身即立刻自动发生变异，变化为与之前完全不同的代码，即功能完全不变，只是代码形式变异，以此杜绝代码被动态分析调试。</p></li><li><p>锁定域名：使 JavaScript 代码只能在指定域名下执行。</p></li><li><p>反格式化：如果对 JavaScript 代码进行格式化，则无法执行，导致浏览器假死。</p></li><li><p>特殊编码：将 JavaScript 完全编码为人不可读的代码，如表情符号、特殊表示内容等等。</p></li></ul><p>总之，以上方案都是 JavaScript 混淆的实现方式，可以在不同程度上保护 JavaScript 代码。</p><p>在前端开发中，现在 JavaScript 混淆主流的实现是 javascript-obfuscator (<a href="https://github.com/javascript-obfuscator/javascript-obfuscator">https://github.com/javascript-obfuscator/javascript-obfuscator</a>) 和 terser (<a href="https://github.com/terser/terser">https://github.com/terser/terser</a>) 这两个库，其都能提供一些代码混淆功能，也都有对应的 Webpack 和 Rollup 打包工具的插件，利用它们我们可以非常方便地实现页面的混淆，最终可以输出压缩和混淆后的 JavaScript 代码，使得 JavaScript 代码可读性大大降低。</p><p>下面我们以 javascript-obfuscator 为例来介绍一些代码混淆的实现，了解了实现，那么自然我们就对混淆的机理有了更加深刻的认识。</p><p>javascript-obfuscator 的官网地址为：<a href="https://obfuscator.io/%EF%BC%8C%E5%85%B6%E5%AE%98%E6%96%B9%E4%BB%8B%E7%BB%8D%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%EF%BC%9A">https://obfuscator.io/，其官方介绍内容如下：</a></p><blockquote><p>A free and efficient obfuscator for JavaScript (including ES2017). Make your code harder to copy and prevent people from stealing your work.</p></blockquote><p>它是支持 ES8 的免费、高效的 JavaScript 混淆库，它可以使得你的 JavaScript 代码经过混淆后难以被复制、盗用，混淆后的代码具有和原来的代码一模一样的功能。</p><p>怎么使用呢？首先，我们需要安装好 Node.js 12.x 版本及以上，确保可以正常使用 npm 命令，具体的安装方式可以参考：<a href="https://setup.scrape.center/nodejs%E3%80%82">https://setup.scrape.center/nodejs。</a></p><p>接着新建一个文件夹，比如 js-obfuscate，然后进入该文件夹，初始化工作空间：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure><p>这里会提示我们输入一些信息，创建一个 package.json 文件，这就完成了项目初始化了。</p><p>接下来我们来安装 javascript-obfuscator 这个库：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D javascript-obfuscator<br></code></pre></td></tr></table></figure><p>稍等片刻，即可看到本地 js-obfuscate 文件夹下生成了一个 node_modules 文件夹，里面就包含了 javascript-obfuscator 这个库，这就说明安装成功了，文件夹结构如图所示：</p><p><img src="https://cdn.cuiqingcai.com/viunz.png" alt="image-20210612155500985"></p><p>接下来我们就可以编写代码来实现一个混淆样例了，如新建一个 main.js 文件，内容如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">const code <span class="hljs-operator">=</span> `  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> x <span class="hljs-operator">=</span> &#x27;<span class="hljs-number">1</span>&#x27; <span class="hljs-operator">+</span> <span class="hljs-number">1</span>  <span class="hljs-symbol">&lt;br&gt;</span>console.log(&#x27;x&#x27;, x)  <span class="hljs-symbol">&lt;br&gt;</span>`;  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-symbol">&lt;br&gt;</span>const options <span class="hljs-operator">=</span> &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-params">compact:</span> <span class="hljs-literal">false</span>,  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-params">controlFlowFlattening:</span> <span class="hljs-literal">true</span>,  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-symbol">&lt;br&gt;</span>const obfuscator <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;javascript-obfuscator&quot;</span>);  <span class="hljs-symbol">&lt;br&gt;</span>function obfuscate(code, options) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  return obfuscator.obfuscate(code, options).getObfuscatedCode();  <span class="hljs-symbol">&lt;br&gt;</span>&#125;  <span class="hljs-symbol">&lt;br&gt;</span>console.log(obfuscate(code, options));<br></code></pre></td></tr></table></figure><p>在这里我们定义了两个变量，一个是 code，即需要被混淆的代码，另一个是混淆选项，是一个 Object。接下来我们引入了 javascript-obfuscator 这库，然后定义了一个方法，传入 code 和 options，来获取混淆后的代码，最后控制台输出混淆后的代码。</p><p>代码逻辑比较简单，我们来执行一下代码：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">main</span>.js<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">var _0x53bf <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;log&quot;</span>];  <span class="hljs-symbol">&lt;br&gt;</span>(function (_0x1d84fe, _0x3aeda0) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0x10a5a <span class="hljs-operator">=</span> function (_0x2f0a52) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>    while (--_0x2f0a52) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>      _0x1d84fe[<span class="hljs-string">&quot;push&quot;</span>](_0x1d84fe[<span class="hljs-string">&quot;shift&quot;</span>]());  <span class="hljs-symbol">&lt;br&gt;</span>    &#125;  <span class="hljs-symbol">&lt;br&gt;</span>  &#125;;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x10a5a(<span class="hljs-operator">++</span>_0x3aeda0);  <span class="hljs-symbol">&lt;br&gt;</span>&#125;)(_0x53bf, <span class="hljs-number">0</span>x172);  <span class="hljs-symbol">&lt;br&gt;</span>var _0x480a <span class="hljs-operator">=</span> function (_0x4341e5, _0x5923b4) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x4341e5 <span class="hljs-operator">=</span> _0x4341e5 <span class="hljs-operator">-</span> <span class="hljs-number">0</span>x0;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0xb3622e <span class="hljs-operator">=</span> _0x53bf[_0x4341e5];  <span class="hljs-symbol">&lt;br&gt;</span>  return _0xb3622e;  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> x <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>x1;  <span class="hljs-symbol">&lt;br&gt;</span>console[_0x480a(<span class="hljs-string">&quot;0x0&quot;</span>)](<span class="hljs-string">&quot;x&quot;</span>, x);<br></code></pre></td></tr></table></figure><p>看到了吧，那么简单的两行代码，被我们混淆成了这个样子，其实这里我们就是设定了一个「控制流平坦化」的选项。整体看来，代码的可读性大大降低，也大大加大了 JavaScript 调试的难度。</p><p>好，那么我们来跟着 javascript-obfuscator 走一遍，就能具体知道 JavaScript 混淆到底有多少方法了。</p><blockquote><p>注意：由于这些例子中，调用 javascript-obfuscator 进行混淆的实现是一样的，所以下文的示例只说明 code 和 options 变量的修改，完整代码请自行补全。</p></blockquote><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a><a href="https://cuiqingcai.com/2022111.html#%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9" title="代码压缩"></a>代码压缩</h3><p>这里 javascript-obfuscator 也提供了代码压缩的功能，使用其参数 compact 即可完成 JavaScript 代码的压缩，输出为一行内容。默认是 true，如果定义为 false，则混淆后的代码会分行显示。</p><p>示例如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">const code <span class="hljs-operator">=</span> `  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> x <span class="hljs-operator">=</span> &#x27;<span class="hljs-number">1</span>&#x27; <span class="hljs-operator">+</span> <span class="hljs-number">1</span>  <span class="hljs-symbol">&lt;br&gt;</span>console.log(&#x27;x&#x27;, x)  <span class="hljs-symbol">&lt;br&gt;</span>`;  <span class="hljs-symbol">&lt;br&gt;</span>const options <span class="hljs-operator">=</span> &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-params">compact:</span> <span class="hljs-literal">false</span>,  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们先把代码压缩 compact 选项设置为 false，运行结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let <span class="hljs-attribute">x</span> = <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-number">0</span>x1;  &lt;br&gt;console<span class="hljs-selector-attr">[<span class="hljs-string">&quot;log&quot;</span>]</span>(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-attribute">x</span>);<br></code></pre></td></tr></table></figure><p>如果不设置 compact 或把 compact 设置为 true，结果如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">var _0x151c <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;log&quot;</span>];  <span class="hljs-symbol">&lt;br&gt;</span>(function (_0x1ce384, _0x20a7c7) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0x25fc92 <span class="hljs-operator">=</span> function (_0x188aec) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>    while (--_0x188aec) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>      _0x1ce384[<span class="hljs-string">&quot;push&quot;</span>](_0x1ce384[<span class="hljs-string">&quot;shift&quot;</span>]());  <span class="hljs-symbol">&lt;br&gt;</span>    &#125;  <span class="hljs-symbol">&lt;br&gt;</span>  &#125;;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x25fc92(<span class="hljs-operator">++</span>_0x20a7c7);  <span class="hljs-symbol">&lt;br&gt;</span>&#125;)(_0x151c, <span class="hljs-number">0</span>x1b7);  <span class="hljs-symbol">&lt;br&gt;</span>var _0x553e <span class="hljs-operator">=</span> function (_0x259219, _0x241445) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x259219 <span class="hljs-operator">=</span> _0x259219 <span class="hljs-operator">-</span> <span class="hljs-number">0</span>x0;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0x56d72d <span class="hljs-operator">=</span> _0x151c[_0x259219];  <span class="hljs-symbol">&lt;br&gt;</span>  return _0x56d72d;  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> x <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>x1;  <span class="hljs-symbol">&lt;br&gt;</span>console[_0x553e(<span class="hljs-string">&quot;0x0&quot;</span>)](<span class="hljs-string">&quot;x&quot;</span>, x);<br></code></pre></td></tr></table></figure><p>可以看到单行显示的时候，对变量名进行了进一步的混淆，这里变量的命名都变成了 16 进制形式的字符串，这是因为启用了一些默认压缩和混淆配置导致的。总之我们可以看到代码的可读性相比之前大大降低了。</p><h3 id="变量名混淆"><a href="#变量名混淆" class="headerlink" title="变量名混淆"></a><a href="https://cuiqingcai.com/2022111.html#%E5%8F%98%E9%87%8F%E5%90%8D%E6%B7%B7%E6%B7%86" title="变量名混淆"></a>变量名混淆</h3><p>变量名混淆可以通过在 javascript-obfuscator 中配置 identifierNamesGenerator 参数实现，我们通过这个参数可以控制变量名混淆的方式，如 hexadecimal 则会替换为 16 进制形式的字符串，在这里我们可以设定如下值：</p><ul><li>hexadecimal：将变量名替换为 16 进制形式的字符串，如 <code>0xabc123</code>。</li><li>mangled：将变量名替换为普通的简写字符，如 <code>a</code>、<code>b</code>、<code>c</code> 等。</li></ul><p>该参数的值默认为 hexadecimal。</p><p>我们将该参数修改为 mangled 来试一下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">const code <span class="hljs-operator">=</span> `  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> hello <span class="hljs-operator">=</span> &#x27;<span class="hljs-number">1</span>&#x27; <span class="hljs-operator">+</span> <span class="hljs-number">1</span>  <span class="hljs-symbol">&lt;br&gt;</span>console.log(&#x27;hello&#x27;, hello)  <span class="hljs-symbol">&lt;br&gt;</span>`;  <span class="hljs-symbol">&lt;br&gt;</span>const options <span class="hljs-operator">=</span> &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-params">compact:</span> <span class="hljs-literal">true</span>,  <span class="hljs-symbol">&lt;br&gt;</span>  <span class="hljs-params">identifierNamesGenerator:</span> <span class="hljs-string">&quot;mangled&quot;</span>,  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">var a <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;hello&quot;</span>];  <span class="hljs-symbol">&lt;br&gt;</span>(function (c, d) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  var e <span class="hljs-operator">=</span> function (f) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>    while (--f) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>      c[<span class="hljs-string">&quot;push&quot;</span>](c[<span class="hljs-string">&quot;shift&quot;</span>]());  <span class="hljs-symbol">&lt;br&gt;</span>    &#125;  <span class="hljs-symbol">&lt;br&gt;</span>  &#125;;  <span class="hljs-symbol">&lt;br&gt;</span>  e(<span class="hljs-operator">++</span>d);  <span class="hljs-symbol">&lt;br&gt;</span>&#125;)(a, <span class="hljs-number">0</span>x9b);  <span class="hljs-symbol">&lt;br&gt;</span>var b <span class="hljs-operator">=</span> function (c, d) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  c <span class="hljs-operator">=</span> c <span class="hljs-operator">-</span> <span class="hljs-number">0</span>x0;  <span class="hljs-symbol">&lt;br&gt;</span>  var e <span class="hljs-operator">=</span> a[c];  <span class="hljs-symbol">&lt;br&gt;</span>  return e;  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> hello <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>x1;  <span class="hljs-symbol">&lt;br&gt;</span>console[<span class="hljs-string">&quot;log&quot;</span>](b(<span class="hljs-string">&quot;0x0&quot;</span>), hello);<br></code></pre></td></tr></table></figure><p>可以看到这里的变量命名都变成了 <code>a</code>、<code>b</code> 等形式。</p><p>如果我们将 identifierNamesGenerator 修改为 hexadecimal 或者不设置，运行结果如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">var _0x4e98 <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>];  <span class="hljs-symbol">&lt;br&gt;</span>(function (_0x4464de, _0x39de6c) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0xdffdda <span class="hljs-operator">=</span> function (_0x6a95d5) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>    while (--_0x6a95d5) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>      _0x4464de[<span class="hljs-string">&quot;push&quot;</span>](_0x4464de[<span class="hljs-string">&quot;shift&quot;</span>]());  <span class="hljs-symbol">&lt;br&gt;</span>    &#125;  <span class="hljs-symbol">&lt;br&gt;</span>  &#125;;  <span class="hljs-symbol">&lt;br&gt;</span>  _0xdffdda(<span class="hljs-operator">++</span>_0x39de6c);  <span class="hljs-symbol">&lt;br&gt;</span>&#125;)(_0x4e98, <span class="hljs-number">0</span>xc8);  <span class="hljs-symbol">&lt;br&gt;</span>var _0x53cb <span class="hljs-operator">=</span> function (_0x393bda, _0x8504e7) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x393bda <span class="hljs-operator">=</span> _0x393bda <span class="hljs-operator">-</span> <span class="hljs-number">0</span>x0;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0x46ab80 <span class="hljs-operator">=</span> _0x4e98[_0x393bda];  <span class="hljs-symbol">&lt;br&gt;</span>  return _0x46ab80;  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> hello <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>x1;  <span class="hljs-symbol">&lt;br&gt;</span>console[_0x53cb(<span class="hljs-string">&quot;0x0&quot;</span>)](_0x53cb(<span class="hljs-string">&quot;0x1&quot;</span>), hello);<br></code></pre></td></tr></table></figure><p>可以看到选用了 mangled，其代码体积会更小，但 hexadecimal 其可读性会更低。</p><p>另外我们还可以通过设置 identifiersPrefix 参数来控制混淆后的变量前缀，示例如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> code = `  <span class="hljs-variable">&lt;br&gt;</span>let hello = &#x27;<span class="hljs-number">1</span>&#x27; + <span class="hljs-number">1</span>  <span class="hljs-variable">&lt;br&gt;</span>console.<span class="hljs-keyword">log</span>(&#x27;hello&#x27;, hello)  <span class="hljs-variable">&lt;br&gt;</span>`;  <span class="hljs-variable">&lt;br&gt;</span><span class="hljs-keyword">const</span> options = &#123;  <span class="hljs-variable">&lt;br&gt;</span>  identifiersPrefix: <span class="hljs-string">&quot;germey&quot;</span>,  <span class="hljs-variable">&lt;br&gt;</span>&#125;;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">var germey_0x3dea <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>];  <span class="hljs-symbol">&lt;br&gt;</span>(function (_0x348ff3, _0x5330e8) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0x1568b1 <span class="hljs-operator">=</span> function (_0x4740d8) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>    while (--_0x4740d8) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>      _0x348ff3[<span class="hljs-string">&quot;push&quot;</span>](_0x348ff3[<span class="hljs-string">&quot;shift&quot;</span>]());  <span class="hljs-symbol">&lt;br&gt;</span>    &#125;  <span class="hljs-symbol">&lt;br&gt;</span>  &#125;;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x1568b1(<span class="hljs-operator">++</span>_0x5330e8);  <span class="hljs-symbol">&lt;br&gt;</span>&#125;)(germey_0x3dea, <span class="hljs-number">0</span>x94);  <span class="hljs-symbol">&lt;br&gt;</span>var germey_0x30e4 <span class="hljs-operator">=</span> function (_0x2e8f7c, _0x1066a8) &#123;  <span class="hljs-symbol">&lt;br&gt;</span>  _0x2e8f7c <span class="hljs-operator">=</span> _0x2e8f7c <span class="hljs-operator">-</span> <span class="hljs-number">0</span>x0;  <span class="hljs-symbol">&lt;br&gt;</span>  var _0x5166ba <span class="hljs-operator">=</span> germey_0x3dea[_0x2e8f7c];  <span class="hljs-symbol">&lt;br&gt;</span>  return _0x5166ba;  <span class="hljs-symbol">&lt;br&gt;</span>&#125;;  <span class="hljs-symbol">&lt;br&gt;</span><span class="hljs-keyword">let</span> hello <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-number">0</span>x1;  <span class="hljs-symbol">&lt;br&gt;</span>console[germey_0x30e4(<span class="hljs-string">&quot;0x0&quot;</span>)](germey_0x30e4(<span class="hljs-string">&quot;0x1&quot;</span>), hello);<br></code></pre></td></tr></table></figure><p>可以看到混淆后的变量前缀加上了我们自定义的字符串 germey。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><a href="https://cuiqingcai.com/2022111.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>以上，我们就介绍了接口加密技术和 JavaScript 的压缩、混淆技术，也对 WebAssembly 技术有了初步的了解，知己知彼方能百战不殆，了解了原理，我们才能更好地去实现 JavaScript 的逆向。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript逆向简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript逆向实战</title>
    <link href="/Blogs/2025/08/28/javascript%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/"/>
    <url>/Blogs/2025/08/28/javascript%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器开发逆向"><a href="#浏览器开发逆向" class="headerlink" title="浏览器开发逆向"></a>浏览器开发逆向</h1><p>前面一节我们了解了 JavaScript 的压缩、混淆等技术，现在越来越多的网站也已经应用了这些技术对其数据接口进行了保护，在做爬虫时如果我们遇到了这种情况，我们可能就不得不硬着头皮来去想方设法找出其中隐含的关键逻辑了，这个过程我们可以称之为 JavaScript 逆向。</p><p>既然我们要做 JavaScript 逆向，那少不了要用到浏览器的开发者工具，因为网页是在浏览器中加载的，所以多数的调试过程也是在浏览器中完成的。</p><p>工欲善其事，必先利其器。本节我们先来基于 Chrome 浏览器介绍一下浏览器开发者工具的使用。但由于开发者工具功能十分复杂，本节主要介绍对 JavaScript 逆向有一些帮助的功能，学会了这些，我们在做 JavaScript 逆向调试的过程会更加得心应手。</p><p>本节我们以一个示例网站 <a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a> 来做演示，用这个示例来介绍浏览器开发者工具各个面版的用法。</p><h2 id="1-面板介绍"><a href="#1-面板介绍" class="headerlink" title="1. 面板介绍"></a><a href="https://cuiqingcai.com/2022112.html#1-%E9%9D%A2%E6%9D%BF%E4%BB%8B%E7%BB%8D" title="1. 面板介绍"></a>1. 面板介绍</h2><p>首先我们用 Chrome 浏览器打开示例网站，页面如图所示：</p><p><img src="https://cdn.cuiqingcai.com/tc2si.png" alt="示例网站页面"></p><p>接下来打开开发者工具，我们会看到类似图 xx 所示的结果。</p><p><img src="https://cdn.cuiqingcai.com/q32zi.png" alt="打开开发者工具"></p><p>这里可以看到多个面板标签，如 Elements、Console、Sources 等，这就是开发者工具的一个个面板，功能丰富而又强大，先对面板作下简单的介绍：</p><ul><li>Elements：元素面板，用于查看或修改当前网页 HTML 节点的属性、CSS 属性、监听事件等等，HTML 和 CSS 都可以即时修改和即时显示。</li><li>Console：控制台面板，用于查看调试日志或异常信息。另外我们还可以在控制台输入 JavaScript 代码，方便调试。</li><li>Sources：源代码面板，用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，还可以在此面板对 JavaScript 代码进行调试，比如添加和修改 JavaScript 断点，观察 JavaScript 变量变化等。</li><li>Network：网络面板，用于查看页面加载过程中的各个网络请求，包括请求、响应等各个详情。</li><li>Performance：性能面板，用于记录和分析页面在运行时的所有活动，比如 CPU 占用情况，呈现页面性能分析结果，</li><li>Memory：内存面板，用于记录和分析页面占用内存情况，如查看内存占用变化，查看 JavaScript 对象和 HTML 节点的内存分配。</li><li>Application：应用面板，用于记录网站加载的所有资源信息，如存储、缓存、字体、图片等，同时也可以对一些资源进行修改和删除。</li><li>Lighthouse：审核面板，用于分析网络应用和网页，收集现代性能指标并提供对开发人员最佳实践的意见。</li></ul><p>了解了这些面板之后，我们来深入了解几个面板中对 JavaScript 调试很有帮助的功能。</p><h2 id="2-查看节点事件"><a href="#2-查看节点事件" class="headerlink" title="2. 查看节点事件"></a><a href="https://cuiqingcai.com/2022112.html#2-%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9%E4%BA%8B%E4%BB%B6" title="2. 查看节点事件"></a>2. 查看节点事件</h2><p>之前我们是用 Elements 面板来审查页面的节点信息的，我们可以查看当前页面的 HTML 源代码及其在网页中对应的位置，查看某个条目的标题对应的页面源代码，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/oigc0.png" alt="查看源代码"></p><p>点击右侧的 Styles 选项卡，可以看到对应节点的 CSS 样式，我们可以自行在这里增删样式，实时预览效果，这对网页开发十分有帮助。</p><p>在 Computed 选项卡中还可以看到当前节点的盒子模型，比如外边距、内边距等，还可以看到当前节点最终计算出的 CSS 的样式，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/9uo6h.png" alt="盒子模型"></p><p>接下来切换到右侧的 Event Listeners 选项卡，这里可以显示各个节点当前已经绑定的事件，都是 JavaScript 原生支持的，下面简单列举几个事件。</p><ul><li><code>change</code>：HTML 元素改变时会触发的事件。</li><li><code>click</code>：用户点击 HTML 元素时会触发的事件。</li><li><code>mouseover</code>：用户在一个 HTML 元素上移动鼠标会触发的事件。</li><li><code>mouseout</code>：用户从一个 HTML 元素上移开鼠标会触发的事件。</li><li><code>keydown</code>：用户按下键盘按键会触发的事件。</li><li><code>load</code>：浏览器完成页面加载时会触发的事件。</li></ul><p>通常，我们会给按钮绑定一个点击事件，它的处理逻辑一般是由 JavaScript 定义的，这样在我们点击按钮的时候，对应的 JavaScript 代码便会执行。比如在图 xx 中，我们选中切换到第 2 页的节点，右侧 Event Listeners 选项卡下会看到它绑定的事件。</p><p><img src="https://cdn.cuiqingcai.com/068my.png" alt="选中切换到第 2 页的节点"></p><p>这里有对应事件的代码位置，内容为一个 JavaScript 文件名称 <code>chunk-vendors.77daf991.js</code>，然后紧跟一个冒号，然后再跟了一个数字 7。所以对应的事件处理函数是定义在 <code>chunk-vendors.77daf991.js</code> 这个文件的第 7 行。点击这个代码位置，便会自动跳转 Sources 面板，打开对应的 <code>chunk-vendors.77daf991.js</code> 文件并跳转到对应的位置，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/s26fz.png" alt="跳转到对应的代码位置"></p><p>所以，利用好 Event Listeners，我们可以轻松地找到各个节点绑定事件的处理方法所在的位置，帮我们在 JavaScript 逆向过程中找到一些突破口。</p><h2 id="3-代码美化"><a href="#3-代码美化" class="headerlink" title="3. 代码美化"></a><a href="https://cuiqingcai.com/2022112.html#3-%E4%BB%A3%E7%A0%81%E7%BE%8E%E5%8C%96" title="3. 代码美化"></a>3. 代码美化</h2><p>刚才我们已经通过 Event Listeners 找到了对应的事件处理方法所在的位置并成功跳转到了代码所在的位置。</p><p>但是，这部分代码似乎被压缩过了，可读性很差，根本没法阅读，这时候应该怎么办呢？</p><p>不用担心，Sources 面板提供了一个便捷好用的代码美化功能。我们点击代码面板左下角的格式化按钮，代码就会变成如图所示的样子。</p><p><img src="https://cdn.cuiqingcai.com/92ouc.png" alt="代码格式化按钮"></p><p><img src="https://cdn.cuiqingcai.com/da7lc.png" alt="格式化后的代码"></p><p>此时会新出现一个叫作 <code>chunk-vendors.77daf991.js:formatted</code> 的选项卡，文件名后面加了 formatted 标识，代表这是被格式化的结果。我们会发现，原来代码在第 7 行，现在自动对应到了第 4445 行，而且对应的代码位置会高亮显示，代码可读性大大增强！</p><p>这个功能在调试过程中非常常用，用好这个功能会给我们的 JavaScript 调试过程带来极大的便利。</p><h2 id="4-断点调试"><a href="#4-断点调试" class="headerlink" title="4. 断点调试"></a><a href="https://cuiqingcai.com/2022112.html#4-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95" title="4. 断点调试"></a>4. 断点调试</h2><p>接下来介绍一个非常重要的功能 —— 断点调试。在调试代码的时候，我们可以在需要的位置上打断点，当对应事件触发时，浏览器就会自动停在断点的位置等待调试，此时我们可以选择单步调试，在面板中观察调用栈、变量值，以更好地追踪对应位置的执行逻辑。</p><p>那么断点怎么打呢？我们接着以上面的例子来说。首先单击如图所示的代码行号。</p><p><img src="https://cdn.cuiqingcai.com/ynj3a.png" alt="单击代码行号"></p><p>这时候行号处就出现了一个蓝色的箭头，这就证明断点已经添加好了，同时在右侧的 Breakpoints 选项卡下会出现我们添加的断点的列表。</p><p>由于我们知道这个断点是用来处理翻页按钮的点击事件的，所以可以在网页里面点击按钮试一下，比如点击第 2 页的按钮，这时候就会发现断点被触发了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/sx6uu.png" alt="断点被触发"></p><p>这时候我们可以看到页面中显示了一个叫作 <code>Paused in debugger</code> 的提示，这说明浏览器执行到刚才我们设置断点的位置处就不再继续执行了，等待我们发号施令执行调试。</p><p>此时代码停在了第 4446 行，回调参数 <code>e</code> 就是对应的点击事件 <code>MouseEvent</code> 。在右侧的 Scope 面板处，可以观察到各个变量的值，比如在 <code>Local</code> 域下有当前方法的局部变量，我们可以在这里看到 <code>MouseEvent</code> 的各个属性，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/wtc7z.png" alt="查看 Local 域"></p><p>另外我们关注到有一个方法 <code>o</code>，它在 <code>Jr</code> 方法下面，所以切换到 <code>Closure(Jr)</code> 域可以查看它的定义及其接收的参数，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/eahmg.png" alt="查看 Closure(Jr) 域"></p><p>我们可以看到，<code>FunctionLocation</code> 又指向了方法 <code>o</code> ，点击之后便又可以跳到指定位置，用同样的方式进行断点调试即可。</p><p>在 Scope 面板还有多个域，这里就不再展开介绍了。总之，通过 Scope 面板，我们可以看到当前执行环境下的变量的值和方法的定义，知道当前代码究竟执行了怎样的逻辑。</p><p>接下来切换到 Watch 面板，在这里可以自行添加想要查看的变量和方法，点击右上角的 + 号按钮，我们可以任意添加想要监听的对象，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/qb3kr.png" alt="Watch 面板"></p><p>比如这里我们比较关注 <code>o.apply</code> 是一个怎样的方法，于是点击添加 <code>o.apply</code>，这里就会把对应的方法定义呈现出来，展开之后可以再点击 <code>FunctionLocation</code> 定位其源码位置。</p><p>我们还可以切换到 Console 面板，输入任意的 JavaScript 代码，便会执行、输出对应的结果，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/nwxwl.png" alt="Console 面板"></p><p>如果我们想看看变量 <code>arguments</code> 的第一个元素是什么，那么可以直接敲入 <code>arguments[0]</code>，便会输出对应的结果 <code>MouseEvent</code>，只要在当前上下文能访问到的变量都可以直接引用并输出。</p><p>此时我们还可以选择单步调试，这里有 3 个重要的按钮，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/564d1.png" alt="单步调试按钮"></p><p>这 3 个按钮都可以做单步调试，但功能不同。</p><ul><li>Step Over Next Function Call：逐语句执行</li><li>Step Into Next Function Call：进入方法内部执行</li><li>Step Out of Current Function：跳出当前方法</li></ul><p>用得较多的是第一个，相当于逐行调试，比如点击 Step Over Next Function Call 这个按钮，就运行到了 4447 行，高亮的位置就变成了这一行，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/8vzzb.png" alt="点击 Step Over Next Function Call 按钮"></p><h2 id="5-观察调用栈"><a href="#5-观察调用栈" class="headerlink" title="5. 观察调用栈"></a><a href="https://cuiqingcai.com/2022112.html#5-%E8%A7%82%E5%AF%9F%E8%B0%83%E7%94%A8%E6%A0%88" title="5. 观察调用栈"></a>5. 观察调用栈</h2><p>在调试的过程中，我们可能会跳到一个新的位置，比如点击上述 Step Over Next Function Call 几下，可能会跳到一个叫作 <code>ct</code> 的方法中，这时候我们也不知道发生了什么，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/1646k.png" alt="跳到 ct 方法中"></p><p>那究竟是怎么跳过来的呢？我们可以观察一下右侧的 Call Stack 面板，就可以看到全部的调用过程了。比如它的上一步是 <code>ot</code> 方法，再上一步是 <code>pt</code> 方法，点击对应的位置也可以跳转到对应的代码位置，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/y49p1.png" alt="Call Stack 面板"></p><p>有时候调用栈是非常有用的，利用它我们可以回溯某个逻辑的执行流程，从而快速找到突破口。</p><h2 id="6-恢复-JavaScript-执行"><a href="#6-恢复-JavaScript-执行" class="headerlink" title="6. 恢复 JavaScript 执行"></a><a href="https://cuiqingcai.com/2022112.html#6-%E6%81%A2%E5%A4%8D-JavaScript-%E6%89%A7%E8%A1%8C" title="6. 恢复 JavaScript 执行"></a>6. 恢复 JavaScript 执行</h2><p>在调试过程中，如果想快速跳到下一个断点或者让 JavaScript 代码运行下去，可以点击 Resume script execution 按钮，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/5hdph.png" alt="Resume script execution 按钮"></p><p>这时浏览器会直接执行到下一个断点的位置，从而避免陷入无穷无尽的调试中。</p><p>当然，如果没有其他断点了，浏览器就会恢复正常状态。比如这里我们就没有再设置其他断点了，浏览器直接运行并加载了下一页的数据，同时页面恢复正常，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/k14kv.png" alt="浏览器恢复正常状态"></p><h2 id="7-Ajax-断点"><a href="#7-Ajax-断点" class="headerlink" title="7. Ajax 断点"></a><a href="https://cuiqingcai.com/2022112.html#7-Ajax-%E6%96%AD%E7%82%B9" title="7. Ajax 断点"></a>7. Ajax 断点</h2><p>上面我们介绍了一些 DOM 节点的 Listener，通过 Listener 我们可以手动设置断点并进行调试。但其实针对这个例子，通过翻页的点击事件 Listener 是不太容易找到突破口的。</p><p>接下来我们再介绍一个方法 —— Ajax 断点，它可以在发生 Ajax 请求的时候触发断点。对于这个例子，我们的目标其实就是找到 Ajax 请求的那一部分逻辑，找出加密参数是怎么构造的。可以想到，通过 Ajax 断点，使页面在获取数据的时候停下来，我们就可以顺着找到构造 Ajax 请求的逻辑了。</p><p>怎么设置呢？</p><p>我们把之前的断点全部取消，切换到 Sources 面板下，然后展开 XHR&#x2F;fetch Breakpoints，这里就可以设置 Ajax 断点，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/0fkn8.png" alt="展开 XHR/fetch Breakpoints"></p><p>要设置断点，就要先观察 Ajax 请求。和之前一样，我们点击翻页按钮 2，在 Network 面板里面观察 Ajax 请求是怎样的，请求的 URL 如图所示。</p><p><img src="https://cdn.cuiqingcai.com/k6gk9.png" alt="请求的 URL"></p><p>可以看到 URL 里面包含 <code>/api/movie</code> 这样的内容，所以我们可以在刚才的 XHR&#x2F;fetch Breakpoints 面板中添加拦截规则。点击 + 号，可以看到一行 <code>Break when URL contains:</code> 的提示，意思是当 Ajax 请求的 URL 包含填写的内容时，会进入断点停止，这里可以填写 <code>/api/movie</code>，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/6fv4d.png"></p><p>这时候我们再点击翻页按钮 3，触发第 3 页的 Ajax 请求。会发现点击之后页面走到断点停下来了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/87p3k.png" alt="断点调试模式"></p><p>格式化代码看一下，发现它停到了 Ajax 最后发送的那个时候，即底层的 <code>XMLHttpRequest</code> 的 <code>send</code> 方法，可是似乎还是找不到 Ajax 请求是怎么构造的。前面我们讲过调用栈 Call Stack，通过调用栈是可以顺着找到前序调用逻辑的，所以顺着调用栈一层层找，也可以找到构造 Ajax 请求的逻辑，最后会找到一个叫作 <code>onFetchData</code> 的方法，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/g5oyy.png" alt="找到 onFetchData 方法"></p><p>接下来切换到 <code>onFetchData</code> 方法并将代码格式化，可以看到如图所示的调用方法。</p><p><img src="https://cdn.cuiqingcai.com/m86ld.png" alt="调用方法"></p><p>可以发现，可能使用了 <code>axios</code> 库发起了一个 Ajax 请求，还有 <code>limit</code>、<code>offset</code>、<code>token</code> 这 3 个参数，基本就能确定了，顺利找到了突破口！我们就不在此展开分析了，后文会有完整的分析实战。</p><p>因此在某些情况下，我们可以在比较容易地通过 Ajax 断点找到分析的突破口，这是一个常见的寻找 JavaScript 逆向突破口的方法。</p><p>要取消断点也很简单，只需要在 XHR&#x2F;fetch Breakpoints 面板取消勾选即可，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/rtskp.png" alt="取消断点"></p><h2 id="8-改写-JavaScript-文件"><a href="#8-改写-JavaScript-文件" class="headerlink" title="8. 改写 JavaScript 文件"></a><a href="https://cuiqingcai.com/2022112.html#8-%E6%94%B9%E5%86%99-JavaScript-%E6%96%87%E4%BB%B6" title="8. 改写 JavaScript 文件"></a>8. 改写 JavaScript 文件</h2><p>我们知道，一个网页里面的 JavaScript 是从对应服务器上下载下来并在浏览器执行的。有时候，我们可能想要在调试的过程中对 JavaScript 做一些更改，比如说有以下需求：</p><ul><li><p>发现 JavaScript 文件中包含很多阻挠调试的代码或者无效代码、干扰代码，想要将其删除。</p></li><li><p>调试到某处，想要加一行 <code>console.log</code> 输出一些内容，以便观察某个变量或方法在页面加载过程中的调用情况。在某些情况下，这种方法比打断点调试更方便。</p></li><li><p>调试过程遇到某个局部变量或方法，想要把它赋值给 <code>window</code> 对象以便全局可以访问或调用。</p></li><li><p>在调试的时候，得到的某个变量中可能包含一些关键的结果，想要加一些逻辑将这些结果转发到对应的目标服务器。</p></li></ul><p>这时候我们可以试着在 Sources 面板中对 JavaScript 进行更改，但这种更改并不能长久生效，一旦刷新页面，更改就全都没有了。比如我们在 JavaScript 文件中写入一行 JavaScript 代码，然后保存，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/p00th.png" alt="在 JavaScript 文件中写入一行 JavaScript 代码"></p><p>这时候可以发现 JavaScript 文件上出现了一个感叹号标志，提示我们做的更改是不会保存的。这时候重新刷新页面，再看一下更改的这个文件，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/c9u43.png" alt="刷新页面后的 JavaScript 文件"></p><p>有什么方法可以修改呢？其实有一些浏览器插件可以实现，比如 ReRes。在插件中，我们可以添加自定义的 JavaScript 文件，并配置 URL 映射规则，这样浏览器在加载某个在线 JavaScript 文件的时候就可以将内容替换成自定义的 JavaScript 文件了。另外，还有一些代理服务器也可以实现，比如 Charles、Fiddler，借助它们可以在加载 JavaScript 文件时修改对应 URL 的响应内容，以实现对 JavaScript 文件的修改。</p><p>其实浏览器的开发者工具已经原生支持这个功能了，即浏览器的 Overrides 功能，它在 Sources 面板左侧，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/vfz28.png" alt="Overrides 功能"></p><p>我们可以在 Overrides 面板上选定一个本地的文件夹，用于保存需要更改的 JavaScript 文件，我们来实际操作一下。</p><p>首先，根据上文设置 Ajax 断点的方法，找到对应的构造 Ajax 请求的位置，根据一些网页开发知识，我们可以大体判断出 <code>then</code> 后面的回调方法接收的参数 <code>a</code> 中就包含了 Ajax 请求的结果，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/1nbk1.png"></p><p>我们打算在 Ajax 请求成功获得 Response 的时候，在控制台输出 Response 的结果，也就是通过 <code>console.log</code> 输出变量 <code>a</code>。</p><p>再切回 Overrides 面板，点击 + 按钮，这时候浏览器会提示我们选择一个本地文件夹，用于存储要替换的 JavaScript 文件。这里我选定了一个我任意新建的文件夹 ChromeOverrides，注意，这时候可能会遇到如图所示的提示，如果没有问题，直接点击 “允许” 即可。</p><p><img src="https://cdn.cuiqingcai.com/fbyji.png" alt="弹出提示"></p><p>这时，在 Overrides 面板下就多了一个 ChromeOverrides 文件夹，用于存储所有我们想要更改的 JavaScript 文件，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/bh127.png" alt="Overrides 面板下出现 ChromeOverrides 文件夹"></p><p>我们可以看到，现在所在的 JavaScript 选项卡是 <code>chunk-19c920f8.012555a2.js:formatted</code>，代码已经被格式化了。因为格式化后的代码是无法直接在浏览器中修改的，所以为了方便，我们可以将格式化后的文件复制到文本编辑器中，然后添加一行代码，修改如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>…  <br>}).then((function(a) {  <br>  console.log(‘response’, a) &#x2F;&#x2F; 添加一行代码  <br>  var e &#x3D; a.data  <br>  , s &#x3D; e.results  <br>  , n &#x3D; e.count;  <br>  t.loading &#x3D; !1,  <br>…</td></tr></tbody></table><p>接着把修改后的内容替换到原来的 JavaScript 文件中。这里要注意，切换到 <code>chunk-19c920f8.012555a2.js</code> 文件才能修改，直接替换 JavaScript 文件的所有内容即可，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/n987x.png" alt="替换 JavaScript 文件的所有内容"></p><p>替换完毕之后保存，这时候再切换回 Overrides 面板，就可以发现成功生成了新的 JavaScript 文件，它用于替换原有的 JavaScript 文件，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/jy0vc.png" alt="生成了新的 JavaScript 文件"></p><p>好，此时我们取消所有断点，然后刷新页面，就可以在控制台看到输出的 Reponse 结果了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/760yf.png" alt="Reponse 结果"></p><p>正如我们所料，我们成功将变量 <code>a</code> 输出，其中的 <code>data</code> 字段就是 Ajax 的 Response 结果，证明改写 JavaScript 成功！而且刷新页面也不会丢失了。</p><p>我们还可以增加一些 JavaScript 逻辑，比如直接将变量 <code>a</code> 的结果通过 API 发送到远程服务器，并通过服务器将数据保存下来，也就完成了直接拦截 Ajax 请求并保存数据的过程了。</p><p>修改 JavaScript 文件有很多用途，此方案可以为我们进行 JavaScript 的逆向带来极大的便利。</p><h1 id="Hook的用法"><a href="#Hook的用法" class="headerlink" title="Hook的用法"></a>Hook的用法</h1><p>在 JavaScript 逆向的时候，我们经常需要追踪某些方法的堆栈调用情况。但在很多情况下，一些 JavaScript 的变量或者方法名经过混淆之后是非常难以捕捉的。上一节我们介绍了一些断点调试、调用栈查看等技巧，但仅仅凭借这些技巧还不足以应对多数 JavaScript 逆向。</p><p>本节我们再来介绍一个比较常用的 JavaScript 逆向技巧 —— Hook 技术。</p><h2 id="1-Hook-技术"><a href="#1-Hook-技术" class="headerlink" title="1. Hook 技术"></a><a href="https://cuiqingcai.com/2022113.html#1-Hook-%E6%8A%80%E6%9C%AF" title="1. Hook 技术"></a>1. Hook 技术</h2><p>Hook 技术中文又叫作钩子技术，指在程序运行的过程中，对其中的某个方法进行重写，在原先的方法前后加入我们自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，得到控制权，这时钩子函数既可以加工处理（改变）该函数的执行行为，也可以强制结束消息的传递。</p><p>要对 JavaScript 代码进行 Hook 操作，就需要额外在页面中执行一些自定义的有关 Hook 逻辑的代码。那么问题来了？怎样才能在浏览器中方便地执行我们所期望执行的 JavaScript 代码呢？在这里推荐一个插件，叫作 Tampermonkey。这个插件的功能非常强大，利用它我们几乎可以在网页中执行任何 JavaScript 代码，实现我们想要的功能。</p><p>下面我们就来介绍一下这个插件的使用方法，并结合一个实际案例，介绍一下这个插件在 JavaScript Hook 中的用途。</p><h2 id="2-Tampermonkey"><a href="#2-Tampermonkey" class="headerlink" title="2. Tampermonkey"></a><a href="https://cuiqingcai.com/2022113.html#2-Tampermonkey" title="2. Tampermonkey"></a>2. Tampermonkey</h2><p>Tampermonkey，中文也叫作 “油猴”，它是一款浏览器插件，支持 Chrome。利用它我们可以在浏览器加载页面时自动执行某些 JavaScript 脚本。由于执行的是 JavaScript，所以我们几乎可以在网页中完成任何我们想实现的效果，如自动爬虫、自动修改页面、自动响应事件等。</p><p>其实，Tampermonkey 的用途远远不止这些，只要我们想要的功能能用 JavaScript 实现，Tampermonkey 就可以帮我们做到。比如我们可以将 Tampermonkey 应用到 JavaScript 逆向分析中，去帮助我们更方便地分析一些 JavaScript 加密和混淆代码。</p><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a><a href="https://cuiqingcai.com/2022113.html#3-%E5%AE%89%E8%A3%85" title="3. 安装"></a>3. 安装</h2><p>首先我们需要安装 Tampermonkey，这里我们使用的浏览器是 Chrome。直接在 Chrome 应用商店或者在 Tampermonkey 的官网 <a href="https://www.tampermonkey.net/">https://www.tampermonkey.net/</a> 下载安装即可。</p><p>安装完成之后，在 Chrome 浏览器的右上角会出现 Tampermonkey 的图标，这就代表安装成功了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/vyqt9.png"></p><h2 id="4-获取脚本"><a href="#4-获取脚本" class="headerlink" title="4. 获取脚本"></a><a href="https://cuiqingcai.com/2022113.html#4-%E8%8E%B7%E5%8F%96%E8%84%9A%E6%9C%AC" title="4. 获取脚本"></a>4. 获取脚本</h2><p>Tampermonkey 运行的是 JavaScript 脚本，每个网站都能有对应的脚本运行，不同的脚本能完成不同的功能。这些脚本我们可以自定义，也可以用已经写好的很多脚本，毕竟有些轮子有了，我们就不需要再去造了。</p><p>我们可以在 <a href="https://greasyfork.org/zh-CN/scripts">https://greasyfork.org/zh-CN/scripts</a> 找到一些非常实用的脚本，如全网视频去广告、百度云全网搜索等，大家可以体验一下。</p><h2 id="5-脚本编写"><a href="#5-脚本编写" class="headerlink" title="5. 脚本编写"></a><a href="https://cuiqingcai.com/2022113.html#5-%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99" title="5. 脚本编写"></a>5. 脚本编写</h2><p>除了使用别人已经写好的脚本，我们也可以自己编写脚本来实现想要的功能。编写脚本难不难呢？其实就是写 JavaScript 代码，只要懂一些 JavaScript 的语法就好了。另外我们需要遵循脚本的一些写作规范，其中就包括一些参数的设置。</p><p>下面我们就简单实现一个小的脚本。首先我们可以点击 Tampermonkey 插件图标，再点击 “管理面板” 按钮，打开脚本管理页面，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/4u47o.png"></p><p>脚本管理页面如图所示。</p><p><img src="https://cdn.cuiqingcai.com/w2zuf.png"></p><p>在这里显示了我们已经有的一些 Tampermonkey 脚本，包括我们自行创建的，也包括从第三方网站下载安装的。另外这里提供了编辑、调试、删除等管理功能，在这里可以方便地对脚本进行管理。</p><p>接下来我们来创建一个新的脚本，点击左侧的 “+” 号，会显示如图所示的页面。</p><p><img src="https://cdn.cuiqingcai.com/pqq74.png"></p><p>初始化的代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;&#x2F; &#x3D;&#x3D;UserScript&#x3D;&#x3D;  <br>&#x2F;&#x2F; @name         New Userscript  <br>&#x2F;&#x2F; @namespace    <a href="http://tampermonkey.net/">http://tampermonkey.net/</a>  <br>&#x2F;&#x2F; @version      0.1  <br>&#x2F;&#x2F; @description  try to take over the world!  <br>&#x2F;&#x2F; @author       You  <br>&#x2F;&#x2F; @match        <a href="https://www.tampermonkey.net/documentation.php?ext=dhdg">https://www.tampermonkey.net/documentation.php?ext=dhdg</a>  <br>&#x2F;&#x2F; @grant        none  <br>&#x2F;&#x2F; &#x3D;&#x3D;&#x2F;UserScript&#x3D;&#x3D;  <br>  <br>(function () {  <br>;  <br>  <br>  &#x2F;&#x2F; Your code here…  <br>})();</td></tr></tbody></table><p>在上面这段代码里，最前面是一些注释，它们非常有用，这部分内容叫作 <code>UserScript Header</code> ，我们可以在里面配置一些脚本的信息，如名称、版本、描述、生效站点等等。</p><p>下面简单介绍一下 <code>UserScript Header</code> 的一些参数定义。</p><ul><li><p><code>@name</code>：脚本的名称，就是在控制面板显示的脚本名称。</p></li><li><p><code>@namespace</code>：脚本的命名空间。</p></li><li><p><code>@version</code>：脚本的版本，主要是做版本更新时用。</p></li><li><p><code>@author</code>：作者。</p></li><li><p><code>@description</code>：脚本描述。</p></li><li><p><code>@homepage</code>、 <code>@homepageURL</code>、 <code>@website</code>、<code>@source</code>：作者主页，用于在 Tampermonkey 选项页面上从脚本名称点击跳转。请注意，如果 <code>@namespace</code> 标记以 <code>http://</code> 开头，此处也要一样。</p></li><li><p><code>@icon</code>、 <code>@iconURL</code> 、<code>@defaulticon</code>：低分辨率图标。</p></li><li><p><code>@icon64</code> 、 <code>@icon64URL</code>：64 × 64 高分辨率图标。</p></li><li><p><code>@updateURL</code>：检查更新的网址，需要定义 <code>@version</code>。</p></li><li><p><code>@downloadURL</code>：更新下载脚本的网址，如果定义成 <code>none</code> 就不会检查更新。</p></li><li><p><code>@supportURL</code>：报告问题的网址。</p></li><li><p><code>@include</code>：生效页面，可以配置多个，但注意这里并不支持 URL Hash。</p><p>  例如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;&#x2F; @include <a href="http://www.tampermonkey.net/">http://www.tampermonkey.net/</a>*  <br>&#x2F;&#x2F; @include http:&#x2F;&#x2F;*  <br>&#x2F;&#x2F; @include https:&#x2F;&#x2F;*  <br>&#x2F;&#x2F; @include *</td></tr></tbody></table></li><li><p><code>@match</code>：约等于 <code>@include</code> 标签，可以配置多个。</p></li><li><p><code>@exclude</code>：不生效页面，可配置多个，优先级高于 <code>@include</code> 和 <code>@match</code>。</p></li><li><p><code>@require</code>：附加脚本网址，相当于引入外部的脚本，这些脚本会在自定义脚本执行之前执行，比如引入一些必须的库，如 jQuery 等，这里可以支持配置多个 <code>@require</code>参数。</p><p>  例如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;&#x2F; @require <a href="https://code.jquery.com/jquery-2.1.4.min.js">https://code.jquery.com/jquery-2.1.4.min.js</a>  <br>&#x2F;&#x2F; @require <a href="https://code.jquery.com/jquery-2.1.3.min.js#sha256=23456">https://code.jquery.com/jquery-2.1.3.min.js#sha256=23456</a>…  <br>&#x2F;&#x2F; @require <a href="https://code.jquery.com/jquery-2.1.2.min.js#md5=34567...,sha256=6789">https://code.jquery.com/jquery-2.1.2.min.js#md5=34567...,sha256=6789</a>…</td></tr></tbody></table></li><li><p><code>@resource</code>：预加载资源，可通过 <code>GM_getResourceURL</code> 和 <code>GM_getResourceText</code> 读取。</p></li><li><p><code>@connect</code>：允许被 <code>GM_xmlhttpRequest</code> 访问的域名，每行 1 个。</p></li><li><p><code>@run-at</code>：脚本注入的时刻，如页面刚加载时，某个事件发生后等。</p><ul><li><code>document-start</code>：尽可能地早执行此脚本。</li><li><code>document-body</code>：DOM 的 body 出现时执行。</li><li><code>document-end</code>：<code>DOMContentLoaded</code> 事件发生时或发生后执行。</li><li><code>document-idle</code>：<code>DOMContentLoaded</code> 事件发生后执行，即 DOM 加载完成之后执行，这是默认的选项。</li><li><code>context-menu</code>：如果在浏览器上下文菜单（仅限桌面 Chrome 浏览器）中点击该脚本，则会注入该脚本。注意：如果使用此值，则将忽略所有 <code>@include</code> 和 <code>@exclude</code> 语句。</li></ul></li><li><p><code>@grant</code>：用于添加 GM 函数到白名单，相当于授权某些 GM 函数的使用权限。</p><p>  例如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;&#x2F; @grant GM_setValue  <br>&#x2F;&#x2F; @grant GM_getValue  <br>&#x2F;&#x2F; @grant GM_setClipboard  <br>&#x2F;&#x2F; @grant unsafeWindow  <br>&#x2F;&#x2F; @grant window.close  <br>&#x2F;&#x2F; @grant window.focus</td></tr></tbody></table><p>  如果没有定义过 <code>@grant</code> 选项，Tampermonkey 会猜测所需要的函数使用情况。</p></li><li><p><code>@noframes</code>：此标记使脚本在主页面上运行，但不会在 iframe 上运行。</p></li><li><p><code>@nocompat</code>：由于部分代码可能是为专门的浏览器所写，通过此标记，Tampermonkey 会知道脚本可以运行的浏览器。</p><p>  例如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;&#x2F; @nocompat Chrome</td></tr></tbody></table><p>  这样就指定了脚本只在 Chrome 浏览器中运行。</p></li></ul><p>除此之外，Tampermonkey 还定义了一些 API，使得我们可以方便地完成某个操作。</p><ul><li><code>GM_log</code>：将日志输出到控制台。</li><li><code>GM_setValue</code>：将参数内容保存到 Storage 中。</li><li><code>GM_addValueChangeListener</code>：为某个变量添加监听，当这个变量的值改变时，就会触发回调。</li><li><code>GM_xmlhttpRequest</code>：发起 Ajax 请求。</li><li><code>GM_download</code>：下载某个文件到磁盘。</li><li><code>GM_setClipboard</code>：将某个内容保存到粘贴板。</li></ul><p>还有很多其他的 API，大家可以到 <a href="https://www.tampermonkey.net/documentation.php">https://www.tampermonkey.net/documentation.php</a> 查看更多的内容。</p><p>在 <code>UserScript Header</code> 下方是 JavaScript 函数和调用的代码，其中 <code>&#39;use strict&#39;</code> 标明代码使用 JavaScript 的严格模式。在严格模式下，可以消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为，如不能直接使用未声明的变量，这样可以保证代码的运行安全，同时提高编译器的效率，提高运行速度。在下方 <code>// Your code here...</code> 处就可以编写自己的代码了。</p><h2 id="6-实战分析"><a href="#6-实战分析" class="headerlink" title="6. 实战分析"></a><a href="https://cuiqingcai.com/2022113.html#6-%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90" title="6. 实战分析"></a>6. 实战分析</h2><p>下面我们通过一个简单的 JavaScript 逆向案例来演示一下如何实现 JavaScript 的 Hook 操作，轻松找到某个方法执行的位置，从而快速定位逆向入口。</p><p>接下来我们来看一个简单的网站：<a href="https://login1.scrape.center/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E7%BB%93%E6%9E%84%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E3%80%82%E4%BD%86%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E6%98%AF%EF%BC%8C%E7%82%B9%E5%87%BB%E7%99%BB%E5%BD%95%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4">https://login1.scrape.center/，这个网站的结构非常简单，就是一个用户名密码登录。但是不同的是，点击登录的时候，表单提交</a> POST 的内容并不是单纯的用户名和密码，而是一个加密后的 token。</p><p>页面如图所示。</p><p><img src="https://cdn.cuiqingcai.com/h09sh.png" alt="image-20210509215948819"></p><p>我们输入用户名密码，都为 admin，点击登录按钮，观察一下网络请求的变化。</p><p>可以看到如下结果如图所示。</p><p><img src="https://cdn.cuiqingcai.com/neccv.png" alt="image-20210509220046359"></p><p>我们不需要关心 Response 的结果和状态，主要看 Request 的内容就好了。</p><p>可以看到，点击登录按钮时，发起了了一个 POST 请求，内容为：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{“token”:”eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJhZG1pbiJ9”}</td></tr></tbody></table><p>嗯，确实，没有诸如 <code>username</code> 和 <code>password</code> 的内容了，那怎么模拟登录呢？</p><p>模拟登录的前提当然就是找到当前 token 生成的逻辑了，那么问题来了，到底这个 token 和用户名、密码是什么关系呢？我们怎么来找寻其中的蛛丝马迹呢？</p><p>这里我们就可能思考了，本身输入的是用户名和密码，但提交的时候却变成了一个 token，经过观察并结合一些经验可以看出，token 的内容非常像 Base64 编码。这就代表，网站可能首先将用户名密码混为了一个新的字符串，然后经过了一次 Base64 编码，最后将其赋值为 token 来提交了。所以，初步观察我们可以得出这么多信息。</p><p>好，那就来验证一下吧！探究网站 JavaScript 代码里面是如何实现的。</p><p>首先我们看一下网站的源码，打开 Sources 面板，看起来都是 Webpack 打包之后的内容，经过了一些混淆，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/ztakd.png" alt="image-20210509222556397"></p><p>这么多混淆代码，总不能一点点扒着看吧？那么遇到这种情形，这怎么去找 token 的生成位置呢？</p><p>解决方法其实有两种，一种就是前文所讲的 Ajax 断点，另一种就是 Hook。</p><h3 id="Ajax-断点"><a href="#Ajax-断点" class="headerlink" title="Ajax 断点"></a><a href="https://cuiqingcai.com/2022113.html#Ajax-%E6%96%AD%E7%82%B9" title="Ajax 断点"></a>Ajax 断点</h3><p>由于这个请求正好是一个 Ajax 请求，所以我们可以添加一个 XHR 断点监听，把 POST 的网址加到断点监听上面。在 Sources 面板右侧添加一个 XHR 断点，匹配内容就填当前域名就好了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/icog3.png" alt="image-20210509223127936"></p><p>这时候如果我们再次点击登录按钮，发起一次 Ajax 请求，就可以进入断点了，然后再看堆栈信息，就可以一步步找到编码的入口了。</p><p>再次点击登录按钮，页面就进入断点状态停下来了，结果如图所示。</p><p><img src="https://cdn.cuiqingcai.com/dz078.png" alt="image-20210509223337762"></p><p>一步步找，最后可以找到入口其实是在 <code>onSubmit</code> 方法那里。但实际上我们观察到，这里的断点的栈顶还包括了一些类似 async Promise 等无关的内容，而我们真正想找的是用户名和密码经过处理，再进行 Base64 编码的地方，这些请求的调用实际上和我们找寻的入口没有很大的关系。</p><p>另外，如果我们想找的入口位置并不伴随这一次 Ajax 请求，这个方法就没法用了。</p><p>所以下面我们再来看另一个方法 —— Hook。</p><h3 id="Hook-Function"><a href="#Hook-Function" class="headerlink" title="Hook Function"></a><a href="https://cuiqingcai.com/2022113.html#Hook-Function" title="Hook Function"></a>Hook Function</h3><p>所以这里介绍第二种可以快速定位入口的方法，那就是使用 Tampermonkey 自定义 JavaScript，实现某个 JavaScript 方法的 Hook。Hook 哪里呢？很明显，Hook Base64 编码的位置就好了。</p><p>那么这里就涉及一个小知识点：JavaScript 里面的 Base64 编码是怎么实现的？</p><p>没错，就是 <code>btoa</code> 方法，在 JavaScript 中该方法用于将字符串编码成 Base64 字符串，因此我们来 Hook <code>btoa</code> 方法就好了。</p><p>好，这里我们新建一个 Tampermonkey 脚本，内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;&#x2F; &#x3D;&#x3D;UserScript&#x3D;&#x3D;  <br>&#x2F;&#x2F; @name         HookBase64  <br>&#x2F;&#x2F; @namespace    <a href="https://login1.scrape.center/">https://login1.scrape.center/</a>  <br>&#x2F;&#x2F; @version      0.1  <br>&#x2F;&#x2F; @description  Hook Base64 encode function  <br>&#x2F;&#x2F; @author       Germey  <br>&#x2F;&#x2F; @match        <a href="https://login1.scrape.center/">https://login1.scrape.center/</a>  <br>&#x2F;&#x2F; @grant        none  <br>&#x2F;&#x2F; &#x3D;&#x3D;&#x2F;UserScript&#x3D;&#x3D;  <br>(function () {  <br>;  <br>  function hook(object, attr) {  <br>    var func &#x3D; object[attr];  <br>    object[attr] &#x3D; function () {  <br>      console.log(“hooked”, object, attr);  <br>      var ret &#x3D; func.apply(object, arguments);  <br>      debugger;  <br>      return ret;  <br>    };  <br>  }  <br>  hook(window, “btoa”);  <br>})();</td></tr></tbody></table><p>首先我们定义了一些 <code>UserScript Header</code>，包括 <code>@name</code> 和 <code>@match</code> 等，这里比较重要的就是 <code>@name</code>，表示脚本名称；另外一个就是 <code>@match</code>，它代表脚本生效的网址。</p><p>脚本的内容如上面代码所示。我们定义了一个 <code>hook</code> 方法，传入 <code>object</code> 和 <code>attr</code> 参数，意思就是 Hook <code>object</code> 对象的 <code>attr</code> 参数。例如我们如果想 Hook <code>alert</code> 方法，那就把 <code>object</code> 设置为 <code>window</code>，把 <code>attr</code> 设置为字符串 <code>alert</code> 。这里我们想要 Hook Base64 的编码方法，而在 JavaScript 中，Based64 编码是用 <code>btoa</code> 方法实现的，所以这里我们就只需要 Hook <code>window</code> 对象的 <code>btoa</code> 方法就好了。</p><p>那么 Hook 是怎么实现的呢？我们来看已下，首先一句 <code>var func = object[attr]</code>，相当于我们先把它赋值为一个变量，我们调用 <code>func</code> 方法就可以实现和原来相同的功能。接着，我们直接改写这个方法的定义，将 <code>object[attr]</code> 改写成一个新的方法，在新的方法中，通过 <code>func.apply</code> 方法又重新调用了原来的方法。这样我们就可以保证前后方法的执行效果是不受什么影响的，之前这个方法该干啥就还是干啥。</p><p>但是和之前不同的是，我们自定义方法之后，现在可以在 <code>func</code> 方法执行的前后，再加入自己的代码，如 <code>console.log</code> 将信息输出到控制台，<code>debugger</code> 进入断点等。在这个过程中，我们先临时保存下来了 <code>func</code> 方法，然后定义一个新的方法，接管程序控制权，在其中自定义我们想要的实现，同时在新的方法里面重新调回 <code>func</code> 方法，保证前后结果是不受影响的。所以，我们达到了在不影响原有方法效果的前提下，实现在方法前后自定义的功能，这就是 Hook 的过程。</p><p>最后，我们调用 <code>hook</code> 方法，传入 <code>window</code> 对象和 <code>btoa</code> 字符串，保存。</p><p>接下来刷新下页面，这时候我们就可以看到这个脚本在当前页面生效了，可以发现 Tempermonkey 插件面板提示了已经启用，同时在 Sources 面板下的 Page 选项卡可以观察到我们定义的 JavaScript 脚本被执行了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/acsk0.png" alt="image-20210509223942108"></p><p>然后输入用户名、密码，点击提交，成功进入了断点模式停下来了，代码就卡在了我们自定义的 <code>debugger</code> 这一行代码的位置，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/n0or9.png" alt="image-20210509224216857"></p><p>成功 Hook 住了，这说明 JavaScript 代码在执行过程中调用到了 <code>btoa</code> 方法。</p><p>这时看一下控制台，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/ev1me.png" alt="image-20210509224328452"></p><p>这里也输出了 <code>window</code> 对象和 <code>btoa</code> 方法，验证正确。</p><p>这样，我们就顺利找到了 Base64 编码操作这个路口，然后看一下堆栈信息，也已经不会出现 async、Promise 这样的调用了，很清晰地呈现了 <code>btoa</code> 方法逐层调用的过程，非常清晰明了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/17rng.png" alt="image-20210509224356222"></p><p>另外再观察下 Local 面板，看看 <code>arguments</code> 变量是怎样的，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/0wuj4.png" alt="image-20210509224448758"></p><p>可以说一目了然了，<code>arguments</code> 就是指传给 <code>btoa</code> 方法的参数，<code>ret</code> 就是 <code>btoa</code> 方法返回的结果，可以看到 <code>arguments</code> 就是 <code>username</code> 和 <code>password</code> 通过 JSON 序列化之后的字符串，经过 Base64 编码之后得到的值恰好就是 Ajax 请求参数 <code>token</code> 的值。</p><p>结果几乎也明了了，我们还可以通过调用栈找到 <code>onSubmit</code> 方法的处理源码：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>onSubmit: function() {  <br>  var e &#x3D; c.encode(JSON.stringify(this.form));  <br>  this.$http.post(a[“a”].state.url.root, {  <br>    token: e  <br>  }).then((function(e) {  <br>  console.log(“data”, e)  <br>  }))  <br>}</td></tr></tbody></table><p>仔细看看，<code>encode</code> 方法其实就是调用了一下 <code>btoa</code> 方法，就是一个 Base64 编码的过程，答案其实已经很明了了。</p><p>当然我们还可以进一步打断点验证一下流程，比如在调用 <code>encode</code> 方法的一行打断点，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/94afz.png" alt="image-20210509224938312"></p><p>打完断点之后，可以点击 Resume 按钮恢复 JavaScript 的执行，跳过当前 Tempermonkey 定义的断点位置，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/wif60.png" alt="image-20210509225049534"></p><p>然后重新再点击登录按钮，可以看到这时候就停在了当前打断点的位置了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/db9n7.png" alt="image-20210509225531743"></p><p>这时候可以在 Watch 面板下输入 <code>this.form</code>，验证此处是否为在表单中输入的用户名密码，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/vn5bl.png" alt="image-20210509225732574"></p><p>没问题，然后逐步调试。我们还可以可以观察到，下一步就跳到了我们 Hook 的位置，这说明调用了 <code>btoa</code> 方法，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/jvx5f.png" alt="image-20210509225907721"></p><p>返回的结果正好就是 token 的值。</p><p>所以，验证到这里，已经非常清晰了，整体逻辑就是对登录表单的用户名和密码进行了 JSON 序列化，然后调用了 <code>encode</code> 也就是 <code>btoa</code> 方法，并赋值为了 <code>token</code> 发起登录的 Ajax 请求，逆向完成。</p><p>我们通过 Tampermonkey 自定义 JavaScript 脚本的方式，实现了某个方法调用的 Hook，使得我们能快速定位到加密入口的位置，非常方便。</p><p>以后如果观察出一些门道，可以多使用这种方法来尝试，如 Hook <code>encode</code> 方法、<code>decode</code> 方法、<code>stringify</code> 方法、<code>log</code> 方法、<code>alert</code> 方法等，简单又高效。</p><h1 id="模拟执行javascript"><a href="#模拟执行javascript" class="headerlink" title="模拟执行javascript"></a>模拟执行javascript</h1><p>前面我们了解了一些 JavaScript 逆向的调试技巧，通过一些方法，我们可以找到一些突破口，进而找到关键的方法定义。</p><p>比如说，通过一些调试，我们找到了一个加密参数 token 是由某一个叫做 encrypt 方法产生的，如果里面的逻辑相对简单的话，那其实我们可以用 Python 完全重写一遍。但是现实情况往往不是这样的，一般来说，一些加密相关的方法通常会引用一些相关标准库，比如说 JavaScript 就有一个广泛使用的库，叫做 crypto-js，GitHub 仓库链接是：<a href="https://github.com/brix/crypto-js%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BE%88%E5%A4%9A%E4%B8%BB%E6%B5%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AD%89%E7%AD%89%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AF%B9%E4%BA%8E">https://github.com/brix/crypto-js，这个库实现了很多主流的加密算法，包括对称加密、非对称加密、字符编码等等，比如对于</a> AES 加密，通常我们需要输入待加密文本和加密密钥，实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>const ciphertext &#x3D; CryptoJS.AES.encrypt(message, key).toString();</td></tr></tbody></table><p>对于这样的情况，我们其实就没法很轻易地完全重写一遍了，因为 Python 中并不一定有和 JavaScript 完全一样的类库。</p><p>那有什么解决办法吗？有的，既然 JavaScript 已经实现好了，那我用 Python 直接模拟执行这些 JavaScript 得到结果不就好了吗？</p><p>所以，本节我们就来了解下使用 Python 模拟执行 JavaScript 的解决方案。</p><h2 id="1-案例引入"><a href="#1-案例引入" class="headerlink" title="1. 案例引入"></a><a href="https://cuiqingcai.com/2022114.html#1-%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5" title="1. 案例引入"></a>1. 案例引入</h2><p>这里我们先看一个和上文描述的情形非常相似的案例，链接是：<a href="https://spa7.scrape.center/%EF%BC%8C%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">https://spa7.scrape.center/，如图所示：</a></p><p><img src="https://cdn.cuiqingcai.com/hft6o.png" alt="image-20210825014021855"></p><p>这是一个 NBA 球星网站，用卡片的形式展示了一些球星的基本信息，另外每一张卡片上其实都有一个加密字符串，这个加密字符串其实和球星的相关信息是有关联的，每个球星的 加密字符串也是不同的。</p><p>所以，这里我们要做的就是找出这个加密字符串的加密算法并用程序把加密字符串的生成过程模拟出来。</p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a><a href="https://cuiqingcai.com/2022114.html#2-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="2. 准备工作"></a>2. 准备工作</h2><p>由于本节我们需要使用 Python 模拟执行 JavaScript，这里我们使用的库叫做 PyExecJS，我们使用 pip3 安装即可，命令如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>pip3 install pyexecjs</td></tr></tbody></table><p>PyExecJS 是用于执行 JavaScript 的，但执行 JavaScript 的功能需要依赖一个 JavaScript 运行环境，所以除了安装好这个库之外，我们还需要安装一个 JavaScript 运行环境，个人比较推荐的是 Node.js，所以我们还需要安装下 Node.js，可以到 <a href="https://nodejs.org/">https://nodejs.org/</a> 下载安装。更加详细的安装和配置过程可以参考：<a href="https://setup.scrape.center/pyexecjs%E3%80%82">https://setup.scrape.center/pyexecjs。</a></p><p>PyExecJS 库在运行时会检测本地 JavaScript 运行环境来实现 JavaScript 执行，做好如上准备工作之后， 接着我们运行代码检查一下运行环境：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import execjs  <br>print(execjs.get().name)</td></tr></tbody></table><p>运行结果类似如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Node.js (V8)</td></tr></tbody></table><p>如果你成功安装好 PyExecJS 库和 Node.js 的话，其结果就是 Node.js (V8)，当然如果你安装的是其他的 JavaScript 运行环境，结果也会有所不同。</p><h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a><a href="https://cuiqingcai.com/2022114.html#3-%E5%88%86%E6%9E%90" title="3. 分析"></a>3. 分析</h2><p>接下来我们就对这个网站稍作分析，打开 Sources 面板，我们可以非常轻易地找到加密字符串的生成逻辑，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/jqozz.png" alt="image-20210826034346308"></p><p>首先声明了一个球员相关的列表，如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>const players &#x3D; [  <br>  {  <br>    name: ‘凯文-杜兰特’,  <br>    image: ‘durant.png’,  <br>    birthday: ‘1988-09-29’,  <br>    height: ‘208cm’,  <br>    weight: ‘108.9KG’  <br>  }  <br>  …  <br>]</td></tr></tbody></table><p>然后对于每一个球员，都把每个球员的信息调用了加密算法进行了加密，我们可以打个断点看下：</p><p><img src="https://cdn.cuiqingcai.com/hhqxx.png" alt="image-20210825014950392"></p><p>这里我们可以看到，getToken 方法的输入就是单个球员的信息，就是上述列表的一个元素对象，然后 <code>this.key</code> 就是一个固定的字符串。整个加密逻辑就是提取了球员的名字、生日、身高、体重，然后先 Base64 编码然后再进行 DES 加密，最后返回结果。</p><p>加密算法是怎么实现的呢？其实就是依赖了 crypto-js 库，使用了 CryptoJS 对象来实现的。</p><p>那 CryptoJS 这个对象是哪里来的呢？总不能凭空产生吧？其实这个网站就是直接引用了这个库，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/3k2i9.png" alt="image-20210826035113504"></p><p>引用这个 JavaScript 文件之后，CryptoJS 就被注入到浏览器全局环境下了，因此我们就可以在别的方法里面直接使用 CryptoJS 对象里面的方法了。</p><h2 id="4-模拟调用"><a href="#4-模拟调用" class="headerlink" title="4. 模拟调用"></a><a href="https://cuiqingcai.com/2022114.html#4-%E6%A8%A1%E6%8B%9F%E8%B0%83%E7%94%A8" title="4. 模拟调用"></a>4. 模拟调用</h2><p>好，那既然这样，我们要怎么模拟呢？下面我们来实现下。</p><p>首先，我们要模拟的其实就是这个 getToken 方法，输入球员相关信息，得到最终的加密字符串，这里我们直接把 key 替换下，把 getToken 方法稍微改写如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>function getToken(player) {  <br>  let key &#x3D; CryptoJS.enc.Utf8.parse(“fipFfVsZsTda94hJNKJfLoaqyqMZFFimwLt”);  <br>  const { name, birthday, height, weight } &#x3D; player;  <br>  let base64Name &#x3D; CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(name));  <br>  let encrypted &#x3D; CryptoJS.DES.encrypt(  <br>    <code>$&#123;base64Name&#125;$&#123;birthday&#125;$&#123;height&#125;$&#123;weight&#125;</code>,  <br>    key,  <br>    {  <br>      mode: CryptoJS.mode.ECB,  <br>      padding: CryptoJS.pad.Pkcs7,  <br>    }  <br>  );  <br>  return encrypted.toString();  <br>}</td></tr></tbody></table><p>因为这个方法的模拟执行是需要 CryptoJS 这个对象的，如果我们直接调用这个方法肯定会报 CryptoJS 未定义的错误。</p><p>那怎么办呢？我们只需要再模拟执行下刚才看到的 crypto-js.min.js 不就好了吗？</p><p>OK，所以，我们需要模拟执行的内容就是两部分：</p><ul><li>模拟运行 crypto-js.min.js 里面的 JavaScript，用于声明 CryptoJS 对象。</li><li>模拟运行 getToken 方法的定义，用于声明 getToken 方法。</li></ul><p>好，接下来我们就把 crypto-js.min.js 里面的代码和上面 getToken 方法的代码复制一下，都粘贴到一个 JavaScript 文件里面，比如就叫做 crypto.js。</p><p>接下来我们就用 PyExecJS 模拟执行一下吧，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import execjs  <br>import json  <br>  <br>item &#x3D; {  <br>    ‘name’: ‘凯文-杜兰特’,  <br>    ‘image’: ‘durant.png’,  <br>    ‘birthday’: ‘1988-09-29’,  <br>    ‘height’: ‘208cm’,  <br>    ‘weight’: ‘108.9KG’  <br>}  <br>  <br>file &#x3D; ‘crypto.js’  <br>node &#x3D; execjs.get()  <br>ctx &#x3D; node.compile(open(file).read())  <br>  <br>js &#x3D; f”getToken({json.dumps(item, ensure_ascii&#x3D;False)})”  <br>print(js)  <br>result &#x3D; ctx.eval(js)  <br>print(result)</td></tr></tbody></table><p>这里我们单独定义了一位球员的信息，赋值为 item 变量。然后使用 execjs 的 get 方法获取了 JavaScript 执行环境，赋值为 node。</p><p>接着我们调用了 node 的 compile 方法，传入了刚才定义的 crypto.js 文件的文本内容，compile 方法会返回一个 JavaScript 的上下文对象，我们赋值为 ctx。执行到这里，其实就可以理解为，ctx 对象里面就执行过了 crypto-js.min.js，CryptoJS 就声明好了，然后也执行过了 getToken 的定义，所以 getToken 方法也定义好了，相当于完成了一些初始化的工作。</p><p>接着，我们只需要定义好我们想要执行的 JavaScript 代码就好了，我们定义了一个 js 变量，其实就是模拟调用了 getToken 方法并传入了球员信息，我们打印了下 js 变量的值，内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>getToken({“name”: “凯文-杜兰特”, “image”: “durant.png”, “birthday”: “1988-09-29”, “height”: “208cm”, “weight”: “108.9KG”})</td></tr></tbody></table><p>其实这就是一个标准的 JavaScript 方法调用的写法而已。</p><p>接着我们调用 ctx 对象的 eval 方法并传入 js 变量，其实就是模拟执行了这句 JavaScript 代码，照理来说最终返回的就是加密字符串了。</p><p>然而，运行之后，我们可能看到这个报错：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>execjs._exceptions.ProgramError: ReferenceError: CryptoJS is not defined</td></tr></tbody></table><p>很奇怪，CryptoJS 未定义？我们明明执行过 crypto-js.min.js 里面的内容了呀？</p><p>问题其实出在 crypto-js.min.js 里面，可以看到其里面声明了一个 JavaScript 的自执行方法，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/2rxkp.png" alt="image-20210825020403826"></p><p>自执行方法什么意思呢？就是声明了一个方法，然后紧接着调用执行，我们可以看下这个例子：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>!(function (a, b) {  <br>  console.log(“result”, a, b);  <br>})(1, 2);</td></tr></tbody></table><p>这里我们先声明了一个 function，然后接收 a 和 b 两个参数，然后把内容输出出来，然后我们把这个 function 用小括号括起来，这其实就是一个方法，可以被直接调用的，怎么调用呢？后面再跟上对应的参数就好了，比如传入 1 和 2，执行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result 1 2</td></tr></tbody></table><p>可以看到，这个自执行的方法就被执行了。</p><p>同理地，crypto-js.min.js 也符合这个格式，它接收 t 和 e 两个参数，t 就是 this，其实就是浏览器中的 window 对象，e 就是一个 function（用于定义 CryptoJS 的核心内容）。</p><p>我们再来观察下 crypto-js.min.js 开头的定义：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>“object” &#x3D;&#x3D; typeof exports  <br>  ? (module.exports &#x3D; exports &#x3D; e())  <br>  : “function” &#x3D;&#x3D; typeof define &amp;&amp; define.amd  <br>  ? define([], e)  <br>  : (t.CryptoJS &#x3D; e());</td></tr></tbody></table><p>在 Node.js 中，其实 exports 就是用来将一些对象的定义进行导出的，这里 <code>&quot;object&quot; == typeof exports</code> 其实结果就是 true，所以就执行了 <code>module.exports = exports = e()</code> 这段代码，这样就相当于把 <code>e()</code> 作为整体导出了，而这个 <code>e()</code> 其实就对应这后面的整个 function，function 里面定义了加密相关的各个实现，其实就指代整个加密算法库。</p><p>但是在浏览器中，其结果就不一样了，浏览器环境中并没有 exports 和 define 这两个对象。所以，上述代码在浏览器中最后执行的就是 <code>t.CryptoJS = e()</code> 这段代码，其实这里就是把 CryptoJS 对象挂载到 this 对象上面，而 this 就是浏览器中的全局 window 对象，后面就可以直接用了。如果我们把代码放在浏览器中运行，那是没有任何问题的。</p><p>然而，我们使用的 PyExecJS 是依赖于一个 Node.js 执行环境的，所以上述代码其实执行的是 <code>module.exports = exports = e()</code>，这里面并没有声明 CryptoJS 对象，也没有把 CryptoJS 挂载到全局对象里面，所以后面我们再调用 CryptoJS 就自然而然出现了未定义的错误了。</p><p>那怎么办呢？其实很简单，那我们直接声明一个 CryptoJS 变量，然后手动声明一下它的初始化不就好了吗？所以我们可以把代码稍作修改，改成如下内容：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>var CryptoJS;  <br>!(function (t, e) {  <br>  CryptoJS &#x3D; e();  <br>  “object” &#x3D;&#x3D; typeof exports  <br>    ? (module.exports &#x3D; exports &#x3D; e())  <br>    : “function” &#x3D;&#x3D; typeof define &amp;&amp; define.amd  <br>    ? define([], e)  <br>    : (t.CryptoJS &#x3D; e());  <br>})(this, function () {  <br>  &#x2F;&#x2F;…  <br>});</td></tr></tbody></table><p>这里我们就首先声明了一个 CryptoJS 变量，然后直接给 CryptoJS 变量赋值给 <code>e()</code>，这样就完成了 CryptoJS 的初始化。</p><p>这样我们再重新运行刚才的 Python 脚本，就可以得到执行结果了：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>gQSfeqldQIJKAZHH9TzRX&#x2F;exvIwb0j73b2cjXvy6PeZ3rGW6sQsL2w&#x3D;&#x3D;</td></tr></tbody></table><p>这样我们就成功得到加密字符串了，和示例网站上显示的是一模一样的，这样我们就成功模拟 JavaScript 的调用完成了某个加密算法的运行过程。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><a href="https://cuiqingcai.com/2022114.html#5-%E6%80%BB%E7%BB%93" title="5. 总结"></a>5. 总结</h2><p>本节介绍了利用 PyExecJS 来模拟执行 JavaScript 的方法，结合一个案例来完成了整个的实现和问题排查的过程。本节内容还是比较重要的，以后我们如果需要模拟执行 JavaScript 就可以派得上用场。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript逆向实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linuxcmd</title>
    <link href="/Blogs/2025/08/28/linuxcmd/"/>
    <url>/Blogs/2025/08/28/linuxcmd/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-Linux指令学习date-2022-12-02-22-19-26tags-Linuxcategories-程序笔记"><a href="#title-Linux指令学习date-2022-12-02-22-19-26tags-Linuxcategories-程序笔记" class="headerlink" title="title: Linux指令学习date: 2022-12-02 22:19:26tags:- Linuxcategories: 程序笔记   "></a>title: Linux指令学习<br>date: 2022-12-02 22:19:26<br>tags:<br>- Linux<br>categories: 程序笔记   </h2><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近玩树莓派总要用到Linux命令行，兴趣盎然正好入门</p><p>命令行指令主要分为</p><ul><li>文件管理与传输</li><li>文档编辑</li><li>磁盘管理与维护</li><li>网络通讯</li><li>系统管理与设置</li><li>备份与压缩</li><li>设备管理</li></ul><p>这里只整理了我开发树莓派用到的指令，想要完整的命令行可以移步<a href="https://www.runoob.com/linux/linux-command-manual.html">菜鸟</a></p><span id="more"></span><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="cd跳转到要切换的目录"><a href="#cd跳转到要切换的目录" class="headerlink" title="cd跳转到要切换的目录"></a>cd跳转到要切换的目录</h2><h2 id="mkdir-创建目录-make-dir"><a href="#mkdir-创建目录-make-dir" class="headerlink" title="mkdir 创建目录 make dir"></a><strong>mkdir</strong> 创建目录 make dir</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir [-p] dirName<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-p 确保目录名称存在，不存在的就建一个。</li></ul><h2 id="cp-拷贝文件-copy"><a href="#cp-拷贝文件-copy" class="headerlink" title="cp 拷贝文件 copy"></a><strong>cp</strong> 拷贝文件 copy</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-keyword">source</span> dest<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> [<span class="hljs-keyword">options</span>] <span class="hljs-keyword">source</span>... directory<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li><li>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</li><li>-f：覆盖已经存在的目标文件而不给出提示。</li><li>-i：与 <strong>-f</strong> 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 <strong>y</strong> 时目标文件将被覆盖。</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li><li>-l：不复制文件，只是生成链接文件。</li></ul><h2 id="mv-移动文件-move"><a href="#mv-移动文件-move" class="headerlink" title="mv 移动文件 move"></a><strong>mv</strong> 移动文件 move</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> [options] <span class="hljs-built_in">source</span> dest<br><span class="hljs-built_in">mv</span> [options] <span class="hljs-built_in">source</span>... directory<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><strong>-b</strong>: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li><li><strong>-i</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li><li><strong>-f</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li><li><strong>-n</strong>: 不要覆盖任何已存在的文件或目录。</li><li><strong>-u</strong>：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li></ul><h2 id="rm-删除文件-remove"><a href="#rm-删除文件-remove" class="headerlink" title="rm 删除文件 remove"></a><strong>rm</strong> 删除文件 remove</h2><p>注意，rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎</p><ul><li>-f：强制删除（force），和 -i 选项相反，使用 -f，系统将不再询问，而是直接删除目标文件或目录。</li><li>-i：和 -f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 -i 可以有效防止不小心删除有用的文件或目录。</li><li>-r：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建目录和父目录a,b,c,d</span><br><span class="hljs-built_in">mkdir</span> -p a/b/c/d<br><br><span class="hljs-comment"># 拷贝文件夹a到/tmp目录</span><br><span class="hljs-built_in">cp</span> -rvf a/ /tmp/<br><br><span class="hljs-comment"># 移动文件a到/tmp目录，并重命名为b</span><br><span class="hljs-built_in">mv</span> -vf a /tmp/b<br><br><span class="hljs-comment"># 删除tmp目录的所有文件</span><br><span class="hljs-built_in">rm</span> -rvf /tmp/<br></code></pre></td></tr></table></figure><h2 id="ls-看到当前目录的所有内容"><a href="#ls-看到当前目录的所有内容" class="headerlink" title="ls 看到当前目录的所有内容"></a>ls 看到当前目录的所有内容</h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ls <span class="hljs-selector-attr">[-alrtAFR]</span> <span class="hljs-selector-attr">[name...]</span><br></code></pre></td></tr></table></figure><p><strong>参数</strong> :</p><ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li></ul><h2 id="pwd-看到当前终端所在的目录"><a href="#pwd-看到当前终端所在的目录" class="headerlink" title="pwd  看到当前终端所在的目录"></a>pwd  看到当前终端所在的目录</h2><p>Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。</p><p>执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">pwd</span> [<span class="hljs-params">--help</span>][<span class="hljs-params">--version</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li>–help 在线帮助。</li><li>–version 显示版本信息。</li></ul><h2 id="find-在指定目录下查找文件"><a href="#find-在指定目录下查找文件" class="headerlink" title="find 在指定目录下查找文件"></a>find 在指定目录下查找文件</h2><p><a href="https://www.runoob.com/linux/linux-comm-find.html">https://www.runoob.com/linux/linux-comm-find.html</a></p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find   path   -option   [   -<span class="hljs-built_in">print</span> ]   [ -<span class="hljs-built_in">exec</span>   -ok   <span class="hljs-built_in">command</span> ]   &#123;&#125; \;<br></code></pre></td></tr></table></figure><h1 id="系统管理与设置"><a href="#系统管理与设置" class="headerlink" title="系统管理与设置"></a>系统管理与设置</h1><h2 id="mount：挂载Linux系统外的文件"><a href="#mount：挂载Linux系统外的文件" class="headerlink" title="mount：挂载Linux系统外的文件"></a><strong>mount</strong>：挂载Linux系统外的文件</h2><p><a href="https://www.runoob.com/linux/linux-comm-mount.html">https://www.runoob.com/linux/linux-comm-mount.html</a></p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">mount <span class="hljs-comment">[-hV]</span><br>mount -a <span class="hljs-comment">[-fFnrsvw]</span> <span class="hljs-comment">[-t vfstype]</span><br>mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-o options <span class="hljs-comment">[,...]</span>]</span> device | dir<br>mount <span class="hljs-comment">[-fnrsvw]</span> <span class="hljs-comment">[-t vfstype]</span> <span class="hljs-comment">[-o options]</span> device dir<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>-V：显示程序版本</li><li>-h：显示辅助讯息</li><li>-v：显示较讯息，通常和 -f 用来除错。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">mount /dev/sdb1 /xiaodianying<br></code></pre></td></tr></table></figure><h2 id="chown：设置文件所有者和文件关联组的命令"><a href="#chown：设置文件所有者和文件关联组的命令" class="headerlink" title="chown：设置文件所有者和文件关联组的命令"></a><strong>chown</strong>：设置文件所有者和文件关联组的命令</h2><p><a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p><p>Linux&#x2F;Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 。</p><p>chown 需要超级用户 <strong>root</strong> 的权限才能执行此命令。</p><p>只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 <a href="https://www.runoob.com/linux/linux-comm-chgrp.html">chgrp</a> 命令。</p><p><strong>使用权限</strong> : root</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">chown [-cfhvR] [--help] [--version] user[:group] file...<br></code></pre></td></tr></table></figure><p><strong>参数</strong> :</p><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li><li>-c : 显示更改的部分的信息</li><li>-f : 忽略错误信息</li><li>-h :修复符号链接</li><li>-v : 显示详细的处理信息</li><li>-R : 处理指定目录以及其子目录下的所有文件</li><li>–help : 显示辅助说明</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 毁灭性的命令</span><br><span class="hljs-built_in">chmod</span> 000 -R /<br><br><span class="hljs-comment"># 修改a目录的用户和组为 xjj</span><br><span class="hljs-built_in">chown</span> -R xjj:xjj a<br><br><span class="hljs-comment"># 给a.sh文件增加执行权限（这个太常用了)</span><br><span class="hljs-built_in">chmod</span> a+x a.sh<br></code></pre></td></tr></table></figure><h2 id="chmod：控制用户对文件权限的命令"><a href="#chmod：控制用户对文件权限的命令" class="headerlink" title="chmod：控制用户对文件权限的命令"></a>chmod：控制用户对文件权限的命令</h2><p><a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p><p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg" alt="img"></p><p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png" alt="img"></p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-cfvR] [--<span class="hljs-built_in">help</span>] [--version] mode file...<br></code></pre></td></tr></table></figure><h3 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h3><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p><table><thead><tr><th align="left">who</th><th align="left">用户类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>u</code></td><td align="left">user</td><td align="left">文件所有者</td></tr><tr><td align="left"><code>g</code></td><td align="left">group</td><td align="left">文件所有者所在组</td></tr><tr><td align="left"><code>o</code></td><td align="left">others</td><td align="left">所有其他用户</td></tr><tr><td align="left"><code>a</code></td><td align="left">all</td><td align="left">所有用户, 相当于 <em>ugo</em></td></tr></tbody></table><p>operator 的符号模式表:</p><table><thead><tr><th align="left">Operator</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">为指定的用户类型增加权限</td></tr><tr><td align="left"><code>-</code></td><td align="left">去除指定用户类型的权限</td></tr><tr><td align="left"><code>=</code></td><td align="left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table><p>permission 的符号模式表:</p><table><thead><tr><th align="left">模式</th><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>r</code></td><td align="left">读</td><td align="left">设置为可读权限</td></tr><tr><td align="left"><code>w</code></td><td align="left">写</td><td align="left">设置为可写权限</td></tr><tr><td align="left"><code>x</code></td><td align="left">执行权限</td><td align="left">设置为可执行权限</td></tr><tr><td align="left"><code>X</code></td><td align="left">特殊执行权限</td><td align="left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td align="left"><code>s</code></td><td align="left">setuid&#x2F;gid</td><td align="left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td align="left"><code>t</code></td><td align="left">粘贴位</td><td align="left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table><h3 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h3><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p><table><thead><tr><th align="left">#</th><th align="left">权限</th><th align="left">rwx</th><th align="left">二进制</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">读 + 写 + 执行</td><td align="left">rwx</td><td align="left">111</td></tr><tr><td align="left">6</td><td align="left">读 + 写</td><td align="left">rw-</td><td align="left">110</td></tr><tr><td align="left">5</td><td align="left">读 + 执行</td><td align="left">r-x</td><td align="left">101</td></tr><tr><td align="left">4</td><td align="left">只读</td><td align="left">r–</td><td align="left">100</td></tr><tr><td align="left">3</td><td align="left">写 + 执行</td><td align="left">-wx</td><td align="left">011</td></tr><tr><td align="left">2</td><td align="left">只写</td><td align="left">-w-</td><td align="left">010</td></tr><tr><td align="left">1</td><td align="left">只执行</td><td align="left">–x</td><td align="left">001</td></tr><tr><td align="left">0</td><td align="left">无</td><td align="left">—</td><td align="left">000</td></tr></tbody></table><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a><strong>yum</strong></h2><p>假定你用的是centos，则包管理工具就是yum。如果你的系统没有wget命令，就可以使用如下命令进行安装。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yum install wget -y<br></code></pre></td></tr></table></figure><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a><strong>systemctl</strong></h2><p>当然，centos管理后台服务也有一些套路。<code>service</code>命令就是。<code>systemctl</code>兼容了<code>service</code>命令，我们看一下怎么重启mysql服务。 推荐用下面这个</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">service mysql restart<br>systemctl restart  mysqld <br></code></pre></td></tr></table></figure><p>对于普通的进程，就要使用kill命令进行更加详细的控制了。kill命令有很多信号，如果你在用<code>kill -9</code>，你一定想要了解<code>kill -15</code>以及<code>kill -3</code>的区别和用途。</p><p><strong>su</strong><br>su用来切换用户。比如你现在是root，想要用xjj用户做一些勾当，就可以使用su切换。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">su xjj<br>su - xjj<br></code></pre></td></tr></table></figure><p><code>-</code>可以让你干净纯洁的降临另一个账号，不出意外，推荐。</p><h1 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h1><h2 id="cat：连接文件并打印到标准输出设备上"><a href="#cat：连接文件并打印到标准输出设备上" class="headerlink" title="cat：连接文件并打印到标准输出设备上"></a>cat：连接文件并打印到标准输出设备上</h2><p><a href="https://www.runoob.com/linux/linux-comm-find.html">https://www.runoob.com/linux/linux-comm-find.html</a></p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">cat <span class="hljs-selector-attr">[-AbeEnstTuv]</span> <span class="hljs-selector-attr">[--help]</span> <span class="hljs-selector-attr">[--version]</span> fileName<br></code></pre></td></tr></table></figure><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p>-n 或 –number：由 1 开始对所有输出的行数编号。</p><p>-A, –show-all：等价于 -vET。</p><p>-e：等价于”-vE”选项；</p><p>-t：等价于”-vT”选项；</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text"># 查看文件大小<br>du -h file<br><br># 查看文件内容<br>cat file<br></code></pre></td></tr></table></figure><h2 id="less-随意浏览文件"><a href="#less-随意浏览文件" class="headerlink" title="less:随意浏览文件"></a>less:随意浏览文件</h2><p><a href="https://www.runoob.com/linux/linux-comm-less.html">https://www.runoob.com/linux/linux-comm-less.html</a></p><p>支持翻页和搜索，支持向上翻页和向下翻页语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">less</span> [参数] 文件 <br></code></pre></td></tr></table></figure><h2 id="tail：查看文件的内容"><a href="#tail：查看文件的内容" class="headerlink" title="tail：查看文件的内容"></a><strong>tail</strong>：查看文件的内容</h2><p><a href="https://www.runoob.com/linux/linux-comm-tail.html">https://www.runoob.com/linux/linux-comm-tail.html</a></p><p>tail 命令可用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件。</p><p><strong>tail -f filename</strong> 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p><h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">tail <span class="hljs-selector-attr">[参数]</span> <span class="hljs-selector-attr">[文件]</span>  <br></code></pre></td></tr></table></figure><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li>-f 循环读取</li><li>-q 不显示处理信息</li><li>-v 显示详细的处理信息</li><li>-c&lt;数目&gt; 显示的字节数</li><li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">tail -n100 access.log<br>head -n100 access.log<br></code></pre></td></tr></table></figure><p><strong>统计</strong></p><p>sort和uniq经常配对使用。<br>sort可以使用<code>-t</code>指定分隔符，使用<code>-k</code>指定要排序的列。<br>下面这个命令输出nginx日志的ip和每个ip的pv，pv最高的前10</p><p>ext<br>tail -n100 access.log<br>head -n100 access.log</p><pre><code class="hljs">**统计**sort和uniq经常配对使用。sort可以使用`-t`指定分隔符，使用`-k`指定要排序的列。下面这个命令输出nginx日志的ip和每个ip的pv，pv最高的前10</code></pre>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linuxcmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>multiplexerdemultiplexer</title>
    <link href="/Blogs/2025/08/28/multiplexerdemultiplexer/"/>
    <url>/Blogs/2025/08/28/multiplexerdemultiplexer/</url>
    
    <content type="html"><![CDATA[<p>前置知识<br>[[位运算]]</p><h1 id="Logic-Gates"><a href="#Logic-Gates" class="headerlink" title="Logic Gates"></a>Logic Gates</h1><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p><img src="https://pic3.zhimg.com/80/v2-7286e1c81a80e4727042fe89d9178bc2_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-d2d04b751590cfe45c826f4cb5dee9ce_1440w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-da8679f7d01afe9d577fd503186fb5b9_1440w.webp" alt="img"></p><h2 id="Binary-symbols"><a href="#Binary-symbols" class="headerlink" title="Binary symbols"></a>Binary symbols</h2><p>一大段为1和0（增加容错率），中间隔了一段不定义</p><p><img src="https://slideplayer.com/slide/9051355/27/images/52/Figure+1.3+Example+of+binary+signals.jpg" alt="Chapter 1 Digital Systems and Binary Numbers - ppt download"></p><h2 id="多逻辑门"><a href="#多逻辑门" class="headerlink" title="多逻辑门"></a>多逻辑门</h2><p>一个逻辑门可以有多个input，运算法则与两个一致</p><p><img src="https://player.slideplayer.com/27/9051355/data/images/img45.jpg" alt="img"></p><h2 id="Binary-Code-Decimal-BCD"><a href="#Binary-Code-Decimal-BCD" class="headerlink" title="Binary Code Decimal (BCD)"></a>Binary Code Decimal (BCD)</h2><ul><li>The most obvious way of representing&#x2F;encoding digits is “natural BCD” (NBCD), where each decimal digit is represented by its corresponding four-bit binary value</li><li>This is also called “8421” encoding</li></ul><h1 id="Encoder-and-Decoder"><a href="#Encoder-and-Decoder" class="headerlink" title="Encoder and Decoder"></a>Encoder and Decoder</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>Encoder</strong> is a combinational circuit that changes a set of binary signals into a code (2n input lines with ‘n’ bits)</p><p><strong>Decoder</strong> is the opposite of an encoder as it is a combinational circuit that changes a code into a set of binary signals (‘n’ input lines and maximum of 2n output lines)</p><p><img src="https://www.electricaltechnology.org/wp-content/uploads/2022/08/Difference-between-Encoder-and-Decoder.png" alt="What is the Differences Between Encoder and Decoder?"></p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><ul><li><p>A Binary Encoder takes ALL its data inputs <strong>one at a time</strong> and then converts</p><p>them into a single encoded output</p></li><li><p>A binary encoder, is a multi-input combinational logic circuit that converts the <strong>logic level “1” data at its inputs into an equivalent binary code</strong> <em>at its output</em></p></li><li><p>The output lines of a digital encoder generate the <em>binary equivalent of the input line whose value is equal to “1”</em> and are available to encode either a decimal or hexadecimal input pattern to typically a binary or BCD output code</p></li><li><p>Generally, binary encoders produce outputs of 2-bit, 3-bit or 4-bit codes depending upon the number of data input lines</p></li><li><p>An “n-bit” binary encoder has 2n input lines and n-bit output lines with common types that include 4-to-2, 8-to-3 and 16-to-4 line configurations</p></li></ul><p><img src="https://www.electronics-tutorials.ws/wp-content/uploads/2013/08/comb11.gif" alt="Priority Encoder and Digital Encoder Tutorial"></p><p>用output1和0不同的组合表示不同的input（input只能有一个输入）</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.ytimg.com/vi/NWiPVMDh7GE/maxresdefault.jpg" alt="Encoder in Digital Electronics | Working, Application and Logic Circuit of  Encoder - YouTube"></h2><p>因为D0是00，这样设计不论怎样都不影响</p><p>8路</p><p><img src="https://static.javatpoint.com/tutorial/digital-electronics/images/encoders7.gif" alt="Encoders"></p><p>有几路output就有几路或门</p><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><ul><li>The Binary Decoder is the exact opposite to that of an “Encoder”</li><li>The name “Decoder” means to translate or decode coded information from one format into another</li><li>‘n’ input lines and maximum of 2n out putlines</li><li>A digital decoder transforms a set of digital input signals into an equivalent decimal code at its output</li></ul><p>作用就是还原encoder的电信号</p><p>用了两个非门和四个三路与门来还原</p><p><img src="https://www.electrically4u.com/wp-content/uploads/2020/09/2-to-4-decoder-block-and-circuit-diagram.png?ezimgfmt=rs:361x203/rscb4/ngcb4/notWebP" alt="What is a decoder? Operation, types and applications"></p><h1 id="Multiplexer-and-De-multiplexer"><a href="#Multiplexer-and-De-multiplexer" class="headerlink" title="Multiplexer and De-multiplexer"></a>Multiplexer and De-multiplexer</h1><p>The multiplexer and de-multiplexer are used in many applications as a way to reduce the number of wires needed to communicate between subsystems</p><ul><li>The multiplexer and de-multiplexer are represented as trapezoids</li><li>The short end of the trapezoid faces the outputs for a multiplexer and faces the inputs for a de-multiplexer.</li></ul><h2 id="Multiplexer"><a href="#Multiplexer" class="headerlink" title="Multiplexer"></a>Multiplexer</h2><p>A multiplexer (MUX) is used to select which of the many input signals should be transferred to its output based upon the value of an equivalent binary number or sometimes the binary code decimal (BCD) on the select pins</p><p>类似于多个开关，信号如何来就如何去</p><p>A multiplexer selects information from an input line and directs the information to an output line</p><ul><li>A typical multiplexer has <em>n</em> control inputs called <em>selection inputs</em>, 2<em>n</em> information inputs (<em>I</em>2<em>n</em> − 1, … , <em>I</em>0), and one output <em>Y</em></li></ul><p><img src="https://www.circuitbasics.com/wp-content/uploads/2020/06/image-45.png" alt="A Complete Guide to Electronic Multiplexers - Circuit Basics"></p><p><img src="https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/combination-multiplexer3.gif" alt="The Multiplexer (MUX) and Multiplexing Tutorial"></p><p>此处b，a是选择器（s1，s0）</p><h2 id="demultiplexer"><a href="#demultiplexer" class="headerlink" title="demultiplexer"></a>demultiplexer</h2><p>A de-multiplexer is a digital switch with a single input(source) and multiple outputs (destinations)</p><p>• The select pins determine which output the input connected to</p><h1 id="Applications-of-Mux-and-De-mux"><a href="#Applications-of-Mux-and-De-mux" class="headerlink" title="Applications of Mux and De-mux"></a>Applications of Mux and De-mux</h1><p><strong>Telephone network:</strong> In telephone network, multiple audio signals are integrated on a single line for transmission with the help of multiplexers. At the other end of the network, a de-multiplexer is used to convert a particular signal back to its original form and transfer it to the phone that is supposed to receive the data.</p><p><strong>Computer memory:</strong> Multiplexers are used to implement huge amount of memory into the computer, at the same time reduces the number of copper lines required to connect the memory to other parts of the computer circuit. In an Arithmetic Logic Unit (ALU) circuit, the output is stored in multiple registers with the help of de-multiplexer.</p><p><strong>Serial to parallel converter:</strong> Used to reconstruct parallel data from incoming serial data stream. In this technique, data from the incoming serial data stream is the data input to the de-multiplexer at the regular intervals. A counter is attach to the control input of the de-multiplexer. This counter directs the data signal to the output of the de-multiplexer where the data signals are stored. When all data signals have been stored, the output of the de-multiplexer can be retrieved and read out in parallel.</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>multiplexerdemultiplexer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stochasticprocess</title>
    <link href="/Blogs/2025/08/28/stochasticprocess/"/>
    <url>/Blogs/2025/08/28/stochasticprocess/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-马克代夫理论date-2020-05-10-08-45-06tags-数学categories-技术mathjax-true"><a href="#title-马克代夫理论date-2020-05-10-08-45-06tags-数学categories-技术mathjax-true" class="headerlink" title="title: 马克代夫理论date: 2020-05-10 08:45:06tags:- 数学categories: 技术mathjax: true"></a>title: 马克代夫理论<br>date: 2020-05-10 08:45:06<br>tags:<br>- 数学<br>categories: 技术<br>mathjax: true</h2><h1 id="随机过程是什么？"><a href="#随机过程是什么？" class="headerlink" title="随机过程是什么？"></a>随机过程是什么？</h1><p>一般来说，把一组随机变量定义为随机过程。在研究随机过程时人们透过表面的偶然性描述出必然的内在规律并以概率的形式来描述这些规律，从偶然中悟出必然正是这一学科的魅力所在。</p><p>整个学科的理论基础是由柯尔莫哥洛夫和杜布奠定的。这一学科最早源于对物理学的研究，如吉布斯、玻尔兹曼、庞加莱等人对统计力学的研究，及后来爱因斯坦、维纳、莱维等人对布朗运动的开创性工作。</p><span id="more"></span><h1 id="高斯过程"><a href="#高斯过程" class="headerlink" title="高斯过程"></a>高斯过程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>高斯过程（Gaussian Process, GP）是概率论和数理统计中随机过程（stochastic process）的一种，是一系列服从正态分布的随机变量（random variable）在一指数集（index set）内的组合</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>高斯过程模型属于无参数模型，相对解决的问题复杂度及与其它算法比较减少了算法计算量。</li><li>高斯模型可以解决高维空间（实际上是无限维）的数学问题，可以面对负杂的数学问题。</li><li>结合贝叶斯概率算法，可以实现通过先验概率，推导未知后验输入变量的后验概率。由果推因的概率。<br>高斯过程观测变量空间是连续域，时间或空间。</li><li>高斯过程观测变量空间是实数域的时候，我们就可以进行回归而实现预测。</li><li>高斯过程观测变量空间是整数域的时候（观测点是离散的），我们就可以进行分类。结合贝叶斯算法甚至可以实现单类分类学习（训练），面对小样本就可以实现半监督学习而后完成分类。面对异常检测领域很有用，降低打标签成本（小样本且单类即可训练模型）。</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>为了了解高斯过程，我们需要知道高斯分布（函数）、随机过程、以及贝叶斯概率等。。。</p><p>MD不学了。。。</p><p>前置知识高斯分布杀了我。。。</p><p>坑挖好了以后再填</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stochasticprocess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代数篇</title>
    <link href="/Blogs/2025/08/28/%E4%BB%A3%E6%95%B0%E7%AF%87/"/>
    <url>/Blogs/2025/08/28/%E4%BB%A3%E6%95%B0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h2><ul><li>都有变量</li><li>表示一种确定的对应关系</li><li>对应关系可以用数学的方法算出来</li></ul><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>函数将曲线与方程联系起来，可以直观看到一些变量变化的趋势</p><ul><li>将人们对具体数据的关注变为了对趋势的关注</li><li>作为数学工具的使用</li></ul><h2 id="函数中的因果关系"><a href="#函数中的因果关系" class="headerlink" title="函数中的因果关系"></a>函数中的因果关系</h2><p>数学上的因果关系与生活中的可能不完全相同</p><p>不要混淆相关性与必然性</p><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>数量也有方向，在实际生活中，这些与数量一样重要</p><h2 id="余弦定理"><a href="#余弦定理" class="headerlink" title="余弦定理"></a>余弦定理</h2><p>可以对向量夹角进行计算</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>分类</p><p>将关键词组成的多维向量与标准向量进行夹脚运算，夹脚越小越接近，从而实现分类</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>将多个同样维度的向量放在一起形成矩阵</p><p>矩阵乘法是向量与向量相乘的延伸</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代数篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化理论</title>
    <link href="/Blogs/2025/08/28/%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/"/>
    <url>/Blogs/2025/08/28/%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-优化理论date-2020-05-10-09-12-50tags-数学categories-技术mathjax-true"><a href="#title-优化理论date-2020-05-10-09-12-50tags-数学categories-技术mathjax-true" class="headerlink" title="title: 优化理论date: 2020-05-10 09:12:50tags:- 数学categories: 技术mathjax: true"></a>title: 优化理论<br>date: 2020-05-10 09:12:50<br>tags:<br>- 数学<br>categories: 技术<br>mathjax: true</h2><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在特定约束条件下，选择变量值，是目标函数最大化&#x2F;最小化</p><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ul><li><p>优化</p><ul><li>数据<ul><li>离散</li><li>连续</li></ul></li><li>条件<ul><li>无拘束</li><li>有拘束</li></ul></li><li>函数<ul><li>线性</li><li>非线性</li></ul></li><li>目标<ul><li>单目标</li><li>多目标</li></ul></li></ul><span id="more"></span><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="梯度下降法（局部最优）"><a href="#梯度下降法（局部最优）" class="headerlink" title="梯度下降法（局部最优）"></a>梯度下降法（局部最优）</h2><h3 id="理论指导"><a href="#理论指导" class="headerlink" title="理论指导"></a>理论指导</h3><p>基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。</p><p>我们同时可以假设这座山最陡峭的地方是无法通过肉眼立马观察出来的，而是需要一个复杂的工具来测量，同时，这个人此时正好拥有测量出最陡峭方向的能力。所以，此人每走一段距离，都需要一段时间来测量所在位置最陡峭的方向，这是比较耗时的。那么为了在太阳下山之前到达山底，就要尽可能的减少测量方向的次数。这是一个两难的选择，如果测量的频繁，可以保证下山的方向是绝对正确的，但又非常耗时，如果测量的过少，又有偏离轨道的风险。所以需要找到一个合适的测量方向的频率，来确保下山的方向不错误，同时又不至于耗时太多！</p><p>所以首先，我们需要有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向(在后面会详细解释)</p><h4 id="前置知识：微分"><a href="#前置知识：微分" class="headerlink" title="前置知识：微分"></a>前置知识：微分</h4><p>看待微分的意义，可以有不同的角度，最常用的两种是：</p><ul><li>函数图像中，某点的切线的斜率</li></ul></li></ul><ul><li><p>函数的变化率<br>  几个微分的例子：</p><p>学习坡度下降法，必须以微分作为辅助</p><p>博主写过<a href="https://mavericreate.top/Zh-Blog/2020/04/28/Calculus/">微积分</a>有关的笔记,感兴趣可以去看看</p><p>这里补充一下<strong>多变量微分</strong></p><p>就是对每个变量进行分别微分</p><p>$$\cfrac{\partial}{\partial x}(x^2y^2)&#x3D;2xy^2$$</p><p>$$\cfrac{\partial}{\partial y}(-2y^5+z^2)&#x3D;-10y^4$$</p><p>$$\cfrac{\partial}{\partial \theta_2}(5\theta_1+2\theta_2-12\theta_3)&#x3D;2$$</p><p>$$\cfrac{\partial}{\partial \theta_2}(0.55-(5\theta_1+2\theta_2-12\theta_3)&#x3D;-2$$</p><h4 id="梯度的概念"><a href="#梯度的概念" class="headerlink" title="梯度的概念"></a>梯度的概念</h4><p>梯度实际上就是多变量微分的一般化。</p></li></ul><p>我们可以看到，梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。</p><p>梯度是微积分中一个很重要的概念，之前提到过梯度的意义</p><ul><li>在<strong>单变量</strong>的函数中，梯度其实就是函数的<strong>微分</strong>，代表着函数在某个给定点的切线的斜率</li><li>在<strong>多变量</strong>函数中，梯度是一个<strong>向量</strong>，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向</li></ul><p><strong>这也就说明了为什么我们需要千方百计的求取梯度！</strong>我们需要到达山底，就需要在每一步观测到此时最陡峭的地方，梯度就恰巧告诉了我们这个方向。梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，这正是我们所需要的。所以我们只要沿着梯度的方向一直走，就能走到局部的最低点。</p><p><strong>梯度垂直于等值线</strong></p><h3 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a><strong>数学解释</strong></h3><p>J是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是α，走完这个段步长，就到达了Θ1这个点！</p><h4 id="α"><a href="#α" class="headerlink" title="α"></a>α</h4><p>α在梯度下降算法中被称作为学习率或者步长，意味着我们可以通过α来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈，其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以α的选择在梯度下降法中往往是很重要的！α不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</p><h4 id="⚠️"><a href="#⚠️" class="headerlink" title="⚠️"></a>⚠️</h4><p>梯度前加一个负号，就意味着朝着梯度相反的方向前进！我们在前文提到，梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号；<strong>那么如果时上坡，也就是梯度上升算法，当然就不需要添加负号了。</strong></p><h3 id="两个栗子🌰"><a href="#两个栗子🌰" class="headerlink" title="两个栗子🌰"></a>两个栗子🌰</h3><h4 id="单变量函数"><a href="#单变量函数" class="headerlink" title="单变量函数"></a>单变量函数</h4><p>有一个二次函数</p><p>$$J(x)&#x3D;x^2$$</p><p>轻易求出微分</p><p>$$J\prime(x)&#x3D;x^2$$</p><p>然后设置容易起点</p><p>$$x^0&#x3D;1$$</p><p>将学习率设置成$$a$$</p><p>然后根据公式我们进行迭代计算</p><p>如图，经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底</p><h4 id="多变量函数"><a href="#多变量函数" class="headerlink" title="多变量函数"></a>多变量函数</h4><p>有一个复合函数</p><p>$$J(x)&#x3D;a^2+b^2$$</p><p>现在要通过梯度下降法计算这个函数的最小值。我们通过观察就能发现最小值其实就是 (0，0)点。但是接下来，我们会从梯度下降算法开始一步步计算到这个最小值！<br>我们假设初始的起点为：</p><p>$$(1,3)$$</p><p>假设学习率为：</p><p>$$a&#x3D;0.1$$</p><p>![Screen Shot 2020-05-10 at 11.38.38 AM](&#x2F;Users&#x2F;maverick&#x2F;Desktop&#x2F;PROGRAM&#x2F;Mavericreate&#x2F;Zh-Blog&#x2F;source&#x2F;_posts&#x2F;Optimization-theory&#x2F;Screen Shot 2020-05-10 at 11.38.38 AM.png)</p><p>我们发现，已经基本靠近函数的最小值点</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>下面我们将用python实现一个简单的梯度下降算法。场景是一个简单的线性回归的例子：假设现在我们有一系列的点，如下图所示：</p><p>我们将用梯度下降法来拟合出这条直线！</p><p>首先，我们需要定义一个代价函数，在此我们选用<a href="https://en.wikipedia.org/wiki/Least_squares"><strong>均方误差代价函数</strong></a>（也称平方误差代价函数）</p><p>此公式中</p><ul><li>m是数据集中数据点的个数，也就是样本数</li><li>½是一个常量，这样是为了在求梯度的时候，二次方乘下来的2就和这里的½抵消了，自然就没有多余的常数系数，方便后续的计算，同时对结果不会有影响</li><li>y 是数据集中每个点的真实y坐标的值，也就是类标签</li><li>h 是我们的预测函数（假设函数），根据每一个输入x，根据Θ 计算得到预测的y值，即$$h_\theta(x^i)&#x3D;\theta_0+\theta_1x_{1}^{(i)}$$</li></ul><p>我们可以根据代价函数看到，代价函数中的变量有两个，所以是一个多变量的梯度下降问题，求解出代价函数的梯度，也就是分别对两个变量进行微分</p><p>明确了代价函数和梯度，以及预测的函数形式。我们就可以开始编写代码了。但在这之前，需要说明一点，就是为了方便代码的编写，我们会将所有的公式都转换为矩阵的形式，python中计算矩阵是非常方便的，同时代码也会变得非常的简洁。<br>为了转换为矩阵的计算，我们观察到预测函数的形式</p><p>$$h_\theta(x^i)&#x3D;\theta_0+\theta_1x_{1}^{(i)}$$</p><p>我们有两个变量，为了对这个公式进行矩阵化，我们可以给每一个点x增加一维，这一维的值固定为1，这一维将会乘到Θ0上。这样就方便我们统一矩阵化的计算</p><p>$$(x_{1}^i,x^i)\to(x_{0}^i,x_{1}^i,y^i)with x_{0}^i&#x3D;1\forall i$$</p><p>然后我们将代价函数和梯度转化为矩阵向量相乘的形式</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-comment"># 首先，我们需要定义数据集和学习率</span><br><br><span class="hljs-comment"># 数据集大小 即20个数据点</span><br>m = <span class="hljs-number">20</span><br><span class="hljs-comment"># x的坐标以及对应的矩阵</span><br>X0 = ones((m, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 生成一个m行1列的向量，也就是x0，全是1</span><br>X1 = arange(<span class="hljs-number">1</span>, m+<span class="hljs-number">1</span>).reshape(m, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 生成一个m行1列的向量，也就是x1，从1到m</span><br>X = hstack((X0, X1))  <span class="hljs-comment"># 按照列堆叠形成数组，其实就是样本数据</span><br><span class="hljs-comment"># 对应的y坐标</span><br>Y = array([<br>    <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>,<br>    <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span><br>]).reshape(m, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 学习率</span><br>alpha = <span class="hljs-number">0.01</span><br><br><span class="hljs-comment">#接下来我们以矩阵向量的形式定义代价函数和代价函数的梯度</span><br><br><span class="hljs-comment"># 定义代价函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cost_function</span>(<span class="hljs-params">theta, X, Y</span>):<br>    diff = dot(X, theta) - Y  <span class="hljs-comment"># dot() 数组需要像矩阵那样相乘，就需要用到dot()</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>/(<span class="hljs-number">2</span>*m)) * dot(diff.transpose(), diff)<br><br><br><span class="hljs-comment"># 定义代价函数对应的梯度函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient_function</span>(<span class="hljs-params">theta, X, Y</span>):<br>    diff = dot(X, theta) - Y<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>/m) * dot(X.transpose(), diff)<br><br><span class="hljs-comment">#最后就是算法的核心部分，梯度下降迭代计算</span><br>  <br><span class="hljs-comment"># 梯度下降迭代</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient_descent</span>(<span class="hljs-params">X, Y, alpha</span>):<br>    theta = array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    gradient = gradient_function(theta, X, Y)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">all</span>(<span class="hljs-built_in">abs</span>(gradient) &lt;= <span class="hljs-number">1e-5</span>):<br>        theta = theta - alpha * gradient<br>        gradient = gradient_function(theta, X, Y)<br>    <span class="hljs-keyword">return</span> theta<br><br><span class="hljs-comment">#当梯度小于1e-5时，说明已经进入了比较平滑的状态，类似于山谷的状态，这时候再继续迭代效果也不大了，所以这个时候可以退出循环！</span><br>optimal = gradient_descent(X, Y, alpha)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;optimal:&#x27;</span>, optimal)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;cost function:&#x27;</span>, cost_function(optimal, X, Y)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br><br><span class="hljs-comment">#通过matplotlib画出图像，</span><br><span class="hljs-comment"># 根据数据画出对应的图像</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot</span>(<span class="hljs-params">X, Y, theta</span>):<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    ax = plt.subplot(<span class="hljs-number">111</span>)  <span class="hljs-comment"># 这是我改的</span><br>    ax.scatter(X, Y, s=<span class="hljs-number">30</span>, c=<span class="hljs-string">&quot;red&quot;</span>, marker=<span class="hljs-string">&quot;s&quot;</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;X&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Y&quot;</span>)<br>    x = arange(<span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0.2</span>)  <span class="hljs-comment"># x的范围</span><br>    y = theta[<span class="hljs-number">0</span>] + theta[<span class="hljs-number">1</span>]*x<br>    ax.plot(x, y)<br>    plt.show()<br><br>plot(X1, Y, optimal)<br><br></code></pre></td></tr></table></figure><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><h3 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h3><p>1、求方程的根，2、最优化。</p><p><strong>牛顿法的核心思想是对函数进行泰勒展开。</strong></p><h3 id="求方程的根"><a href="#求方程的根" class="headerlink" title="求方程的根"></a>求方程的根</h3><p>并不是所有的方程都有求根公式，或者求根公式很复杂，导致求解困难。利用牛顿法，可以迭代求解。</p><p>原理是利用泰勒公式，在$$x_0$$处展开，且展开到一阶，即$$f(x) &#x3D; f(x_0)+(x－x_0)f’(x_0)$$</p><p>求解方程f(x)&#x3D;0，即$$f(x_0)+(x-x_0)<em>f’(x_0)&#x3D;0$$，求解$$x &#x3D; x_1&#x3D;x_0－f(x_0)&#x2F;f’(x_0)$$，因为这是利用泰勒公式的一阶展开，$$f(x) &#x3D; f(x_0)+(x－x_0)f’(x_0)$$处并不是完全相等，而是近似相等，这里求得的x1并不能让$$f(x)&#x3D;0$$，只能说f(x1)的值比f(x0)更接近$$f(x)&#x3D;0$$，于是乎，迭代求解的想法就很自然了，可以进而推出$$x(n+1)&#x3D;x(n)－f(x(n))&#x2F;f’(x(n))$$，通过迭代，这个式子必然在$$f(x</em>)&#x3D;0$$的时候收敛。整个过程如下图：</p><h3 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h3><p>在最优化的问题中，线性最优化至少可以使用单纯行法求解，但对于非线性优化问题，牛顿法提供了一种求解的办法。假设任务是优化一个目标函数f，求函数f的极大极小问题，可以转化为求解函数f的导数f’&#x3D;0的问题，这样求可以把优化问题看成方程求解问题（f’&#x3D;0）。剩下的问题就和第一部分提到的牛顿法求解很相似了。</p><p>这次为了求解f’&#x3D;0的根，把f(x)的泰勒展开，展开到2阶形式：</p><p>$$f(x+\Delta x)&#x3D;f(x)+f’(x)\Delta x+f’’(x)\Delta x^2&#x2F;2$$</p><p>本式成立，且当$$\Delta x$$无限趋近于0时</p><p>$$f’(x)+f’’(x)\Delta x&#x3D;0$$</p><p>求解</p><p>$$\Delta x&#x3D;-\cfrac{f’(x_n)}{f’’(x_n)}$$</p><p>迭代公式为：</p><p>$$x_{n+1}&#x3D;x_n-\cfrac{f’(x_n)}{f’’(x_n)},n&#x3D;0,1…$$</p><p>一般认为牛顿法可以利用到曲线本身的信息，比梯度下降法更容易收敛（迭代更少次数），如下图是一个最小化一个目标方程的例子，红色曲线是利用牛顿法迭代求解，绿色曲线是利用梯度下降法求解。</p><p>在上面讨论的是2维情况，高维情况的牛顿迭代公式是：</p><p>$$x_{n+1}&#x3D;x_n-[Hf(x_n)]^{-1}\nabla f(x_n),n\ge0$$</p><p>其中H是hessian矩阵，定义为</p><p>高维情况依然可以用牛顿迭代求解，但是问题是Hessian矩阵引入的复杂性，使得牛顿迭代求解的难度大大增加，但是已经有了解决这个问题的办法就是Quasi-Newton methond，不再直接计算hessian矩阵，而是每一步的时候使用梯度向量更新hessian矩阵的近似。</p><p>[[stochastic-process]]</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1.<a href="https://blog.csdn.net/qq_41800366/article/details/86583789">https://blog.csdn.net/qq_41800366/article/details/86583789</a></p><p>2.<a href="https://blog.csdn.net/michaelhan3/article/details/82350047">https://blog.csdn.net/michaelhan3/article/details/82350047</a></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用说明</title>
    <link href="/Blogs/2025/08/28/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/Blogs/2025/08/28/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-快速安装软件"><a href="#Docker-快速安装软件" class="headerlink" title="Docker 快速安装软件"></a>Docker 快速安装软件</h1><h3 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h3><ul><li>安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑</li><li>不方便安装多版本软件，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=2">视频教程</a></p></blockquote><h3 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h3><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul><h3 id="演示-Docker-安装-Redis"><a href="#演示-Docker-安装-Redis" class="headerlink" title="演示 Docker 安装 Redis"></a>演示 Docker 安装 Redis</h3><p>Redis 官网：<a href="https://redis.io/">https://redis.io/</a></p><blockquote><p>官网下载安装教程只有源码安装方式，没有 Windows 版本。想要自己安装 windows 版本需要去找别人编译好的安装包。</p></blockquote><p>Docker 官方镜像仓库查找 Redis ：<a href="https://hub.docker.com/">https://hub.docker.com/</a><br><img src="https://cos.easydoc.net/46901064/files/kv8zs4qr.png" alt="Docker镜像官网"></p><p>一个命令跑起来：<code>docker run -d -p 6379:6379 --name redis redis:latest</code><br>命令参考：<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p><p><img src="https://cos.easydoc.net/46901064/files/kv8zy4xn.png" alt="Docker运行Redis后"></p><h3 id="安装-Wordpress"><a href="#安装-Wordpress" class="headerlink" title="安装 Wordpress"></a>安装 Wordpress</h3><p>docker-compose.yml</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br>  <span class="hljs-attribute">wordpress</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">wordpress</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">8080:80</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">WORDPRESS_DB_HOST</span><span class="hljs-punctuation">:</span> <span class="hljs-string">db</span><br>      <span class="hljs-attribute">WORDPRESS_DB_USER</span><span class="hljs-punctuation">:</span> <span class="hljs-string">exampleuser</span><br>      <span class="hljs-attribute">WORDPRESS_DB_PASSWORD</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepass</span><br>      <span class="hljs-attribute">WORDPRESS_DB_NAME</span><span class="hljs-punctuation">:</span> <span class="hljs-string">exampledb</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">wordpress:/var/www/html</span><br><br>  <span class="hljs-attribute">db</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attribute">restart</span><span class="hljs-punctuation">:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">MYSQL_DATABASE</span><span class="hljs-punctuation">:</span> <span class="hljs-string">exampledb</span><br>      <span class="hljs-attribute">MYSQL_USER</span><span class="hljs-punctuation">:</span> <span class="hljs-string">exampleuser</span><br>      <span class="hljs-attribute">MYSQL_PASSWORD</span><span class="hljs-punctuation">:</span> <span class="hljs-string">examplepass</span><br>      <span class="hljs-attribute">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;1&#x27;</span><br>    <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db:/var/lib/mysql</span><br><br><span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">wordpress</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">db</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><h3 id="安装-ELK"><a href="#安装-ELK" class="headerlink" title="安装 ELK"></a>安装 ELK</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">5044</span>:<span class="hljs-number">5044</span> -it --name elk sebp/elk<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config#global-configuration-options-with-wslconfig">内存不够解决方法</a><br>转到用户目录 <code>cd ~</code>，路径类似这个：<code>C:\Users\&lt;UserName&gt;</code><br>创建 <code>.wslconfig</code> 文件填入以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">10</span>GB <span class="hljs-comment"># Limits VM memory in WSL 2 to 4 GB</span><br><span class="hljs-attr">processors</span>=<span class="hljs-number">2</span> <span class="hljs-comment"># Makes the WSL 2 VM use two virtual processors</span><br></code></pre></td></tr></table></figure><p>生效配置，命令行运行 <code>wsl --shutdown</code></p><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><blockquote><p>觉得老师讲得不错的话，记得点赞、关注、分享，鼓励下老师<br>你们的鼓励会让老师更加有动力继续创造更多更好的内容</p></blockquote><p>你可以到 <a href="https://github.com/gzyunke/test-docker/issues">Github issue</a> 给我提问或反馈遇到的问题。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/Blogs/2025/08/28/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/Blogs/2025/08/28/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="bit，byte之间的转换"><a href="#bit，byte之间的转换" class="headerlink" title="bit，byte之间的转换"></a>bit，byte之间的转换</h1><p>1byte&#x3D;8bit</p><p>1个int&#x3D;4byte&#x3D;32bit</p><p>1个short&#x3D;2byte，一个long&#x3D;8byte，一个char&#x3D;2bytes</p><p>byte的最高位为符号位，剩余7位为数值位，符号位为0表示正数，1为负数；</p><h2 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h2><p>原码：将一个数值以二进制的形式展示；</p><p>反码：正数的反码就是它的原码，负数的反码就是原码的符号位不变，数值位取反；</p><p>补码：正数的补码就是它的原码，负数的补码就是反码的符号位不变，数值位加1；</p><p>计算机在存储一个数字时并不是直接存储该数字对应的二进制数字，而是存储该数字对应二进制数字的补码</p><table><thead><tr><th>数值</th><th>15</th><th>-15</th></tr></thead><tbody><tr><td>原码</td><td>00001111</td><td>1000‭1111‬</td></tr><tr><td>反码</td><td>00001111</td><td>11110000</td></tr><tr><td>补码（实际存储）</td><td>00001111</td><td>11110001</td></tr></tbody></table><ul><li>机器数：一个数在计算机的存储形式是二进制数，我们称这些二进制数为机器数，机器数是有符号，在计算机中用机器数的最高位存放符号位，0表示正数，1表示负数。</li><li>机器数的真值：因为带有符号位，所以机器数的形式值不等于其真值，以机器数1000 0111为例，其真正表示的值为-7，而形式值为135。<strong>将带符号的机器数的真正表示的值称为机器数的真值。</strong></li><li>所以输入数据后：转换为原码，原码转反码，反码转补码最后储存</li></ul><p><img src="https://pic4.zhimg.com/80/v2-7507f422286e51a39cd4a873e76c1d97_1440w.webp" alt="img"></p><h3 id="使用补码运算"><a href="#使用补码运算" class="headerlink" title="使用补码运算"></a>使用补码运算</h3><p>1 - 1 &#x3D; 1 + (-1)</p><p>&#x3D; 原：[ 0000 0001 ] + 原：[ 1000 0001 ]</p><p>&#x3D; 补：[ 0000 0001 ] + 补：[ 1111 1111 ]</p><p>&#x3D; 补： [ 0000 0000 ] &#x3D; 原： [ 0000 0000 ] &#x3D; 0</p><p>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了，而且人们还发现可以用[1000 0000]表示-128。</p><p><strong>-128的推算过程如下</strong>：</p><p>(-1) + (-127) &#x3D; -128</p><p>&#x3D; 原：[1000 0001] + 原：[ 1111 1111 ]</p><p>&#x3D; 补：[ 1111 1111 ] + 补：[ 1000 0001 ]</p><p>&#x3D; 补：[ 1000 0000 ]</p><p><strong>注意</strong>：因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示，只要补码是[1000 0000]，其十进制数值就为-128。</p><p>计算机中一个8位的二进制数的存储范围是用补码表示的[-128,127]</p><h1 id="C中的进制数"><a href="#C中的进制数" class="headerlink" title="C中的进制数"></a>C中的进制数</h1><h2 id="二进制数、八进制数和十六进制数的表示"><a href="#二进制数、八进制数和十六进制数的表示" class="headerlink" title="二进制数、八进制数和十六进制数的表示"></a>二进制数、八进制数和十六进制数的表示</h2><p>二进制：0b或0B开头</p><p>八进制：必须以0开头</p><p>十六进制：必须以0x或0X开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">0b101</span>;  <span class="hljs-comment">//换算成十进制为 5</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">0177777</span>;  <span class="hljs-comment">//换算成十进制为 65535</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">0xffff</span>;  <span class="hljs-comment">//换算成十进制为 65535</span><br><span class="hljs-type">int</span> c= <span class="hljs-number">0xffffffff</span>;<span class="hljs-comment">//换算成十进制为 -1</span><br></code></pre></td></tr></table></figure><h2 id="0xffffffff"><a href="#0xffffffff" class="headerlink" title="0xffffffff"></a>0xffffffff</h2><p>8个f，换算成二进制是1111 1111 1111 .。。（8组1111），如果是unsigned int（最高位不是符号位），则为4294967295（最大的int），如果是signed，则为-1</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><table><thead><tr><th></th><th>short</th><th>int</th><th>long</th></tr></thead><tbody><tr><td>八进制</td><td>%ho</td><td>%o</td><td>%lo</td></tr><tr><td>十进制</td><td>%hd</td><td>%d</td><td>%ld</td></tr><tr><td>十六进制</td><td>%hx 或者 %hX</td><td>%x 或者 %X</td><td>%lx 或者 %lX</td></tr></tbody></table><h1 id="位运算（-、-、-、-、-、"><a href="#位运算（-、-、-、-、-、" class="headerlink" title="位运算（&amp;、|、^、~、&gt;&gt;、&lt;&lt;）"></a>位运算（&amp;、|、^、~、&gt;&gt;、&lt;&lt;）</h1><h2 id="逻辑运算符与二进制运算符区别"><a href="#逻辑运算符与二进制运算符区别" class="headerlink" title="逻辑运算符与二进制运算符区别"></a>逻辑运算符与二进制运算符区别</h2><p>1.&amp;是一个<a href="https://www.baidu.com/s?wd=%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">位运算符</a>，&amp;&amp;是一个<a href="https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">逻辑运算符</a></p><p>2，&amp;是将两个<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>的数逐位相与，结果是相与之后的结果，&amp;&amp;就是判断两个表达式的真假性，只有两个表达式同时为真才为真，有一个为假则为假。</p><p>3.&amp;除了是一个<a href="https://www.baidu.com/s?wd=%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">位运算符</a>，也是取地址符，&amp;&amp;就是一个单纯的逻辑运算符，没有任何其他含义。</p><h2 id="位运算概述"><a href="#位运算概述" class="headerlink" title="位运算概述"></a>位运算概述</h2><p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、&#x2F;)都是叫位运算，即将符号位共同参与运算的运算。</p><p>口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：</p><p>int a &#x3D; 35;<br>int b &#x3D; 47;<br>int c &#x3D; a + b;</p><p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：</p><p>35:  0 0 1 0 0 0 1 1<br>47:  0 0 1 0 1 1 1 1<br>————————————————————<br>82:  0 1 0 1 0 0 1 0</p><p>所以，相比在代码中直接使用(+、-、*、&#x2F;)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p><h2 id="位运算概览"><a href="#位运算概览" class="headerlink" title="位运算概览"></a>位运算概览</h2><h3 id="按位与运算符（-）"><a href="#按位与运算符（-）" class="headerlink" title="按位与运算符（&amp;）#"></a>按位与运算符（&amp;）#</h3><p><strong>定义</strong>：参加运算的两个数据，按二进制位进行”与”运算。<br>两位同时为1，结果才为1，否则结果为0。<br><strong>与运算的用途：</strong><br>1）<strong>清零</strong><br>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。<br>2）<strong>取一个数的指定位</strong><br>比如取数 X&#x3D;1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y&#x3D;0000 1111，然后将X与Y进行按位与运算（X&amp;Y&#x3D;0000 1110）即可得到X的指定位。<br>3）<strong>判断奇偶</strong><br>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) &#x3D;&#x3D; 0)代替if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数。</p><h3 id="按位或运算符（-）"><a href="#按位或运算符（-）" class="headerlink" title="按位或运算符（|）"></a>按位或运算符（|）</h3><p>定义：参加运算的两个对象，按二进制位进行”或”运算。<br>参加运算的两个对象只要有一个为1，其值为1。<br>例如：3|5即 0000 0011| 0000 0101 &#x3D; 0000 0111，因此，3|5的值得7。　<br>注意：负数按补码形式参加按位或运算。<br>或运算的用途：<br>1）常用来对一个数据的<strong>某些位设置为1</strong><br>比如将数 X&#x3D;1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y&#x3D;0000 1111，然后将X与Y进行按位或运算（X|Y&#x3D;1010 1111）即可得到。</p><h3 id="异或XOR运算符（-）"><a href="#异或XOR运算符（-）" class="headerlink" title="异或XOR运算符（^）"></a>异或XOR运算符（^）</h3><p>定义：参加运算的两个数据，按二进制位进行”异或”运算。<br>参加运算的两个对象，如果两个相应位<strong>相同为0，相异为1</strong></p><p>异或的几条性质:</p><ul><li>1、交换律</li><li>2、结合律 (a^b)^c &#x3D;&#x3D; a^(b^c)</li><li>3、对于任何数x，都有 x^x&#x3D;0，x^0&#x3D;x</li><li>4、自反性: a^b^b&#x3D;a^0&#x3D;a;</li></ul><p>异或运算的用途：<br>1）<strong>翻转指定位</strong><br>比如将数 X&#x3D;1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y&#x3D;0000 1111，然后将X与Y进行异或运算（X^Y&#x3D;1010 0001）即可得到。<br>2）<strong>与0相异或值不变</strong><br>例如：1010 1110 ^ 0000 0000 &#x3D; 1010 1110<br>3）<strong>交换两个数</strong><br>实例<br>void Swap(int &amp;a, int &amp;b){<br>    if (a !&#x3D; b){<br>        a ^&#x3D; b;<br>        b ^&#x3D; a;<br>        a ^&#x3D; b;<br>    }<br>}  </p><h3 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符 (~)"></a>取反运算符 (~)</h3><p>定义：参加运算的一个数据，按二进制进行”取反”运算。<br>运算规则：　<br>对一个二进制数按位取反，即将0变1，1变0。<br>取反运算的用途：<br><strong>1）使一个数的最低位为零</strong><br>使a的最低位为0，可以表示为：a &amp; <del>1。</del>1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为” ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p><h3 id="左移运算符（"><a href="#左移运算符（" class="headerlink" title="左移运算符（&lt;&lt;）"></a>左移运算符（&lt;&lt;）</h3><p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。<br>设 a&#x3D;1010 1110，a &#x3D; a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a&#x3D;1011 1000。<br>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h3 id="右移运算符（-）"><a href="#右移运算符（-）" class="headerlink" title="右移运算符（&gt;&gt;）"></a>右移运算符（&gt;&gt;）</h3><p>定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br>例如：a&#x3D;a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。<br>操作数每右移一位，相当于该数除以2。</p><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p><p>&amp;&#x3D;        例：a&amp;&#x3D;b    相当于     a&#x3D;a&amp;b</p><p>|&#x3D;        例：a|&#x3D;b    相当于     a&#x3D;a|b</p><p>’&gt;&gt;‘&#x3D;      例：a&gt;&gt;&#x3D;b   相当于     a&#x3D;a&gt;&gt;b</p><p>&lt;&lt;&#x3D;      例：a&lt;&lt;&#x3D;b     相当于      a&#x3D;a&lt;&lt;b</p><p>^&#x3D;        例：a^&#x3D;b    相当于   a&#x3D;a^b</p><p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p><p>不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以”与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行”与运算”，右端对齐后，左边不足的位依下面三种情况补足，</p><ul><li>1）如果整型数据为正数，左边补16个0。</li><li>2）如果整型数据为负数，左边补16个1。</li><li>3）如果整形数据为无符号数，左边也补16个0。<br>如：long a&#x3D;123；int b&#x3D;1；计算a&amp; b。</li></ul><p>如：long a&#x3D;123；int b&#x3D;-1；计算a&amp; b。</p><p>如：long a&#x3D;123；unsigned intb&#x3D;1；计算a &amp; b。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息安全网页运作原理</title>
    <link href="/Blogs/2025/08/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BD%91%E9%A1%B5%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%BD%91%E9%A1%B5%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h1><h2 id="HyperText-Transfer-Protocol"><a href="#HyperText-Transfer-Protocol" class="headerlink" title="HyperText Transfer Protocol"></a>HyperText Transfer Protocol</h2><h3 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h3><p>超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本</p><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）</p><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p><img src="https://pic3.zhimg.com/80/v2-6e7f7b4c7dab1c7924f598e33ddf9c0e_1440w.jpg"></p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>客户端发送请求时，用来指定服务器的域名。  </p><p><img src="https://pic2.zhimg.com/80/v2-422cc33de650189353768441edde4095_1440w.jpg"><br>Host: <a href="https://link.zhihu.com/?target=http://www.A.com">http://www.A.com</a><br>有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。  </p><h3 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h3><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。  </p><p><img src="https://pic3.zhimg.com/80/v2-efe02adff2d13e0c5418a350d200d162_1440w.jpg"></p><p>Content-Length: 1000<br>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。  </p><h3 id="Connection-字段"><a href="#Connection-字段" class="headerlink" title="Connection 字段"></a>Connection 字段</h3><p>Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。  </p><p><img src="https://pic2.zhimg.com/80/v2-9c8d7f0df9bda0b7e72316ca07719235_1440w.jpg"></p><p>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。<br>Connection: keep-alive<br>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。  </p><h3 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h3><p>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。  </p><p><img src="https://pic3.zhimg.com/80/v2-605221661a85ac454620921828cf414a_1440w.jpg"></p><p>Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>上面的类型表明，发送的是网页，而且编码是UTF-8。<br>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。<br>Accept: <em>&#x2F;</em><br>上面代码中，客户端声明自己可以接受任何格式的数据。  </p><h3 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h3><p>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式  </p><p><img src="https://pic4.zhimg.com/80/v2-c5acc9516c67e06d8242300435b992af_1440w.jpg"></p><p>Content-Encoding: gzip<br>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。<br>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。<br>Accept-Encoding: gzip, deflate  </p><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><p>说一下 GET 和 POST 的区别？<br>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。<br>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源</p><p><img src="https://pic1.zhimg.com/80/v2-b236f5547723b789000c1417fd3f6060_1440w.jpg"></p><p>而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。<br>比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。  </p><p><img src="https://pic3.zhimg.com/80/v2-b62f287f4e676591a8162e20bca97f62_1440w.jpg"></p><p>GET 和 POST 方法都是安全和幂等的吗？<br>安全和幂等：  </p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>那么很明显 <strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<br>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以<strong>不是幂等的</strong>。  </p><h1 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h1><p>你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？  </p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>1. 简单</strong><br>HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。<br><strong>2. 灵活和易于扩展</strong><br>HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。<br>同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。<br>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层，HTTP&#x2F;3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。<br><strong>3. 应用广泛和跨平台</strong><br>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。  </p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有<strong>一大缺点「不安全</strong>」。<br><strong>1. 无状态双刃剑</strong><br>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。<br>这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是酸爽！<br>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。<br>Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。<br>相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了，  </p><p><img src="https://pic2.zhimg.com/80/v2-ae8d27bcce3600c93983266d5bef4519_1440w.jpg"></p><p><strong>2. 明文传输双刃剑</strong><br>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。<br>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。<br><strong>3. 不安全</strong><br>HTTP 比较严重的缺点就是不安全：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。</li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。</li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。</li></ul><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL&#x2F;TLS 层，使得在安全上达到了极致。<br>那你说下 HTTP&#x2F;1.1 的性能如何？<br>HTTP 协议是基于 TCP&#x2F;IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。<br><strong>1. 长连接</strong><br>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。<br>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。  </p><p><img src="https://pic4.zhimg.com/80/v2-783426b22fe1e00799f019aa69ed98a7_1440w.jpg"></p><p><strong>2. 管道网络传输</strong><br>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。<br>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间<br>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。  </p><p><img src="https://pic4.zhimg.com/80/v2-79febcc4e634d293781ac79c38859267_1440w.jpg"></p><p>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」<br><strong>3. 队头阻塞</strong><br>「请求 - 应答」的模式加剧了 HTTP 的性能问题。<br>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。  </p><p><img src="https://pic3.zhimg.com/80/v2-06fb83f8c44f481398a16008218dcb0a_1440w.jpg"></p><p>总之 HTTP&#x2F;1.1 的性能一般般，后续的 HTTP&#x2F;2 和 HTTP&#x2F;3 就是在优化 HTTP 的性能。  </p><h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><ol><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><p>HTTPS 解决了 HTTP 的哪些问题？<br>HTTP 由于是明文传输，所以安全上存在以下三个风险：  </p><ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议。  </p><p><img src="https://pic3.zhimg.com/80/v2-11869f14c2fcea7116a9bbb50f764096_1440w.jpg"></p><p>HTTP 与 HTTPS可以很好的解决了上述的风险：  </p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>可见，只要自身不做「恶」，SSL&#x2F;TLS 协议是能保证通信是安全的。<br>HTTPS 是如何解决上面的三个风险的？  </p><ul><li><strong>混合加密的方式实现信息的机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法的方式来实现完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li><strong>将服务器公钥放入到数字证书中</strong>，解决了冒充的风险。</li></ul><p><strong>1. 混合加密</strong><br>通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。  </p><p><img src="https://pic4.zhimg.com/80/v2-63be05f9c77e1a3d9efe84ed7ace09cf_1440w.jpg"></p><p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：  </p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据</li></ul><p>采用「混合加密」的方式的原因：  </p><ul><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><p><strong>2. 摘要算法</strong><br>摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。  </p><p><img src="https://pic4.zhimg.com/80/v2-814e10f03dc78a1a775bd36b7a6341d7_1440w.jpg"></p><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同<br>加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。<br><strong>3. 数字证书</strong><br>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<br>这就存在些问题，如何保证公钥不被篡改和信任度？<br>所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。  </p><p><img src="https://pic2.zhimg.com/80/v2-316fa991868e4aed92d9eae3225fe309_1440w.jpg"></p><p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。  </p><h2 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h2><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是握手阶段。<br>SSL&#x2F;TLS 的「握手阶段」涉及四次通信，可见下图：  </p><p><img src="https://pic1.zhimg.com/80/v2-29cf8cbd6cde84a8b5ee7ae92f547380_1440w.jpg"></p><h2 id="SSL-TLS-协议建立的详细流程"><a href="#SSL-TLS-协议建立的详细流程" class="headerlink" title="SSL&#x2F;TLS 协议建立的详细流程"></a>SSL&#x2F;TLS 协议建立的详细流程</h2><p><strong>1. ClientHello</strong><br>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。<br>在这一步，客户端主要向服务器发送以下信息：<br>（1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。<br>（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。<br><strong>2. SeverHello</strong><br>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：<br>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。<br><strong>3.客户端回应</strong><br>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。<br>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：<br>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。<br>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。<br><strong>4. 服务器的最后回应</strong><br>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。<br>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。  </p><h1 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h1><p>说说 HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？<br>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：  </p><ul><li>使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><h2 id="HTTP-1-1-还是有性能瓶颈"><a href="#HTTP-1-1-还是有性能瓶颈" class="headerlink" title="HTTP&#x2F;1.1 还是有性能瓶颈"></a>HTTP&#x2F;1.1 还是有性能瓶颈</h2><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><p>那上面的 HTTP&#x2F;1.1 的性能瓶颈，HTTP&#x2F;2 做了什么优化？<br>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。<br>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：<br><strong>1. 头部压缩</strong><br>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分<br>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了<br><strong>2. 二进制格式</strong><br>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式<br>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧</p><p><img src="https://pic1.zhimg.com/80/v2-6ea02bd0dea7eae3fee729897df02f94_1440w.jpg"><br>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。<br><strong>3. 数据流</strong><br>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>每个请求或回应的所有数据包，称为一个数据流（Stream）。<br>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数<br>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。  </p><p><img src="https://pic4.zhimg.com/80/v2-bad1522712684f79322c1bd50133b617_1440w.jpg"></p><p><strong>4. 多路复用</strong><br>HTTP&#x2F;2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。<br>移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。<br>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。  </p><p><img src="https://pic4.zhimg.com/80/v2-325c064984c2454c4bfb7bf83afad1eb_1440w.jpg"></p><p><strong>5. 服务器推送</strong><br>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。<br>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。  </p><h2 id="HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？"><a href="#HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;2 有哪些缺陷？HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;2 有哪些缺陷？HTTP&#x2F;3 做了哪些优化？</h2><p>HTTP&#x2F;2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。<br>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。  </p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li><li>HTTP&#x2F;2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul><p>这都是基于 TCP 传输层的问题，所以 HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！  </p><p><img src="https://pic1.zhimg.com/80/v2-86a7d45bbe7308f105bc28e720e69d20_1440w.jpg"></p><p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP&#x2F;1.1 的队头阻塞 和 HTTP&#x2F;2 的一个丢包全部重传问题。<br>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。  </p><ul><li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li><li>TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。</li><li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS&#x2F;1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS&#x2F;1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-feda45b9cfcd67c810760ebea083a6bd_1440w.jpg"></p><p>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。<br>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP&#x2F;3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p><h1 id="网站访问流程"><a href="#网站访问流程" class="headerlink" title="网站访问流程"></a>网站访问流程</h1><p>浏览器不管是访问JSP、PHP还是ASP.NET，整体流程几乎是一样的。</p><h2 id="解析主机名"><a href="#解析主机名" class="headerlink" title="解析主机名"></a>解析主机名</h2><p>浏览器拿到网址之后首先会将主机名解析出来，如<a href="http://www.example.com/hello.html%E5%88%99%E4%BC%9A%E5%B0%86%E4%B8%BB%E6%9C%BA%E5%90%8Dwww.example.com%E8%A7%A3%E6%9E%90%E5%87%BA%E6%9D%A5%E3%80%82">http://www.example.com/hello.html则会将主机名www.example.com解析出来。</a></p><h2 id="查找ip"><a href="#查找ip" class="headerlink" title="查找ip"></a>查找ip</h2><p>根据主机名，会首先查找IP，首先查询hosts文件，成功则返回其对应ip地址，如果没有查询到，则去查询DNS服务器，成功就会返回ip，否则会报告连接错误。<br>在host中有这么几句</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">localhost name resolution is handled within DNS itself.<br><span class="hljs-number">127.0.0.1</span> localhost<br></code></pre></td></tr></table></figure><p>所以访问localhost是本机ip，如果这里改掉ip，localhost就会访问其他的ip<br>这里是有一些安全机制的，浏览器是会提醒host文件异常的。</p><h2 id="发送http请求"><a href="#发送http请求" class="headerlink" title="发送http请求"></a>发送http请求</h2><p>浏览器会把自身相关信息与请求相关信息封装成HTTP请求消息改送给服务器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: www.csdn.net<br><span class="hljs-attribute">Connection</span>: keep-alive<br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/webp,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span><br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">3</span>; WOW64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">45</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2454</span>.<span class="hljs-number">99</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br><span class="hljs-attribute">Accept</span>-Encoding: gzip, deflate, sdch<br><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">If</span>-None-Match: W/<span class="hljs-string">&quot;5617e6e2-1947a&quot;</span><br><span class="hljs-attribute">If</span>-Modified-Since: Fri, <span class="hljs-number">09</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">16</span>:<span class="hljs-number">10</span>:<span class="hljs-number">10</span> GMT<br><span class="hljs-attribute">Cookie</span>: uuid_tt_dd=-<span class="hljs-number">2336166380439124030</span>_20150919; .......<br></code></pre></td></tr></table></figure><h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>服务器读取HTTP请求中的内容，在经过解析主机，解析站点名称，解析访问资源后，会查找相关资源，如果查找成功，则返回状态码200，失败就会返回大名鼎鼎的404，在服务器监测到请求不存在的资源后，可以按照程序员设置的跳转到别的页面。所以有各种各样的404错误页面。</p><p>在服务器请求资源的过程中，如php文件会在服务器运行之后再返回。所以php等后台脚本是在服务器运行的。</p><h2 id="服务器返回HTTP响应"><a href="#服务器返回HTTP响应" class="headerlink" title="服务器返回HTTP响应"></a>服务器返回HTTP响应</h2><p>服务器会将请求的资源封装成http响应<br>浏览器得到返回数据后可以会提取数据，然后调用解析内核进行翻译，最后显示出页面<br>之后浏览器会对其引用的文件比如图片，CSS，JS等文件不断进行上述过程，直到所有文件都被下载下来之后，网页就会显示出来</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>信息安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息安全网页运作原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>具体电路分析</title>
    <link href="/Blogs/2025/08/28/%E5%85%B7%E4%BD%93%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <url>/Blogs/2025/08/28/%E5%85%B7%E4%BD%93%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="动态电路分析​​"><a href="#动态电路分析​​" class="headerlink" title="动态电路分析​​"></a><strong>动态电路分析​</strong>​</h3><ol><li><p>​<strong>​一阶电路（RC&#x2F;RL）​</strong>​</p><ul><li>​<strong>​换路定则​</strong>​：电容电压&#x2F;电感电流不能突变</li><li>​<strong>​三要素法​</strong>​：<br>  f(t)&#x3D;f(∞)+[f(0+)−f(∞)]e−t&#x2F;τ<ul><li>τ&#x3D;RC（RC电路），τ&#x3D;L&#x2F;R（RL电路）</li></ul></li></ul></li><li><p>​<strong>​二阶电路（RLC）​</strong>​</p><ul><li>微分方程：dt2d2x​+2αdtdx​+ω02​x&#x3D;K</li><li>阻尼类型：<table><thead><tr><th>条件</th><th>类型</th><th>响应形式</th></tr></thead><tbody><tr><td>α&gt;ω0​</td><td>过阻尼</td><td>x(t)&#x3D;A1​es1​t+A2​es2​t</td></tr><tr><td>α&#x3D;ω0​</td><td>临界阻尼</td><td>x(t)&#x3D;(A1​+A2​t)e−αt</td></tr><tr><td>α&lt;ω0​</td><td>欠阻尼</td><td>x (t)&#x3D;e−αt[B1​cosβt+B2​sinβt]</td></tr></tbody></table></li></ul></li></ol><h3 id="交流电路分析​​"><a href="#交流电路分析​​" class="headerlink" title="交流电路分析​​"></a><strong>交流电路分析​</strong>​</h3><ol><li><p>​<strong>​正弦信号​</strong>​</p><ul><li>三要素：幅值 Vm​、频率 ω、相位 ϕ</li><li>RMS值：Vrms​&#x3D;Vm​&#x2F;2​</li></ul></li><li><p>​<strong>​相量法​</strong>​</p><ul><li><p>阻抗计算：</p><table><thead><tr><th>元件</th><th>阻抗 Z</th><th>导纳 Y&#x3D;1&#x2F;Z</th></tr></thead><tbody><tr><td>电阻</td><td>R</td><td>G</td></tr><tr><td>电容</td><td>jωC1​</td><td>jωC</td></tr><tr><td>电感</td><td>jωL</td><td>jωL1​</td></tr></tbody></table></li></ul></li><li><p>​<strong>​滤波器设计​</strong>​</p><table><thead><tr><th>类型</th><th>传递函数 H(ω)</th><th>截止频率 ωc​</th></tr></thead><tbody><tr><td>RC低通</td><td>1+jωRC1​</td><td>ωc​&#x3D;RC1​</td></tr><tr><td>RL高通</td><td>R+jωLjωL​</td><td>ωc​&#x3D;LR​</td></tr><tr><td>RLC带通</td><td>(jω)2LC+jωRC+1jωRC​</td><td>β&#x3D;LR​</td></tr></tbody></table></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>具体电路分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几何篇</title>
    <link href="/Blogs/2025/08/28/%E5%87%A0%E4%BD%95%E7%AF%87/"/>
    <url>/Blogs/2025/08/28/%E5%87%A0%E4%BD%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="几何学发展阶段"><a href="#几何学发展阶段" class="headerlink" title="几何学发展阶段"></a>几何学发展阶段</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>发现各种面积以及很多复杂几何体的计算公式，知晓圆周率的存在</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>量化的角度测量（360度与60进位）</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>记录所发现的规律，传播知识，形成体系</p><h3 id="为什么是古希腊人完成公理体系的搭建？"><a href="#为什么是古希腊人完成公理体系的搭建？" class="headerlink" title="为什么是古希腊人完成公理体系的搭建？"></a>为什么是古希腊人完成公理体系的搭建？</h3><ul><li>古希腊人大多数时间都用于理性的思考与辩论，使他们在从知识点中抽象出概念形成体系</li><li>自由是科学进步的必要条件</li></ul><h1 id="公理化体系"><a href="#公理化体系" class="headerlink" title="公理化体系"></a>公理化体系</h1><p>使数学能被快速掌握并快速发展</p><h2 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h2><p>公理：如果一个结论找不到根据，又符合事实，且需要不断被使用，就只能将其称为公理</p><p>定理：由公理推出</p><h3 id="一般性公理"><a href="#一般性公理" class="headerlink" title="一般性公理"></a>一般性公理</h3><ul><li>a&#x3D;b,b&#x3D;c,则a&#x3D;c</li><li>如果a&#x3D;b，c&#x3D;d，那么a+c&#x3D;b+d</li><li>如果a&#x3D;b，c&#x3D;d，那么a-c&#x3D;b-d</li><li>能彼此重合的图形是全等的</li><li>整体大于部分</li></ul><h3 id="几何学公理（欧几里得）"><a href="#几何学公理（欧几里得）" class="headerlink" title="几何学公理（欧几里得）"></a>几何学公理（欧几里得）</h3><ul><li>直线公理：两点一直线</li><li>有限直线可以继续延长</li><li>圆公理：容易点为中心，容易距离可以画圆</li><li>垂直公理：直角彼此相等</li><li>平行公理：过直线外一点仅可做一条平行线</li></ul><h3 id="非欧几何公理"><a href="#非欧几何公理" class="headerlink" title="非欧几何公理"></a>非欧几何公理</h3><p>与欧几里得前四条一样，第五条通过修改假定可以得到另外的几何学系统</p><p>黎曼几何假定一条平行线也做不出来，但是适用于物理情况</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>数学问题可以被拆解为几个基本的公理，解决公理即可解决问题</p><p>遇到具体问题，先从定义与公理出发，得到相关的定理</p><p>任何人只要运用逻辑推理，就能先易后难地学会整个体系的知识</p><h1 id="圆周率"><a href="#圆周率" class="headerlink" title="圆周率"></a>圆周率</h1><h2 id="五个阶段"><a href="#五个阶段" class="headerlink" title="五个阶段"></a>五个阶段</h2><ul><li>通过经验对圆周率进行估算</li><li>靠理性</li><li>用数列估算</li><li>运用微积分</li><li>运用计算机算（本质还是微积分）</li></ul><h2 id="圆周率的重要性"><a href="#圆周率的重要性" class="headerlink" title="圆周率的重要性"></a>圆周率的重要性</h2><ul><li>各个方面的对称性</li><li>圆可以和任何由直线组成的几何图形平滑地连接</li></ul><h1 id="解析几何"><a href="#解析几何" class="headerlink" title="解析几何"></a>解析几何</h1><p>用解方程的方法解决几何问题，还能运用几何学的直观特性赋予方程形象的解释</p><h2 id="三大贡献"><a href="#三大贡献" class="headerlink" title="三大贡献"></a>三大贡献</h2><ul><li>构造出统一体系</li><li>基本概念用代数的方式描绘出来</li><li>将几何学与代数两个相对的数学分支统一起来</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>几何篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UART</title>
    <link href="/Blogs/2025/08/28/UART/"/>
    <url>/Blogs/2025/08/28/UART/</url>
    
    <content type="html"><![CDATA[<h1 id="UART-universal-asynchronous-receiver-transmitter"><a href="#UART-universal-asynchronous-receiver-transmitter" class="headerlink" title="UART(universal asynchronous receiver &#x2F; transmitter)"></a>UART(universal asynchronous receiver &#x2F; transmitter)</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>UART stands for universal asynchronous receiver &#x2F; transmitter and defines a protocol, or set of rules, for exchanging serial data between two devices.</p><ul><li>UART is very simple and <strong>only uses two wires between transmitter and receiver to transmit and receive in both directions</strong>.</li><li>UART was <strong>one of the earliest serial protocols</strong>.</li></ul><h2 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h2><p>A UART may be used when</p><ul><li>High speed is not required</li><li>An inexpensive communication link between two devices is required</li><li>UART communication is very cheap</li><li>Single wire for each direction(and ground wire).</li><li>Simple hardware.</li></ul><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p>In UART communication, two UARTs communicate directly with each other</p><p>The transmitting UART converts parallel data from a controlling device like a CPU into serial form, transmits it in serial to the receiving UART, which then converts the serial data back into parallel data for the receiving device.</p><p>The UART that is going to transmit data receives the data from a data bus. The data bus is used to send data to the UART by another device like a CPU. Data is <strong>transferred from the data bus to the transmitting UART</strong> <strong>in parallel form</strong>. After the transmitting UART gets the parallel data from the data bus, it <strong>adds a start bit, a parity bit, and a stop bit, creating the data packet</strong>.</p><p>在 UART 通信中，两个 UART 直接相互通信。发送端将来自控制设备（如 CPU）的并行数据转换为串行形式，接着将其串行传输到接收端，然后接收端将串行数据转换回并行数据以供接收设备使用。</p><p>数据从一个UART的发送引脚（Tx） 流向另一个UART的接收（Rx） 引脚</p><h3 id="Simplex（单工"><a href="#Simplex（单工" class="headerlink" title="Simplex（单工"></a>Simplex（单工</h3><blockquote><p>Uni-directional flow of data</p></blockquote><p>In only one direction</p><p>UART只用Tx或Rx其中一根线进行通讯，也就是只作接收或发送</p><h3 id="Half-duplex（半双工"><a href="#Half-duplex（半双工" class="headerlink" title="Half duplex（半双工"></a>Half duplex（半双工</h3><blockquote><p>Bi-directional flow of data (one direction at a time.)</p></blockquote><p>In both direction, but only one TX and one RX at a time</p><p>UART在同一时间，只用作发送或接收</p><h3 id="Full-duplex（全双工"><a href="#Full-duplex（全双工" class="headerlink" title="Full duplex（全双工"></a>Full duplex（全双工</h3><blockquote><p>Bi-directional flow of data in both directions at the same time (simultaneous flow).</p></blockquote><p>Both sides can transmit and receive in the same time</p><p>UART在发送的同时，也可以接收</p><h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>Each character is sent as</p><ul><li>a logic <em>low</em> <strong>start</strong> bit</li><li>a configurable number of data bits (usually 7 or 8, sometimes 5)</li><li>an <strong>optional parity bit</strong></li><li>one or more <strong>logic high stop bits</strong></li><li>with a <strong>particular bit timing (“baud”)</strong></li></ul><p>When the receiving UART detects a start bit, it starts to read the incoming bits at a specific frequency known as the baud rate. Baud rate is a measure of the speed of data transfer, expressed in bits per second (bps).</p><p>Both UARTs must operate at about the same baud rate. The baud rate between the transmitting and receiving UARTs can only differ by about 10% before the timing of bits gets too far off.</p><p>UART transmitted data is organized into packets. Each packet contains 1 start bit, 5 to 9 data bits (depending on the UART), an optional parity bit, and 1 or 2 stop bits:</p><h2 id="Data-Frame"><a href="#Data-Frame" class="headerlink" title="Data Frame"></a>Data Frame</h2><p>The data frame contains the actual data being transferred. It can be 5 bits up to 8 bits long fi a parity bit is used.</p><p>if no parity bit is used, the data frame can be 9 bits long. In most cases, the data is sent with the least significant bit first.</p><p>UART属于异步传输数据，这意味着没有时钟信号将发送的位输出与接收的位采样同步，也就是发送与接收使用各自的时钟。发送端将开始和停止位添加到传输的数据帧中，通过数据帧中定义的开始位和结束位，接收端知道何时开始读取这些位。</p><p>每个数据帧包含 1 个起始位、5 到 9 个数据位（取决于 UART的设置，如果有奇偶校验位是5到8，没有则是5到9）、一个可选的奇偶校验位和 1 个或 2 个停止位：</p><p><img src="https://pic3.zhimg.com/80/v2-70f190a00d291bba9cff2a200e82225e_720w.webp" alt="img"></p><h3 id="Start-bit"><a href="#Start-bit" class="headerlink" title="Start bit"></a>Start bit</h3><p>The UART data transmission line is normally held at a <strong>high voltage level when it’s not transmitting data</strong>.</p><p>To start the transfer of data, the transmitting UART pulls the transmission line from high to low for one clock cycle.</p><p>When the receiving UART detects the high to low voltage transition, it begins reading the bits in the data frame at the frequency of the baud rate.</p><p>UART 数据传输线在不传输数据时通常保持在高电平。要开始发送数据时，发送端UART先在一个时钟周期内将传输线从高电平拉到低电平。当接收端UART 检测到从高到低的电压转换时，它开始以设置好的波特率的频率读取数据帧中的位。</p><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>数据帧包含正在传输的实际数据。如果使用奇偶校验位，它可以是 5 位到 8 位。如果不使用奇偶校验位，则数据帧可以是 9 位。在大多数情况下，首先发送的数据是最低有效位。</p><h3 id="Parity"><a href="#Parity" class="headerlink" title="Parity"></a>Parity</h3><p>Parity describes the evenness or oddness of a number.</p><p>The parity bit is <strong>a way for the receiving UART to tell if any data has changed during transmission</strong>(Bits can be changed by electromagnetic radiation, mismatched baud rates, or long distance data transfers).</p><p>After the receiving UART reads the data frame, it counts the number of bits with a value of 1and checks if the total is an even or odd number.</p><p>If the parity bit is a 0 (even parity), the 1 bits in the data frame should total to an even number. If the parity bit is a 1 (odd parity), the 1 bits in the data frame should total to an odd number.</p><p>When the parity bit matches the data, the UART knows that the transmission was free of errors. But if the parity bit is a 0, and the total is odd; or the parity bit is a 1, and the total is even, the UART knows that bits in the data frame have changed.</p><p>奇偶校验位是接收端UART 判断数据在传输过程中是否发生变化的一种方式。位会因电磁辐射、不匹配的波特率或长距离数据传输而发生改变。接收端 UART 读取数据帧后，检查数据部分值为1的个数是奇数还是偶数。当奇偶校验位与数据匹配时，UART 知道传输没有错误。</p><h3 id="Stop-bits"><a href="#Stop-bits" class="headerlink" title="Stop bits"></a>Stop bits</h3><p>To <strong>signal the end of the data packet</strong>, the sending UART <strong>drives the data transmission line from a low voltage to a high voltage</strong> for at least two bit durations.</p><p>发送端UART 将数据传输线从低电平拉到高电平持续至少两个位的时间来表示整个数据包的传输已经结束。</p><h3 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h3><p>All operations of the UART hardware are controlled by a clock signal which runs at a multiple of the data rate, typically 8 times the bit rate.</p><p>The receiver tests the state of the incoming signal on each clock pulse, looking for the beginning of the start bit.</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ol><li><p>The transmitting UART receives data in parallel from the data bus（UART 从数据总线并行接收数据</p><p><img src="https://pic4.zhimg.com/80/v2-e313af39d2d11b2506bbb4115e90a4db_720w.webp" alt="img"></p></li><li><p>The transmitting UART adds the start bit, parity bit, and the stop bit(s) to the data frame（发送 UART 将起始位、奇偶校验位和停止位添加到数据帧</p></li></ol><p><img src="https://pic3.zhimg.com/80/v2-7a2a8b69c3e254a7b94af3bd516fd98e_720w.webp" alt="img"></p><ol start="3"><li>The entire packet is sent serially from the transmitting UART to the receiving UART. The receiving UART samples the data line at the pre-configured baud rate（整个数据包从发送 UART 串行发送到接收 UART。接收 UART 以预配置的波特率对数据线进行采样：</li></ol><p><img src="https://pic2.zhimg.com/80/v2-90aa2be6d36d73cab28abf5b20286621_720w.webp" alt="img"></p><ol start="4"><li>The receiving UART discards the start bit, parity bit, and stop bit from the data frame（接收 UART 丢弃数据帧中的起始位、奇偶校验位和停止位</li></ol><p><img src="https://pic3.zhimg.com/80/v2-6651afb43334c9b97c3de786d65a66b6_720w.webp" alt="img"></p><ol start="5"><li>The receiving UART converts the serial data back into parallel and transfers it to the data bus on the receiving end接收端 UART 将串行数据转换回并行，并将其传输到接收端的数据总线：</li></ol><p><img src="https://pic4.zhimg.com/80/v2-c150e3de5909fdb6acb9446edf559263_720w.webp" alt="img"></p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><h3 id="Framing-error"><a href="#Framing-error" class="headerlink" title="Framing error"></a>Framing error</h3><p>A “framing error” occurs <strong>when the designated “start” and “stop” bits are not found</strong>.</p><p>As the start” bit is used to identify the beginning of an incoming character, it acts as a reference for the remaining bits.</p><p>If the data line is <strong>not in the expected state (hi&#x2F;lo) when the “stop” bit is expected</strong>, a Framing Error will occur.</p><h3 id="Parity-error"><a href="#Parity-error" class="headerlink" title="Parity error"></a>Parity error</h3><p>A Parity Error occurs when the <strong>parity of the number of 1 bits disagrees with that specified by the parity bit</strong>.</p><p>Use of a parity bit is optional, so this error will only occur if parity-checking has been enabled.</p><h2 id="PHYSICAL-LAYER-STANDARDS"><a href="#PHYSICAL-LAYER-STANDARDS" class="headerlink" title="PHYSICAL LAYER STANDARDS"></a>PHYSICAL LAYER STANDARDS</h2><p>There are actually quite a number of different standards that utilizes similar protocol. For instances, TL level UART, RS-232, RS-422, RS-485 and etc. We will only discuss about TL level UART and RS-232 here.</p><h3 id="TTL-level-uart"><a href="#TTL-level-uart" class="headerlink" title="TTL level uart"></a>TTL level uart</h3><p>Most microcontrollers with UART Uses TTL (Transistor-transistor Logic) level UART. It is the simplest form of UART. Both logic 1and 0 are represented by 5V and OV respectively.</p><p>The TTL level UART is commonly used in the communications between microcontrollers and ICs. Only 2 wires are required for the full duplex communications as illustrated in the picture below</p><h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p>RS-232 (Recommended Standard 232) is a standard for serial binary data signals connecting between a Data Terminal Equipment (DTE) and a Data Communication Equipment (DCE). It is commonly used in computer serial ports. One of the significant differences between TTL level UART and RS-232 is <strong>the voltage level</strong>. Valid signals in RS-232 are <strong>#3 to - #15V</strong>, and signals near OV is not a valid RS-232 level.</p><p>Besides voltage level, the RS-232 also has <strong>a few extra pins specifically designed for the communication between PC and modem</strong>. The pinouts of the DB-9 and their functions are shown below.</p><h3 id="INTERFACING-BETWEEN-TTML-LEVEL-UART-AND-R-232"><a href="#INTERFACING-BETWEEN-TTML-LEVEL-UART-AND-R-232" class="headerlink" title="INTERFACING BETWEEN TTML LEVEL UART AND R$-232"></a>INTERFACING BETWEEN TTML LEVEL UART AND R$-232</h3><p>From previous discussions, we know that microcontrollers make use of TTL level UART while the PC serial port uses RS-232. Since both standards uses similar software protocol, both of them are able to communicate via UART. However, <strong>because of the differences in voltage level and polarity, w e will need a level shifter to interface the TL level UART with the RS-232</strong>. Nowadays, this can be easily done with the commonly available IC such as the MAX232 from Maxim</p><h2 id="Advantage-Disadvantage"><a href="#Advantage-Disadvantage" class="headerlink" title="Advantage &amp; Disadvantage"></a>Advantage &amp; Disadvantage</h2><p>Adv</p><ul><li><p>Only uses two wires</p></li><li><p>No clock signal is necessary</p></li><li><p>Has a parity bit to allow for error checking</p></li></ul><ul><li>﻿﻿The structure of the data packet can be changed as long as both sides are set up for it</li><li>﻿﻿Well documented and widely used method</li></ul><p>Disadv</p><ul><li><p>The size of the data frame is limited to a maximum of 9 bits</p></li><li><p>Doesn’t support multiple slave or multiple master systems</p></li><li><p>The baud rates of each UART must be within 10% of each other</p></li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>USART stands for Universal Synchronous Asynchronous Receiver Transmitter, it <strong>converts parallel data into serial data</strong> like UART.</p><p>UART peripheral <strong>supports only asynchronous mode</strong>, whereas USART supports both synchronous and asynchronous modes.</p><p>All modern microcontrollers come with a <strong>USART module instead of just a UART module.</strong></p><p>You can use the USART module both in the synchronous mode as well as asynchronous mode.</p><p>In synchronous transmission, the clock is sent separately from the data stream, and no start&#x2F;stop bits are used. This improves data transmission efficiency by avoiding the extra bits like start&#x2F;stop, which are not useful data.</p><p><a href="https://zhuanlan.zhihu.com/p/462722309">https://zhuanlan.zhihu.com/p/462722309</a></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32</title>
    <link href="/Blogs/2025/08/28/STM32/"/>
    <url>/Blogs/2025/08/28/STM32/</url>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>STM32系列专为要求高性能、低成本、低功耗的嵌入式应用设计的<strong>ARM Cortex®-M0，M0+，M3, M4和M7内核</strong>，按内核架构分为不同产品：<strong>主流产品</strong>（STM32F0、STM32F1、STM32F3）、<strong>超低功耗产品</strong>（STM32L0、STM32L1、STM32L4、STM32L4+）、<strong>高性能产品</strong>（STM32F2、STM32F4、STM32F7、STM32H7）。<br><strong>命名规则：</strong> STM32型号的说明：以STM32F103RBT6这个型号的芯片为例，该型号的组成为7个部分，其命名规则如下：</p><p><img src="https://pic2.zhimg.com/80/v2-20715c073751f1fe5c29fc9743de0749_1440w.jpg" alt="img"></p><h2 id="单片机的最小系统"><a href="#单片机的最小系统" class="headerlink" title="单片机的最小系统"></a>单片机的最小系统</h2><p>单片机、电源电路、时钟电路以及复位电路</p><h3 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h3><p>一种集成电路芯片它采用超大规模技术将具有数据处理能力的微处理器（CPU）、存储器（含程序存储器ROM和数据存储器RAM）、输入、输出接口电路（I&#x2F;O接口）集成在同一块芯片上，构成一个即小巧又很完善的计算机硬件系统，在单片机程序的控制下能准确、迅速、高效地完成程序设计者事先规定的任务。所以说，一片单片机芯片就具有了组成计算机的全部功能。</p><h3 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h3><p>由电容串联电阻构成，由图并结合“电容电压不能突变”的性质，可以知道，当系统一上电，RST脚将会出现高电平，并且，这个高电平持续的时间由电路的RC值来决定。典型的51单片机当RST脚的高电平持续两个机器周期以上就将复位，所以，适当组合RC的取值就可以保证可靠的复位。</p><h3 id="时钟电路"><a href="#时钟电路" class="headerlink" title="时钟电路"></a>时钟电路</h3><p>单片机外部接上振荡器（也可以是内部振荡器）提供高频脉冲经过分频处理后，成为单片机内部时钟信号，作为片内各部件协调工作的控制信号。作用是来配合外部晶体实现振荡的电路，这样可以为单片机提供运行时钟。以MCS一5l单片机为例随明：MCS一51单片机为12个时钟周期执行一条指令。也就是说单片机运行一条指令，必须要用12个时钟周期。没有这个时钟，单片机就跑不起来了，也没有办法定时和进行和时间有关的操作。 时钟电路是微型计算机的心脏，它控制着计算机的二个节奏。CPU就是通过复杂的时序电路完成不同的指令功能的。</p><h3 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h3><p>用于给单片机供电，一个稳定的电源是单片机正常工作的前提，因此，单片机附近经常会有电容用于滤波</p><p><img src="https://pic1.zhimg.com/80/v2-d7eb5e8f9f68a499b4f19947488cf664_1440w.jpg" alt="img"></p><p>学习路线</p><p><img src="https://img-blog.csdnimg.cn/20200716000115135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xhbGFsYTEybGw=,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半导体物理</title>
    <link href="/Blogs/2025/08/28/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E5%8D%8A%E5%AF%BC%E4%BD%93%E7%89%A9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>[[01基础（量子与固体物理）]]</p><p>[[02载流子统计与运输]]</p><p>[[03非平衡态动力学]]</p><p>[[04器件物理核心]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>半导体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>制造工艺</title>
    <link href="/Blogs/2025/08/28/%E5%88%B6%E9%80%A0%E5%B7%A5%E8%89%BA/"/>
    <url>/Blogs/2025/08/28/%E5%88%B6%E9%80%A0%E5%B7%A5%E8%89%BA/</url>
    
    <content type="html"><![CDATA[<p>[[微纳工艺]] ：</p><p>[[封装]] ：</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>制造工艺</category>
      
    </categories>
    
    
    <tags>
      
      <tag>制造工艺</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量空间</title>
    <link href="/Blogs/2025/08/28/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/"/>
    <url>/Blogs/2025/08/28/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<ol><li><p>​<strong>​核心概念​</strong>​</p><ul><li>​<strong>​子空间​</strong>​：对加法和数乘封闭（含零向量）</li><li>​<strong>​基与维数​</strong>​：最大线性无关组，维数&#x3D;基向量数</li><li>​<strong>​秩​</strong>​：rank A&#x3D; 主元列数 &#x3D; 列空间维数</li></ul></li><li><p>​<strong>​四大子空间​</strong>​ 🌟</p><table><thead><tr><th>空间</th><th>定义域</th><th>维数公式</th><th>关联</th></tr></thead><tbody><tr><td>列空间 C(A)</td><td>Rm</td><td>rank A</td><td>Ax&#x3D;b 的解存在条件</td></tr><tr><td>零空间 N(A)</td><td>Rn</td><td>n−rank A</td><td>Ax&#x3D;0 的解空间</td></tr><tr><td>行空间 C(AT)</td><td>Rn</td><td>rank A</td><td>与列空间维数相同</td></tr><tr><td>左零空间 N(AT)</td><td>Rm</td><td>m−rank A</td><td>ATy&#x3D;0 的解空间</td></tr></tbody></table></li><li><p>​<strong>​正交性​</strong>​</p><ul><li>​<strong>​正交基​</strong>​：向量两两正交 → 标准正交基（单位化）</li><li>​<strong>​Gram-Schmidt 正交化​</strong>​：逐步构造正交基（如 u2​&#x3D;v2​−u1​⋅u1​v2​⋅u1​​u1​）</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>向量空间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>唐浩天的外置大脑</title>
    <link href="/Blogs/2025/08/28/%E5%94%90%E6%B5%A9%E5%A4%A9%E7%9A%84%E5%A4%96%E7%BD%AE%E5%A4%A7%E8%84%91/"/>
    <url>/Blogs/2025/08/28/%E5%94%90%E6%B5%A9%E5%A4%A9%E7%9A%84%E5%A4%96%E7%BD%AE%E5%A4%A7%E8%84%91/</url>
    
    <content type="html"><![CDATA[<p>学了很多东西但没有进行归纳是不完整的</p><p>[[数学]]</p><p>[[我是编程高手]]</p><p>[[微电子专业知识体系]]</p><p>[[类脑芯片]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>唐浩天的外置大脑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>器件物理核心</title>
    <link href="/Blogs/2025/08/28/%E5%99%A8%E4%BB%B6%E7%89%A9%E7%90%86%E6%A0%B8%E5%BF%83/"/>
    <url>/Blogs/2025/08/28/%E5%99%A8%E4%BB%B6%E7%89%A9%E7%90%86%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>[[PN结]]</p><h4 id="​​2-金属-半导体接触​​"><a href="#​​2-金属-半导体接触​​" class="headerlink" title="​​2. 金属-半导体接触​​"></a>​<strong>​2. 金属-半导体接触​</strong>​</h4><ul><li>​<strong>​肖特基势垒​</strong>​：<ul><li>理想势垒高度 ΦB0​&#x3D;Φm​−χs​</li><li>电流机制：热电子发射 J∝e−eΦB​&#x2F;kT</li></ul></li><li>​<strong>​欧姆接触​</strong>​：高掺杂 → 隧穿效应主导</li></ul><h4 id="​​3-MOSFET基础​"><a href="#​​3-MOSFET基础​" class="headerlink" title="​​3. MOSFET基础​"></a>​<strong>​3. MOSFET基础​</strong></h4><p>[[MOSFET]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
      <category>电子器件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>器件物理核心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固态硬盘的历史结构与原理</title>
    <link href="/Blogs/2025/08/28/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8E%86%E5%8F%B2%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8E%86%E5%8F%B2%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数字存储完全指南-03-：固态硬盘的历史、结构与原理"><a href="#数字存储完全指南-03-：固态硬盘的历史、结构与原理" class="headerlink" title="数字存储完全指南 03 ：固态硬盘的历史、结构与原理"></a>数字存储完全指南 03 ：固态硬盘的历史、结构与原理</h1><p> <a href="https://sspai.com/post/68712">在上一章，我给大家介绍了机械硬盘的原理和参数，</a> 机械硬盘作为一种量大实惠的储存设备，已经为我们尽心尽力服务了几十年，为人类的发展做出了巨大贡献。在这几十年里，科学家们也没有停止对储存技术的探索，像是电影从胶片转向数字一般，偏向机械原理的机械硬盘已经不能满足越来越高的储存需求，新的储存技术不断出现。</p><p><img src="https://cdn.sspai.com/2021/09/25/1a0823b89d481395084b14e5815f0c04.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>转过头来看，其它技术有点像魔法</p><p>固态硬盘，或者说闪存技术就是在各种技术中脱颖而出的那个胜者，它不是效率最高的那个，但却是性价比比较高同时适用场景相对广泛的一个技术。</p><p><img src="https://cdn.sspai.com/2021/09/25/b4748a9cce0a6beb6643e3152c305bf4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>工厂里面的闪存颗粒，来源：Made-in-China.com</p><p>那这一章我们就来聊聊现在广泛使用的最新技术，也是购买储存设备的第一选择 —— 固态硬盘（SSD）。</p><p>说到固态硬盘，大家对于它的第一印象应该都差不多，那就是快和贵。固态硬盘贵自有贵的道理，它<strong>技术原理上保证了速度与容量上限会不断刷新</strong>，同时摆脱了机械结构，不会像机械硬盘那样晃一下数据爆炸，还能做进小型化和各种奇奇怪怪形态的设备上。</p><p><img src="https://cdn.sspai.com/2021/09/25/03a43dd49147045c2f48862d2b47eba2.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>小小的内存卡和固态硬盘都是使用 NAND 闪存颗粒储存数据的</p><p>虽然比起机械硬盘，现在固态硬盘仍然比较贵。但随着固态硬盘价格不断走低，以后它始终会成为我们的主力储存设备，机械硬盘只能退而其次成为担任仓库盘的角色，甚至不会再出现在我们电脑里（现在很多人的笔记本已经是这样子了），就像现在磁带的现状（20 后或者 30 后的孩子们以后可能会奇怪地问我们，为什么以前的人们要把数据放在一个旋转的盘上）。</p><p>到了今年，也许我们闭着眼睛买固态硬盘，也不会有太差的体验，但固态硬盘作为一个新型储存设备，大多相关技术和参数对大众来讲比较高深和新颖，坑还是蛮多的。我们更要仔细了解一下固态硬盘的原理，工作方式，还有如何查看它的实际性能，帮助我们理解接下来实际去购买和使用的部分。</p><h2 id="固态硬盘的历史"><a href="#固态硬盘的历史" class="headerlink" title="固态硬盘的历史"></a><strong>固态硬盘的历史</strong></h2><blockquote><p>通常人们以储存读取部分有没有活动的机械部件，来区分固态硬盘和机械硬盘，下面出现的设备都满足这个条件。</p></blockquote><p>如果我们自己买过 M.2 固态硬盘或者拆过固态硬盘外壳的话，就会发现里面有很多一个一个的颗粒，这些储存颗粒就是固态硬盘储存数据的地方。说起来有点神奇，而这些储存颗粒诞生的基础 —— 浮栅晶体管（MOSFET）和非易失性储存器（NVM，像是 EEPROM 这类的都是非易失性储存器）甚至比机械硬盘出现的更早，只不过机械硬盘的结构和原理注定了它开始阶段能发展得更快。</p><p><img src="https://cdn.sspai.com/2021/09/25/4dce448f70ce3d268b31d2f83730f458.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NVMe 上的储存颗粒</p><p>最早使用非易失性储存器储存数据的装置可以追溯到 1950 年，还记得机械硬盘历史上最著名的厂商 IBM 吗，这次首先应用这项技术的还是它（真的牛啤，<strong>我查了下 1950-1999 年 IBM 储存相关的专利，占了全球的 10% 以上</strong>）。那个时候甚至有两种技术同步发展：<strong>磁芯储存器和卡式只读储存器</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/78e5bdc33420800e3085abe937c75e16.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>这两种设备看起来完全不一样，图片来源：Dataram &amp; computerhistory.org</p><p>磁芯储存器的原理简单粗暴，把磁性材料制作成的小圈通过电线串起来排成阵列，每个小圈都可以磁化或者去磁，代表了 0 和 1，计算机就可以通过读取导线电压或者给导线输送电压，改变某个特定小圈的磁性来实现储存读取数据。</p><p><img src="https://cdn.sspai.com/2021/09/25/9ca1c696d1416c8dc1d2d679721ade7b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁芯储存器放大的图片，图片来源：Dataram &amp; computerhistory.org</p><p>更绝的是<strong>它的组装真就是手工</strong>，由女性工人使用显微镜手动穿线（有我们这边穿珠子兼职那味了）。之前 NASA 登月 50 年的时候，国内疯狂报道阿波罗卫星软件编程真的是「编织」出来的，指的就是磁芯储存器（阿波罗上面的约 32KB）。</p><p><img src="https://cdn.sspai.com/2021/09/25/a74e95ea63e19b4272a8cb542ad7bf37.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>阿波罗卫星上的磁芯储存器，来源：NASA</p><p>至于，另外一个卡式只读储存器（CCROS，好像没有正式中文名）原理就更简单了，可以想象成是一堆打孔铁片叠在一起。</p><p><img src="https://cdn.sspai.com/2021/09/25/052149f9fa66be5939495028e9a8af49.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>卡式只读储存器的储存卡片</p><p>用专门的机器把编好的程序等等按照特殊的编码方式在铁片上打孔，然后交给计算机就能读取，这里就可以看出来数据是没有办法修改的，想要改数据只能重新找个新的铁片去打孔。这两个技术原理和制造实在是不太适合发展，所以在我们第一章提到的磁鼓储存器出来之后就迅速被淘汰了。</p><p>他俩的淘汰其实跟<strong>真空管时代</strong>结束是一起的，之前计算机是用真空管 —— 把电路封装在玻璃管里形成二极管&#x2F;三极管等等，然后用它们来实现计算机最基础的与（A 和 B）或（A 或 B）非（非 A 非 B）门，<strong>第一台电子计算机就是这样出现的</strong>。和真空管时代结束后就来到了我们现在很熟悉的<strong>半导体时代</strong>，半导体时代的计算设备干的还是真空管时代计算设备的那些判断，不过<strong>真空管变成了半导体制作的浮栅晶体管</strong>，由于半导体晶体管可以通过「生长」快速巨量制造出来，而且理论上可以做到非常小，比如<strong>现在我们所说的 5nm 纳米 CPU 工艺，就是可以把一个晶体管里的沟道长度做到 5 纳米大小</strong>，所以才会有我们现在的算力大爆炸（详细的原理我们下面原理部分会介绍）。</p><p><img src="https://cdn.sspai.com/2021/09/25/ed0d22e19ec2a4e419178f5cf19e58bc.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>计算机门的前辈真空管计算机里面的真空管，和现代 CPU 显微镜下的晶体管对比</p><p><img src="https://cdn.sspai.com/2021/09/25/f6cdbbdd4e29b9030db06adb3c644960.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>计算机门的前辈真空管计算机里面的真空管，和现代 CPU 显微镜下的晶体管对比，图片来源：IBM</p><p>现在还用真空管的，基本上就只剩下 HiFi 发烧友们玩的功放了（在广东真空管又叫做胆，胆机就是这样来的），而半导体和 1959 年在贝尔实验室发明的晶体管几乎是现在所有数码设备的基础，储存设备也不例外，接下来出现的技术和设备都是使用半导体的了。</p><h3 id="固态硬盘的前身：Bulk-Core"><a href="#固态硬盘的前身：Bulk-Core" class="headerlink" title="固态硬盘的前身：Bulk Core"></a><strong>固态硬盘的前身：Bulk Core</strong></h3><p>时间来到了 1976 年，一家名为 Dataram 的名字很直白的公司推出了 Bulk Core 这个很多人认为是第一个固态硬盘的设备，一个 41 厘米长床头柜那么大的箱子，号称比机械硬盘快 1 万倍，由 8 个 256KB 的单元组成 2MB 的容量，最重要的是这些单元使用了半导体来制作内存模块。</p><p><img src="https://cdn.sspai.com/2021/09/25/6a3f648415dd10ce29c9510c220860e1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>年代太久远，资料和图片都没几张，图片来源：dataram.com</p><p>其实在它出现之前也有电可变储存器和其他几种半导体储存技术出现，基本都是各家自己研制然后用到自己的超级计算机上。但这些都不属于可以量产的级别，而且价格贵到离谱。</p><p>即使放到 76 年后固态硬盘的价格也不是一般公司能够承受得起的，Bulk Core 价格查不到，但是同时期推出的给 IBM 大型机使用的 STC4305（它用来储存的技术和我们现在相机的成像原理很像），<strong>45MB 售价 40 万美元，相当于现在的 167 万美元</strong>（dollar times，2021），在那个年代买家公司给自己打工几十年都够了，大家自己仔细品品。</p><p><img src="https://cdn.sspai.com/2021/09/25/361db38e8c689c2f1f2d764cd618ed04.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>STC4305 外观，买固态送柜子</p><p>在 ROM 出来之前大部分固态都是使用 RAM（也就是我们今天运行内存那种）保存数据的，<strong>需要电池来维持数据，断电之后数据便会丢失</strong>。</p><h3 id="固态储存设备的基石：浮栅晶体管-（只读）储存器-ROM"><a href="#固态储存设备的基石：浮栅晶体管-（只读）储存器-ROM" class="headerlink" title="固态储存设备的基石：浮栅晶体管&#x2F;（只读）储存器 ROM"></a><strong>固态储存设备的基石：浮栅晶体管&#x2F;（只读）储存器 ROM</strong></h3><p><strong>半导体和晶体管可以说是现在整个电子世界的基石</strong>，而<strong>浮栅晶体管其实是 1967 年由亚洲人发明的</strong>，分别是韩裔美国工程师 Dawon Kahng（姜大元）与华裔美国工程师 Simon Min Sze（施敏）。</p><p><img src="https://cdn.sspai.com/2021/09/25/a85930b9ea0fb92f4de94aea8fc9ca52.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>两位工程师的照片，左一为 Dawon Kahng，右一为 Simon Min Sze</p><p>关于浮栅晶体管的原理和结构我们会在下面介绍，<strong>浮栅晶体管也是半导体晶体管的一种</strong>，它之所以和现在 CPU 使用的晶体管区别开来，并且适用于储存设备，是因为它被高电阻材料包围的结构特性，<strong>可以让其中包含的电荷在很长一段时间内保持不变</strong>，<strong>注意这个很长一段时间指的是以 10 年以上</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/28bd549c966d6c6b7ca0f68b58b71c76.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>浮栅晶体管的结构，图片来源：US Patent US7115939B2</p><p>姜大元和诗敏不仅发明了浮栅晶体管，而且提出了实际的应用场景 —— 利用浮栅组成的储存单元制作出只读储存器（EPROM）。</p><p><img src="https://cdn.sspai.com/2021/09/25/28fe0271e4e98b1d7e3ce38563e39d2a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>常见的 EPROM 封装形态</p><p>我们现在常见的 <strong>ROM</strong> 其实就是只读储存器（Read-Only-Memory）的缩写，<strong>EP</strong> 指的是可擦除（Erasable）可编程（Programmable）。也就是说它可以通过高电压的设备把数据放进浮栅晶体管储存单元里，之后就没办法修改了，所以说是只读。而可擦除则是利用强紫外线来直接把浮栅晶体管里面的电荷都放跑，这样就达到了擦除的效果，之所以只能用紫外线，是因为浮栅晶体管本身被高电阻材料包围，很难用电去「吸」出里面的电荷。</p><p>后来人们在这个基础上发明了 <strong>EEPROM</strong>，也就是我们接下来介绍的<strong>闪存 Flash 的前身</strong>。它多出来的这个代表电（Electric），指的是这个 <strong>ROM 可以被高电压擦除（电子隧穿效应，下面会详细介绍），然后重新写入数据</strong>，这个基本就是 1980 年代后的事情了。</p><p>说个我们小时候，现在年轻人可能碰不到的例子：<strong>游戏机的卡带</strong>，比如我小时候玩的任天堂 GBA 的卡带，拆开就会发现里面有一块黑黑的一坨东西，或者一大块黑黑的芯片，那个就是装着游戏本体的 EPROM，而另外小的一块用来写入存档的就是 EEPROM（有时候也会合并到那一大坨黑黑东西里面）。</p><p><img src="https://cdn.sspai.com/2021/09/25/3e121d4b117237cf9e434279a4a5426f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>赛尔达的卡带，电路板上其实已经标出了 EEPROM</p><p>以前我们老是觉得玩游戏存档速度要存到天荒地老，就是因为 以前 EEPROM 技术限制只能单字节擦除和写入，这个速度写个存档可以想象速度想快也快不起来。</p><p>同时因为 EEPROM 和 EPROM 其实都是同一种浮栅晶体管，受到强紫外线照射会把储存器清空，而阳光里面最不缺的就是紫外线，所以以前我们老是发现卡带放久了就会「掉档」（有过掉档重玩的痛苦记忆的同学可以留个评论哈哈），就是因为放存档的 EEPROM 里面电荷都被阳光（通常几个星期）或者室内的荧光灯（可能要几年）晒跑了。</p><p><img src="https://cdn.sspai.com/2021/09/25/74b85fdebddf7ccdbcf8266d7665fda0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>看到空空如也的存档，整个人都哇塞了</p><p>这两项储存器先天结构就优于当时的机械硬盘，单从速度方面也比当时的机械硬盘快几十倍，所以当时一些固态储存公司开始发展起来，比如我们现在常见的闪迪就是这个时候进入市场的。英特尔也开始研发闪存，同时用固态给处理器加速（现在傲腾加速条系列也保留着那个时候的基因），很多人还开始给自己的个人电脑配上了固态（不是用来储存，太贵了，只用来加快电脑运行）。</p><p>这个时候的固态硬盘其实已经有进入民用的条件，1980 年 256KB 的固态储存才 1000 美元左右（折合现在 3000 美元），按照当时的电脑价格来讲并没有到离谱的程度。</p><h3 id="用到现在的成熟技术：闪存-Flash"><a href="#用到现在的成熟技术：闪存-Flash" class="headerlink" title="用到现在的成熟技术：闪存 Flash"></a><strong>用到现在的成熟技术：闪存 Flash</strong></h3><p>1980 年，在东芝工作的日本科学家 Fujio Masuoka（舛冈富士雄）在 EEPROM 基础上发明了闪存。这位科学家也是个牛人，EEPROM 的前身 SAMOS 储存器也是他发明的，闪存应用之后，他的团队还发明了第一个 3D 晶体管（GAAFET），优势是可以在 7 纳米以下的尺寸工作，直到现在 3 纳米 GAAFET 还是世界上最小的纳米电子器件，2021 年都还没有实现量产，这位牛人可谓是包圆了固态储存领域。</p><p><img src="https://cdn.sspai.com/2021/09/25/d809e6121706ed40b6374487ac7e4982.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>舛冈富士雄本人</p><p>实际上 NOR 和 NAND 闪存都是舛冈富士雄先后（1980,1986）发明出来的，但他的发明在东芝却不被重视，还要自己拿着样品去参加 IEEE 大会，引起了轰动后被英特尔注意到才大力研发，甚至发明 NAND 闪存后只有几百美元奖金和一个闲职，这也导致了后来富士雄 2006 年起诉东芝，获得百万美元赔偿的结果。</p><p>作为发明公司，东芝是第一个开始卖闪存固态的，1987 年推出了他们的第一款商用 NAND 闪存，1988 年英特尔推出了第一款商用的 NOR 闪存，但东芝不受重视的态度让它基本没有市场，英特尔则靠着相关技术霸占市场，获得了几十亿美元的利润。</p><p><img src="https://cdn.sspai.com/2021/09/25/325ad4f65f2e2acdcb9790cba49196ae.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>舛冈富士雄起诉东芝的相关新闻</p><p>闪存分为两个类型，平时我们或许听过 NAND 和 NOR 闪存就是指这两个类型，从名字就可以看出它们是用原理对应的逻辑门来命名的，具体原理下面会讲。简单来讲就是之前那些 ROM 必须完全擦除才能重写，速度又慢又浪费寿命，而闪存可以做到按块&#x2F;页进行擦除，写入和读取，<strong>而且可以做到很快速的擦除，闪存的名字是按照发明者同事的建议命名的，擦除过程就是像闪光灯一样迅速，所以叫做闪存</strong>。闪存就是为了「更快」而诞生的。</p><p>从结构上看，这两款闪存的区别是：</p><p><strong>NAND 闪存</strong>单元体积比较小，所以密度更高，同样成本可以做到更大容量，同时按块方式让擦写读取速度都很快，擦写寿命也比较长；缺点是必须按照块来擦写，也没有真正的随机访问能力，也可靠性相对较低。</p><p><img src="https://cdn.sspai.com/2021/09/25/7543ffa308404dc4528e4d1d55615f95.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NAND 闪存颗粒，图片来源：三星 Samsung</p><p><strong>NOR 闪存</strong>单元体积比较大，容量就很小，擦写速度非常慢，但读取速度很快。可以按字节为单位提供真正的随机访问能力，这意味着它可以就地执行代码（不用把代码搬到运行内存），可靠性也比较高，也因为如此擦写寿命比较短。</p><p><img src="https://cdn.sspai.com/2021/09/25/5078d3e23dd710ca4383d2b41d0e5b02.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NOR 闪存颗粒，图片来源：镁光 Micron</p><p>从这两个闪存类型可以看出，<strong>NAND 容量大读写都快的特点适合做大容量储存</strong>，事实上我们现在的固态硬盘基本都是 3D NAND 闪存；<strong>而 NOR 可以就地执行代码和真正随机访问的能力，加上很快的读取速度就非常适合用来装程序文件</strong>，比如主板上的 BIOS 通常就是 NOR 闪存。这两个类型和它们的详细区别在下面都会详细介绍。</p><p>从这里开始就是我们熟悉的固态储存世界了，<strong>闪存单元能做到在微观尺寸正常工作，意味着只要工艺一直提升，（物理极限下）同体积容量就能够做到越来越大</strong>。1991 年闪迪为 IBM 研发了世界上第一个 2.5 寸闪存固态硬盘，20MB 容量只要 1000 美元；之后 10 年固态硬盘容量迅速突破 GB 级，1996 年 ATTO SiliconDisk II 就达到了 1.6GB，2000 年 E-Disk ATE35 3.5 寸固态硬盘就有 19GB 可选，2003 年就有 TB 级别的系统，接下来就是我们熟知的大公司入场，各种合并收购，形成现在的局面了。</p><p>虽然价格是一大阻碍，但相比脆弱的机械硬盘，可靠的固态硬盘在军用，商用和民用领域都发展非常迅速，价格也从之前的天价迅速降到现在 1G 不足 1 块钱。</p><p><img src="https://cdn.sspai.com/2021/09/25/1a05b2f71d4ea348b002e71acee0ff80.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>写入 3GB&#x2F;s 的爱国者 1TB 固态才约 0.7 元&#x2F;GB</p><p>在 2009 年后固态硬盘甚至达到了当时 SATA 接口的极限，从而出现现在的 PCIE 和 NVMe 固态，容量方面也开始出现 SLC&#x2F;MLC&#x2F;TLC&#x2F;QLC 等堆叠技术让容量不断提升（先不说缺点，至少容量上去了），现在的固态硬盘已经往 100TB 上面走，相信很快我们就能用得起，到时候机械硬盘的用处就更少了。</p><p><img src="https://cdn.sspai.com/2021/09/25/236eb458ee168acb3c11d96f1bdb5e57.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者的 AIC 企业级 NVMe 固态，为了拍照移动了贴纸位置</p><p><strong><strong>相关文献</strong></strong>：</p><p>[1]. Dataram 官方对 Bulk Core 的<a href="http://www.dataram.com/blog/">介绍</a>。</p><p>[2]. 想知道 NASA 在卫星的磁芯储存器上装了什么，可以看看开源的阿波罗 11 号制导计算机<a href="https://github.com/chrislgarry/Apollo-11/blob/master/README.zh_cn.md">指令模块，登月模块的源代码</a>和完整的<a href="https://github.com/virtualagc/virtualagc">制导计算机源码</a>（可以用来弄个模拟器什么的）。</p><p>[3]. 浮栅晶体管与浮栅储存单元详情可以查看姜大元和施敏发表的<a href="https://onlinelibrary.wiley.com/doi/epdf/10.1002/j.1538-7305.1967.tb01738.x">原论文</a>。</p><p>[4]. 想要详细了解 NOR 闪存的结构可以查看对应的<a href="https://patents.google.com/patent/US9646991">专利</a>。</p><p>[5]. 想要详细了解 NAND 闪存的结构可以查看对应的<a href="https://patents.google.com/patent/US9716092">专利</a>。</p><p>[6]. 关于舛冈富士雄个人和东芝的故事可以看日本商业期刊的文章<a href="https://biz-journal.jp/2017/12/post_21816.html">「なぜ東芝は、利益の9割を稼ぐNANDメモリ開発者を辱めて追放したのか？」</a>，不懂日文或者想看故事的同学可以看看虎嗅的另一篇转载<a href="https://www.huxiu.com/article/247658.html">「东芝沉浮启示录」</a>。</p><h2 id="固态硬盘-SSD-的结构和原理"><a href="#固态硬盘-SSD-的结构和原理" class="headerlink" title="固态硬盘 SSD 的结构和原理"></a><strong>固态硬盘 SSD 的结构和原理</strong></h2><p>我在前面就给大家谈到，现在固态硬盘大部分都是用 3D NAND 闪存颗粒（我们常常听说的 SLC&#x2F;MLC&#x2F;TLC&#x2F;QLC 什么的就是不同工作模式下的闪存颗粒），<strong>闪存颗粒其实就是很多很多浮栅晶体管制成的储存单元</strong>，所以在这个小节我们会从浮栅晶体管的原理讲起，带你从头到尾了解固态硬盘的工作原理，不过<strong>不同于机械硬盘拥有直观的机械结构，固态硬盘的工作基本上都发生于纳米级别的微观世界，甚至是基于量子力学的工作原理</strong>，会比机械硬盘难理解一点，想要了解的同学们一定要有耐心一点。</p><p>在进一步介绍固态硬盘的结构和原理之前，我们先来了解一下固态储存器的几个分类。</p><h3 id="易失性和非易失性储存器"><a href="#易失性和非易失性储存器" class="headerlink" title="易失性和非易失性储存器"></a><strong>易失性和非易失性储存器</strong></h3><p>从名字应该就可以看到它俩的区别，虽然都是把比特信息储存在电容器和晶体管组成的储存单元里，都是用晶体管里面的电荷多少来代表 1 和 0，<strong>但是易失性储存器一旦断电储存单元上面的信息就会很快丢失，而非易失性储存器即使断电也能保存授权单元上面的数据，简单来讲就是断电丢不丢数据的区别。</strong></p><p>因为易失性储存器的晶体管不像非易失性储存器那样，有高电阻材料去留住电荷，需要高电压还有量子隧穿效应来读写数据，所以它工作需要的电压更低（通常在 1-2V 左右）并且读写速度更高。我们常见的内存条 RAM 就是一种易失性储存器，<strong>如果我们对好的内存条跑分，就会发现它的读写时间是在纳秒级别，而且读写速度几十 GB&#x2F;S 以上，比固态硬盘之类非易失性储存器的性能好上一个量级</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/5fb3f835a82fbaf48850cafa8a512c29.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>运行内存和 CPU 缓存的跑分</p><p>这也解答了很多人为什么不用内存来做固态硬盘的疑问，因为不严格来讲正是因为「易失」所以才「快」。<strong>非易失性储存器我们上面也讲到了，浮栅晶体管的特性让它即使断电也能将数据保存 10 年以上</strong>，但多出来的一层高电阻材料让非易失性储存器读写速度和随机读写能力比起易失性储存器就要差上不少，这也是为啥现代计算机需要用运行内存作为储存器和 CPU 之间的「桥梁」，因为易失性储存器拥有纳秒级别的随机读写能力，让它更能跟上 CPU 思考的速度提供数据，免得 CPU 没有数据进行计算，只能干等。</p><p>有关于随机读写能力的重要性，还有内存条等易失性储存器等详细的结构工作原理，会在接下来其它储存设备的部分讲解。</p><h3 id="固态硬盘的基础：NAND-NOR-Flash-闪存"><a href="#固态硬盘的基础：NAND-NOR-Flash-闪存" class="headerlink" title="固态硬盘的基础：NAND&#x2F;NOR Flash 闪存"></a><strong>固态硬盘的基础：NAND&#x2F;NOR Flash 闪存</strong></h3><p>在机械硬盘部分，我们报废了一个机械硬盘才能看到它里面的结构，而固态硬盘就简单多了，特别是现在的 NVMe 固态硬盘，直接就能看到所有的硬件结构。</p><p><img src="https://cdn.sspai.com/2021/09/25/6f54236b39cd25649fd44bde03813682.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>别看电路板什么的，看起来很复杂，但其实主要部件就两个 —— <strong>用来放数据的储存颗粒和用来控制数据的主控芯片</strong>，有些固态可能还会有一个缓存 DRAM 颗粒。</p><p><img src="https://cdn.sspai.com/2021/09/25/131efbcdbd2cd6fa9bbd76cc6d4df1d0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>固态硬盘储存颗粒和主控特写</p><p>先来说说放数据的储存颗粒，现在固态硬盘绝大部分都是 NAND 闪存，可以说现代设备能存点什么数据，那基本上离不开它。<strong>而 NAND 闪存的基本存储单元就是浮栅晶体管，我们常见的颗粒就是大量的它叠起来的。</strong></p><h3 id="闪存最基础的结构：浮栅晶体管"><a href="#闪存最基础的结构：浮栅晶体管" class="headerlink" title="闪存最基础的结构：浮栅晶体管"></a><strong>闪存最基础的结构：浮栅晶体管</strong></h3><p>我们先来看一个最简单的平面浮栅晶体管<strong>截面结构图</strong>，浮栅晶体管还有其它几种类型，我会放在后面文章简单提及一下：</p><p><img src="https://cdn.sspai.com/2021/09/25/dfaf4701d878c41a4d28d0c07e4d95fe.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>浮栅晶体管 FGMOS 的基本结构</p><p>为了方便大家理解，这里同时放上每个组成部分使用的材料，可以看到浮栅晶体管有一个硅底座（我们叫它 <strong>P-</strong> ），左右分别用铜制作的端点来向另一种硅材料制成的 <strong>N 级</strong>施加电压和检测电压，以读取中间储存结构的电荷量，所以我们叫它们 <strong>N+ 源</strong>（左边，加检测电压时电子从这边流入）和 <strong>N+ 漏</strong>（右边如果导通，电子从这边漏走到检测电路），由于它俩是对称的，所以源和漏极可以互换。</p><p>中间则是利用特殊工艺制作的储存结构，在硅底座上面「生长」出一块完全绝缘的二氧化硅，然后通过另一种特殊工艺在中间生成可以储存电荷的材料，比如多晶硅或者其它金属。然后在整个结构的顶上再加一层铜做的控制级（用来加写入电压）。</p><p><strong>顶上这层就叫做控制栅，而储存电荷的材料就叫做浮栅</strong>。之所以叫浮栅，因为它是整个被二氧化硅包裹的，像是浮在水里面一样，如果有电子跑进了浮栅，在不施加高电压的情况下，由于周围都是绝缘材料，它是跑不了的，<strong>所以电子在里面能够保存数十年</strong>。顺便一讲运行内存 RAM 这些断电就没数据的颗粒，结构也和这个类似，就是少了中间的浮栅而已，至于为什么不弄我们放到其它储存设备那部分讲。</p><p>有了稳定持续的电子储存方法，我们就可以<strong>通过往某个浮栅里面写入一定量的电子来储存 0 和 1，通过检测浮栅里面的电子数量来读取 0 或 1</strong>。<strong>通常我们设定浮栅里面电子少于一定数量或者没有电子就代表 1，浮栅里面电子多于一定数量就代表 0。</strong></p><p><img src="https://cdn.sspai.com/2021/09/25/4d9dfa69f0982f0541d649474c98dfbe.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>电子量和 bit 的关系</p><p><strong>读取浮栅晶体管的数据</strong>：浮栅中的电子量非常难以直接测量，但<strong>我们不需要测量精确的电子数量，只需要知道它有没有达到我们规定的数量就可以</strong>。</p><p>我们先假装没有浮栅这个结构，然后在最顶上那层控制栅和漏级都加上一个电压，这个时候底座里面的自由电子会被往控制栅方向吸引，但底座和控制栅之间有一层绝缘的二氧化硅，<strong>所以自由电子会累积在底座的顶部，也就是两个 N+ 中间</strong>，当电压达到一定程度，中间的自由电子累积到足够的数量，<strong>刚好</strong>会把两个 N+ 打通形成一条无形的通路，电流就能从漏极流向原极，这个打通的电压我们就叫它<strong>阈值电压</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/88666a53452571b76313cfbeafdce1ef.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>读取数据时施加的电压</p><blockquote><p>这里有个需要说明的地方，我们从漏级加的电压，当两个 N+ 打通的时候电流是从漏级流向原级，但里面的电子是从源极流向漏极（至于为什么是相反的，就要回忆一下你学过的高中物理了，简单来讲就是电流和电子移动方向是相反的），所以<strong>我们的源和漏是以电子的流向来划分的</strong>。</p></blockquote><p>这里我们再把浮栅加进去，再施加同样的阈值电压，如果浮栅里面带大量的电子（也就是表示 0 的时候），浮栅里面的电子会抵消一部分控制栅对底座上自由电子的吸引力，这样两个 N+ 就没办法打通。</p><p>阈值电压就是固态出厂前在工厂里面测出来写到主控里面，想要读取某个晶体管数据的时候就往最顶上那层控制栅和漏级都加上阈值电压，如果漏极端检测电路能够检测到电子的流动，证明浮栅上面电子数量在规定值以下的，也就是 1；反之如果检测不到电子的流动，证明浮栅上面电子数量在规定值以上，那就是 0，<strong>整一个过程就是浮栅晶体管的读操作</strong>。</p><p><strong>往浮栅晶体管写入数据</strong>：但我们想要给浮栅晶体管写入 0 的时候，也就是往浮栅里面存入电子。我们可以通过给顶上的控制栅和漏极加一个比阈值电压高很多的电压，然后<strong>让控制栅的电压大于漏极电压</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/3633574f530c124a21b22ac120e047bc.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>写入 0 时需要的电压</p><p>这个时候由于大电压两个 N+ 之间的电子流动会加快，<strong>同时控制栅有更大的电压，吸引力会大到让部分电子因为量子隧穿效应穿过绝缘的二氧化硅进入浮栅。</strong>从而完成充入电荷的操作，这部分电子相当于被二氧化硅组成的「陷阱」陷住了，过几十年都跑不掉，所以人们也把它叫做*<strong>电荷陷阱</strong>。</p><p>而当我们想要给浮栅晶体管写入 1，也就是要放掉浮栅里面存的电子，我们就反过来给两个 N+ 加一个大电压。</p><p><img src="https://cdn.sspai.com/2021/09/25/d5bea04922d848edf04f4ec7d35ccea1.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>写入 1 时需要的电压</p><p>这样子电子会因为<strong>量子隧穿效应</strong>被大电压从浮栅里面「吸」出来跑到 P- 底座里面。<strong>写 0 写 1 两个操作分别就是浮栅晶体管的编程&#x2F;擦除操作。</strong>这两个操作会对隔离底座和浮栅的二氧化硅层产生破坏性的影响，<strong>写入多次后晶体管就会与底座接触，没办法储存电子，也就是坏掉了</strong>，所以固态会有擦写寿命这样一个参数，具体的我们在下面参数部分会讲到。</p><blockquote><p>我们平时格式化固态硬盘，就是把 NAND 闪存所有浮栅晶体管都写成 1，也就是放掉了所有电子。要写入数据的时候只要把对应的 1 写成 0。</p></blockquote><h3 id="那一张照片需要多少个浮栅晶体管来储存？"><a href="#那一张照片需要多少个浮栅晶体管来储存？" class="headerlink" title="那一张照片需要多少个浮栅晶体管来储存？"></a><strong>那一张照片需要多少个浮栅晶体管来储存？</strong></h3><p>通过前面的内容很容易可以看出来，一个平面浮栅晶体管可以储存一个 bit 的数据，那么要多少个它们才能放下一张我们平时拍的照片呢？</p><p>以 4K（3840_<em>2160）照片为例，我们按下快门之后，总共有 3840</em>_2460&#x3D;829,4400 个像素，每个像素需要分别用红绿蓝三个子像素的数字表示，每个子像素（0-255）需要 8bit 数据，这样算下来我们的照片总共就有 1,9906,5600bit。</p><p><img src="https://cdn.sspai.com/2021/09/25/f3076253737f5b6d8bf23257a40d394a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>一张普通的照片和放大之后的像素</p><p>也就是说<strong>我们按下快门之后，1,9906,5600 个，也就是大约 2 亿个像上面那么复杂的浮栅晶体管就会勤勤恳恳地用电子把我们的照片数据存下来</strong>。而一张不压缩的 4K 照片 1,9906,5600bit 也不过 23.73MB，现代固态硬盘里面的固态颗粒一般都是 256G，<strong>可以装 11000+ 张 4K 照片，却只有那么小一颗，你可以想象里面有多少个晶体管</strong>。希望这个例子能让你直观地认识到，我们习以为常的科技产品背后到底蕴含着多么惊人的科学技术。</p><p><img src="https://cdn.sspai.com/2021/09/25/fe3334ba9a84e1dcfcb8089b0bba2d1f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>512G 的西数 SN550 固态颗粒与硬币的对比</p><p>我们现在的固态容量越来越大，就是因为我们可以把浮栅晶体管做得越来越小，但是这个小也有一定的限度，参考之前我们学到的结构就可以知道，如果两个 N+ 之间的距离小到一定程度也会发生量子隧穿效应，不需要添加电压电子就可以直接从源极跑到漏极，那么就没办法测量中间的电荷了，等到那个时候估计我们也会用上新原理的储存设备（又可以写一篇科普了，哈哈）。</p><h3 id="另一种主力储存颗粒：NOR-Flash-闪存"><a href="#另一种主力储存颗粒：NOR-Flash-闪存" class="headerlink" title="另一种主力储存颗粒：NOR Flash 闪存"></a><strong>另一种主力储存颗粒：NOR Flash 闪存</strong></h3><p>上面我们有提到这些闪存的名字，都是按照控制门来命名的，而上面原理部分也没有提到 NAND 闪存为啥叫这个名，这节我就来和 NOR 闪存一起来讲解。</p><p>NOR 闪存和 NAND 闪存用的都是同样的浮栅晶体管结构，只不过不同于 NAND 利用量子隧穿效应写入电子，NOR 闪存用的是热电子注入技术。</p><p><strong>不过它俩主要的不同，不是在于单个单元上，而是在单元的排列上。</strong></p><p>由于人们用 NAND 闪存来做大容量储存器，所以它的数据密度越来越大，浮栅晶体管和对应的电路做得越来越小，<strong>NAND 储存单元小到没办法给每个浮栅晶体管都单独接上寻找地址的地址线和传输数据的数据总线，每一纳米面积都要利用到极致，真的是寸土寸金</strong>。所以不仅 NAND 里面地址线和数据总线是共用的，而且只能以一页为单位把 10000-30000个浮栅晶体管<strong>串联</strong>起来，一页只有一条地址线和数据总线，<strong>所以 NAND 读写数据只能以页为单位，串联方式也成为它名字的由来</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/e4bd8770163d31e8ef23000169b50c13.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>一页 NAND 闪存的排列方式</p><p>而 NOR 闪存<strong>每个浮栅晶体管都是有单独的地址线和数据总线</strong>，它们之间互相<strong>并联</strong>。这样子做极大增加了每个储存单元的面积和复杂程度，所以<strong>同样面积的 NOR 闪存比起 NAND 闪存容量少很多，同时造价非常昂贵</strong>。不过这样子的好处也很明显，每一个浮栅晶体管的数据都可以以 bit 为单位单独读写，<strong>读取速度非常非常快</strong>，这意味着它有真正的随机访问能力，快到像是我们上面提到的可以就地执行代码，CPU 可以直接从储存设备取指令不用把数据放到运行内存，特别适合做主板 BIOS 或者单片机里面的 ROM，并联方式也成为它名字的由来。</p><p><img src="https://cdn.sspai.com/2021/09/25/7ed7033002cf9a4645292e3e6dd24eec.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>一页 NOR 闪存的排列方式</p><p>它俩的特性造成 NAND 闪存擦写起来很快（串联只需要发送一个电压就可以擦一整页），读起来很慢（因为一次要读一页）；而 NOR 读很快，擦写起来很慢（要一个个浮栅晶体管擦除）。</p><h3 id="现代固态的改良：3D（V-）NAND"><a href="#现代固态的改良：3D（V-）NAND" class="headerlink" title="现代固态的改良：3D（V-）NAND"></a><strong>现代固态的改良：3D（V-）NAND</strong></h3><p>上面我们了解的只是一个很简单的平面浮栅晶体管原理，而事实上现在厂家为了固态大容量已经开始让浮栅储存单元竖着叠起来，也就是现代固态基本都在用的 3D NAND（也叫 V-NAND，V 就是垂直 vertical 的意思）。</p><p><img src="https://cdn.sspai.com/2021/09/25/553db43ab7d519c3fbbab1f03de9705c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>3D NAND 的结构，图片来源：Youtube@Branch Education</p><p><img src="https://cdn.sspai.com/2021/09/25/5e7a1cbec68e6f76bf03e8daab8ee1f6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>3D NAND 和白纸厚度的对比，图片来源：Youtube@Branch Education</p><p>原理和我们上面学到的平面浮栅晶体管差不多，看结构也能理解大半。由于这部分实在太复杂，接下来我会尽量简单讲解一下，<strong>大家如果对这个比较感兴趣，同时英文比较好的话，我全力推荐 YouTube 上凯侠（Kioxia，也就是之前的东芝储存，被东芝卖掉后改名）赞助 Branch Education 制作的一系列 SSD 原理科普视频</strong>，有 3D 动画比较直观，系列视频我会放到相关文献里面，这个系列也是本节主要图片和动图的来源，仅作教学用途之用，请勿随意保存转载。</p><p>总体而言 3D NAND 的目标是<strong>把每一个浮栅晶体管做得尽量小同时每一个浮栅晶体管能储存更多的数据</strong>。现在的 QLC 已经能够做到每个存储单元放 4bit 的数据（实际上 QLC &#x3D; Quad Level Cells，就是 4 层储存单元的意思），以后会越来越多，这样子做的弊端我们放到以后再谈，先来说说现代闪存颗粒的结构和原理。</p><h3 id="现代闪存颗粒的立体储存单元"><a href="#现代闪存颗粒的立体储存单元" class="headerlink" title="现代闪存颗粒的立体储存单元"></a><strong>现代闪存颗粒的立体储存单元</strong></h3><p>我们先来看一下每个储存单元的结构：</p><p><img src="https://cdn.sspai.com/2021/09/25/4db7f89939643405f206238c0807aada.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>排列图和单个储存单元，图片来源：Youtube@Branch Education</p><p><strong>基本上就是我们前面学到的浮栅晶体管的原理，只不过把它竖起来并且串联起来</strong>，这也是为啥它也叫垂直 V-NAND。</p><p>只不过 3D NAND 工作流程稍不相同，左边的通道就相当于上面说的 P 和 N，当给控制栅打阈值电压时，如果中间的浮栅没有电子，产生的电场强度足以让左边通道的电子流动，这样在数据总线上就能检测出来，如果中间的浮栅有大量电子，那么产生的电场强度不足以让通道里的电子流动。</p><p><img src="https://cdn.sspai.com/2021/09/25/37b402cb860892001c074f914881de42.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>读取 0 和 1，图片来源：Youtube@Branch Education</p><h3 id="单个单元存储多-bit-的数据"><a href="#单个单元存储多-bit-的数据" class="headerlink" title="单个单元存储多 bit 的数据"></a><strong>单个单元存储多 bit 的数据</strong></h3><p>我们现在了解了单个储存单元的结构，那么像是 TLC 这类的技术是如何让单个存储单元储存多个 bit 的数据呢？</p><p>以 TLC 为例，一个储存单元可以装 3bit 的数据，也就是 000、001、010、011、100、101、110、111 七种状态。</p><p><strong>我们先来说一说比较简单的读取过程</strong>。</p><p><strong>由于储存单元没有电子代表 1，我们把它倒回来，然后从低到高设置 7 个阈值电压。</strong></p><p><img src="https://cdn.sspai.com/2021/09/25/d9db119a93516955587c1f639dd4e122.gif"></p><p>TLC 颗粒读取存 3bit 的七个电压，图片来源：Youtube@Branch Education</p><p>由于 NAND 同一页的储存单元都是串联的，接下来我们：</p><ul><li>给同一页的所有储存单元给最低的阈值电压，然后从左到右一个个储存单元检测通道是否有流动。</li><li>如果某个储存单元检测到通道接通，那么这个储存单元就只有最低的电荷，也就是 111。</li><li>检查完所有储存单元状态后再给它们第 2 个高点的阈值电压，然后再从左到右一个个检测。</li><li>如果某个组成单元检测到通道接通，那么这个单元储存的电荷量就在第二个区间，也就是 110。</li></ul><p>……</p><p><img src="https://cdn.sspai.com/2021/09/25/0590e42431cf1a0706362e1b463b8b65.gif"></p><p>TLC 读取过程，图片来源：Youtube@Branch Education</p><p><strong>接下来重复这个步骤 7 次，就可以把每个单元的值都读出来了</strong>，虽然闪存颗粒里面的所有页都是可以同时读取的，但仍然比只需要检测一次 0 和 1 的 SLC 储存单元慢了不少。</p><p><strong>接下来是比较保密的写入过程</strong>。</p><p>现代固态颗粒的浮栅晶体管做的实在太小，要保证数据能够很好的保存数 10 年，<strong>我们需要保证包围着浮栅的绝缘层不能太薄，电子能够很好的隔离在浮栅里不会跑掉；也不能太厚，导致很难控制写入的电子数量</strong>。通过实验最终绝缘层保持在 75-100 个原子宽的最佳厚度。</p><p>实际的写入过程其实和我们上面学到的差不多，就是通过给控制栅电压，把左侧通道里面的特定数量电子通过量子遂穿效应「吸」到浮栅里面。</p><p><img src="https://cdn.sspai.com/2021/09/25/6002202df7709593167db87b7b2ff2c5.gif"></p><p>TLC 写入过程，图片来源：Youtube@Branch Education</p><p>不过以 TLC 为例，由于需要写入 7 种状态的电子量，需要精确调整控制栅的的电压和其他一些参数，<strong>这些电压和参数所有厂商都处于高级保密的状态，属于顶级的商业机密</strong>，基本上算是制作固态颗粒的看家本领了，*<em>如果有哪位同学知道的话可以任何联系方式私信我</em>***。</p><p>观察单个储存单元，我们会发现整个组成单元被厂商们做成圆柱形，<strong>里面的结构从中间的通道到外边的绝缘层像是树干一样一层包一层</strong>。这是因为圆柱形可以让浮栅有整整一圈的面积，就能放下更多的电子数量，从而能够把多个 bit 状态对应的电子数量区间弄大，让检测更不容易出错。</p><p>现在 PLC 都已经出来了，大小不变的每一个储存单元能放下足足 5bit 的数据。<strong>那么大家是不是可以无限细分储存状态呢</strong>？也不是的，举个例子，假设每个储存单元最多能储存 10000 个电子，那么 TLC 7 种状态，每个状态电子数量差能有 1000 多个，没有那么容易弄混；到了 PLC 32 种状态，每个状态电子数量差就只有 300 个了，写入的时候电子一不小心多了或少了就会变成另一种状态，读取的时候也容易读成另一种状态，这对制作工艺读写算法的要求越来越严苛，所以理论上除非我们能够精确控制每一个电子的流动，不然现在的工艺很快就会走到尽头。</p><p><strong>至于细分下去会有什么坏处，为什么大家都在喷厂家 TLC，QLC 是偷工减料</strong>，这些我们放到下一章再仔细讲。</p><h3 id="从微观到宏观：储存单元最后如何组成闪存颗粒"><a href="#从微观到宏观：储存单元最后如何组成闪存颗粒" class="headerlink" title="从微观到宏观：储存单元最后如何组成闪存颗粒"></a><strong>从微观到宏观：储存单元最后如何组成闪存颗粒</strong></h3><p>基本单位储存单元，我们已经了解得非常透彻了，这小节我们就来把它们组装起来。</p><ul><li>首先 NAND 里面几万个储存单元（Cell）会组成一<strong>页（Page）</strong>（通常有 4&#x2F;8&#x2F;16&#x2F;32KB），这一页共享地址线和数据总线，所有的读写都必须按页为单位：</li></ul><p><img src="https://cdn.sspai.com/2021/09/25/b386afb13e60569c830208714b035965.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闪存颗粒的一页，图片来源：Youtube@Branch Education</p><p>另外我们看相关新闻的时候，常常会看见某某厂商又研发出了多少多少层的 3D NAND，这个层数指的就是储存单元，在垂直方向上叠了多少层，叠加层数越多容量自然越大，比如现在三星 NAND 颗粒就有 176 层，可以做到单个颗粒 1TB。</p><ul><li>然后 500~1200 页组成一个闪存颗粒的<strong>块（Block）</strong>，每次擦除都必须以块为单位：</li></ul><p><img src="https://cdn.sspai.com/2021/09/25/cc0e6753f08943cf4a699803b16b4076.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闪存颗粒的一块，图片来源：Youtube@Branch Education</p><ul><li>接着几千个块组成一个<strong>面（Plane）</strong>，面上会有一个寄存器，存储这个面所有储存单元的地址、临时存放数据指令等：</li></ul><p><img src="https://cdn.sspai.com/2021/09/25/9a04d7afd8c7a3cd59229463ff3f3daa.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闪存颗粒的一面，图片来源：Youtube@Branch Education</p><p>最后两个面组成一个<strong>片（Die）</strong>，Die 就是直接从晶圆上取下来的裸片：</p><p><img src="https://cdn.sspai.com/2021/09/25/827d592d5fcfe36b026e1681617e3c0f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闪存颗粒的一片，图片来源：Youtube@Branch Education</p><p>几个 Die 最后就压成我们能够摸到看到的黑黑的闪存颗粒了：</p><p><img src="https://cdn.sspai.com/2021/09/25/6f9dc54efb95176337b8af9bcce39efc.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者固态上的闪存颗粒</p><p>一个固态上往往有很多个闪存颗粒，比如爱国者 NVMe 1TB 单面固态上就有 4 个 256G 的闪存颗粒，也就是有 1,0995,1162,7776 差不多 1 万亿个储存单元，这是何等的复杂和精妙啊，现代储存设备真的是人类顶尖智慧的结晶。</p><p><img src="https://cdn.sspai.com/2021/09/25/b2e751690a20776bf3af5d13a5667a4d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>电子显微镜下的块，图片来源：TechInsights</p><p><img src="https://cdn.sspai.com/2021/09/25/9d2d6f41f83c997bd7f8d5c23c5157cd.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>英特尔的 3D XPoint 技术，图片来源：英特尔 Intel</p><blockquote><p>虽然比较抽象复杂，但晶体管原理结构部分我还是建议大家弄懂，方便我们理解后面固态硬盘的一些特性。</p></blockquote><h3 id="固态硬盘的大脑：主控芯片"><a href="#固态硬盘的大脑：主控芯片" class="headerlink" title="固态硬盘的大脑：主控芯片"></a><strong>固态硬盘的大脑：主控芯片</strong></h3><p>在上面我们了解到了闪存颗粒的基本结构，知道它有多么复杂，这么复杂的一个东西我们要给它快速存取数据，同时有数据平衡延长寿命，纠错和优化性能等功能，自然就需要一个控制器，<strong>在固态硬盘上面这个控制器就叫做主控，相当于一个小的处理器</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/25/7ebdb210707c651c1492f15cf93e3e7c.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>固态硬盘上的主控</p><p>固态上的主控其实蛮好辨认的，储存颗粒都是统一的颜色大小，一般来讲画风不一样的就是主控（缓存通常和储存颗粒一样颜色，但是小一点）。</p><p><strong>主控通过传输数据的通道直接连接着所有的储存颗粒，如果有 DRAM 缓存的话还直接连接着缓存，并维护一份所有储存单元的物理地址表</strong>。如果说储存颗粒是一个车站，里面停着很多等待装载乘客的客车，那么主控就是一个调度员，根据所有进入车站旅客的目的地来分配不同的客车，同时记录下每个乘客的出入记录和进去了哪个客车，为了保证一辆车不被挤爆，有时候还需要通过均衡调度来平衡每辆客车的乘客数量等等，总之主控就是个「全局指挥者」，哪里需要哪里搬。</p><p><img src="https://cdn.sspai.com/2021/09/25/9e85978fc4570675959b1465b732f70c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>主控连接和维护的地址表，图片来源：Youtube@Branch Education</p><p>地址表（FTL 映射表，将逻辑地址映射到物理地址）就是每个页的物理地址和对应的逻辑地址，像是 <strong>09:4:1:0351:045</strong> 就表示这个页位于<strong>第 9 个固态颗粒 -&gt; 第 4 个片 -&gt; 第 1 个面 -&gt; 第 351 块 -&gt; 第 45 页的物理地址</strong>，主控会给每个地址分配一个像是 <strong>105485652284</strong> 这样的区号作为<strong>逻辑地址</strong>，计算机文件系统给主控发送读取写入命令，主控返回数据的地址，主控给颗粒上的寄存器发命令的时候都是用逻辑地址表示的。</p><p>当电脑向固态硬盘发出读取某个数据的指令时，主控就会把目标页地址（上面说过 NAND 最小只能按页读取）通过储存通道发送到对应的固态颗粒上，然后页通过地址线和数据总线把储存单元的值都读出来，读一个就把结果暂存在面上的寄存器中，等读完这个页所有的储存单元，页面寄存器就会把数据通过储存通道返回到主控。</p><p>写入擦除数据也是一样，记住 NAND 写入之前必须先擦除对应的块（NAND 擦除最小单位是块），主控会根据地址表找出现在空闲的块，然后发送擦除指令到面，面会把块上所有储存单元的电子全部清空，也就是变成 1，111 等等最低状态。</p><p>接着主控会将要写入的页上每个储存单元地址和要写入的数据代表的阈值电压发送到面，面上的寄存器再一个个写入储存单元，如果是 1，111…… 这样就不用写，如果是 0，001…… 就根据不同的电压来写。   </p><p><img src="https://cdn.sspai.com/2021/09/25/4545b05934430c70362c99603961ed50.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>主控通过储存通道发送的不同类型数据</p><p><strong>写入过程如果固态硬盘有 DRAM 缓存或者模拟 SLC 缓存的话，这个过程会先发生于缓存上（原理也差不多）</strong>，然后在固态空闲时再写入到真正的储存颗粒里，提高实际的写入速度。</p><p>主控还负责另外一个很重要的功能，那就是<strong>均衡负载，延长 NAND 固态颗粒的寿命</strong>。在上面我们学到每次擦除时电子都会对储存单元的氧化层造成物理损伤，如果每次写入数据都逮着一个固态颗粒上的同一个块薅羊毛，那么很快这个块就死翘翘了。</p><p>所以主控通常还会记录每个块的擦除次数，把数据平均分配到不同的块中，让每个块儿的擦写次数都比较均匀，最大限度延长颗粒的寿命。当某个块的确挂掉的时候，主控还负责在地址表上把这个块屏蔽掉，不然再往这个块写入的数据就保存不了了。</p><p>通常主控还有很多额外的功能，比如预读取算法将高频率读取的文件放到缓存，以增加实际的读取速度；把某些空间模拟成 SLC 来当作缓存用；TRIM 算法减少实际擦除次数等等，这个我们后面几章会详细说。</p><h3 id="部分固态硬盘会有的：DRAM-缓存"><a href="#部分固态硬盘会有的：DRAM-缓存" class="headerlink" title="部分固态硬盘会有的：DRAM 缓存"></a><strong>部分固态硬盘会有的：DRAM 缓存</strong></h3><p>有些固态硬盘上还有一个和储存颗粒一样颜色，但是小一点的颗粒，这个一般就是固态硬盘的 DRAM 缓存。</p><p><img src="https://cdn.sspai.com/2021/09/25/c4e4575e6464771d89e9b44c76b0b6b1.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>西数 SN550 固态的 DRAM 缓存颗粒</p><p>DRAM 缓存原理和结构决定它比储存颗粒要快很多很多，所以写入数据时先将数据写入缓存，然后空闲时再写入储存颗粒，这样就让用户实际感受到的写入速度快很多。通常厂商都是按照 1GB：1MB 以上的比例来配置 DRAM 缓存，用户写大文件的时候缓存不够用就会暴露颗粒真实速度了。</p><p>现在的 NVMe 固态一般都没有 DRAM 缓存，转而用部分储存单元模拟 SLC 来做缓存，因为上面我们学到 SLC 储存单元无论是读取还是写入，只需要检测或者给一个阈值电压，比起 QLC 这种要检测几十次的简直不知道快到哪里去了。还有更快更贵的 SRAM 技术，虽然比起 DRAM 可能有其他好处 ，但是 DRAM 便宜啊，现在模拟 SLC 做缓存和 HMB 使用计算机运行内存做缓存等技术甚至连 DRAM 都不用了，厂商可以节省成本，消费者也能买得便宜一点（也许）。</p><p>所以普通的固态硬盘测试跑的一般就是缓存的速度，对于一般用户来讲的确日常也够用了，通常也不会有很多写入超过缓存大小文件的场景。不过如果是电影文件或者安装系统游戏的时候，还是有可能跑出真实速度，所以我们平时也是要测试固态的真实速度的，至于如何测试缓存外的速度，我们后面会讲。</p><p>看到这里你已经把机械硬盘，结构原理相关的内容都学得差不多了，实际上固态硬盘的结构原理部分涉及到的知识，甚至比我介绍要复杂得多，我这里已经努力筛选出普通人需要了解到的相关知识，并且尽量用通俗的方法来表示，希望大家都能看明白。   </p><p><strong><strong>相关文献</strong></strong>：</p><p>[1]. 浮栅晶体管的结构可以参考<a href="https://patents.google.com/patent/US7115939B2/">这份专利</a>。</p><p>[2]. 3D NAND 的结构可以参考闪迪 SanDisk 的<a href="https://patents.google.com/patent/US9443865B2/">相关专利</a>。</p><p>[3]. 现代 SSD 读取数据的原理可以看下 Youtube@Branch Education 的 <a href="https://www.youtube.com/watch?v=YtBysgPOKx4">「How does NAND Flash Work? Reading from TLC : Triple Level Cells || Exploring Solid State Drives」</a>。</p><p>[4]. 现代 SSD 写入数据的原理可以看下 Youtube@Branch Education 的 <a href="https://www.youtube.com/watch?v=5f2xOxRGKqk">「The Engineering Puzzle of Storing Trillions of Bits in your Smartphone &#x2F; SSD using Quantum Mechanics」</a>。</p><p>[5]. 现代 SSD 数据储存的结构可以看下 Youtube@Branch Education 的 <a href="https://www.youtube.com/watch?v=5Mh3o886qpg">「How do SSDs Work? | How does your Smartphone store data? | Insanely Complex Nanoscopic Structures!」</a>。</p><p>[6]. 现代 SSD 主控如何管理数据可以看下 Youtube@Branch Education 的 <a href="https://www.youtube.com/watch?v=r-SivgEpA1Q">「How does this SSD store 8TB of Data? || Inside the Engineering of Solid-State Drive Architecture」</a>。</p><p>[7]. 推荐一个正规的教程吧，<a href="https://www.bilibili.com/video/BV1xE411T7Dy">《清华大学 存储技术基础 2020》</a>，机电的同学应该很熟悉，非公开课程请大家低调观看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>在本章中，我给大家详细介绍了固态硬盘的历史，同时了解固态硬盘的结构和原理，还给大家科普了两种常见的闪存颗粒。<strong>文章的内容真的是比较抽象又比较复杂，真心觉得能够看到这里的朋友学习能力和毅力都是一流的</strong>，有这么好的特质做什么都能成功，我自己都佩服你们，不得不给你们点个赞。</p><p>原本我是打算用一章讲完固态硬盘相关的知识，没想到固态硬盘要说的东西实在太多了，不得已拆成了上下两章。本章介绍完固态硬盘基本的结构原理之后，下一章就要介绍固态硬盘的各种参数以及它们对性能的影响，还有我们如何去测试查看硬盘的性能数据。</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
      <category>数据存储历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>固态硬盘的历史结构与原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>场论统一</title>
    <link href="/Blogs/2025/08/28/%E5%9C%BA%E8%AE%BA%E7%BB%9F%E4%B8%80/"/>
    <url>/Blogs/2025/08/28/%E5%9C%BA%E8%AE%BA%E7%BB%9F%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>格林 → 斯托克斯 → 高斯</p><h3 id="向量场积分​​"><a href="#向量场积分​​" class="headerlink" title="向量场积分​​"></a><strong>向量场积分​</strong>​</h3><h4 id="​​16-1-标量场曲线积分（I型）​​"><a href="#​​16-1-标量场曲线积分（I型）​​" class="headerlink" title="​​16.1 标量场曲线积分（I型）​​"></a>​<strong>​16.1 标量场曲线积分（I型）​</strong>​</h4><ul><li><p>​<strong>​物理意义​</strong>​：计算曲线型物体的质量（如电线、管道）</p><p>  ∫C​f(x,y,z)ds&#x3D;∫ab​f(r(t))∣r′(t)∣dt</p><ul><li>f：线密度函数，ds：弧长微元</li></ul></li></ul><h4 id="​​16-2-向量场曲线积分（II型）​​"><a href="#​​16-2-向量场曲线积分（II型）​​" class="headerlink" title="​​16.2 向量场曲线积分（II型）​​"></a>​<strong>​16.2 向量场曲线积分（II型）​</strong>​</h4><ul><li><p>​<strong>​三大应用​</strong>​：</p><table><thead><tr><th>类型</th><th>公式</th><th>物理意义</th></tr></thead><tbody><tr><td>​<strong>​功​</strong>​</td><td>∫C​F⋅dr</td><td>力场沿路径做功</td></tr><tr><td>​<strong>​环量​</strong>​</td><td>∮C​F⋅Tds</td><td>向量场旋转强度</td></tr><tr><td>​<strong>​通量​</strong>​</td><td>∮C​F⋅nds</td><td>穿过曲线的流量</td></tr></tbody></table></li></ul><h4 id="​​16-3-保守场与路径无关​​"><a href="#​​16-3-保守场与路径无关​​" class="headerlink" title="​​16.3 保守场与路径无关​​"></a>​<strong>​16.3 保守场与路径无关​</strong>​</h4><ul><li>​<strong>​核心判据​</strong>​（四等价条件）:<ol><li>∮C​F⋅dr&#x3D;0（闭曲线积分为零）</li><li>∇×F&#x3D;0（旋度为零）</li><li>F&#x3D;∇f（存在势函数 f）</li><li>积分与路径无关</li></ol></li></ul><h4 id="​​16-4-格林公式​​"><a href="#​​16-4-格林公式​​" class="headerlink" title="​​16.4 格林公式​​"></a>​<strong>​16.4 格林公式​</strong>​</h4><ul><li><p>​<strong>​连接曲线与区域积分​</strong>​：</p><p>  ∮C​Pdx+Qdy&#x3D;∬D​(∂x∂Q​−∂y∂P​)dA</p></li><li><p>​<strong>​物理意义​</strong>​：平面区域 D 的环量 &#x3D; 旋度在 D 上的积分</p></li></ul><h4 id="​​16-6-标量场曲面积分（I型）​​"><a href="#​​16-6-标量场曲面积分（I型）​​" class="headerlink" title="​​16.6 标量场曲面积分（I型）​​"></a>​<strong>​16.6 标量场曲面积分（I型）​</strong>​</h4><ul><li><p>​<strong>​应用​</strong>​：计算曲面质量（如薄壳）</p><p>  ∬Σ​g(x,y,z)dσ</p><ul><li>g：面密度函数，dσ：面积微元</li></ul></li></ul><h4 id="​​16-7-斯托克斯定理​​"><a href="#​​16-7-斯托克斯定理​​" class="headerlink" title="​​16.7 斯托克斯定理​​"></a>​<strong>​16.7 斯托克斯定理​</strong>​</h4><ul><li><p>​<strong>​三维环量定理​</strong>​：</p><p>  ∮C​F⋅dr&#x3D;∬Σ​(∇×F)⋅dS</p></li><li><p>​<strong>​意义​</strong>​：曲面边界环量 &#x3D; 旋度通过曲面的通量</p><ul><li>_示例_：计算涡旋流体通过网面的总旋转量</li></ul></li></ul><h4 id="​​16-8-高斯散度定理​​"><a href="#​​16-8-高斯散度定理​​" class="headerlink" title="​​16.8 高斯散度定理​​"></a>​<strong>​16.8 高斯散度定理​</strong>​</h4><ul><li><p>​<strong>​统一通量理论​</strong>​：</p><p>  ∬​Σ​F⋅dS&#x3D;∭V​(∇⋅F)dV</p></li><li><p>​<strong>​物理意义​</strong>​：</p><ul><li>左：闭合曲面 Σ 的净流出量</li><li>右：向量场在体积 V 内的总源&#x2F;汇强度</li><li>_应用_：计算电场中闭合面的净电通量</li></ul></li></ul><blockquote><p>​<strong>​三大定理关系​</strong>​：</p><p><code>格林（2D平面） → 斯托克斯（3D曲面）   格林（2D） → 高斯（3D空间）</code>  </p><ul><li>格林是斯托克斯在二维特例；高斯将通量推广到三维</li></ul></blockquote><hr><h3 id="​​第17章-二阶微分方程​​"><a href="#​​第17章-二阶微分方程​​" class="headerlink" title="​​第17章 二阶微分方程​​"></a>​<strong>​第17章 二阶微分方程​</strong>​</h3><h4 id="​​17-1-二阶线性方程​​"><a href="#​​17-1-二阶线性方程​​" class="headerlink" title="​​17.1 二阶线性方程​​"></a>​<strong>​17.1 二阶线性方程​</strong>​</h4><ul><li><p>​<strong>​标准形式​</strong>​：</p><p>  y′′+P(x)y′+Q(x)y&#x3D;0</p></li><li><p>​<strong>​解的结构​</strong>​：</p><ul><li>通解 &#x3D; C1​y1​(x)+C2​y2​(x)（y1​,y2​ 线性无关）</li></ul></li></ul><h4 id="​​17-2-非齐次方程​​"><a href="#​​17-2-非齐次方程​​" class="headerlink" title="​​17.2 非齐次方程​​"></a>​<strong>​17.2 非齐次方程​</strong>​</h4><ul><li><p>​<strong>​特解构造法​</strong>​：</p><table><thead><tr><th>非齐次项 r(x)</th><th>特解形式 yp​</th></tr></thead><tbody><tr><td>eαx</td><td>Aeαx</td></tr><tr><td>sinβx</td><td>Asinβx+Bcosβx</td></tr><tr><td>xn</td><td>多项式待定系数</td></tr></tbody></table></li><li><p>​<strong>​通解公式​</strong>​：</p><p>  y&#x3D;齐次解C1​y1​+C2​y2​​​+特解yp​​​</p></li></ul><h4 id="​​17-3-物理应用​​"><a href="#​​17-3-物理应用​​" class="headerlink" title="​​17.3 物理应用​​"></a>​<strong>​17.3 物理应用​</strong>​</h4><ul><li><p>​<strong>​典型模型​</strong>​：</p><table><thead><tr><th>方程</th><th>物理系统</th></tr></thead><tbody><tr><td>my′′+cy′+ky&#x3D;0</td><td>弹簧阻尼振动</td></tr><tr><td>LQ′′+RQ′+C1​Q&#x3D;0</td><td>RLC电路振荡</td></tr><tr><td>y′′+ω2y&#x3D;0</td><td>无阻尼简谐振动</td></tr></tbody></table></li></ul><h4 id="​​17-4-欧拉方程​​"><a href="#​​17-4-欧拉方程​​" class="headerlink" title="​​17.4 欧拉方程​​"></a>​<strong>​17.4 欧拉方程​</strong>​</h4><ul><li><p>​<strong>​变系数线性方程​</strong>​：</p><p>  x2y′′+axy′+by&#x3D;0</p></li><li><p>​<strong>​解法​</strong>​：令 x&#x3D;et 转化为常系数方程</p></li></ul><h4 id="​​17-5-幂级数解法​​"><a href="#​​17-5-幂级数解法​​" class="headerlink" title="​​17.5 幂级数解法​​"></a>​<strong>​17.5 幂级数解法​</strong>​</h4><ul><li>​<strong>​适用条件​</strong>​：变系数方程在常点邻域</li><li>​<strong>​步骤​</strong>​：<ol><li>设解 y&#x3D;∑n&#x3D;0∞​cn​xn</li><li>代入方程比较系数求 cn​</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>场论统一</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>固态硬盘的参数解读与实际性能</title>
    <link href="/Blogs/2025/08/28/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E9%99%85%E6%80%A7%E8%83%BD/"/>
    <url>/Blogs/2025/08/28/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E9%99%85%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="数字存储完全指南-04：固态硬盘的参数解读与实际性能"><a href="#数字存储完全指南-04：固态硬盘的参数解读与实际性能" class="headerlink" title="数字存储完全指南 04：固态硬盘的参数解读与实际性能"></a>数字存储完全指南 04：固态硬盘的参数解读与实际性能</h1><p><a href="https://sspai.com/post/68976">在上一章我带大家从微观的晶体管到宏观的闪存颗粒，</a>让大家详细了解了固态硬盘的原理和结构。那么这一章我们就综合上一章学到的知识来介绍一下我们选购和使用固态硬盘时需要了解到的一些参数，以及如何测试固态硬盘的实际性能和速度，相关的性能参数又代表着什么。</p><h2 id="固态硬盘的参数解读"><a href="#固态硬盘的参数解读" class="headerlink" title="固态硬盘的参数解读"></a>固态硬盘的参数解读</h2><p>在介绍各个参数之前，我想先推荐一个比较好用的查看硬盘信息（机械硬盘和固态硬盘都可以，比较好用）的软件给大家 —— <strong>CrystalDiskInfo</strong>，看名字大家都应该能猜到它是和 CrystalDiskMark 同一家出的软件，完美继承了它家软件的特点：<strong>界面简单，功能简洁好用，有二次元皮肤</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/30/cb8c691d3e58f6a412222458226a9670.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CrystalDiskInfo 的界面</p><p>可以看到无论是固态硬盘还是之前介绍的机械硬盘，它都能读取到比较详细的信息，基本可以覆盖我们下面要介绍到的参数了。</p><h3 id="固态硬盘的尺寸"><a href="#固态硬盘的尺寸" class="headerlink" title="固态硬盘的尺寸"></a>固态硬盘的尺寸</h3><p>不同于机械硬盘基本上快大一统成 SATA 接口，只有少部分企业级在用一些特殊的接口，<strong>固态硬盘在接口方面可谓是群魔乱舞</strong>，不同接口对应的协议和最终的速度也是各不相同。不过等到固态硬盘发展到像机械硬盘那么成熟之后，这个现象也会逐渐消失，比如现在 M.2 接口就逐渐成为固态硬盘接口的主流，估计以后能像 Type-C 那样统一固态硬盘领域。</p><p>目前固态硬盘的尺寸也像接口那样五花八门。为了跟之前的硬盘位硬盘架通用，早前固态硬盘通常会设计成跟 2.5 寸机械硬盘一样大，用的也是 SATA 接口。</p><p><img src="https://cdn.sspai.com/2021/09/30/5e8c2a673c86ab57606e7cf91714d29a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo 的 2.5 英寸 SATA 固态硬盘与机械硬盘的大小对比</p><p><strong>使用 SATA 接口的固态硬盘大部分被设计成和机械硬盘通用尺寸和接口</strong>。如果你手边刚好有一个 SATA 固态硬盘，我非常鼓励你试一下把它拆开来，大部分固态硬盘的外壳都没有螺丝，直接用卡扣固定，拆下来之后你就会发现，其实真正储存和电路部分只有一小块，剩下的都是空的：</p><p><img src="https://cdn.sspai.com/2021/09/30/4c9c9c3899840881eaf10e7493df5f8b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>拆开的 SATA 固态硬盘，实际储存部分只有一小块</p><p>甚至有些商家还会给空空的地方贴一些海绵或者配重块，来让整块固态硬盘手感好一点。外壳纯粹就是为了兼容笔记本或者台式机里的 2.5 寸硬盘位。</p><p>因为 SATA 接口和走 SATA&#x2F;AHCI 协议的接口速度上限被限定在 700MB&#x2F;S 左右，所以新的固态硬盘都会选择使用 M.2 接口或者直接插 PCIe 槽。</p><p><img src="https://cdn.sspai.com/2021/09/30/d1ed10d2042035d26b7169318de55850.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>主板上的 M.2 接口</p><p>我们在购买 NVMe 固态硬盘或者把它们装到电脑主板上时，<strong>通常都会看到类似于 22XX 4 个数字的参数，这个就表示固态硬盘的尺寸</strong>。</p><p>22&#x3D;22mm，也就是固态硬盘宽度是 2.2 厘米的意思，后面两个数字就是固态硬盘的长度，通常会有 20，42，60，80 等常见长度，以毫米为单位。我们购买的时候一定要先看看自己设备上的 M.2 接口预留出了多少空间，免得太长放不进去。</p><p><img src="https://cdn.sspai.com/2021/09/30/3c24501cbd26e7105bfab72af4cadd7c.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>M.2 接口上通常也会标注出长度数字</p><p>至于 2230 长度的固态硬盘估计大部分人都没见过，在早前比较常用，如果你现在在笔记本或者其他地方找到这个接口，大部分时候其实是给 WiFi 模块用的。</p><p>在有些设备上还会使用 mSATA 固态硬盘，虽然它的缺口和 NVMe 固态硬盘一样，但是宽度比较宽，所以接口是不通用的。</p><p><img src="https://cdn.sspai.com/2021/09/30/33f1d0666abe374b78a3899637373a75.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>金士顿 Kingston 的 mSATA 固态硬盘，图片来源：Amazon</p><h3 id="固态硬盘的接口协议"><a href="#固态硬盘的接口协议" class="headerlink" title="固态硬盘的接口协议"></a>固态硬盘的接口协议</h3><p>在介绍机械硬盘结构原理的那一章，我们已经了解到接口，协议，和总线的联系和区别。这一章我们介绍固态硬盘接口时可以顺便稍微复习相关的知识，同时拓展介绍一下它们仨。</p><p>先来简单复习一下：</p><ul><li><strong>总线</strong>：计算机设备里各个部件之间交换数据（传输电信号等）的通道，这个通道每秒能传输的数据量就叫做带宽。</li><li><strong>协议</strong>：双方交换数据的规则，比如如何识别对方的身份、如何建立断开连接、编码解码方式（也就是电信号怎么传输接收）等等。</li><li><strong>接口</strong>：让两个设备之间可以通过特殊的形状物理连接起来。</li></ul><p>机械硬盘一般使用的就是 SATA 总线或者，然后使用 SATA&#x2F;AHCI 协议来和设备其他部件沟通，但放在固态硬盘上事情就有一些复杂了。在本小节开头，我们也提到<strong>目前固态硬盘的接口协议等等种类还比较多，也让很多用户稀里糊涂买到了不适合自己的固态硬盘或者速度没有达到设备上限的固态硬盘，浪费了额外的时间和性能</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/30/82892ed327c26bbf901950dd0a65b41a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>比如看起来是 M.2 接口的 B Key 固态只能走 SATA 协议</p><p>我们先来说一下总线，目前我们民用储存设备常见到的总线有 <strong>SATA 总线、PCIe 总线和企业级 SAS 总线</strong>（如果你用一些服务器主板的话，可能会有）。之前我们了解到 SATA 总线一般是给机械硬盘使用，而且速度上限比较低，而 SAS 总线又是企业级使用比较多，<strong>那么除了低速的固态硬盘走 SATA 总线，现代的 NVMe 固态硬盘一般都是走 PCIe 总线了</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/30/5f3acd295ac28b565e5a1fb0a2682335.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>这三种总线的速度，上面是 PCIe 总线，下面是 SATA 和 SAS 总线，图片来源：维基百科</p><p>而协议方面目前民用的也是只有比较少的几个，<strong>SATA&#x2F;AHCI 协议，NVMe 协议，SCSI 协议</strong>（同样是企业级服务器用的比较多），没错，<strong>我们常看到的 NVMe 固态硬盘中的 NVMe 指的就是这个硬盘使用的协议</strong>。高效的协议能让总线满效率运行，跑满总线的带宽，这也是 NVMe 固态硬盘能那么快的原因。</p><p>和简单的总线协议不同，固态硬盘接口方面可就复杂多了。<strong>最基础的就是我们常见的 SATA 接口，还有为了笔记本等便携式设备引申出来的 mSATA 接口，还有固态硬盘专享的 M.2（NGFF） 接口，SATA Express（SATAe） 接口，PCIe 接口，甚至还有不常见的走 SAS 总线的 SAS 接口与 U.2，AIC 接口等等</strong>，这些接口各自走前面的 3 个总线和协议，大概像是这个样子：</p><p><img src="https://cdn.sspai.com/2021/09/30/c66d403409b8ea28fe801d9c5a7a55c9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>机械硬盘和固态硬盘不同接口对应的总线协议</p><p>怎么样？是不是觉得很复杂？没关系，<strong>接下来我就来带你实际从不同接口的固态硬盘出发，简简单单就记住它们的关系</strong>。</p><p>在逐个介绍之前我先说一下总体情况，和机械硬盘物理速度上限较低，所以不太需要考虑协议和总线速度的情况不同，对固态硬盘，特别是对现代高端固态硬盘来讲，不同接口协议总线已经开始可以限制固态硬盘的速度发挥了。</p><p>这里又要重新强调一下之前讲过的木桶效应，<strong>固态硬盘最终速度取决于接口协议总线最慢的部分</strong>。但通常厂家都会保证速率和协议达到要求，才会推出对应的固态硬盘，<strong>所以我们使用的时候，通常只需要保证它走的总线速率足够就可以满速运行</strong>。</p><h3 id="SATA-mSATA-SATAe-接口固态硬盘"><a href="#SATA-mSATA-SATAe-接口固态硬盘" class="headerlink" title="SATA&#x2F;mSATA&#x2F;SATAe 接口固态硬盘"></a>SATA&#x2F;mSATA&#x2F;SATAe 接口固态硬盘</h3><p>SATA 接口是大部分人刚用上固态硬盘，甚至现在机箱里面唯一的固态硬盘接口类型。固态硬盘刚开始普及民用的时候算是比较贵重的数码产品，每 GB 比起机械硬盘甚至要贵上好几十倍。</p><p><img src="https://cdn.sspai.com/2021/09/30/d01ff3be0ea2a790ac3b0a255f8a311e.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>2013 - 2020 固态硬盘每 TB 价格走势</p><p>这导致那个时候没什么人用固态硬盘，加上那个时候固态硬盘速度也没有现在那么快，还没突破 SATA 总线上限，所以主板厂商并不会专门设计一个专供固态硬盘使用的接口。那个时候的固态硬盘只能是继续使用 SATA 接口，使用 SATA3.0 协议。</p><p>同时那个年代的计算机机箱通常只设计了给机械硬盘的硬盘位，所以就像我们上面提到的即使固态硬盘的储存颗粒只有小小的一颗，也是要用一个 2.5 或者 3.5 寸硬盘那么大的壳子来包住它。</p><p><img src="https://cdn.sspai.com/2021/09/30/dda62812904c43c00305d2963a0ca799.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>壳子里面的主要部分就很小一块</p><p>固态硬盘的全面普及最早是在笔记本上，之前笔记本放机械硬盘的做法是把 SATA 接口焊在主板上，然后在主板上留一个 2.5 寸机械硬盘那么大小的位置。但固态硬盘本身只有很小的一个，也不需要机械硬盘那么高的供电，没有必要用 SATA 这个电源部分就占了一半的接口，跟没有必要留 2.5 寸机械硬盘那么大的位置，加上那个时候超极本超薄本等轻薄设备的概念兴起，所以主板厂商就设计出了 mSATA 接口。</p><p><img src="https://cdn.sspai.com/2021/09/30/8f136666d2c494d8e6ba938362c19da6.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>笔记本上的 mSATA 接口，图片来源：Reddit 用户 </p><p>它和我们现在见到的 M.2 接口已经非常相似了，不过仍然是走的 SATA 协议和总线，你可以把它理解为 SATA 接口的迷你版，毕竟 mSATA 就是 mini SATA 的缩写，这个时候厂商终于可以把固态做到合适的大小。</p><p>不过到现在这个接口基本上已经没有什么笔记本在使用，都用上了更新的 M.2 接口，如果新笔记本里面还有这个接口，通常上面插的都是无线网卡而不是固态硬盘。倒是很多移动固态硬盘内部还在使用 mSATA 接口转 USB，毕竟大部分人对于移动硬盘的速度需求并不高，能超越 SATA 速率的 USB3.2&#x2F;USB4 也还没有普及，厂商没必要用上对硬件要求更高的协议和接口。</p><p><img src="https://cdn.sspai.com/2021/09/30/d2561baef758d47f57da1d3a18e45a31.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>笔记本上常见的英特尔无线网卡，一般还会带蓝牙，这个型号是 AX200</p><blockquote><p>另外英特尔还推出过一个叫做 SATA Express 的接口，他可以直接插两个 SATA 来走 SATA 协议，也可以用整个接口走 PCIe*1&#x2F;2，不过这个东西接口还是太大，速度上限提升也不高，只出过几款对应的主板，连支持的设备都没有出就夭折了。</p></blockquote><p>随着固态硬盘的速度越来越高，这两个接口已经远远无法满足日益加快的固态硬盘，所以<strong>厂商必须设计一个专门用于固态硬盘，并且可以直接与速度最快的 PCIe 总线交流的接口</strong>。</p><h3 id="M-2（NGFF）-PCIe-接口固态硬盘"><a href="#M-2（NGFF）-PCIe-接口固态硬盘" class="headerlink" title="M.2（NGFF） &#x2F;PCIe 接口固态硬盘"></a>M.2（NGFF） &#x2F;PCIe 接口固态硬盘</h3><p>专门用于固态硬盘，并且可以与速度最快的 PCIe 总线交流的接口，说的就是我们今天常见的 M.2 接口了。M.2 是我们比较常听说的名字，但它其实叫做 NGFF（Next Generation Form Factor），翻译成中文就是次世代接口，后来被改名叫 M.2，可能是觉得这个接口不可能一直次世代吧。「2」就是第二代的意思，「M」则是我们下面提到的 M.KEY，表明接口的形状，中间用点隔开表示它们俩是不同的参数。</p><p>M.2 接口作为现在和未来的主流接口，自然有向后兼容，既可以使用 SATA 协议也可以使用 NVMe 协议，由于支持协议众多并且接口复杂，<strong>M.2 接口通过接口上的缺口来确定协议类型，由于不同缺口像钥匙那样，所以叫做 KEY</strong>，M.2 接口有从 ABCDEFGHJKLM 这么多种 KEY，KEY 对不上是插不进去对应接口的（真就钥匙呗……）。不过倒不用担心太过复杂，因为<strong>我们日常只能看到两种：M KEY 和 B KEY</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/30/86467757762f86947fcedd6f47a114aa.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同 M.2 KEY 的用途，图片来源：维基百科</p><p>如果我们观察自己的 NVMe 固态硬盘，会发现缺口都在右边，这个就是 M Key，如果插槽右边有对应的突出就可以插进去，通常它们就是使用 NVMe 协议走 PCIe 总线。</p><p>而 B KEY 的缺口则是在左边，插进对应的插槽之后通常只能走 SATA 总线。另外还有同时有两个缺口的固态硬盘，这种就是 B&amp;M KEY，既可以走 SATA 总线也可以走 PCIe 总线。不过一般来讲这种类型都是 SATA 或者 PCIe*2 居多，速度上限不高。</p><p><img src="https://cdn.sspai.com/2021/09/30/d748cad6bf50f851c7d5e2e7ba663590.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>硬盘转接卡上的 M KEY，B KEY 和对应的 M.2 接口</p><p><strong>主板上的位置寸土寸金，所以一般我们现在看到的主板只会保留 M KEY 的 M.2 接口</strong>。大家购买固态硬盘的时候也要认清是哪种 KEY，<strong>如果是新设备建议只购买 M KEY 的固态硬盘</strong>，免得到时候插不进去或者插进去却只能走 SATA 总线。</p><blockquote><p>A&#x2F;E KEY 就是我们上面提到 2230 这种无线网卡比较常用的 M.2 接口所用的 KEY 类型。</p></blockquote><p><img src="https://cdn.sspai.com/2021/09/30/8d2864c4e9dc1ebab610d3199f9b0f30.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>使用 M.2 接口的无线网卡，图片来源：淘宝</p><blockquote><p>NVMe 协议中的 NVM 其实就是我们之前提到的非易失性储存器英文，整个名字可以简单理解为非易失性储存器控制协议。</p></blockquote><p>既然 M.2 接口的高速固态硬盘使用的是 NVMe 协议走 PCIe 总线，有些厂商干脆就把固态硬盘做成 PCIe 接口，插到 PCIe 插槽插使用。这就是 PCIe 固态硬盘，用的一般也是 NVMe 协议。</p><p><img src="https://cdn.sspai.com/2021/09/30/19c4331ef67fd245f30719d321ec5f8f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>比如英特尔的高端 AIC 固态硬盘一般都是 PCIe 接口</p><h3 id="其它接口：SAS-AIC-U-2-接口"><a href="#其它接口：SAS-AIC-U-2-接口" class="headerlink" title="其它接口：SAS&#x2F;AIC&#x2F;U.2 接口"></a>其它接口：SAS&#x2F;AIC&#x2F;U.2 接口</h3><p>上面介绍的都是我们日常比较常见的一些固态硬盘接口类型，下面简单介绍一下比较少见的接口，这些接口一般都是企业级或者服务器使用比较多，如果我们使用服务器主板的话，还是有机会看见的。</p><p>SAS 和 U.2 这些都是 SATA 接口改过来的接口，目的就是<strong>为了兼容 SATA 硬盘的同时能够用上其他协议总线</strong>。比如 SAS 就可以有服务器常见的 SCSI 总线，U.2 可以用 NVMe 协议走 PCIe 总线。</p><p><img src="https://cdn.sspai.com/2021/09/30/b35dd8be73c7216911bb0d866bc6436c.gif"></p><p>SAS 和 U.2 接口的样子</p><blockquote><p>SATA 硬盘可以插到 SAS 和 U.2 接口上，反过来 SAS 硬盘和 U.2 硬盘则不能插到 SATA 接口上。</p></blockquote><p>AIC 就是 PCIe Add in Card 的意思，其实就和 PCIe 固态差不多，也可以直接插在 PCIe 接口上使用，主要是因为服务器上有很多设备都比较老，用不了其他接口，插PCIe 是最直接的。</p><p><img src="https://cdn.sspai.com/2021/09/30/fb8ec2eb89aa611de1a82bba458df1b0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo 的 AIC 企业级固态硬盘</p><h3 id="接口兼容性与速度上限"><a href="#接口兼容性与速度上限" class="headerlink" title="接口兼容性与速度上限"></a>接口兼容性与速度上限</h3><p>接下来我通过实际的例子来说一下不同接口的固态硬盘的速度上限，首先 SATA 这类接口就不用说了，加上损耗最高 600MB&#x2F;S。</p><ul><li>接下来你再看你设备上的 M.2 接口，如果是 B KEY，还要在看主板说明书。</li><li>如果主板说明书上没有写明这个接口支持 PCIe×2 总线，那么无论你买啥，只要能插进去，最高速度都不超过 600MB&#x2F;S。</li><li>如果主板说明书上写明这个接口支持 PCIex2 总线，那么就要购买同样支持 PCIex2 的 B KEY&#x2F;B&amp;M KEY 的固态硬盘，插上去之后最高速度大概能来到 1GB&#x2F;S 左右。</li></ul><p><img src="https://cdn.sspai.com/2021/09/30/9d5b9ae1cf6e9b68665f62f68d46b8e2.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>B KEY 的 M.2 接口与速率上限的关系</p><ul><li>如果你设备的 M.2 接口是 M KEY，还是要查看主板说明书。</li><li>一般来讲笔记本的 M.2 接口都有可能向下兼容走 SATA 总线，但台式机主板上的 M.2 接口一般只支持走 PCIe 总线。<strong>一定要先看主板说明书再购买对应的固态硬盘</strong>。</li><li>如果接口兼容 SATA，那么有两个缺口的 B&amp;M KEY 固态硬盘能插进去，此时速度上限就是 600MB&#x2F;S。</li><li>如果插入 M KEY 的固态硬盘，具体的速度上限就由它使用的 PCIe 传输模式决定，<strong>通过前面推荐的 CrystalDiskInfo 就可以看到固态硬盘正在使用的传输模式和支持的传输模式</strong>。</li></ul><p><img src="https://cdn.sspai.com/2021/09/30/85dbcb8cb27e18e306f8d6ce90dc5019.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>M KEY 的 M.2 接口与速率上限的关系</p><p><img src="https://cdn.sspai.com/2021/09/30/81628d9bc8942329003e7b2bd09a46cf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CrystalDiskInfo 上查看储存设备的传输模式</p><p>比如常见的 NVMe 固态硬盘走 PCIe 3.0x4，那么速度上限就是 4GB&#x2F;S，如果是比较贵的 PCIe4.0 NVMe 固态硬盘速度上限则是 PCIe4.04 也就是 8GB&#x2F;S。</p><p><img src="https://cdn.sspai.com/2021/09/30/6013b320724d5f6498990dae367db0a6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo PCIe4.0 P7000 固态硬盘（1 TB）的速度最高可以到 7GB&#x2F;S 左右</p><h2 id="固态硬盘的颗粒与主控"><a href="#固态硬盘的颗粒与主控" class="headerlink" title="固态硬盘的颗粒与主控"></a>固态硬盘的颗粒与主控</h2><p>虽然固态硬盘使用的接口协议总线决定了读写速度的上限，<strong>但固态硬盘实际能跑多快，还是要看颗粒的质量还有主控算法</strong>。</p><h3 id="SLC-MLC-TLC-QLC-颗粒"><a href="#SLC-MLC-TLC-QLC-颗粒" class="headerlink" title="SLC&#x2F;MLC&#x2F;TLC&#x2F;QLC 颗粒"></a>SLC&#x2F;MLC&#x2F;TLC&#x2F;QLC 颗粒</h3><p>这几个名词算是我们购买固态硬盘，或者看其他人评测时最常提到的参数了，如果是后两个颗粒，通常还伴随着对厂家的鄙视。但实际上它们都是什么呢？</p><p><img src="https://cdn.sspai.com/2021/09/30/48cd517979e55113e100746ebb375b80.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>评测里面提到 QLC 基本上都是骂的</p><p>其实通常人们在他们后面加上颗粒是不太严谨的，<strong>因为它们从物理上都是由无数相同的浮栅晶体管组成的 NAND 闪存颗粒</strong>。无论是 SLC 还是 MLC 还是后面几个，它们用的储存单元都是一样一样的浮栅晶体管，而区别在于<strong>每个浮栅晶体管组成的储存单元，它的状态数量（其它科普常用层数来表示）不一样</strong>。</p><p>再上一章，我们已经用 TLC 来演示现代固态硬盘 NAND 闪存颗粒的原理，通过给储存单元阈值电压，检测电路是否导通来读取储存单元里面的数据。其它的几个类型也是类似：</p><ul><li><strong>SLC</strong> &#x3D; Single Level Cell，指的是通过一个阈值电压区分 0, 1 两种状态的储存单元，这样一个储存单元就能储存 1bit 的数据。</li><li><strong>MLC</strong> &#x3D; Multi Level Cell，指的是通过三阈值电压区分 00, 10, 01, 11 四种状态的储存单元，这样一个储存单元就能储存 2bit 的数据。</li><li><strong>TLC</strong> &#x3D; Triple Level Cell，指的是通过七个阈值电压区分 000, 001, 010, 011, 100, 101, 110, 111 八种状态的储存单元，这样一个储存单元就能储存 3bit 的数据。</li><li><strong>QLC</strong> &#x3D; Quadruple Level Cell，指的是通过十五个阈值电压区分 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111 十六个状态的储存单元，这样一个储存单元就能储存 4bit 的数据。</li></ul><p><img src="https://cdn.sspai.com/2021/09/30/7db47225301b02b4278ee4f52f1367e9.gif"></p><p>上一章也有的 TLC 检测数据过程动图</p><p>现在连 PLC 都快出来了，按照上面的原理一个储存单元就能储存 5bit 的数据。</p><p>这样做的好处自然显而易见，<strong>同样面积的储存单元，QLC 比起 SLC 能够存放 4 倍的数据</strong>，也就是说闪存颗粒的密度提升了 4 倍，这已经是很惊人的差距了，<strong>同一块闪存颗粒如果全做 QLC 可以有 1000GB 容量，那么 TLC 只有 750G， MLC 只有 500G，SLC 更是只有 256G 了</strong>。</p><p>而且由于数据密度提高，相同容量的 TLC 固态价格也和数据密度一样是 SLC 的 1&#x2F;4 左右，也就是说便宜同时还变大碗。这听起来好像很美好，那么为什么大家都那么抵制使用 TLC &#x2F;QLC 储存单元的固态硬盘呢？</p><h3 id="多层储存单元的缺陷"><a href="#多层储存单元的缺陷" class="headerlink" title="多层储存单元的缺陷"></a>多层储存单元的缺陷</h3><p>首先就是一个储存单元上，分的阈值电压越多读取的时候就要越多次，比如 TLC 读取一次一页的数据就要轮流给 7 个阈值电压，每给一次阈值电压都要一个个检测储存单元是否导通，而 SLC 只要一个阈值电压检测一次，<strong>每多一个需要检测的阈值电压，读取速度就会慢很多倍</strong>。</p><p>多个阈值电压也会带来读取困难后果，上一章我们也讲到不能无限细分预置电压去无限提高容量密度。即使只做到 TLC 的级别也会带来阈值电压区间过小的问题，因为我们往储存单元写入数据的时候，并不能精确控制电子量，如果阈值电压过小电子量又刚好卡在中间，那么数据到底是 010 还是隔壁的 011呢？<strong>这个时候就需要 ECC 纠错算法的加入，通过校验数据纠正这个储存单元上的信息然后重新写入正确的数据，这一步又大大减慢了读取速度</strong>。</p><ol><li>写入的时候也是这样，阈值电压越多，储存单元储存数据需要的电子量要求就越精准，自然就越容易出错。<strong>出错的时候又要 ECC 纠错算法来校验重新写入正确数据，写入速度也被拉慢了</strong>。</li><li>阈值电压变的设置对储存单元的寿命也有影响，先不说上面提到反复写入影响到的寿命，<strong>我们知道每一次写入都会对包括浮栅的绝缘层造成物理损伤，而闪存颗粒又是每一次写入数据都需要先擦除对应块再写入数据</strong>，这样时间长了浮栅里面保存的电子就会越来越容易穿过漏洞逐渐增多的绝缘层「越狱」跑掉。</li></ol><p>对于 SLC 而言，0,1 两个状态相差的电子量很多，即时跑掉一点也不影响读取；不过当到 QLC 这种，每个状态之间电子量差很小，只需要有一点点电子从浮栅中跑出来，就会让这个储存单元读取的数据变成另一个状态。而当写入后短时间内电子跑掉的量大于两个数据状态之间的差，主控就会认定这个储存单元已经挂掉了。<strong>清楚了原理之后，我们很容易就能发现比起 SLC，MLC&#x2F;TLC&#x2F;QLC 等等越多层的储存单元挂掉需要的时间越来越短</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/30/62dfc92c7d74a83d45e37e19b10d630c.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SLC 对比其它类型储存单元检测数据时间，写入时间，擦除时间和平均寿命对比</p><ol><li>多层储存单元还会带来其它问题，比如数据可靠性不足，对保存环境要求更高等等。</li></ol><p><strong>从 MLC 到 QLC，容量密度越来越高，价格越来越便宜的同时，以上提到的缺点也会越来越严重</strong>。简单总结就是，<strong>在对比之下 SLC 读写速度最快，数据保存最稳定可靠，寿命最长</strong>，对比之下我们才知道 SLC 除了数据密度低和贵，真的是哪哪都好。这也不怪大众批评厂商用 TLC&#x2F;MLC 是「偷工减料」了。</p><h3 id="正确看待多层储存单元"><a href="#正确看待多层储存单元" class="headerlink" title="正确看待多层储存单元"></a>正确看待多层储存单元</h3><p>看完上面的部分，很多人可能就觉得哎呀，我一定要花很多钱去上 SLC&#x2F;MLC 固态硬盘，不然总感觉用不了多久也不可靠。</p><p>但其实没有必要，我觉得只要在商品详情和包装盒上标明储存单元类型（虽然基本没有厂商这么干），然后容量价格比的确够低，那么大家还是值得根据自己的需求去购买的（<strong>虽然现在市面上基本没有全盘 SLC 的民用产品了</strong>，很快估计连全盘 MLC 的产品厂家都不会再生产了）。</p><p><img src="https://cdn.sspai.com/2021/10/01/97bb0c6455025b8ca434da32a2c3fb74.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>标明储存单元类型的固态硬盘</p><p>现在厂商都会使用 DRAM 或者将固态硬盘的一部分空间模拟成 SLC 来加当做缓存来解决 TLC&#x2F;QLC 的速度问题，而且即使是 QLC，只要容量足够大并且有一个好的主控，那么我们日常使用每个储存单元的擦写数据可以控制得很低，只要你不是每天 24 小时不停在写入，基本上也有十几年的寿命（详细的参数在下面会介绍）。所以最后还是要看个人的需求，如果的确对数据可靠性和速度有很高要求，并且价格不敏感，那的确不要考虑 QLC 甚至是 TLC，感觉大部分时候都可以，具体的我会在选购那章详细介绍。</p><blockquote><p>说实话基本很少见硬盘颗粒坏掉的，一般都是主控先坏，不然也不会有那么多厂家回收固态颗粒再当做新的卖了。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/01/9d597ef435e5cc66c131507ea32c3dee.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>大厂的 QLC 固态硬盘也还是不便宜</p><p>当然也不是说就能无脑买了，某些无良厂商会用回收或者质量差的反正就很垃圾的颗粒和主控弄成全盘 QLC，然后配上一丁点高质量 DRAM 或者 SLC 缓存当做高配固态卖，这种固态硬盘无论是缓外速度还是寿命，可靠性都一塌糊涂。。</p><blockquote><p>即使是大厂也经常会有偷换颗粒这种新闻，所以我们买之前也要搜一下固态型号，看看有没有相关的黑历史；另外相同类型的颗粒在厂家那边还会有原厂颗粒、黑片、白片等区别，详细的我会在选购那章展开讲。</p></blockquote><h3 id="简单查看固态硬盘上的颗粒类型"><a href="#简单查看固态硬盘上的颗粒类型" class="headerlink" title="简单查看固态硬盘上的颗粒类型"></a>简单查看固态硬盘上的颗粒类型</h3><p>说了这么多，也来到了实战的环节。这一节我就来教教大家怎么看自己固态硬盘用了什么类型的闪存颗粒，闪存颗粒的质量怎么样。</p><p>各位可以拿出自己的固态硬盘来观察一下，或者购买对应固态硬盘之前先网上搜一下对应的照片，闪存颗粒上面一般会有一些编码。当然有一些厂家也会使用没有编码的闪存颗粒，或者把闪存颗粒上的编码丝印刮掉，这种的话想要了解颗粒的具体参数，就只能去咨询厂家了（<strong>除非你把闪存颗粒从电路板上拆下来，接上 AlcorMP 这类的软件进行查看编号</strong>）。</p><p><img src="https://cdn.sspai.com/2021/10/01/548dba8109f559f209a14e77a91b0992.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>没有编码丝印的闪存颗粒</p><p><img src="https://cdn.sspai.com/2021/10/01/211d26d0b917d61236180a98a91b09b5.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>AlcorMP 查看闪存颗粒编号</p><p>一般来讲，不同厂家使用不同颗粒的编码差别会很大，比如正规的大厂一般会在颗粒上带有晶圆厂的 Logo，自家的品牌或者产地容量等等。</p><p><img src="https://cdn.sspai.com/2021/10/01/8d893bec4f223e1adf9770954d1d8cf8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>西部数据 SN550 上面的颗粒就是很清楚</p><p>但一般我们只需要关注底下或者唯一的编码就行，说实话，闪存颗粒作为和芯片一样的高精尖技术，<strong>目前（文章发表时）地球上也只有三星、海力士、东芝、镁光、西部数据（闪迪）、我们国家的长江存储占据了绝大部分闪存颗粒市场</strong>，基本上你能看到的固态都逃不掉以上几家的颗粒。</p><p><img src="https://cdn.sspai.com/2021/10/01/84ed4679d47b29cc456e43514cd7b844.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>这几家的原厂颗粒长这个样子</p><p>如果闪存颗粒上只有一个编号没有其他信息，那么大概率是自封的闪存颗粒。<strong>自封闪存颗粒只有生产出来是在原厂，后续的封装检测均由企业自行完成，所以并不是自封就是不好，品质取决于企业的技术和良心</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/01/52130460efdb36b2162958b1b3092deb.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>像是这种只有一个编号的，就是自封颗粒</p><p><strong>如果是原厂闪存颗粒，我们就可以使用 SSD-Z 或者 FlashMaster 这类的应用去获得详细的储存单元类型和颗粒生产信息</strong>。但如果是自封闪存颗粒，<strong>只能是拿着这个固态的型号或者编码去问客服或者谷歌一下</strong>，没错就是这样子，因为原厂颗粒还好，但是现在固态很多都用上了自封颗粒，也没办法用 flash.top 或者 FlashMaster 这类的应用去查询。</p><p><img src="https://cdn.sspai.com/2021/10/01/44a16f4a47108e5cba3371c33833adb8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>原厂颗粒的查询结果</p><p>目前比较好用的检测自封闪存颗粒的方法是使用俄罗斯人 Ochkin Vadim 开发的 <a href="https://blog.elcomsoft.com/2019/01/identifying-ssd-controller-and-nand-configuration/">Flash ID 检测工具</a> 来曲线救国，这个工具利用的是固态硬盘主控读取闪存颗粒序列号的命令，获得闪存颗粒序列号后再和内置的数据库对比得到闪存颗粒真正的编码。</p><p><img src="https://cdn.sspai.com/2021/10/01/a1e91dbefd10ed1c065f249826db4345.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Flash ID 检测工具</p><p>至于如何分辨闪存颗粒是原厂颗粒，黑片，白片还是工程版，各家原厂颗粒的命名规则和具体的方法，最终确定一个颗粒的品质。这个过程并没有准确百分百的方法，具体的我会留到选购这一章再讲。</p><blockquote><p>其实最好的方法还是直接问对应品牌的客服。一般客服都会反馈给工程师，然后得到结果，一次不行实在想知道的话可以问多几次，一般都会有回复。</p></blockquote><h3 id="主控-SSD-控制器"><a href="#主控-SSD-控制器" class="headerlink" title="主控&#x2F;SSD 控制器"></a>主控&#x2F;SSD 控制器</h3><p>从物理状态来讲，其实颗粒的擦写次数并不高，所以主控好不好非常重要。<strong>主控的水平关乎同一个颗粒下的读取写入速度，还有寿命等，甚至比闪存颗粒的质量更加重要</strong>。使用相同闪存颗粒的两个固态硬盘，如果一个用好主控，一个用一般的主控，不仅读写速度能相差几倍，寿命甚至能相差 10 倍。</p><p><img src="https://cdn.sspai.com/2021/10/25/5005d00fe5243f2a3d3f2380347782c4.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo P7000 固态硬盘上的主控</p><p><strong>主控又被称为 SSD 控制器，本质上就是一个小型处理器，甚至会有多个核心，也像真正的 CPU 那样有 SRAM 缓存</strong>。和闪存颗粒不同，固态硬盘的主控芯片有很多厂商在做，国内外知名的有<strong>三星（Samsung）、慧荣科技（Silicon Motion）、群联（Phison）、Marvell（马牌）</strong>，国内则有华澜微(Sage)、国科微（GOKE）、联芸科技(MAXIO）、得一微电子（YEESTOR）、英韧科技（InnoGrit）、忆芯科技（StarBlaze）、大唐存储（DATSSD）、大普微电子(DapuStor) 等等多家，虽然目前技术还不如国外主控，但也在不断追赶。</p><p><img src="https://cdn.sspai.com/2021/10/01/30555dbb75c6b3172c5187c30b6761cc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>三星、慧荣科技、群联、Marvell 的主控芯片</p><blockquote><p>主控里面也是会有一个小的操作系统，很多发烧友的「开卡」操作就是给掉盘或者给主控坏掉的固态硬盘修好后换上新主控刷入新 ROM（固件）的操作。</p></blockquote><p>以 NVMe 固态硬盘为例，主控主要做以下几个工作：</p><p><img src="https://cdn.sspai.com/2021/10/01/fed2a655da8d63b41227d82c2f0fa61a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>典型的主控结构</p><p>这就是主控最主要的工作，如 NVMe 固态硬盘往往需要性能比较强的多核处理器，就是因为 NVMe 协议的队列长度和深度都比较大，还支持乱序执行。主控除了像上一章我们提到的那样控制数据写入读出之外，还要同时执行 FTL 算法，调度算法，缓存算法等等下面提到的工作。</p><h4 id="FTL（FlashTranslation-Layer）-算法"><a href="#FTL（FlashTranslation-Layer）-算法" class="headerlink" title="FTL（FlashTranslation Layer） 算法"></a>FTL（FlashTranslation Layer） 算法</h4><p>FTL 算法也就是上一章我们提到的物理地址转换成逻辑地址的算法，主控会将不同页物理位置转换成一个逻辑编码组成一张映射表，而且每次写入还要实时更新每一个逻辑扇区的状态。这样做的好处是文件系统不需要关注实际的物理设备是机械硬盘还是固态硬盘，只需要发送相同的逻辑扇区读写指令，剩下的就交给机械硬盘或者固态硬盘的主控来处理。</p><blockquote><p>映射表本身也是储存在闪存颗粒上的。</p></blockquote><p>不同的 FTL 算法也会显著影响固态硬盘的 4K 读写速度，由于映射表本身需要频繁读写，所以<strong>固态硬盘通电后映射表通常是要放到缓存上，也就是要占用缓存空间</strong>。如果 FTL 按页映射，那么 4K 读写速度就会比较好，但是映射表会很大，占用很多缓存空间；如果 FTL 按块映射，虽然不会占用太多缓存空间，但是 4K 读写速度会比按页映射差，实际固态硬盘主控 FTL 算法一般是两者的混合。</p><h4 id="垃圾回收机制-TRIM-回收指令"><a href="#垃圾回收机制-TRIM-回收指令" class="headerlink" title="垃圾回收机制&#x2F;TRIM 回收指令"></a>垃圾回收机制&#x2F;TRIM 回收指令</h4><p>另外，我们之前学到<strong>闪存颗粒上的块如果不是空的需要先擦除才能写入</strong>，而且每次产出都会对对应的储存单元造成物理的磨损。所以 FTL 算法还要<strong>保证每次写入的都是新的块而不需要先擦除老的块</strong>，以减少擦写次数提高块的寿命。</p><p>但这样就会造成原本块上的相同数据变成无效（<strong>先把原本块的内容读出来，再和新的数据合并写到另外一个地方，但没有擦掉原本的块，只是在 FTL 表上把原来的块标注为可擦除</strong>），所以主控还负责等到这些有无效数据块累积到一定的数量时，再一次性地把这些块擦除（不同的垃圾回收算法会稍有不同），得到可用的空白闪存块，这个过程就是垃圾回收，也是主控和 FTL 算法的主要工作。</p><p><strong>另外固态还有一个类似的专有机制叫做 TRIM</strong>，这个机制更加极致，如果系统（比如 WIN10）检测到固态硬盘支持这个指令，那么删除数据的时候根本不会发出删除指令，只会建立那个部分的磁盘快照（在空白块建立快照的速度比擦除那一块再写入要快得多），然后把这个快照交给主控，主控就会在空闲时按照这个快照去慢慢擦除对应的块，等擦除完成再通知系统，这样下次系统需要写个数据的时候就可以直接写入对应的块了。</p><p><img src="https://cdn.sspai.com/2021/10/01/d3062fb249cb0c155fa9c572a927b15b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CrystalDiskInfo 可以看到固态一般都是支持 TRIM 指令并默认开启</p><blockquote><p>大部分系统都是默认开启这项功能，以 Windows 为例，我们可以通过在命令行里面输入 <code>fsutil behavior query disabledeletenotify</code> 来查看 TRIM 有没有开启。其他系统也可以搜索一下类似的指令，想要关闭的话也可以通过类似的指令关闭。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/01/f4ea0a073b2f3d6c8b3f21319e195ce1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>通过命令行查看 TRIM 状态，显示已禁用就是开启 TRIM</p><p><strong>通过垃圾回收还有 TRIM 指令，不仅可以大大提升固态硬盘的写入速度，还能让所有块的擦除次数尽量平均，最大化延长闪存颗粒的寿命</strong>。</p><h4 id="控制通道和队列"><a href="#控制通道和队列" class="headerlink" title="控制通道和队列"></a>控制通道和队列</h4><p>为了优化性能，固态硬盘会将闪存颗粒安置在多个通道上，每个通道都有一条 I&#x2F;O 总线来接收输出数据，每个通道也有一个独立的通道控制器负责和主控通讯，并把主控不断发过来的读取写入命令弄成队列，然后一条条交给对应的闪存颗粒执行。</p><p>因为固态硬盘不像机械硬盘有机械结构，<strong>分出多条通道就意味着可以同时执行多条指令，保证固态能发挥最高性能</strong>。而且通道控制器生成的队列也有深度参数，也就是一条队列能有多少条命令排队，<strong>现代的 NVMe 固态硬盘使用的 NVMe 协议可以支持到几万条队列，每一个队列更是有几万个命令深度，所以可以同时支持上亿条读写命令，这也是 NVMe 固态硬盘顺序读取能达到 8GB&#x2F;S 的重要原因</strong>。</p><h4 id="纠正-bit-翻转错误的-ECC-算法"><a href="#纠正-bit-翻转错误的-ECC-算法" class="headerlink" title="纠正 bit 翻转错误的 ECC 算法"></a>纠正 bit 翻转错误的 ECC 算法</h4><p><strong>检查并修正闪存颗粒上储存单元的错误也是主控非常重要的一个工作</strong>。如果我们查看闪存颗粒针对企业的说明书，会发现上面还有一个重要的名词 —— <strong>（R）BER（Raw Bit Error Rate）</strong>，也就是 bit 翻转率。</p><p>上一章和这一章我们都多次提到，浮栅中的电子是会慢慢穿过绝缘层「越狱」跑掉的，这会导致读取时读到错误的数据，比如 SLC 一个储存单元写入了代表 0 的电子量，因为绝缘层磨损太严重，时间太久，或者环境温度太高等原因，里面的电子慢慢跑掉了大部分，那么在读取到这个储存单元的数据就会变成 0，那就是所谓的 bit 翻转。</p><p><strong>BER 指的是一个储存单元出现错误的概率，RBER 指的是没有纠错算法时一个储存单元出现错误的概率</strong>。为了防止错误的发生，每次写入数据时主控都会将额外的校验码写到闪存页的额外储存区中，然后定时用校验码配合 ECC 纠错算法检查错误，<strong>如果发现某个储存单元发生了错误，纠错算法就会用校验码算出这个储存单元正确的数据重新写入</strong>。</p><p>由于需要经常纠错，并且每次都有大量的储存单元需要检测，<strong>一般会在主控内做一个专门用来纠错的硬件 —— 纠错码引擎</strong>，包含很多编码器和解码器，也是可以并行计算提高效率。</p><p>RBER 是衡量闪存颗粒品质的一个重要特性，也会随着闪存颗粒擦写次数的增加造成绝缘层磨损而变差，呈指数分布。</p><p><img src="https://cdn.sspai.com/2021/10/01/21e974a6e49ad1df2bd3371c15e45a1d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>固态硬盘擦写次数和 RBER 的指数分布对应关系</p><p>当一个储存单元经过纠错算法纠错之后，很快又再次出错，这个储存单元就相当于没救了，<strong>UBER（Uncorrectable Bit Error Rate）就是指发生不可纠正错误的几率，当 UBER 大到一定程度我们就可以说这个闪存颗粒报废了</strong>，当所有闪存颗粒的 UBER 都达到一定程度，那么这个固态硬盘就报废了。</p><p>其实不仅是写入，每个闪存块如果读取多了也会让里面的电子量改变，从而导致数据出错，这个问题叫做<strong>读干扰</strong>。</p><blockquote><p>这里也可以看出 TLC&#x2F;QLC 由于状态太多，更加容易出现纠错算法都纠错不来的错误。</p></blockquote><h4 id="控制缓存-模拟-SLC-缓存"><a href="#控制缓存-模拟-SLC-缓存" class="headerlink" title="控制缓存&#x2F;模拟 SLC 缓存"></a>控制缓存&#x2F;模拟 SLC 缓存</h4><p>我们前面也有提到固态硬盘厂商为了成本与性能之间做个权衡，会在固态硬盘上放一个 DRAM 颗粒或者让一部分闪存颗粒模拟 SLC 来做缓存，读写数据的时候先写入缓存，空闲的时候再让缓存写入其他速度没那么快的颗粒。</p><p>用 DRAM 作缓存通常是 1GB：1MB，这种方式比较好理解，为了防止断电掉数据，很多固态硬盘也加上了电容来给断电之后有时间让缓存数据写到闪存颗粒上，所以 DRAM 缓存没啥缺点。但是现在很多固态硬盘已经是没有 DRAM 缓存，所以我们仔细讲讲动态模拟 SLC 缓存。</p><p>上面我们也学到了 SLC 和其它类型储存单元物理上使用的是一样的浮栅储存单元，所以<strong>厂家就想到干脆牺牲一部分容量把 MLC&#x2F;TLC&#x2F;QLC 固态硬盘的一部分模拟成 SLC，把这部分 SLC 当做缓存来用</strong>。这样厂商就能节省下一个比较贵的 DRAM 颗粒同时让固态硬盘又能小一点点，总体成本下降不少（至于售价降不降，那就看厂商的良心了）。<strong>很多业内人士和评测博主都不会给没有 DRAM 的固态硬盘太好的评价</strong>，因为 DRAM 缓存和 SLC 缓存两者的速度差别实在太大，同时用闪存颗粒的一部分用来做缓存也会让闪存颗粒寿命更短。</p><p>当固态硬盘使用 DRAM 时，主控还负责动态调整 SLC 缓存的空间。毕竟如果固定用一块地方做 SLC 缓存，每次读取写入数据都要过这部分，质量再好的闪存颗粒也会瞬间暴毙。所以<strong>主控一般会动态分配不用的块作为 SLC 缓存，用一段时间之后再清除 SLC 缓存上的所有数据恢复成 TLC&#x2F;QLC 等其它类型（这个过程一般叫做升&#x2F;降级）</strong>。</p><p>SLC 缓存除了速度不够快，还有另一个显著的缺点，那就是<strong>缓存容量会随着固态硬盘剩余容量而减少。</strong>比如一个 256G 的 QLC 固态硬盘，厂商如果分配 30GB 的 SLC 缓存，那就要占用 30*4 &#x3D; 120GB 的 QLC 空间，当用户把这块固态硬盘用到 256-130+30&#x3D;156GB 以后，剩下的空间就不足以分配这么多的 SLC缓存。</p><p>良心点的厂商还会额外加点空间补回来，没良心的厂商直接就破罐子破摔，毕竟用户用到 156GB 以后可以通过减少 SLC 缓存容量的方式让用户继续装数据，不过这样子固态硬盘速度就会越来越慢，最后变成 QLC 的真实速度。<strong>很多垃圾固态硬盘被人戏称为大号 U 盘，就是没有缓存以后实际速度会降到连 U 盘都不如，甚至顺序写入都只有几 MB，甚至比不过机械硬盘</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/01/68be0e0c4af0768d39dda83591298943.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>杂牌「大号 U 盘」固态硬盘的缓外速度，图片来源：什么值得买@blackocean</p><p>另外现在还有 <strong>HMB</strong> 等类似的技术，原理就是支持的操作系统可以将运行内存分出一部分来当做固态硬盘的缓存，这样既不用 DRAM 颗粒节省成本，也避免了 SLC 缓存的缺点。<strong>不过目前好像只有 NVMe 固态硬盘加上 WIN10 1709 以上版本才能开启这个技术</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/01/0c51922e9b48e265c151525ab577fbdd.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>我手上的西部数据 SN550 宣传页面就着重宣传了这个技术</p><h4 id="OP-空间"><a href="#OP-空间" class="headerlink" title="OP 空间"></a>OP 空间</h4><p>看完上面那这部分，细心的朋友可能就会发现，<strong>固态硬盘除了用户数据外，还有很多额外的数据要装</strong> —— FTL 映射表、纠错用的校验码、SLC 缓存等等。</p><p><strong>所以厂商通常会把固态硬盘的实际容量做得比标称容量大</strong>，根据良心程度大 5%~30% 不等，也就是说 256G 的固态硬盘真正空间甚至能有 332GB。<strong>多出来的这部分空间就叫做 OP 空间</strong>（OP&#x3D; Over Provisioning，就是额外提供的意思）。</p><p><strong>这部分空间也是动态的，由主控进行调整</strong>。除了放我们上面说的那些额外数据外，当部分储存单元坏掉的时候，主控还负责把 OP 空间里面的容量释放到正常用量里，保证用户能使用的总容量不变。另外<strong>多出一部分空间来平衡擦除次数，也可以一定程度上延长固态硬盘的寿命</strong>，如果有 30% 容量的 OP 空间甚至可以将固态硬盘寿命延长 50% 以上。</p><p>一些玩固态硬盘的发烧友，所谓的开盘其中一部分操作就是用特殊的工厂软件把这部分空间开出来，获得额外的免费容量。想折腾手上又刚好有空闲固态硬盘的朋友可以自己去找下对应品牌的工厂软件玩一下。</p><p><img src="https://cdn.sspai.com/2021/10/01/f3c2a20421f1c863c8f69114b159f33f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>东芝的固态硬盘管理软件可以很方便地调整 OP 空间</p><p>至于我们如何查看缓存容量和 OP 空间大小，OP 空间一般需要对应品牌的工厂软件才能看到，缓存容量则是要通过实际测试跑出来，下面实际测试部分，我会仔细教大家怎么做。</p><h4 id="主控协议-ONFI-Toggle"><a href="#主控协议-ONFI-Toggle" class="headerlink" title="主控协议 ONFI&#x2F;Toggle"></a>主控协议 ONFI&#x2F;Toggle</h4><p>至于闪存颗粒接口标准和主控之间的交互协议目前则有 ONFI&#x2F;Toggle 两种，厂商也围绕这两个协议组成了联盟，ONFI 协议联盟主要有英特尔，镁光，海力士；Toggle 协议主要有三星和东芝，ONFI 协议主要就是为了对抗三星东芝的垄断而诞生的，背后也有一段故事。这个协议的具体还有它们背后的故事，我在这里就不细说了，感兴趣的朋友可以看看相关文献里面的内容，或者自己去找找。</p><p>看到这里我们已经了解的主控经常用的工作内容，算法越高级每个部分效率越好，而更高级的算法对主控性能的要求就更高。相信大家对主控性能和算法质量的重要性有了更加深刻的理解。</p><p>就像 CPU 需要散热风扇一样，现在固态硬盘主控性能日益提升，和颗粒产生的热量一起已经需要散热马甲来压住，等以后甚至还要给固态硬盘专门准备散热风扇了。</p><p><img src="https://cdn.sspai.com/2021/10/01/21eb428509c6a69c47821ac0236b8f69.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>温度上来后 PCIe4.0 的固态硬盘速度立马就下去了</p><h2 id="其它固态硬盘参数"><a href="#其它固态硬盘参数" class="headerlink" title="其它固态硬盘参数"></a>其它固态硬盘参数</h2><h3 id="P-E（Program-Erase-Cycle）-循环擦写次数"><a href="#P-E（Program-Erase-Cycle）-循环擦写次数" class="headerlink" title="P&#x2F;E（Program&#x2F;Erase Cycle） 循环擦写次数"></a>P&#x2F;E（Program&#x2F;Erase Cycle） 循环擦写次数</h3><p>在固态硬盘部分，我们反复介绍到擦除对闪存颗粒寿命的影响响，<strong>实际上有专门的参数去量化固态硬盘的寿命，就是 P&#x2F;E</strong>。</p><p><strong>一个 P&#x2F;E 就是将整个固态硬盘上所有的块擦除一次</strong>，如果一块固态硬盘产品参数上写着 10000 P&#x2F;E，那就意味着将这块固态硬盘产出 1 万次后，里面的储存单元将无法储存电子，也就是这个固态硬盘的寿命。</p><p><strong>通常 SLC 固态硬盘的 P&#x2F;E 在 100000 次以上，MLC 固态硬盘在 10000 次，TLC 固态硬盘在 3000 次，现在越来越多的 QLC 固态硬盘更是只有可怜的 1000 次以下（金士顿 Kingston，2021.04）</strong>。</p><p>听起来是不是比想象中要少多了，有些朋友甚至会怀疑 QLC 固态硬盘到底能用多久。但上面我们介绍主控工作内容的时候，所有工作内容最后要实现的效果，几乎都有减少块磨损这一项，为了减少磨损做的操作统一起来叫做<strong>磨损均衡</strong>。</p><blockquote><p>原本 P&#x2F;E 指的是每个储存单元擦写一次，但因为有磨损均衡在，优秀的 FTL 算法和 OP 空间让每个储存单元都能尽量平均擦写，所以 P&#x2F;E 就变成了将整个固态硬盘上所有的块擦写一次。</p></blockquote><p>我们用实际场景来看看，假如一个 512G 的固态硬盘，每天写入 20G 的数据，那么：</p><ul><li>SLC 固态硬盘理论寿命在 512*100000&#x2F;20≈7000 年。</li><li>MLC 固态硬盘理论寿命在 512*10000&#x2F;20≈700 年。</li><li>TLC 固态硬盘理论寿命在 512*3000&#x2F;20≈200 年。</li><li>QLC 固态硬盘理论寿命在 512*1000&#x2F;20≈70 年。</li><li>以后普及的 PLC 固态硬盘如果按照现在技术理论寿命在 512*35&#x2F;20≈2年。</li></ul><p>看起来是不是除了 PLC 以外还好，但<strong>所有类型的固态硬盘实际寿命都会更长</strong>。首先每日 20G 的写入量，即使以系统盘来讲也算是比较多的，除非你天天安装卸载很多软件游戏，或者高清影音文件，不然用不了那么多。</p><p>其次按照上面的计算，大家有没有发现<strong>容量越大寿命越长</strong>，所以如果你用的是大容量的固态硬盘，无论是什么类型的颗粒基本都不用担心寿命的问题。<strong>所以很多人买固态硬盘关注 P&#x2F;E 循环擦写次数，其实没有太大意义</strong>。</p><blockquote><p>当然，如果按照另外一种计算方法就会比较惊悚，那就是连续写入，就是 24 小时不断写文件进去固态硬盘，<strong>按照这种计算方法 QLC 只需要三天就会挂掉</strong>。这种场景民用领域比较小众，但还是有的，比如挂 PT 下载或者做监控和直播，这种情况就千万不要选择 SLC 以外的固态硬盘了。</p></blockquote><p>其实固态硬盘写入还有一种叫做<strong>写入放大</strong>的问题，首先就是上面提到的空闲时 GC 垃圾回收还有 TRIM 机制造成的无效数据搬运，增加擦写次数的问题；另外当用户使用固态硬盘大部分容量之后（比如 512GB 用了 400G），只剩下一小部分可用空间来装新数据，如果这个时候用户就不动前面这 400GB 然后不断删除再写入新数据，这个时候主控再怎么做磨损均衡，也只能把数据写在那 100GB 的闪存块里，导致这 100GB 闪存块擦写次数要比剩下的 400G 多得多。就会让固态硬盘实际寿命短不少，剩下这部分空间也容易出现错误，不断纠错导致读写速度下降，<strong>这也是固态硬盘使用容量多之后掉速的原因之一</strong>。</p><h3 id="写入量参数：TBW-DWPD"><a href="#写入量参数：TBW-DWPD" class="headerlink" title="写入量参数：TBW&#x2F;DWPD"></a>写入量参数：TBW&#x2F;DWPD</h3><p>与其关注 P&#x2F;E，写入量更为重要，这点是有厂商背书的。虽然民用固态硬盘一般不会标出预计写入量，<strong>但企业级固态都会标出 TBW&#x2F;DWPD，而且会以这个作为保修的标准之一</strong>。</p><p><strong>TBW（TB Write）</strong>就是固态硬盘的总写入量，一般都会写在厂商保修条款里面：</p><p><img src="https://cdn.sspai.com/2021/10/25/818863d33f5adfa1290c55ee18aa77fe.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>单位就是 TB，一般保修年限和 TBW 以先到的为准。TBW 单位是 TB，别以为普通用户用不了这么多，这里放个只挖了几个月虚拟货币的固态硬盘参数给大家开开眼：</p><p><img src="https://cdn.sspai.com/2021/10/01/a4c40ced1e1b605cd088015221ed9e3d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><img src="https://cdn.sspai.com/2021/10/01/ce9f7ff3df80128fce888f892e259b21.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>挖了几个月矿的西部数据 SN550，读写都快 1200TB 的固态硬盘你见过吗</p><p>更别说企业用户了，所以对于写入量更大的企业用户还有另外一个参数 <strong>DWPD</strong>，这个参数代表每天全盘写入次数，也就是每天写满多少个硬盘容量。</p><p>DWPD 一般只有用料十足卖的贼贵的企业级固态才敢这么标，民用级固态可不敢这么玩，拿我们上面举例的 512GB QLC 固态来讲，与普通企业级硬盘 10DWPD 也就是每天写 10 个盘容量来算：512*150&#x2F;5120&#x3D;15 天，半个月就能把这个盘干废了，所以知道为什么买二手硬盘要小心小心再小心了吧。而企业级固态这么玩还能有几年的保修时长，足以看出颗粒和主控品质的差距。</p><p><img src="https://cdn.sspai.com/2021/10/01/292465236b81e7491bfa362671591141.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>三星关于 DWPD 和 TBW 的介绍</p><p>TBW 除以固态硬盘本身的容量就可以转换为 P&#x2F;E 次数，DWPD 乘以保修时长大概就可以得到 TBW。</p><p>总体来讲，一块闪存颗粒或者说固态硬盘的寿命是以颗粒类型为基底，好的颗粒质量和主控算法能在此基础上让寿命延长。</p><h3 id="查看固态硬盘寿命"><a href="#查看固态硬盘寿命" class="headerlink" title="查看固态硬盘寿命"></a>查看固态硬盘寿命</h3><p>看到这里很多朋友是不是已经迫不及待想知道自己固态硬盘的剩余寿命了，其实固态硬盘主控都帮我们统计好了读取和写入量。<strong>使用 CrystalDiskInfo 这类软件就可以直接看到总写入量和读取量</strong>，然后再查看你的固态硬盘对应的产品参数，结合颗粒类型就可以算出这个固态硬盘的健康程度和剩余寿命。另外说一下 CrystalDiskInfo 左边的健康度其实大概也是这么算出来的，不过偏向保守，实际数值会比这个差，CrystalDiskInfo 显示 60% 以下基本就可以当做寿命快到了。</p><p><img src="https://cdn.sspai.com/2021/10/01/85d191d0b21a2235e5e402aa539b96ae.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CrystalDiskInfo 的健康度和总写入读取量</p><p>按照我用来做系统盘的普通 NVMe 固态硬盘来讲，已经使用了得有两三年了吧，目前写入量 18401GB，换算成 P&#x2F;E 大概是 71，按照 TLC P&#x2F;E 来讲才消耗了 14% 的寿命。这就是我一个日常用户大概的使用情况，所以说与其担心颗粒寿命不如担心一下主控能不能挨这么久，毕竟大部分固态坏掉的都是主控，颗粒还能被厂商回收起来再次利用。</p><p><strong>相关文献：</strong></p><p>[1]. 固态硬盘的主要尺寸标准可以参考全球网络储存工业协会 SNIA 的<a href="https://www.snia.org/forums/cmsi/knowledge/formfactors">介绍</a>。<br>[2]. NVMe 协议以及对应控制器的详细情况，可以参考这份 NVM Express <a href="https://nvmexpress.org/developers/">官方的开发者文档</a>。<br>[3]. 查看储存颗粒详细参数可以上 <a href="https://www.flashinfo.top/">https://www.flashinfo.top/</a> 这个网站或者使用 <a href="https://github.com/iTXTech/FlashMaster">FlashMaster</a>，另外这里也放一份俄罗斯人 Ochkin Vadim 制作的 <a href="https://blog.elcomsoft.com/2019/01/identifying-ssd-controller-and-nand-configuration/">Flash ID 读取工具</a>。<br>[4]. 闪存颗粒的生产过程可以看一下镁光官方在 YouTube 上传的视频<a href="https://www.youtube.com/watch?v=M-wNC3Z3ZX4">「Making Memory Chips – Process Steps」</a>。<br>[5]. ONFI 与 Toggle 协议的介绍可以查看各自的官方文档<a href="http://www.onfi.org/specifications">「ONFI Specifications」</a>和 <a href="https://composter.com.ua/documents/TH58TEG8DDKTAK0.pdf">「TOSHIBA memory Toggle DDR1.0 Technical Data Sheet」</a>。<br>[6]. 各家固态硬盘更新固件，还有开盘的工具：铠侠（东芝）<a href="https://personal.kioxia.com/en-emea/software/storage-utilities.html">固态硬盘固件管理工具 Kioxia Storage Utilities</a>，三星<a href="https://www.samsung.com/semiconductor/minisite/ssd/download/tools/">固态硬盘管理工具 Samsung SSD Magician Software</a>，西部数据<a href="https://support.wdc.com/downloads.aspx?p=279">固态硬盘管理工具 WD SSD Dashboard</a>。<br>[7]. 未来我们能买到的便宜的 PLC 颗粒的<a href="https://www.techpowerup.com/283337/western-digital-may-introduce-penta-layer-cell-plc-nand-by-2025">介绍</a>。<br>[8]. 关于我们常看见的 BiCS4 3D NAND 名词可以参考铠侠（东芝）官方的<a href="https://business.kioxia.com/en-us/memory/bics.html">介绍</a></p><h2 id="测试固态硬盘的实际性能"><a href="#测试固态硬盘的实际性能" class="headerlink" title="测试固态硬盘的实际性能"></a>测试固态硬盘的实际性能</h2><p>了解完对应的参数之后，我们就来到了实际测试环节了。在<strong>这个环节使用的软件和基本参数反映的意义与机械硬盘部分都差不多</strong>，有一些在固态硬盘特性加持下会有一些不同。</p><p>但我们需要知道的是，和机械硬盘直接跑就能获得比较准确的速度不同，<strong>固态硬盘在不同负载和扇区大小的情况下，性能都会有明显的差别</strong>。除此以外，不同的文件系统，不同的CPU，不同的内存主板供电，甚至是不同操作系统的格式化方法等等都会影响到固态硬盘的实际性能，有时候带宽足够固态硬盘也会跑不出标称的性能，<strong>最重要的还是散热，不同的散热对高端固态硬盘的性能有巨大的影响</strong>。</p><p>也正因为如此固态硬盘的标准测试方法，一直都众说纷纭，特别是行业联盟或者业内给出的测试方法往往过于复杂，要求很高，对于普通用户不太适用。这种复杂程度也让固态硬盘的国标测试方法直到最近才出来（GB&#x2F;T 36355-2018，2019 年生效）</p><p><img src="https://cdn.sspai.com/2021/10/01/3f69eadaf34b9fc4d6bc4a00e777b845.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>固态盘测试国标 GB&#x2F;T 36355-2018 封面</p><p>但国标测试方法对普通用户而言还是有点复杂，所以通常用户自己使用的时候，只需要按照我下面给的方法测试一下，接近标称性能就足够了，不过这种波动也成为很多无良厂商混用主控，偷偷更换内存颗粒的借口。</p><blockquote><p>测试环境：AMD 5600X + 华硕 B550M-PRO + 海盗船复仇者 8G*2 3200Mhz，室温 27℃ 空闲固态硬盘无散热马甲（吐槽一下华硕主板 PCIe3.0 M.2 接口有散热马甲，PCIe4.0 M.2 接口反而没有就离谱），新建简单卷关闭文件压缩。</p></blockquote><h3 id="空盘、半盘、满盘测试"><a href="#空盘、半盘、满盘测试" class="headerlink" title="空盘、半盘、满盘测试"></a>空盘、半盘、满盘测试</h3><p><strong>测试方法简单总结就是：空盘，半盘，和满盘测试</strong>。在这部分我们依旧使用 ASS SSD Benchmark 和 CrystalDiskMark 这两款软件。</p><blockquote><p><strong>注意，以下测试基本都是最极端的情况，实际使用情况会比测试结果好</strong>。</p></blockquote><p>我们以 aigo 性价比 SATA 固态硬盘 S500 和高端 NVMe4.0 固态硬盘 P7000 为例：</p><ol><li>首先是两个盘刚刚格式化之后，或者容量为空的时候，开始用两个测试软件跑一次测试。</li></ol><p><img src="https://cdn.sspai.com/2021/10/01/b164f26b2642d3ba172b48138eed1610.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SATA 固态硬盘 S500 空盘测试结果</p><p><img src="https://cdn.sspai.com/2021/10/01/5cb33df2ba524ce68b43c0d4e665feff.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NVMe4.0 固态硬盘 P7000 空盘测试结果</p><ol><li>接下来我们可以用手头上的大文件，比如电影或者游戏安装包等等来把硬盘的容量用到一半，接下来再进行同样的测试。</li></ol><p><img src="https://cdn.sspai.com/2021/10/01/dd2e78cd667c6f8b6ff3c596d18792a3.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SATA 固态硬盘 S500 半盘测试结果</p><p><img src="https://cdn.sspai.com/2021/10/01/b8e3120902482b8a6b00b9a713b47a62.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NVMe4.0 固态硬盘 P7000 半盘测试结果</p><ol><li>最后我们把所有的固态硬盘容量用到只剩 50GB 左右，再进行最后一次测试。</li></ol><p><img src="https://cdn.sspai.com/2021/10/01/3f9a38c40b19fe47abebf50b05a61941.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SATA 固态硬盘 S500 满盘测试结果</p><p><img src="https://cdn.sspai.com/2021/10/01/a33a65eed069ef8a25529ce23d1a9814.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NVMe4.0 固态硬盘 P7000 满盘测试结果</p><p>如果你只想测试不同容量下的日常速度，每次填满到目标容量之后等待 0.5~1 个小时让缓存容量恢复（上面测试就是这种）；如果你想测试固态硬盘缓存外的极限速度，那么这几次测试过程最好是连续的，另外如果你想获得更加准确的数据，可以把软件跑的数据量从 1GB 提升到 10GB，但是测试时间会长很多很多。</p><p><strong>测试过程从头到尾不要让其它硬盘占用带宽，同时建议打开 CrystalDiskInfo 或者类似软件来实时监看固态硬盘温度</strong>，如果温度过高，性能低就不关固态硬盘本身的事了，需要我们自己加强散热。</p><p>之所以我们要这样测试，是因为<strong>厂商对于固态硬盘通常标注的都是空盘 1GB 测试容量下连续读取的速度，也就是最理想情况下最好的那个数据</strong>。我们日常使用基本上不会有这种良好的场景（比如你不会买一个固态硬盘一直让它空着吧，也不会每天都只复制单个 1GB 左右的文件吧）。</p><p>我们分为空盘，半盘和满盘来进行测试，不仅可以<strong>模拟日常使用固态硬盘各个阶段的实际场景，满盘容量加上连续的测试也可以让 DRAM 和 SLC 缓存都被用完，测出真正的缓外速度</strong>，看看厂商的颗粒主控质量。</p><p>如果一个固态硬盘跑分和官方标称的速度差不多，并且空盘半盘满盘三个状态下跑分速度都没有明显掉速，或者只有满盘状态下才会有不严重的掉速，那么这个盘的质量还是很不错的。如果半盘的情况下开始掉速，但不严重，那么这个盘的质量还可以。如果半盘或者写入量大一点就开始严重掉速，那么这个固态硬盘的质量就需要好好考虑了。</p><h3 id="HD-Tune-Pro：测出缓外速度和缓存容量"><a href="#HD-Tune-Pro：测出缓外速度和缓存容量" class="headerlink" title="HD Tune Pro：测出缓外速度和缓存容量"></a>HD Tune Pro：测出缓外速度和缓存容量</h3><p>上一个测试，<strong>算上填满容量的时间需要蛮久的，特别是当一些固态硬盘缓外速度比较慢的时候，整个过程还是挺煎熬的</strong>。而且要进行 5，6 个步骤，还挺麻烦。如果你想要简单直接一点就能测出最好的速度和缓外速度，顺便还能大概估算出缓存容量，那么可以试试使用 HD Tune Pro。</p><p><img src="https://cdn.sspai.com/2021/10/01/5b25a24f4aa3f08cc1e6c965de54e3c4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>HD Tune Pro 界面</p><p><strong>HD Tune Pro 原本是为测试机械硬盘而设计的，所以对于固态硬盘的测试数据仅供参考</strong>。但它有一个优点，<strong>可以设置自动写入不同类型的文件直到达到特定的硬盘容量来测试</strong>。并且测试的结果有很明确直观的图表，这样就很方便，我们看出缓存内和缓存外的速度，<strong>通过跌下来的那一瞬间，我们还可以判断出固态硬盘大概的缓存容量</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/01/42e2c02c91edd5adeb4737118865c18d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SATA 固态硬盘 S500 写速度与缓存容量</p><p><img src="https://cdn.sspai.com/2021/10/01/27e721a72832b05aea179c131d06f7cd.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SATA 固态硬盘 S500 读速度与缓存容量</p><p><img src="https://cdn.sspai.com/2021/10/01/5649addf0651dcd04417f5d6fb175158.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NVMe4.0 固态硬盘 P7000 写速度与缓存容量</p><p><img src="https://cdn.sspai.com/2021/10/01/197daa02b55b0a6b49074253ec899124.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>NVMe4.0 固态硬盘 P7000 读速度与缓存容量</p><p>HD Tune Pro 的使用有一点需要注意，就是需要硬盘没有被格式化而且没有分区，不然选择写入的时候就会提示写入已被禁用。如果已经建好分区卷，可以在 Windows 的磁盘管理里面选择对应的磁盘右键选择删除卷就可以了。<strong>另外软件默认的块大小是 64KB，与其他测试软件对比时块大小要对应才可以</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/01/8e07226b71d2f2a9f65455fa8c6767e0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>对应的固态硬盘要未分配才行</p><h3 id="实际复制测试"><a href="#实际复制测试" class="headerlink" title="实际复制测试"></a>实际复制测试</h3><p>很多同学觉得这样子测试耗时也比较长，不如我直接拿大文件来复制粘贴测试算了。虽然这样子也能测试出实际的使用场景，<strong>但前提是你必须保证大文件所在的原始盘读取速度要大于目标盘的写入速度</strong>，无论你是测 4K 还是连续读写都是一样。比如极端一点，你从一个机械硬盘复制 50GB 的电影到 NVMe 固态，那么你测出来的写入速度就只有 100MB&#x2F;S 左右，之所以使用测试软件，就是因为<strong>测试软件它的测试文件是生成在运行内存里的，速度保证能达到最快</strong>。</p><p>保证原始盘比目标盘快的情况下，我们只需要在原始盘准备大约 30~50G 的单个文件和 1000 个小文件（比如图片或者小说），就可以通过反复复制查看缓存内与缓存外的速度了。</p><p>空盘情况下，如果速度再复制某个文件的时候突然掉下来，那么这时候查看固态硬盘已用容量，大概就是固态硬盘缓存的大小了。</p><h3 id="测试缓外速度的意义"><a href="#测试缓外速度的意义" class="headerlink" title="测试缓外速度的意义"></a>测试缓外速度的意义</h3><p>有些朋友可能会问了，我们日常使用固态硬盘基本都没有这么大的文件或者这么长时间的读写，那么测试缓外速度和缓存容量还有意义吗？</p><p>不管我们自己跑，还是查看别人的评测，缓存容量都是很有必要测试的一项，虽然一般缓存我们用户日常也够用了，通常也不会有很多写入超过缓存大小文件的场景。不过如果是电影文件或者安装系统游戏的时候，还是有可能跑出真实速度，所以我们平时也是要测试固态硬盘缓存外速度的，如果缓存外的速度特别烂，那这个固态用料和厂商的良心也好不到哪里去。而且首先既然缓存是比较快的，那么<strong>同样价格买到的固态硬盘，缓存容量和缓存外速度自然是越大越好</strong>。</p><p>上面几种测试方法，一般都是给用户或者媒体简单测试一下使用的，<strong>想要查看更详细准确的数据或者做更专业的测试，可以使用 FIO 等这类专业的储存设备测试软件</strong>，不过它们通常没有安装包下载，需要自己根据使用平台去编译源代码，使用的时候也是要用命令行，普通用户用我推荐的软件方法去测试就足够了。</p><p><strong>相关文献：</strong></p><p>[1]. 英睿达 Crucial 官方的<a href="https://www.crucial.cn/articles/about-ssd/how-to-test-a-ssd">简单固态硬盘测试方法</a>。<br>[2]. 国家标准 GB&#x2F;T 36355-2018<a href="http://www.gb688.cn/bzgk/gb/newGbInfo?hcno=DDCE6E784463E4131FAA64D63D8E6918">《信息技术 固态盘测试方法》</a><br>[3]. 希捷科技 Seagate 的<a href="https://www.seagate.com/files/www-content/product-content/pulsar-fam/_cross-product/zh-cn/docs/bp-ssd-performance-tp623-2-1201cn.pdf">固态硬盘性能测试方法</a>。<br>[4]. JEDEC 固态技术学会发表的<a href="https://www.jedec.org/sites/default/files/docs/JESD218.pdf">固态硬盘测试标准</a>和<a href="https://www.jedec.org/sites/default/files/docs/JESD219.pdf">固态硬盘负载测试标准</a>。</p><h2 id="机械硬盘和固态硬盘的优缺点及使用场景"><a href="#机械硬盘和固态硬盘的优缺点及使用场景" class="headerlink" title="机械硬盘和固态硬盘的优缺点及使用场景"></a>机械硬盘和固态硬盘的优缺点及使用场景</h2><p>到这里你已经基本上了解完了机械硬盘和固态硬盘的原理结构，还有常见的参数。这一小节我们就来对比一下它们两个之间的优缺点，以及推荐的使用场景。</p><blockquote><p>以下讨论的优缺点均截止于文章发布前，讨论的设备仅限民用普及的储存设备。</p></blockquote><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>尺寸方面固态硬盘十分占优，即使是 2.5 英寸机械硬盘制作成的移动硬盘，加上保护措施等外壳仍然会比银行卡大上不少。而固态硬盘只需要将颗粒和电路板集成度做高，就可以做得非常小，即使是比较大的 2280 NVMe 固态硬盘加上外壳，体积仍然只有机械硬盘的几分之一。</p><p>所以固态硬盘十分适合放到笔记本，平板等等便携式设备里面。而机械硬盘现在的用途越来越偏向大容量的存储设备，比如台式机和 NAS。</p><h3 id="价格-容量"><a href="#价格-容量" class="headerlink" title="价格&#x2F;容量"></a>价格&#x2F;容量</h3><p>储存设备价格通常是以每 GB 多少元为标准。</p><p>机械硬盘方面，随着 16TB 甚至 18TB 机械硬盘的出现，让机械硬盘的每 GB 价格降到了一毛多左右，这个价格是固态硬盘，暂时还追不上来的。</p><p>但是通过使用 QLC 颗粒还有其他一些技术，固态硬盘的价格也迅速下降，现在每 GB 价格低的也只有 5 毛不到。</p><p>容量方面也是类似，目前机械硬盘的容量在 20TB 左右，而固态在 8-12TB，虽然未来两个类型都会有厂商推出更大容量的产品（机械硬盘和固态硬盘都有 100TB 的产品问世了），但高容量都会带来一些妥协的问题，比如机械硬盘的叠瓦和固态硬盘的颗粒速度与寿命。</p><h3 id="写入-读取"><a href="#写入-读取" class="headerlink" title="写入&#x2F;读取"></a>写入&#x2F;读取</h3><p>这方面就是固态硬盘的天下了，机械硬盘的机械结构决定了它的速度达不到太快，每次读取和写入都需要几次等待和物理移动，完成每次请求都要几十毫秒；固态硬盘的全电气化和量子隧穿效应让读写 I&#x2F;O 速度可以达到纳秒级别。</p><p>另外也大家有没有发现，因为读写都是相同的机械结构和类似的原理，机械硬盘是不分读取写入速度的，读取和写入通常都差不多；而固态硬盘因为读写原理和实现方法稍有不同，导致读取和写入速度通常都是不一样的。</p><h3 id="耐用性与数据恢复"><a href="#耐用性与数据恢复" class="headerlink" title="耐用性与数据恢复"></a>耐用性与数据恢复</h3><p>耐用性方面也是固态硬盘比较占优势，还是因为固态硬盘没有机械结构，所以不会因为震动跌落影响工作，把机械硬盘的磁头臂离盘面只有几十纳米，工作的时候一旦跌落或者有大的震动，磁头臂很容易就刮到盘面，直接把触碰部分的数据报废。即使机械硬盘储存数据的寿命比较长，但日常使用的情况下，机械硬盘和固态硬盘的寿命都是以 10 年为单位，所以这方面不用太多考虑。</p><p>但数据恢复方面是机械硬盘的强项，一来是机械硬盘删除数据不是直接删除，而是先标记对应区域可以写入。这样在这块区域没有新的数据写入之前原本的数据还在上面，可以通过特殊的方法提取出来。即使有新的数据覆盖写入，之前的磁颗粒还会残留一些「数据阴影」在上面，技术比较高的数据恢复公司还是有可能恢复数据（详细内容会在数据恢复章节介绍）。</p><p>固态硬盘就不一样了，写入之前需要先擦除块，擦除之后块上的所有储存单元的电子都跑掉了，加上垃圾回收机制和 TRIM 功能会在空闲时把块擦除，所以一旦数据被覆盖，除非第一时间拔出固态硬盘断电，不然基本上是没有可能恢复回来了。SLC 可能还有牛逼的数据恢复公司根据残留电子量推断原来的数据，MLC 以上的多层储存单元基本上没戏了。</p><h3 id="掉速"><a href="#掉速" class="headerlink" title="掉速"></a>掉速</h3><p>机械硬盘和固态硬盘都会掉速，但是原因却不一样。机械硬盘掉速主要是在文件碎片方面，而固态硬盘掉速主要则是因为缓存。但即使固态硬盘用到缓存外，我们日常碰到比较多的情景 —— 4K 读写能力仍然好于大部分机械硬盘。</p><h2 id="机械硬盘换固态硬盘的提升"><a href="#机械硬盘换固态硬盘的提升" class="headerlink" title="机械硬盘换固态硬盘的提升"></a>机械硬盘换固态硬盘的提升</h2><p>很多人认为把机械硬盘换成固态硬盘，然后把系统装在固态硬盘里，只是提升了开机速度，但其实除了开机速度和复制文件变快，整个系统的反应都会因此提升。<strong>原因部分是因为固态硬盘更快的读写速度，但更直接的原因是固态硬盘更高的 I&#x2F;O 数</strong>。</p><p>我们日常在操作系统上运行软件游戏，除了操作系统在不断的调用系统目录里面的各种库文件，软件和游戏本身也在不停的访问自己安装目录里面的文件。</p><p>比如我们 Chrome 浏览器访问少数派首页，表面上看只是一个网页，但浏览器需要加载很多个脚本文件、样式文件、还有网页上的每一张图片等等的各种资源。</p><p><img src="https://cdn.sspai.com/2021/10/01/2e3f892009599dff2ccc8114dedaa5e8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>这些资源不仅数量众多，其实容量也不小，用浏览器的开发者模式就可以看到，每加载一个网页就要往硬盘上写入几十 MB 的数据。资源被加载后，浏览器会先把它们放在硬盘上的一个缓存目录里面，等全部加载完再运行上面的代码并图片显示出来。之前我们学到这几百个小文件考验的是什么？没错就是 4k 读写能力，而固态硬盘的同样时间内完成的 I&#x2F;O 请求是机械硬盘的几百倍甚至几千倍，所以同样的几百个资源，放到缓存目录和读取用时只是机械硬盘的几百分之一甚至几千分之一，<strong>最后我们用户感受到的效果是什么 —— 就是加载网页变快了</strong>。</p><p>你看机械硬盘换成固态硬盘甚至能让网页加载变快。不仅如此，打开关闭软件、登录退出软件、加载保存工程文件、游戏加载地图等等日常操作都会变快不少，综合到用户体验上就是感觉整个系统反应都变快了。</p><h2 id="不同类型硬盘的适合人群和应用场景"><a href="#不同类型硬盘的适合人群和应用场景" class="headerlink" title="不同类型硬盘的适合人群和应用场景"></a>不同类型硬盘的适合人群和应用场景</h2><p>中和机械硬盘和固态硬盘的优缺点，以及日常使用人群的用途，我来给大家讲讲不同类型硬盘适合的人群和场景。</p><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p><strong>影音发烧友和不放到本地就不放心的用户</strong>，那么非常推荐使用机械硬盘，更便宜同时容量更大，尽量不要使用固态硬盘，因为频繁写入颗粒寿命本来就短，而喜欢下载用户很快把剩余容量用到很小，反复擦写剩下的部分导致固态硬盘寿命更加短。</p><p><strong>省钱专家&#x2F;办公用户</strong>，不是所有用户都需要很快的速度，如果你的需求只是组一台用来办公或者轻度影音娱乐的电脑，不玩游戏，偶尔看看电影，那么固态硬盘也是一个不必要的选项，毕竟垃圾固态硬盘便宜，小容量的机械硬盘更便宜。</p><p><strong>工程专业&#x2F;安防监控</strong>，工程专业的学生或者业内人员往往会有一大堆像鬼那么大的工程文件，这个时候同时满足大容量优先和 4K 读写能力没有那么重要两个条件，机械硬盘就是一个不错的选择；另外像是安防监控这些需要不停连续读写，容量满之后还要滚动擦写的领域，上面我们已经提到了固态硬盘连续读写寿命能有多短，机械硬盘就是唯一选择。</p><p><strong>NAS 和数据仓库</strong>，这是机械硬盘另一个典型的应用场景，就是容量大 + 断电保存 + 数据安全，毕竟固态硬盘一旦出错或者误删除里面的数据基本就不用期待着能找回来了。同时机械硬盘的磁化是永久的，同时固态硬盘断电之后闪存颗粒里面的电子会慢慢流失，QLC 固态硬盘在实际生活中往往几年后就会开始丢失数据。</p><blockquote><p>可以使用像 aigo  <a href="https://detail.tmall.com/item.htm?spm=a1z10.4-b-s.w4004-17546965513.9.c09f59437Xz7gH&id=643489383988">H809</a> 这样的 2TB 移动机械硬盘，不仅花一点钱能装很多数据，也能随时带走。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/01/e690bfe0bdd7c0500175d258316273f2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo H809 2TB 移动机械硬盘</p><h3 id="SATA-低速固态"><a href="#SATA-低速固态" class="headerlink" title="SATA&#x2F;低速固态"></a>SATA&#x2F;低速固态</h3><p><strong>经常出差的商务办公人士</strong>，他们的数据比较重要也比较多，同时经常出差，最好就是把笔记本里面的机械硬盘全部换成固态硬盘，防止经常旅途中的忘记休眠或者关机笔记本的意外和震动让机械硬盘损坏。但他们的关注点主要在数据安全上，不想要 U 盘那么慢的速度但也没有很多大文件需要经常复制，特别是商务人士换设备的频率比较低，用上最新设备的比例很低，这个时候 SATA 接口的固态硬盘就是一个很实惠的选择。</p><p><strong>固态硬盘当移动硬盘用的人</strong>，很多人需要更高速度更耐用的移动硬盘，同时现在除了雷电接口其它接口的速率上限往往不高，即使是 USB3.1 接口速度上限也只有 1.25GB&#x2F;S，用 SATA 接口的固态硬盘加上硬盘盒作为移动硬盘使用就很合适。其实市面上很多固态移动硬盘产品就是这样做的，拆开外壳以后就是完整的一个 SATA 固态硬盘。</p><p><strong>旧机升级</strong>，直到现在仍然有很多人在使用没有 M.2 高速储存接口的设备，比如给父母用的电脑或者学校教室用的教学电脑，虽然不需要很快的读写速度，但又想提升现有设备的体验。这个时候就可以先上低速固态，低速只是相对于高端固态来讲，对比机械硬盘仍然是几十倍的提升，能够明显提升旧设备的反应速度。</p><p><strong>单机游戏玩家</strong>，这是低速固态硬盘的一个经典使用场景 —— 储存不太重要的数据，同时对读写速度都有要求。单机游戏容量越来越大，同时主机游戏玩家也在追求更好的游戏体验，用低速的固态硬盘就能获得几百倍与机械硬盘的 4K 读写能力，同时用较低的价格获得较大的容量。</p><blockquote><p>所以像是 aigo <a href="https://detail.tmall.com/item.htm?spm=a220o.1000855.0.da321h.39711e29AtWCpC&id=614088996011">固态硬盘 S500</a> 或者 aigo <a href="https://detail.tmall.com/item.htm?spm=a1z10.4-b-s.w4004-21649478661.9.c09f59437Xz7gH&id=604273181004">移动固态硬盘 S7 Pro</a> 这样子的设备就很适合上面几种用户了。比银行卡还小的体积加上轻薄机身，固态硬盘不怕摔不怕晃，价格便宜同时拥有优秀 4K 读写能力加上 1TB 的大容量，既可以做商务人士的第二文档库，也可以做游戏玩家的移动游戏库。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/01/0727957a27897f628a42e25df95ff31f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo 移动固态硬盘 S7 Pro</p><h3 id="NVMe-高速固态"><a href="#NVMe-高速固态" class="headerlink" title="NVMe&#x2F;高速固态"></a>NVMe&#x2F;高速固态</h3><p><strong>系统盘&#x2F;移动系统盘</strong>，我们用计算机就是在用操作系统和各种软件，所以系统盘一定要用你预算以内能买到最快的固态硬盘，插在你主板上最快的接口上。最近所有储存设备再快也快不过处理器和运行内存，完全没有性能过剩的问题，能买多快使用体验就能提升多少。</p><p><strong>摄影师&#x2F;数字画家</strong>，对于摄影师和数字画家这种，靠影像来工作的人，随着工作经验的积累带来的还有成千上万张图片。这个时候连低速固态硬盘都已经满足不了需求，必须上高速固态硬盘才能让工作流变得流畅。</p><p><strong>影视行业人士&#x2F;音乐工作者</strong>，对于影视行业和音乐工作者这种专业领域来说，经常需要加载大量的素材，不仅容量大数量还多，对储存设备读写速度还有 4K 能力都有极高的要求，基本上都是能上多好就上多好，毕竟在专业领域速度快一点，赚钱就多一点。另外固态硬盘还有一个优点就是安静，没有机械硬盘那种咔哒咔哒的读取声音，能够让创作者更好地集中注意力。</p><p>其实对于所有工作需要经常和数字设备打交道的人来讲，都应该选择尽量快的固态硬盘。毕竟效率就是金钱，对于效率提升赚来的钱来讲，高速固态最大的缺点 —— 贵，也就显得微不足道了。</p><p><strong>重度&#x2F;职业游戏玩家</strong>，对于重度游戏玩家和职业选手来讲，高速固态就意味着进入游戏更快，加载地图更快，死掉之后重生更快，传送更快，经常玩游戏的话不仅能省下可观的时间，也能让玩游戏更加舒服。现在的游戏也越来越偏向高速固态优化，像是 PS5 和 XBox 今年都以超高速固态、无缝切换地图和快速恢复游戏为卖点，以后超高速固态将会成为游戏玩家的刚需。</p><p><strong>不差钱的土豪</strong>，最后一种自然就是各位不差钱的土豪了，什么原理结构通通都不重要，直接上最贵的。至少在储存设备这个领域，最贵的就是最好的这句话大部分时候是适用的，所以各位不差钱的土豪们直接上最好的就行。</p><blockquote><p>高速固态可以试试 aigo 的 <a href="https://detail.tmall.com/item.htm?spm=a1z10.4-b-s.w4004-23568267321.6.43b73cb0vQsupq&id=638731549233">P3000</a>&#x2F;<a href="https://detail.tmall.com/item.htm?spm=a1z10.4-b-s.w4004-23989685494.3.43b73cb0vQsupq&id=654490003005">5000</a> 系列高速 NVMe 固态硬盘，甚至可以直接往 PCIe 槽插一张 P3000A 企业及固态，什么都不用介绍了，想要用比较低的价格买到参数比较顶级的固态，选这几个很 OK。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/01/317a45d9b9109a942e4f5d615ff87840.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>aigo P5000</p><p>高速固态还可以更好地战未来，比如等未来微软的 Direct Storage 普及之后，PCIe4.0 的重要性就会更加突出，用了一阵子的高速固态还能发挥出更高的性能。</p><blockquote><p>我在查找资料的时候，居然还发现有 <strong>NVMe 机械硬盘</strong>这种神奇的东西。大家也可以去搜一下相关的信息，如果有机会我会把它放到最后一章讲一下。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我用两章的篇幅给大家非常全面地介绍了固态硬盘的原理，结构还有参数，还给大家对比了一下机械硬盘和固态硬盘的优缺点，同时针对不同受众和情景做了推荐。可以说看到这里的你，已经比绝大部分人都要更加了解固态硬盘这个领域了。</p><p>在下一章，我们将介绍运行内存、内存卡、手机内存芯片等其他存储设备的参数原理，接着就要进入大家最感兴趣的选购和使用的环节啦。</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
      <category>数据存储历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>固态硬盘的参数解读与实际性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础篇</title>
    <link href="/Blogs/2025/08/28/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/Blogs/2025/08/28/%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h1><h2 id="定理，定律与命题"><a href="#定理，定律与命题" class="headerlink" title="定理，定律与命题"></a>定理，定律与命题</h2><p>[[定律与定理]]</p><p>命题：描述本质规律</p><p>猜想：未被证明的命题</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>严格证明，没有例外的规律，由推理得出</p><p>逻辑上被证明的命题，在定律的基础上推导出的新规律</p><h3 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h3><p>一般性的规律，由实验得出</p><p>客观规律的统称，反映事物在一定条件下发展变化的客观规律的论断</p><h2 id="自然科学结论与数学结论区别"><a href="#自然科学结论与数学结论区别" class="headerlink" title="自然科学结论与数学结论区别"></a>自然科学结论与数学结论区别</h2><p>数学的每一个结论都是基石</p><p>自然科学结论都是观察得出，有一个反例即可推翻</p><h2 id="数学思维"><a href="#数学思维" class="headerlink" title="数学思维"></a>数学思维</h2><p>从不可能变的事实出发，利用逻辑找出矛盾，最后再设法解决矛盾</p><p>学习数学就是进行逻辑训练</p><h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><h2 id="勾股定理"><a href="#勾股定理" class="headerlink" title="勾股定理"></a>勾股定理</h2><p>定理的提出不是提出特例，而是提出具有普遍意义的陈述</p><h2 id="无理数"><a href="#无理数" class="headerlink" title="无理数"></a>无理数</h2><p>运算的封闭性：前后数的性质保持一致</p><p>通过勾股定律找到等腰直角三角形的矛盾，发现无理数</p><p>很多重大的发现最初都不是直接或间接观测到的，而是数学推理来的</p><h2 id="黄金分割"><a href="#黄金分割" class="headerlink" title="黄金分割"></a>黄金分割</h2><p>美感来于几何图形的相似性（一直切割一直一致）</p><p>扩展到美学与优选法</p><h2 id="数列与级数"><a href="#数列与级数" class="headerlink" title="数列与级数"></a>数列与级数</h2><h3 id="斐波那契数列与黄金分割比"><a href="#斐波那契数列与黄金分割比" class="headerlink" title="斐波那契数列与黄金分割比"></a>斐波那契数列与黄金分割比</h3><p>数列中相邻的两个数的比值是黄金分割比（1.618）</p><p>这种速率与企业增长时能接受的最高员工增长速率相同</p><h3 id="级数：数列变化的趋势比具体数字更重要"><a href="#级数：数列变化的趋势比具体数字更重要" class="headerlink" title="级数：数列变化的趋势比具体数字更重要"></a>级数：数列变化的趋势比具体数字更重要</h3><p>发散：无限多项相加为无穷大</p><p>收敛：相加为有限数</p><h2 id="费马大定理：数学的局限性"><a href="#费马大定理：数学的局限性" class="headerlink" title="费马大定理：数学的局限性"></a>费马大定理：数学的局限性</h2><p>费马大定理：</p><p>除了平方的形式，x^n+y^n&#x3D;z^n这种形式的方程找不到整数解</p><h1 id="贷款与等比级数"><a href="#贷款与等比级数" class="headerlink" title="贷款与等比级数"></a>贷款与等比级数</h1><h2 id="两种还贷方式"><a href="#两种还贷方式" class="headerlink" title="两种还贷方式"></a>两种还贷方式</h2><h3 id="等额本金偿付"><a href="#等额本金偿付" class="headerlink" title="等额本金偿付"></a>等额本金偿付</h3><p>每个月还本金数相同，每个月所还利息随着本金的归还不断减少</p><p>等额本金偿付能少付钱</p><h3 id="等额本息偿付"><a href="#等额本息偿付" class="headerlink" title="等额本息偿付"></a>等额本息偿付</h3><p>每个月所还本金与利息相同</p><h2 id="国债"><a href="#国债" class="headerlink" title="国债"></a>国债</h2><h3 id="连本带息归还"><a href="#连本带息归还" class="headerlink" title="连本带息归还"></a>连本带息归还</h3><h3 id="定期付息"><a href="#定期付息" class="headerlink" title="定期付息"></a>定期付息</h3><p>到期后能用利息再买新的国债，仍能实现利滚利</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础量子与固体物理</title>
    <link href="/Blogs/2025/08/28/%E5%9F%BA%E7%A1%80%E9%87%8F%E5%AD%90%E4%B8%8E%E5%9B%BA%E4%BD%93%E7%89%A9%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E5%9F%BA%E7%A1%80%E9%87%8F%E5%AD%90%E4%B8%8E%E5%9B%BA%E4%BD%93%E7%89%A9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="量子物理基础"><a href="#量子物理基础" class="headerlink" title="量子物理基础"></a>量子物理基础</h3><ol><li><p>​<strong>​能量量子化​</strong>​</p><ul><li>能量离散性（E&#x3D;hν）</li><li>普朗克常数 h 及约化形式 ℏ&#x3D;h&#x2F;2π</li></ul></li><li><p>​<strong>​波粒二象性​</strong>​</p><ul><li>德布罗意关系：p&#x3D;ℏk</li><li>波函数 Ψ 的概率解释：∣Ψ∣2 为概率密度</li></ul></li><li><p>​<strong>​薛定谔方程应用​</strong>​</p><ul><li>​<strong>​无限深势阱​</strong>​：能量量子化 En​∝n2&#x2F;L2</li><li>​<strong>​阶跃势垒​</strong>​：隧穿效应（传输系数 T∝e−2κd）</li><li>​<strong>​矩形势垒​</strong>​：量子隧穿条件（E&lt;V0​）</li></ul></li></ol><h3 id="固体物理与能带理论​​"><a href="#固体物理与能带理论​​" class="headerlink" title="固体物理与能带理论​​"></a><strong>固体物理与能带理论​</strong>​</h3><ol><li><p>​<strong>​晶体结构​</strong>​</p><ul><li>晶胞类型：SC（简立方）、BCC（体心立方）、FCC（面心立方）</li><li>晶面与方向：米勒指数 (hkl)</li></ul></li><li><p>​<strong>​能带模型​</strong>​</p><ul><li>​<strong>​允带与禁带​</strong>​：价带（VB）、导带（CB）、带隙 Eg​</li><li>​<strong>​直接&#x2F;间接带隙​</strong>​：k 空间是否对齐</li><li>​<strong>​Kronig-Penney模型​</strong>​：周期性势场 → 能带形成（E−k 关系）</li></ul></li><li><p>​<strong>​有效质量 m∗​</strong>​</p><ul><li>定义：m∗&#x3D;ℏ2&#x2F;(d2E&#x2F;dk2)</li><li>物理意义：晶格对电子运动的等效惯性</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础量子与固体物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多容器通信</title>
    <link href="/Blogs/2025/08/28/%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1/"/>
    <url>/Blogs/2025/08/28/%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="多容器通信"><a href="#多容器通信" class="headerlink" title="多容器通信"></a>多容器通信</h1><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>项目往往都不是独立运行的，需要数据库、缓存这些东西配合运作。<br>这节我们把前面的 Web 项目增加一个 Redis 依赖，多跑一个 Redis 容器，演示如何多容器之间的通信。</p><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=5">视频教程</a></p></blockquote><h3 id="创建虚拟网络"><a href="#创建虚拟网络" class="headerlink" title="创建虚拟网络"></a>创建虚拟网络</h3><p>要想多容器之间互通，从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了。</p><p>文档参考：<a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h5 id="创建一个名为test-net的网络："><a href="#创建一个名为test-net的网络：" class="headerlink" title="创建一个名为test-net的网络："></a>创建一个名为<code>test-net</code>的网络：</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker network create <span class="hljs-keyword">test</span>-<span class="hljs-keyword">net</span><br></code></pre></td></tr></table></figure><h5 id="运行-Redis-在-test-net-网络中，别名redis"><a href="#运行-Redis-在-test-net-网络中，别名redis" class="headerlink" title="运行 Redis 在 test-net 网络中，别名redis"></a>运行 Redis 在 <code>test-net</code> 网络中，别名<code>redis</code></h5><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">docker run</span> <span class="hljs-literal">-</span><span class="hljs-comment">d</span> <span class="hljs-literal">--</span><span class="hljs-comment">name redis</span> <span class="hljs-literal">--</span><span class="hljs-comment">network test</span><span class="hljs-literal">-</span><span class="hljs-comment">net</span> <span class="hljs-literal">--</span><span class="hljs-comment">network</span><span class="hljs-literal">-</span><span class="hljs-comment">alias redis redis:latest</span><br></code></pre></td></tr></table></figure><h5 id="修改代码中访问redis的地址为网络别名"><a href="#修改代码中访问redis的地址为网络别名" class="headerlink" title="修改代码中访问redis的地址为网络别名"></a>修改代码中访问<code>redis</code>的地址为网络别名</h5><p><img src="https://cos.easydoc.net/46901064/files/kv98rfvb.png" alt="image.png"></p><h5 id="运行-Web-项目，使用同个网络"><a href="#运行-Web-项目，使用同个网络" class="headerlink" title="运行 Web 项目，使用同个网络"></a>运行 Web 项目，使用同个网络</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> -p 8080:8080 --name <span class="hljs-keyword">test</span> -v <span class="hljs-keyword">D</span>:/<span class="hljs-keyword">test</span>:/<span class="hljs-keyword">app</span> --network <span class="hljs-keyword">test</span>-<span class="hljs-keyword">net</span> -<span class="hljs-keyword">d</span> <span class="hljs-keyword">test</span>:v1<br></code></pre></td></tr></table></figure><h5 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h5><p><code>http://localhost:8080/redis</code><br>容器终端查看数据是否一致</p><h3 id="更多相关命令"><a href="#更多相关命令" class="headerlink" title="更多相关命令"></a>更多相关命令</h3><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多容器通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分子生物学与数理逻辑</title>
    <link href="/Blogs/2025/08/28/%E5%88%86%E5%AD%90%E7%94%9F%E7%89%A9%E5%AD%A6%E4%B8%8E%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"/>
    <url>/Blogs/2025/08/28/%E5%88%86%E5%AD%90%E7%94%9F%E7%89%A9%E5%AD%A6%E4%B8%8E%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>这个部分内容在书中篇幅不大，但能看这是侯世达最得意的一个构想</p><p>从低层的基质到高层的智能，这是一个从简单到复杂的<strong>渐成过程 ，让人联想到生物学中从遗传性到表现型的细胞过程。作者想在分子生物学中探寻这种渐成过程的秘密，在智能结构和生命结构中寻找到类似的系统。他在DNA中找到了一种能进行自我反馈的结构，并发现它与TNT数论系统有着高度的同构</strong></p><p>我们在中学都学过DNA通过复制产生DNA双串再有丝分裂进入两个细胞当中，一个DNA双串先分裂成两个单串，随后是碱基配对形成两个新的双串</p><p><img src="https://pic4.zhimg.com/v2-25ec965facef3cda8513a4de947df017_1440w.jpg"></p><p><img src="https://pic1.zhimg.com/v2-42eeb327cb16c88d9d85cc5c22ac1a16_1440w.jpg"></p><p>这个过程是依靠蛋白质完成的，三种酶（解旋酶，催化酶，聚合酶）直接作用于DNA双串执行复制的工作。而蛋白质本身又是经DNA转录，翻译形成，DNA包含了生物体所有信息，显然也包含这三种酶的信息，也就是说DNA是自带复制基因的<strong>自复制的系统</strong>。现在我们把这个系统简化，仅保留DNA复制需要用到的东西：DNA和蛋白质，看看DNA究竟是如何完成自复制的</p><p>蛋白质的形成需要转录和翻译，这就要用到其它蛋白质：核糖体（生成蛋白质），RNA催化酶（转录mRNA）。这时我们仿佛陷入一个怪圈：DNA的复制需要蛋白质→蛋白质的形成需要蛋白质→蛋白质的形成又需要蛋白质→…..这样追究下去，DNA似乎永远也没有办法复制。但事实que不是这样，这些纠缠的关系在细胞中被整合成一种协同作用，所有的东西被一起复制了出来，这系统的魔力。看似简单的组成却包含着我们难以企及的复杂性</p><p>我们难以弄清这种协同是如何发生的，但这能带给我们启发：从遗传性到表现型，从底层算法到高层智能，从无机物到有机物，所有从简单到复杂的过程中，我们都假定在开始时会有一个处在零界点的系统，这个系统的复杂性刚好强到足以支承那种“揪着自己头发往上升”的过程发生。对于细胞，有这么一个刚好强到转录到翻译的过程能够进行的支撑系统，它由核糖体和其它让转录翻译需要的蛋白质组成，它们的协同使自复制可以发生，可以不断地自动地复制下去</p><p>“一个**足够强有力的支撑系统 ，强到可以自我复制”**这是否让你联想到前面介绍的”<strong>足够强有力的形式系统 ，强到可以自我谈论”<strong>没错~作者就是以此构建了分子生物学和数理逻辑学的同构，这两个都是缠结的层次系统</strong>。</strong>画出示意图就能一目了然二者的同构关系</p><p><img src="https://pic1.zhimg.com/v2-bbdd85193a2ddafd081a575686be36e8_1440w.jpg"></p><p>两个系统都有一个可以无限地往上叠加到任意的复杂度怪圈。让人想到智能的异层结构——一个足够复杂的底层基质导致高层的怪圈，而正是这种自己作用于自己的机制能使整体进入不同层次， 让TNT可以谈论自己，让DNA可以复制自己。智能和生命的秘密就隐藏在这里面。作者认为，这二者的同构实际上是同一现象在不同外观下的呈现，本质都是同一种不为人知的规律在操控，支配着宇宙的万事万物</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分子生物学与数理逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同构与层次</title>
    <link href="/Blogs/2025/08/28/%E5%90%8C%E6%9E%84%E4%B8%8E%E5%B1%82%E6%AC%A1/"/>
    <url>/Blogs/2025/08/28/%E5%90%8C%E6%9E%84%E4%B8%8E%E5%B1%82%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>同一事物在不同层次的描述</strong></p><p>证明的第二个关键是“<strong>我</strong>”的表示。自然语言可以用“我”字代指句子，但是数学里只能找其它方式来表示“我”。前面的证明过程还没交代如何表示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">㧟摁&#123;G服 ,n&#125;<br></code></pre></td></tr></table></figure><p>中的<strong>G服，</strong>现在来详细的讲下：</p><p><strong>G服</strong>就是公式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不存在一个a 让&#123;a, n&#125;形成证明对 并 㧟摁&#123;x,n&#125;  <br></code></pre></td></tr></table></figure><p>现在要用<strong>G服</strong>自己带入自己的x，可这要怎么带呢？</p><p>如果直接带进去就成了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不存在... 㧟摁&#123;不存在... 㧟摁&#123;不存在...㧟摁&#123;...,n&#125; ,n&#125; ,n&#125;...&#125;   <br></code></pre></td></tr></table></figure><p>这会是个无限循环的怪圈，没办法写出来</p><p>哥德尔的办法是用<strong>G服的哥德尔编码的TNT数字形式</strong>带入，估计你看到这个名词就不太愿意弄懂它究竟是啥，但我还是简单说下，不想看也可以直接跳过括号：</p><blockquote><p><strong>（</strong>第一步： G服 → G服的哥德尔编码 : 哥德尔编码就是把公式符号用特定的数字指代，比如 <strong>存在</strong> 是<strong>110 ，a</strong> 是 <strong>666， x</strong> 是 <strong>303…</strong> ,所有的TNT符号都有自己的编码数字，那最后G服就能被写成 110 xxx xxx….xxx 这样一连串的数字代码<br>第二步：G服的哥德尔编码 → G服的哥德尔编码的TNT数字形式 ：因为G服全是TNT符号，只能用TNT符号带入，现在把所那一串xxx都变成TNT符号，把数字翻译成TNT的符号，现在110的含义就不是存在了，而就是数字110，用TNT的符号表示110（TNT系统用S+0表示自然数是，1是S0，2是SS0，110就是0前面110个S）翻译完后G服就被写成 SSS…0 SS…0 . . . . . SS…0 ,这才是要带入G服本身的东西<br>所以<strong>㧟摁{x,n}<strong>的意思实际上是：</strong>含有自变量的公式ｘ把自己哥德尔编码的TNT数字形式带入自己的自变量后就是n。</strong>这样的变形可以近似理解为把 <strong>滚 →gun</strong> → <strong>哥屋恩。</strong>还是中文形式，但换一种方式表示。 至于㧟摁{x,n}为什么能表示这么复杂的关系，到底怎么被发明的，你只有亲自翻书书的P589~P592寻找答案了<strong>）</strong></p></blockquote><p>一句话，这里的<strong>G服</strong>变形了，它先后变换形式<strong>两次</strong>后再带入它自己。<strong>这是形式系统可以谈论自己的原因，说白了就是把同一个东西用不同的形式表达，也可以说在不同层次上描述，</strong>而<strong>同一事物在不同层次有不同描述</strong>就是我们的大脑的一种属性！在这个意义上说，哥德尔不完全性定理是我们认识自己心智的一面镜子</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同构与层次</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大脑与同构</title>
    <link href="/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E4%B8%8E%E5%90%8C%E6%9E%84/"/>
    <url>/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E4%B8%8E%E5%90%8C%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>[[同构与层次]]</p><blockquote><p>同构也是本书最重要的概念之一，意为**保存信息的变换。两个同构的事物它们既有差异又有共同点，它们的结构可以相互映射，一个结构的部分在另一个中有相对应的部分，而且其对应的部分在总体结构中起着相似的作用  </p><p>我们能认识事物的意义就是因为同构，<strong>对于同构的认识在人们脑海中产生了意义</strong>。通俗的讲我们看到一个新事物或接收到一条新消息时会把它跟经验里的旧事物做对比，以旧认新，当找到新旧的相似点，发现二者的同构关系时我们才能给新事物一个意义。所有的形式系统也因同构地反应了现实世界才有了意义。比如书主介绍的pq- 系统 ，它的定理长这样：<br>-p-q–<br>-p–q—<br>–p–q—-<br>我会把系统解释为加法，因为每一个符号都能找到准确的解释， 系统和现实世界的加法产生了同构。而同时我们脑中表示pq-系统的符号和过去经验中表示加法的符号发生了关系：</p></blockquote><p><img src="https://pic3.zhimg.com/v2-72ed9b756eb8ff865c89a7022cac147e_1440w.jpg"></p><blockquote><p>pq系统因和加法同构而有意义，它和加法同构是因为我们把它解释为加法。但你也可以把系统解释为其它东西，不同的解释可能产生不同的意义，但前提是要与这个系统存在某种同构关系（如果你把p解释为屁股，q解释为球，- 解释为树，这个系统是没法产生意义的），所以意义不止一种，一千个读者眼中有一千个哈姆雷特就是因为哈姆雷特在不同人脑中同构于不同的事物。  </p><p><strong>人类通过构造同构于世界的形式系统来认知世界</strong> 。物理学家用F&#x3D;ma 来描述自然界的力，化学家用元素周期表反映物质组成，弗洛伊德用本我，自我，超我的模型解释心灵结构。人类认知世界的过程就是人类<strong>在各学科构造形式系统并用其中推演出的定理来描述世界现象</strong>的过程（这句话再出现一遍），这应该更能让你了解哥德尔定理的发现有多么重大的历史意义  </p><p>这里还有个问题：<strong>世上所有的现象都能构建与之同构的形式系统吗？</strong>有没有在本质上毫无意义毫无规律的现象？  </p><p>我们的直觉是有，因为根据经验，生活触手可及的地方都充斥着太多毫无意义的东西，但作者却偏向认为：<strong>世上没有毫无意义的消息，只是你没找到释读的系统罢了</strong><br>作者用数列举例子：<br>7 8 5 3 9 8 1 6 3 3 9 7 4 4 8 ……<br>你可能会认这是毫无规律的随机数列，但实际上它是 pi&#x2F;4的小数部分。这其实就说明自然界的一切现象，不管乍一看多混乱都有可能被形式化  </p><p>我们可以认为<strong>现实世界只为我们提供现象，而发掘意义需要我们找到解释现象的形式系统</strong><br>作者还有个充满决定论意味的猜想：从广义上看，现实世界本身就可以看成一个非常复杂的形式系统，他的符号不是写在二维的纸上，而是在三维空间里运动的粒子。如果真是这样，我们可以设想这个无比宏伟的系统的定理可以推出粒子在宇宙所有时期的所有布局！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大脑与同构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大脑与自我</title>
    <link href="/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E4%B8%8E%E8%87%AA%E6%88%91/"/>
    <url>/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E4%B8%8E%E8%87%AA%E6%88%91/</url>
    
    <content type="html"><![CDATA[<p>知道了同构和符号的概念后我们就要问：自我到底是什么？在我们大脑中的“自我”是什么模样？自我意识究竟是什么？如果没有自我去察觉，这些符号的活动又怎么能产生出意识呢？  </p><p>作者坚持认为意识的涌现已经包含在前面描述的硬件-符号-智能的层级模型里， <strong>自我意识是是大脑中符号层面的东西</strong>，是一个涵盖许多符号的符号集，它具有一定的自主性。可以观察其它的符号的活动，甚至还有表示其它符号的符号。这是一个极其复杂的现象，作者对此有一段哲学化的描述：</p><p><em>“<strong>我一直假定有一个表示自我的子系统。像这样的子系统怎么能保证实际存在与我们的大脑里呢？如果没有自我符号的发展演化，一整套复杂的符号网络———比如我们上面描述过的那种——也能够发展演化吗？如果没有一个表示宿主的有机体符号，这些符号极其活动怎么能实现那些“同构”与周围世界中的实际事件的心理事件呢？进入系统的所有刺激在片刻中都集中在一个很小的空间范围之中.要是没有一个并表示有机体的符号，处于这个有机体中的大脑符号结构就会有一个很显眼的洞，需知，在这个大脑符号结构所反映的事件中，那个有机体扮演着一个比其他对象都更重要的角色。实际上，仔细想一想的话，理解那个围绕着一个生物体的世界的唯一途径，似乎就是在与周围物体的关系中理解这个生物体所起的作用。这就必须要有一个自我符号存在。”</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大脑与自我</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大脑的符号</title>
    <link href="/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E7%9A%84%E7%AC%A6%E5%8F%B7/"/>
    <url>/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E7%9A%84%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p>本书最大的一个疑问：大脑如何通过一堆神经元网络中化学物质的传递而最终产生智能。那种从低层到高层的汇聚是怎么发生的？  </p><blockquote><p>作者的推测是：从物理基质到高层的智能，中间可以看成许多由无数符号构成的符号层 ，<strong>符号是大脑这个复杂系统里的子系统，一切心智活动都是大脑内的符号间的相互作用</strong>  </p><p>我们能思维就是因为脑中有表示现实世界的符号,世界的样貌不是通过感官直接进入意识，而依赖于符号在我们脑海中呈现，我们对现实世界的所有认知在大脑中都有相对应的符号，这种对应是十分复杂而灵活的，并非一个概念对号入座一个符号那样死板。并且符号层是有多个层次的缠结结构，因此一个思想会牵涉到不同层次的符号作用，这让大脑的那些中间层非常难以捉摸  </p><p>思维依赖于符号，符号又依赖于底层物理信号，<strong>神经反应→符号活动→思维概念</strong> 这就是思维的实质</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大脑的符号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大脑和思维</title>
    <link href="/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E5%92%8C%E6%80%9D%E7%BB%B4/"/>
    <url>/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E5%92%8C%E6%80%9D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<blockquote><ol><li>[[大脑的结构]]<br>大脑是一个非常复杂的多层次形式系统！</li></ol></blockquote><p>分岔，无限的分岔是形成智能的基础</p><blockquote><ol start="2"><li>[[大脑的符号]]</li></ol></blockquote><p>大脑的符号感觉应该是理型的世界</p><p>有点像符码与元语言，不单指称具体的某个意义，也包含了解释的规则和框架  </p><blockquote><ol start="3"><li>[[大脑与同构]] 与形式系统的意义<strong>（重点）</strong></li></ol></blockquote><p>同构是保存信息的变换，两个同构的事物它们既有差异又有共同点，它们的结构可以相互映射，一个结构的部分在另一个中有相对应的部分，而且其对应的部分在总体结构中起着相似的作用  </p><blockquote><p>5.大脑是智能所必要的吗？<br>底层的信号发射导致高层符号的激活而产生智能，那高层的活动能否脱离底层的基质？也就是说符号和智能可否不局限于人脑细胞的介质？也许<strong>智能是一种能从硬件中抽取的出来的软件性质</strong>，它具有自身高层的规律。底层的基质只要达到了一定的条件就能汇聚成高层的活动，产生智能，而基质并非要是人脑神经元。以蚁群为例，蚂蚁大脑仅有大约十万神经元，几乎不能承载任何复杂的信息，但它们却可以修筑复杂的蚁巢，可能的解释是：<strong>智能在蚁群整体中产生了！</strong>  </p><p>我们可以把整个蚁群看成大脑，单个蚂蚁不具备智能，却可以担任低层的基质，做机械化的简单工作，而蚁群里的一支蚁队，它们的肢体，气味，移动，所有的共同行为可看成是符号层面的活动，在这个层次上蚁队之间有信息的交流，这种交流活动汇聚成为整个蚁群的智能，一个蚁群可以思考如何建造蚁巢  </p><p>如果产生智能并不非要人脑细胞，这对人工智能事业将会是极大鼓舞</p></blockquote><blockquote><p>6.人工智能与自由意志<br>底层基质的神经信号活动虽然复杂，可都还是由确定的规则支配的活动，因为每条神经细胞的信号传递理论上都可以被确定下来，因此大脑本质上可以看成数学的对象，单个神经元的行为能用计算机描述，那么：<br><strong>大脑活动能用计算机模拟+智能是可抽取的 → 人工智能是可实现的</strong><br>人工智能的研究目的其实不是模拟神经网络，而是实现从其它的基质涌现出智能，从底层硬件基质到低层程序再到高层程序，AI所要研究的就是如何接收上一层次的描述生成下一个层次的描述，但不管怎么说，如果智能的神秘面纱下不过是由加减法支配的线性活动，那AI难道不是指日可待  </p><p>但是机器或者程序要怎样才算有了智能？我们一般认为，机器之所以是机器是因为它只在人给它限定的范围内工作，它不能自己决定自己的行为换句话说，它没有自由意志。那自由意志又是什么？  </p><p>作者推测自由意志是大脑中代表自我的符号与其它符号相互作用的结果，设想如果<strong>一个程序的符号（包括自我符号）能够影响它自己的行为</strong>，它看起来是否就像是有了点自主的意识呢？当程序组快化的“自我”概念出现之后，外界的信息的刺激就会被送到一堆纠缠的符号之中，吞没在自我符号和其它符号的相互作用里，这时候的程序就不能精确地控制它行为的每个细节，因为内部反应变得复杂，它也许开始对自己的工作过程有一种“直觉”，这时候“意义”也许在它的系统里出现，我们就很难说它是不是一个智能体了。系统的漩涡中所有层次相互交错，创造力，意愿，直觉，意识也都会浮现出来。。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大脑和思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大脑的结构</title>
    <link href="/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/Blogs/2025/08/28/%E5%A4%A7%E8%84%91%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1.大脑的结构<br>大脑是一个非常复杂的多层次形式系统！  </p></blockquote><p>分岔，无限的分岔是形成智能的基础</p><blockquote><p>这个系统的最底层是神经元网络，也称大脑的硬件基质，**这一层通过无数化学信号的传递汇聚成高层次的活动，高层的活动又汇聚成更高层的活动，一层层最终上升到顶层就是会思考的智能层次。这种由低到高的汇聚不是按照先后顺序发生的，每个层次的活动其实是同一件事，只是在不同层次看起来（描述起来）不一样，神经网络的活动就是智能层的思考  </p><p>可以把大脑类比计算机，后者也是从底层硬件到高层软件的层次结构。最低层是硬件的电路活动，往上是一层层<strong>组快化程度逐渐提高</strong>的计算机程序，你在打的游戏，你听歌软件。往更高层走那应该就是人工智能啦~</p></blockquote><p><img src="https://picx.zhimg.com/v2-54061d00086e89466416d75ff41524db_1440w.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大脑的结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哥德尔不完备定理</title>
    <link href="/Blogs/2025/08/28/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>数论的所有一致的公理化形式系统都包含不可判定的命题</strong></p></blockquote><p>想看懂这句话得先了解以下几个概念，下面的解释都狭义到刚好足够弄懂这个定理的程度</p><blockquote><p><strong>♤ 数论</strong>：描述自然数（0，1，2…）性质的陈述。。如（3是素数，1792是两个自然数的平方）<br><strong>♤形式系统</strong>：由确定的<strong>推理规则</strong>和特定的<strong>符号</strong>组成的系统，用来反映自然数的性质（这本书提到的都是数论的形式系统，如等下证明会用到的<strong>TNT系统</strong>就是由+，&#x3D;，~，∀等符号（想想高中学过的全称量词与存在量词）还有表示所有自然数的符号组成的）<br><strong>♤</strong> <strong>定理</strong>：形式系统中根据规则推导出来的公式。每一条定理都说了一句关于数论陈述的真话（表述了正确的自然数性质 ，也叫真理，如“1792是两个自然数的平方”就是一条TNT系统的定理，因为这句话是正确的，但是在TNT系统中 这句话是用TNT系统的符号写出来的）<br><strong>♤</strong> <strong>形式系统的完全性</strong>：形式系统中的每一条定理表述了一条真的数论陈述，那如果全世界所有真的数论陈述都可以被一个系统中的定理表述出来，这个系统就是完全的<br><strong>♤</strong> <strong>形式系统的不完全性</strong>：不完全性就是说，有真理不能被定理表述出来</p></blockquote><p>哥德尔不完全性定理：“数论的所有一致的公理化形式系统都包含不可判定的命题“就可理解为：<strong>所有数论的形式系统中都至少有一句话，你没办法判定它是不是定理</strong>（你不能说他不是定理，也不能说它是）</p><p>其实这个句话就是在说：“我不是一条定理”（<strong>我们把它取名为</strong>“G”）**，你没有办法判定是因为</p><p>1.如果G是定理 则<strong>说明它说了一句真话</strong> → 矛盾</p><p>2,如果G不是定理那他就<strong>的确说了一句真话</strong> → 那他就是不能被系统定理表示的真话——系统不完全性的原因</p><p>这里其实就是<strong>说谎者悖论</strong>，说谎者悖论的核心在于其自指星：<br>自指的存在让所有系统都具有不可避免缺陷，<strong>任何系统只要有谈论自身的能力，内部就存在不可消除的矛盾，不完全性成了所有系统的固有性质。</strong>这就告诉我们，不能指望有系统可以解决所有的问题，鉴别所有句子的真假，因为他们都是不完全的漏洞系统。因此在物理学，社会学，哲学或者任何领域，所有构建大一统理论体系的努力是注定要失败的  </p><p>[[证明]]</p><p>[[意义]]</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>哥德尔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哥德尔不完备定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定律与定理</title>
    <link href="/Blogs/2025/08/28/%E5%AE%9A%E5%BE%8B%E4%B8%8E%E5%AE%9A%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E5%AE%9A%E5%BE%8B%E4%B8%8E%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数学的线索"><a href="#数学的线索" class="headerlink" title="数学的线索"></a>数学的线索</h1><h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><h3 id="命题-1"><a href="#命题-1" class="headerlink" title="命题"></a>命题</h3><p>一个判断句的语义（实际表达的概念），这个概念是可以被定义并观察的现象</p><h3 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h3><p>相信为真但未被证明的数学陈述</p><h3 id="定律-law"><a href="#定律-law" class="headerlink" title="定律 law"></a>定律 law</h3><p>一般性的规律</p><p>通过实验观测得出的命题，使用<strong>归纳法</strong></p><h3 id="定理theorem"><a href="#定理theorem" class="headerlink" title="定理theorem"></a>定理theorem</h3><p>严格证明，<strong>没有例外</strong>的规律</p><p>通过已知为真的命题推理得出，使用<strong>演绎法</strong></p><p>被证明的猜想</p><h2 id="证实与证明"><a href="#证实与证明" class="headerlink" title="证实与证明"></a>证实与证明</h2><p>自然科学认可观察得到的规律</p><p>数学的结论必须由定义与公里推出，需要严格证明</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>定律与定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称矩阵</title>
    <link href="/Blogs/2025/08/28/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5/"/>
    <url>/Blogs/2025/08/28/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="对称矩阵与二次型​​"><a href="#对称矩阵与二次型​​" class="headerlink" title="对称矩阵与二次型​​"></a><strong>对称矩阵与二次型​</strong>​</h3><ol><li><p>​<strong>​对称矩阵性质​</strong>​</p><ul><li>特征值为实数，特征向量​<strong>​正交​</strong>​ → 可正交对角化 A&#x3D;QDQT（Q 正交矩阵）</li><li>主元符号与特征值符号一致（惯性定理）</li></ul></li><li><p>​<strong>​二次型 xTAx​</strong>​</p><ul><li>​<strong>​对角化​</strong>​：xTAxx&#x3D;Qy​λ1​y12​+⋯+λn​yn2​</li><li>​<strong>​正定判定​</strong>​：所有特征值 &gt;0 或所有顺序主子式 &gt;0</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对称矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器体系拓展</title>
    <link href="/Blogs/2025/08/28/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E6%8B%93%E5%B1%95/"/>
    <url>/Blogs/2025/08/28/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数字存储完全指南-01：储存设备的诞生与历史"><a href="#数字存储完全指南-01：储存设备的诞生与历史" class="headerlink" title="数字存储完全指南 01：储存设备的诞生与历史"></a>数字存储完全指南 01：储存设备的诞生与历史</h1><p>2021 年 10 月 09 日</p><p>这是少数派与<a href="https://www.aigo.com/">国民好物 aigo</a> 联合推出的信息储存设备的科普系列文章。作为国内早期的存储设备制造商及佼佼者，感谢 aigo 对本文提供的一系列支持，包括但不限于技术知识指导、市场难寻的老物件以及作者用于拆解介绍的最新产品等。</p><p>我们希望通过最简洁通俗的描述，带领大家了解信息储存设备的基本原理，知道那些复杂的参数，如何挑选购买适合自己的存储设备，又是如何更好地使用，更安全稳定地保存我们的数据，以及未来我们能够用上什么技术。 另本系列虽然与 aigo 联合发起，但所有内容不涉及任何品牌指导或要求的商业营销。</p><hr><p>从宇宙大爆炸开始，信息不断产生而又转瞬即逝；当某个原始人将自己被火熏黑的手掌按在岩壁上，便主动存储下了属于人类的第一份信息。人类不断增速的发展，离不开越来越成熟的信息储存读取手段以及越来越先进的存储设备，它们让我们能够稳定地继承先人的知识，储存我们大脑放不下的信息，更好地工作、娱乐、生活，并将我们这一代的成果传承给下一代。随着数字时代进入成长期，与数字信息打交道占据了我们生活越来越多的百分比，而信息的储存设备也变得越来越复杂多样。</p><p>本系列文章就是为了帮助你了解信息世界的储存<strong>（亦作存储，下同）</strong>设备而生，系列将分成过去、现在、未来三部分，用大约十几篇文章，15 万字左右的篇幅，让你了解信息<strong>储存设备的基本原理</strong>，知道那些<strong>复杂的参数都是啥</strong>，<strong>如何挑选购买</strong>适合自己的存储设备，又是如何<strong>更好地使用，更安全稳定地保存我们的数据</strong>，以及未来我们能够用上什么技术。我想实现的最好的目标就是，把这个系列打造成中文区想要了解购买使用储存设备的朋友必看，而且能够毫无难度地理解并打开整个储存设备的新世界大门。</p><p><img src="https://cdn.sspai.com/2021/09/12/f63c35849800ce5f3cd73eacce085692.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>储存设备大合集</p><blockquote><p>提示：本系列的内容老少皆宜，其中购买与使用部分以家用和小型商业用途为基础，大家可以根据自己的用途和侧重点来看相关的部分，而不用担心某些内容太复杂或者不适合自己，看自己想要知道的就行。部分页面失效可以复制网页链接去 <a href="http://wayback.archive.org/">Web Archive</a> 查看历史版本。</p></blockquote><blockquote><p>感谢 aigo 爱国者为为本系列文章提供部分设备。未注释图片来源于 Unsplash 等免费图片分享网站。</p></blockquote><p>好了，接下来我们即将开始正文内容，第一章我先带你来了解一下储存设备的基本历史进行热身，看看那些属于不同时代回忆的储存设备都是怎么工作的，又有哪些设备能勾起你的情怀追忆。</p><p><img src="https://cdn.sspai.com/2021/09/12/41987faa5bd4dac297a984a67a58b6ba.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>桌面上的磁带与 CD 机</p><h2 id="从远古时期开始：挑选储存介质的原则"><a href="#从远古时期开始：挑选储存介质的原则" class="headerlink" title="从远古时期开始：挑选储存介质的原则"></a>从远古时期开始：挑选储存介质的原则</h2><p>还记得我们开头说的岩壁上的手掌印吗？人类从远古到现在，除了数字设备以外常用的储存数据介质（石头、绳子、金属、动物骨头、竹子、蚕丝、纸张等），主要储存方式基本都是<strong>刻和印</strong>，这主要是时代技术的限制，不过也能看出即使条件简陋，人们对信息保存的要求都非常类似，即使到现在也差不多，根据实际经验我们可以总结一下通常挑选储存介质的原则：</p><ul><li><strong>材料坚固容易保存</strong>：身处信息大爆炸时代的我们可能不会想到，在储存设备和储存方式稀少的年代，一般人只有最重要的信息才会使用介质保存下去，所以通常人们都会选择身边最结实的东西，这也导致了直到纸张和墨水出现前，很长一段时间内储存介质的修改是比较困难的。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/f796a60788ea209c2932ef7356d7d96a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>龟壳拓印下来的内容</p><ul><li><strong>储存信息鲁棒性强</strong>：鲁棒性其实就是健壮性，也就是储存介质将信息储存下来之后，能否在一定条件的干扰下保持信息的完整。以前的存储介质一般都不强调要反复修改，储存信息时就宏观改变了介质的性状，加上之前的储存介质一般都比较坚固，这样其实鲁棒性相对现在的设备来讲非常好，比如石头上的刻痕可以历经风霜千万年，即使是看起来脆弱的纸张，也能保持千年不腐。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/3a01c6f2fdf94804d2045dbe65f655e8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>甘肃天水放马滩 5 号墓出土的纸地图，来源：每日甘肃</p><p>后来随着时代的发展，信息的类型还有形式越来越多，所以对存储设备介质的要求也越来越多：</p><ul><li><strong>数据容量&#x2F;材料性价比高</strong>：这点自不必说，随着数字信息的使用越来越广泛，只有容量&#x2F;材料性价比足够高的储存介质，才能被更多人去使用，从而促进对应存储介质的研究发展，形成良性循环。近几年随着科学技术的发展，储存介质的性价比越来越高，从我们以前讨论的每 KB （使用）成本，每 MB 成本，到现在已经可以讨论每 GB 甚至每 TB 成本，都要归功于科学技术的飞速发展。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/7b7ac78302d2d472cf33a0458d113932.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>比如 aigo 爱国者这块 1T 的移动硬盘每 GB 成本只有 5 毛不到</p><p><strong>可以反复修改数据&#x2F;修改数据的成本低</strong>：这也是现在储存介质的基本要求，毕竟信息爆炸的时代已经不像从前，重要信息一次写入介质，其他人只能通过「只读」的方式「访问」信息。比如我们整个虚拟互联网世界，都是靠这些实体的储存设备来维持数据，互联网时代每个人每天都在产生修改删除大量的信息，一个修改数据成本低的储存介质，带来的好处是显而易见的。</p><p><strong>维持数据完整性的成本低</strong>：反复擦写难度越低的储存介质，一般维持数据完整性的难度都会变高，比如我们常见的声音模糊不清的磁带、关机就会丢数据的内存、年代久远的软盘没有数据等等，所以现在很多储存介质都是在反复擦写难度和保存数据完整性难度之间取一个平衡。</p><p><img src="https://cdn.sspai.com/2021/09/12/a698096653780c96ff71dc5fd2f7edc7.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>512MB 的 U 盘已经没办法读取了</p><ul><li><strong>易读取&#x2F;高随机读取性能</strong>：这也是数字时代对储存介质提出的新要求，毕竟之前人类对超出自己能力的信息读取性能要求不大，同时给书本加上目录这种方法也已经能够满足人类自己的随机读取要求，而计算机的出现在某种程度上碾压了人类的大脑，而处理器的速度越来越快，我们同时也需要不断寻找能够配得上处理器速度的储存介质。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/9dd543c950a340aa5a700c16543aef08.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>运行内存 RAM 的速度，以后可能会变成我们的储存设备</p><p>等等等等……</p><p>其实储存介质的挑选原则用一句话来总结就是：<strong>便宜耐操可持续</strong>。由于时代科学技术的限制，以前的存储设备一般都只能满足小部分原则，而现在的储存设备，很多都已经能够满足上面提到的大部分原则。而除了储存介质，数据储存的方式也在不断的变化，从以前主要是实物上刻和印，到现在声、光、电、磁等多种方式应有尽有，未来甚至还能真正实现用生物的方式将信息真正「刻进 DNA 里」。</p><h2 id="改变时代：打孔纸带出现"><a href="#改变时代：打孔纸带出现" class="headerlink" title="改变时代：打孔纸带出现"></a>改变时代：打孔纸带出现</h2><p>你或许见过网上卖的那种小玩具：一个可以换歌的八音盒，只需要插入不同的打孔纸带，就能演奏出不同的歌曲。就是这些不起眼的甚至有一些简陋的打孔纸带，却是人类迈入信息时代的一个里程碑。</p><p><img src="https://cdn.sspai.com/2021/09/12/c544afee6d03cff73682907e611fa1d9.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>可以换歌的八音盒</p><p>早在 17 世纪，第一次工业革命之前几十年的 1725 年，由于农业革命促进生产力的发展和市场的解放，人力的方式已经不能满足市场以及多种方面的需求，人们（主要是那个时候的资本家们）迫切需要让机器自己动起来。有需求自然就有人解决需求，1725 年一个纺织工人 Basile Bouchon 就天才般想到了可以把工作流程数据用打孔纸带记录，然后将纺织机的提针与一个读取结构连接，打孔纸带通过读取结构时，用纸带上有没有小孔来控制提针的提起和落下，从而实现半自动织布，这也是我们现在看到的织布机结构的最初原型。</p><p><img src="https://cdn.sspai.com/2021/09/12/395310b8717584f455d4d82e2e89f045.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>现在看起来很容易懂，当时却是非常精妙，图片来源：Deutsches Technikmuseum Berlin</p><p>打孔纸带出现的意义非常巨大，虽然仍然是刻印类的储存方式，它不仅是人类第一次尝试将储存读取设备应用到工业化中，这种类状态机的思路也为后来设计信息储存设备的大佬们提供了思路，比如后面出现的打孔卡片甚至磁鼓储存器等，直到后面机械硬盘出现前还广泛用于各个行业。</p><p><strong>相关文献</strong>：<br>[1]. 那个年代还没有现代专利系统，要了解更多相关知识的小伙伴可以看看这篇 <a href="https://www.polyomino.org.uk/computer/ECMA-10/">ECMA 打孔带数据交换标准</a></p><h2 id="硬盘的雏形：磁鼓储存器"><a href="#硬盘的雏形：磁鼓储存器" class="headerlink" title="硬盘的雏形：磁鼓储存器"></a>硬盘的雏形：磁鼓储存器</h2><p>接下来我们看看储存设备历史上另一个重要的发明。时间跳到 1932 年，Gustav Tauschek 在奥地利发明出了现代硬盘的前身：磁鼓储存器，利用我们初中就学过的磁生电与电生磁现象巧妙地实现了对数据的储存读取。</p><p>先来看一下它的结构：</p><p><img src="https://cdn.sspai.com/2021/09/12/6380fb3df448a50fa9afd22a3fb0dced.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁鼓储存器的结构</p><p>如果之前已经了解过机械硬盘原理的小伙伴，就会发现磁鼓储存器的原理和机械硬盘已经非常相像了。中间那一条圆柱形就是储存数据的地方，周围那一圈圈的就是很多个磁头，圆柱形的外表有一层铁磁材料，圆柱体就是磁鼓筒（相当于机械硬盘上的盘片）会不断旋转。</p><p>想要读取或者写入某个数据的时候，只需要等待磁鼓筒对应区域转到对应磁头底下，<strong>磁头通过磁生电感应底下区域的磁性，或者通过不同电压改变底下区域的磁性来实现读取或写入信息。</strong></p><p><img src="https://cdn.sspai.com/2021/09/12/4c6754f02592af117cb558f00b25a80b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>看看实物的照片就更加容易理解了，原视频 Youtube@TilTuli</p><p>相比起之前刻和印的方式，磁鼓储存器创新性的采用了磁性的方式储存信息，比起之前的存储设备，<strong>由于磁头的顶端可以做到只有针尖般大小，磁化的区域非常小</strong>，所以整个磁鼓筒可以塞下密度非常高的数据。</p><p>高密度的存储磁鼓储存器的容量来到了惊人的 <strong>62.5KB</strong>，而且由于中间磁鼓筒可以转得很快，读取速度也非常可以（型号 USSC90，磁鼓筒每秒能转 300 圈，最高能够达到 <strong>60KB&#x2F;s</strong>的读写速度，相当于一秒就能够把自己全部的容量读一遍）。对比起之前出现的储存设备，这个简直可以说是质的飞跃，能够满足科技进一步发展的需求。也是因为如此，之后大部分储存设备的原理都向光、电、磁能够精确改变微小区域的方式发展。</p><p>其实，作为一项可以说是跨时代的发明，磁鼓储存器的出现其实是比较晚的，甚至晚于我们接下来介绍的磁带。这中间还有出现过水银延迟线、等其它储存设备。虽然速度很慢，容量很小，但是为人类科技发展的「飞轮效应」跨过了最初的困难。</p><p><strong>相关文献</strong>：<br>[1]. 对这项改变世界的发明感兴趣的小伙伴可以阅读 Gustav Tauschek 本人 1932 年的<a href="https://history-computer.com/Library/US1880523.pdf">磁鼓储存器专利</a>。</p><p>[2]. 一个很有代表的磁鼓储存器型号：USSC90，这是<a href="http://www.ussc90.nl/drum.htm">它的参数和原理介绍</a>。</p><p>[3]. 动图截取自 Youtube@TilTuli 的视频，大家可以看看完整版，点击<a href="https://www.youtube.com/watch?v=eIpoA7Ir9p8&t=31s">「1950’s Early mechanical “Direct Access” Drum Memory Storage」</a>观看</p><h2 id="时代的记忆：磁带与黑胶唱片"><a href="#时代的记忆：磁带与黑胶唱片" class="headerlink" title="时代的记忆：磁带与黑胶唱片"></a>时代的记忆：磁带与黑胶唱片</h2><p>前面所介绍的储存设备，可能我们都不是非常的熟悉，甚至于我们家里的长辈也都不太熟悉。但是接下来介绍的这两个设备，那一定是很多人青春的回忆了。它们都曾经是全世界音乐最流行的载体，但最后一个变为音乐爱好者的珍宝，一个却至今仍然是商业领域热门的储存设备。</p><h3 id="黑胶唱片"><a href="#黑胶唱片" class="headerlink" title="黑胶唱片"></a>黑胶唱片</h3><p>作为一个 90 后，相信同龄人和我一样，通常只能在影视剧里面看到这些顶着大喇叭的留声机和黑胶唱片机。最近怀旧风潮兴起，可能大家也会在视频网站看到一些 UP 主分享一些新式的黑胶唱片机。</p><p><img src="https://cdn.sspai.com/2021/09/12/45fe65aa7c97bf732b48fbca92cb9ac3.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Victor 系列经典的造型与特色的大绿盘</p><p><img src="https://cdn.sspai.com/2021/09/12/4f2dcfc1825ae4d84ce71575a592018b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>唱片店里面的黑胶播放器</p><p>黑胶唱片作为最主要的储存介质，统治了整个 20 世纪的音乐界。留声机作为一种简单的机械设备，最初它不用插电（转盘转动的动力来自于上弦），通过震动直接将声音传导到喇叭放大发声，唱片本身也只是一个简单的塑料片，简直就是便宜耐操的典范。</p><p>黑胶唱片的原理也是一个学习模拟信号基础的经典例子：</p><ul><li><strong>保存声音</strong>：录制机器使用各种方法（振膜传递振动等）驱动一个录音头（就相当于一个小刻刀），录音头在平滑的旋转乙烯基盘片上根据声波振动不同左右震动，刻出一道道深浅不一的同心圆凹槽，直接代表连续的声音变化，凹槽左右边的不同波浪就代表了左右声道的声音变化。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/4e5197c833e1b98544002176714f78c7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>这个录音设备一看就非常直接，图片来源 ：谷歌艺术</p><ul><li><strong>读取声音信息</strong>：唱头上面的针用一定的压力压在唱片的特定位置上，同心圆凹槽左右两边不同的起伏，会让整个唱臂左右摇摆不同的幅度，唱臂里面的电磁铁就会产生不同的电流，放大器放大声音信号并驱动喇叭发出声音。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/1473309c3109afb6f4c7f128c4f643b7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>显微镜可以看到唱针是怎么通过凹槽读取声音的</p><p><img src="https://cdn.sspai.com/2021/09/12/82450fb98d998629142d927a6de1a2bb.gif"></p><p>来个动图，图片来源：Youtube@Applied Science</p><p>就是这么简单直接的一个模拟信息保存传输方式，让音乐不再是贵族们的私人专享，普罗大众从此也能够享受到音乐的愉悦，促进了流行音乐的发展，无数经典的歌曲通过黑胶唱片永久保存下来，让 21 世纪的我们也能够听到 20 世纪的天籁之音。</p><p><img src="https://cdn.sspai.com/2021/09/12/dfe526cf0f8a15c02cffb9630ff41649.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>经典专辑的黑胶唱片</p><p>经过多年发展，黑胶唱片的材质，尺寸和录音读取方式越来越多样，音频质量也在不断提高，甚至索尼与铁三角等厂家还生产并不断更新数字黑胶播放器。直到现在，很多歌手也会为自己的专辑出一张黑胶唱片用作纪念，同时黑胶唱片仍然被部分音乐爱好者追捧（最近美国销量甚至超越 CD，2021.06，MRC Data），折腾不同的设备和唱针就是为了追求那充满时代特色的温暖声音和爆豆声。</p><p><img src="https://cdn.sspai.com/2021/09/12/23efeaf02d11f90580542e5660ff0490.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>索尼的数字黑胶播放器</p><p><img src="https://cdn.sspai.com/2021/09/12/d5bd7d8885a8e96ccd6395322886ded9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>周杰伦的专辑黑胶版</p><p><strong>相关文献</strong>：<br>[1]. 对黑胶感兴趣的小伙伴一定要搜搜看德意志留声机公司（DG），世界上最大的古典音乐唱片品牌，目前是在环球音乐旗下。它的创始人 Emile Berliner 就是第一个发明声音记录方法和最初唱片的巨佬，可以上<a href="https://www.deutschegrammophon.com/en">官网</a>买一张正版黑胶纪念一下。</p><p>[2]. Emile Berliner 发明的留声机结构，可以查看他自己在 1900 年发表的<a href="https://patents.google.com/patent/US692502A/en">留声机专利</a>。</p><p>[3]. 最早的留声机结构可以看一下 Tomas A Edison（没错，就是那个爱迪生）<a href="https://patents.google.com/patent/US200521A/en">1878 年的留声机专利</a>。</p><p>[4]. 文章黑胶唱片机原理图部分引用自 V.H.Emerson 1916 年的<a href="https://patents.google.com/patent/US1345756A/en">专利</a>。</p><p>[5]. 动图截取自 Youtube@Applied Science 的视频，大家可以看看完整版<a href="https://www.youtube.com/watch?v=GuCdsyCWmt8">《Electron microscope slow-motion video of vinyl LP》</a>。</p><h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><p>相比起黑胶唱片机，磁带与中国人结下的不解之缘更加深，我们爸妈那会儿年轻的时候，买到最新的磁带，然后在房间里偷偷享受属于自己的小世界，或者和朋友一起讨论交换最新的歌曲磁带，怕是普通人最潮最常见的娱乐方式了。有钱人甚至能弄一台最新的索尼 Walkman，成为街上回头率百分百的 GGMM。无论是打孔带还是自己灌录，磁带以及它所承载的音乐成为很多人青春回忆里的重要背景。</p><p><img src="https://cdn.sspai.com/2021/09/12/72a4cb0018a3181d55adc7fe3f4e5f53.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>经典的 Walkman 与磁带</p><p><img src="https://cdn.sspai.com/2021/09/12/91fca407b58357d423b4aeba175ee166.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>经典的磁带歌曲</p><p>即使是我们这一代人，小时候其实都有被学英语磁带支配的酸爽。不过就跟学习机最后大部分沦为游戏机一样，磁带机最后大概率会变成播放器。</p><p>那个时候比较经典的磁带怕就是 TDK C60（C+数字 指两面合起来能够录制这么多分钟，C60 也就是每面 30 分钟） 磁带了，不仅能录制最高一个小时（根据机器转速不同实际 35-45 分钟）的音乐，还把「高保真」这一个关键词带进了大众视野，甚至能够录制多声道的立体声。</p><p><img src="https://cdn.sspai.com/2021/09/12/5b135d0185d04bb582e041f4a1f79e70.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>TDK 磁带</p><p>其实磁带的声音和黑胶有点像，因为它们的原理其实都是录制模拟信号，所以前期或者便宜的磁带出来的声音会有点失真和沙沙声。而且大家估计想不到除了我们常用的听歌用途外，<strong>磁带还是非常方便和广泛使用的通用储存设备，即使到了现在磁带依然在商业领域被广泛使用。</strong></p><p><img src="https://cdn.sspai.com/2021/09/12/63d61f4b29475051127888d767f95bee.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>IBM 的商用磁带备份机</p><h3 id="磁带的原理"><a href="#磁带的原理" class="headerlink" title="磁带的原理"></a>磁带的原理</h3><p>磁带其实就是一条上面涂上可以被磁化的氧化物材料（通常是氧化铁）的塑料带，平时我们看到它卷起来只是为了减少储存体积的一种方式。再结合我们初中学到的磁生电与电生磁现象就能很清楚地理解磁带的原理：</p><p><strong>储存数据</strong>：磁带上方固定一个磁头，磁头与磁带接触，用滚轮等方式将磁带以固定速度从磁头下方滚过。磁头接收发过来的不同电压数据脉冲（比如麦克风记录到的声音变化，数字磁带机直接发送 0 和 1 ），利用电生磁现象就会产生方向不一样的磁场，那么底下通过接触这部分磁带上的材料被永久磁化的磁场方向也不同，就记录上了数据。</p><p><strong>读取数据</strong>：读取的原理也和储存类似，不过利用的是磁生电现象，不同的磁场通过磁头会产生不同的电流，磁头就可以将这些电流数据交给其它的部分（比如扬声器发声），实现数据的读取。</p><p><img src="https://cdn.sspai.com/2021/09/12/f39d9ab86184fec9950a0399d3bd3f09.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁带的原理示意图，图片来源：TDK 和 IITK</p><p><img src="https://cdn.sspai.com/2021/09/12/ea63e487ba57966bf804ea17aa0ba0c1.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁带的结构</p><p>磁头一般很小，所以数据密度可以很大，同时如果在一个宽度的磁带上，做两个 1&#x2F;2 的宽度的磁头甚至更多个磁头，就可以实现多轨记录和读取（比如磁带录音带的立体声）。</p><p>看到这里大家是不是觉得有点眼熟，没错它和磁鼓储存器的实现思路有点相像，事实上所有以「电磁」方式来储存数据的设备都差不多是这种思路。</p><h3 id="录像带与其它磁带"><a href="#录像带与其它磁带" class="headerlink" title="录像带与其它磁带"></a>录像带与其它磁带</h3><p>我们之前比较少见到的录像带，其实也是一种磁带。不过由于视频数据量和带宽都比较高，录像带一般会做得比较大比较宽，宽度长度大约和胶片差不多，用多个轨道来分别记录红、绿、蓝三个像素信息、同步信息和音频的模拟信号。读取时候旋转的也比较快，而且磁头是螺旋形扫描的。</p><p>除了储存音乐，标准的磁带还曾经被储存各种各样奇怪的东西，比如程序，文本和游戏，只需要一台磁带机就能在电脑上读出数据。在曾经软驱比电脑还贵的那个年代（甚至有厂家直接把电脑塞进软驱），用磁带来储存数据是一个便宜好用的方法。</p><p><img src="https://cdn.sspai.com/2021/09/12/94f12b6f549e6a03bc3b14f76b285f42.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>游戏和录像带</p><p>了解了原理后，我们也不难知道磁带的优点和它为什么会这么普遍使用了：首先磁带用一种很巧妙的方法让保存材料可以变得很轻薄，加上软性材料可以用特殊的方法收纳（比如卷起来），所以磁带可以<strong>在轻、薄、小的同时实现大容量的储存</strong>还能节省材料。</p><p>写入读取结构简单也可以让磁带与磁带机也变得便宜，既可以录入模拟信息，也可以录入数字信息，<strong>同一台机器就可以实现录制还有播放</strong>，通过使用高转速和更加坚固的材料，还可以实现飞快的顺序读取写入速度。另外写入数据是永久改变材料上的磁性，磁带的数据稳定性很不错，只要保存得当，理论上应该能够保存几十上百年。</p><p>所以磁带迅速风靡全球，在很多发展中国家甚至是主要的储存设备（比如很多国家的演讲都是通过磁带翻录传递到民众中）。<del>另一方面也让最早的盗版盗录产业得以发展</del>。</p><p>当然磁带的原理导致它也是有缺陷的，其中最重要的就是<strong>基本只能顺序读取，随机读取能力差到忽略不计</strong>。相信用过磁带的小伙伴都有过想听磁带里面的某一首歌，然后在那边干等它转啊转的经验，特别是想听倒数第二首歌的时候那感觉真是特别煎熬，更别说随机播放了，基本不存在的。</p><p>除了这个比较大的缺陷磁带还有每台设备转速不一样导致声音不一样，转太快崩太紧容易断，磁带磁带机上（俗称吃磁带），用不是空的磁带录制由于磁性改变不彻底会出现声音重复等。</p><p>那么为什么现在磁带仍然是企业冷备份的优先选择呢？</p><p>主要是<strong>LTO 磁带在实现大容量的同时是真的便宜（0.04 元&#x2F;GB，30TB 只要 2000 不到）</strong>，体积还蛮小的，而且只需要简单地增加磁带数量就能够增加容量，大规模数据物理转移的时候磁带的稳定性也比硬盘高很多。而且磁带机通过特殊的驱动也能够避免勒索软件或者病毒修改数据。用来储存一些基本不用的冷数据（比如你 10 年前的银行账单或者各种完成的项目存档）简直完美。</p><p>所以磁带今天仍然是冷备份的优先选择，像是我们常用的支付宝微信支付等金融数据，都是会稳稳地用磁带保存一份冷备份在地下的，<del>就不用担心服务器全部爆炸，自己的余额都不见了</del>。</p><p><img src="https://cdn.sspai.com/2021/09/12/00e47ab12b7edaa5f21f45b31534d52f.gif"></p><p>企业备份的磁带库</p><p><strong>相关文献</strong>：</p><p>[1]. 常见磁带和磁带机的结构可以参考这份<a href="https://patents.google.com/patent/US4365277A/en">磁带机的专利</a>。</p><p>[2]. 想折腾磁带冷备份的小伙伴可以看一下这份<a href="https://www.saac.gov.cn/daj/hybz/201912/1b944990fa1b4d829ac4ca4315ac65d3/files/3eb7a3f6fa434bd9b88483735cee24a1.pdf">《中华人民共和国档案行业标准：档案数据存储用 LTO 磁带应用规范》</a>。</p><p>[3]. 想看看各种商用储存机长什么样的小伙伴,可以去 IBM 提供的各种 <a href="https://www.ibm.com/demos/it-infrastructure/product.html">3D 产品演示</a>。</p><h3 id="磁带和黑胶唱片的沙沙声爆豆声是怎么来的"><a href="#磁带和黑胶唱片的沙沙声爆豆声是怎么来的" class="headerlink" title="磁带和黑胶唱片的沙沙声爆豆声是怎么来的"></a>磁带和黑胶唱片的沙沙声爆豆声是怎么来的</h3><p>如果你听过磁带和黑胶唱片的声音，那么你一定会对沙沙作响的背景声音和爆豆声印象深刻。甚至最近 lo-FI 音乐开始复苏，就是制作音乐的时候主动往音频文件里面加入这些背景声音和爆豆声的采样（所以说时尚是一个圈），那么这些声音都是怎么来的呢？</p><p>对于黑胶唱片来讲，<strong>这些声音主要是来自于唱片的缺陷和表面的灰尘</strong>。以前唱片在压制条件不会很好（没有真空，唱片不干净之类的），导致刻刀没法把声音正确刻在那个部分，播放的时候就会导致失真。同时我们用的唱片机一般唱片直接暴露在空气中，播放时掉落的灰尘会阻止唱针读取到轨道上的音乐信息，从而让音乐失真一瞬间，这就是爆豆声。</p><p>所以当我们小心清理好唱片并用防尘罩盖好播放，会发现爆豆声直接少了大半，甚至<strong>如果你直接用上真空播放器，会发现黑胶唱片的声音也能如数字 CD 般顺滑</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/b572394bb104afe481e31d4733c1897f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>擦拭前后的声波对比，图片来源 Youtube@<br>Vinyl for Miles</p><p>原视频 Youtube@Vinyl for Miles：<a href="https://www.youtube.com/watch?v=fB17BRtqeJQ&t=608s">「Vinyl Vac Full Review - Before and After Audio Comparison!」</a></p><p>而磁带背景的沙沙声就有点高大上了（排除电路噪声），是<strong>各种来源「不规矩」的磁粒子产生的随机电信号</strong>。它们可以是空气中的粒子，可以是磁头精度不够漏掉的粒子，也可以是磁带生产中的磁离子颗粒太粗了……</p><p>提高生产精度和磁粒子的密集程度，或者增加磁带的宽度（增加带宽提高信噪比）都可以减少这种背景噪声提高声音纯净度，那个时候各家磁带厂家宣传的「高保真」就是这个意思。</p><h2 id="数字信息（信号）和模拟信息（信号）"><a href="#数字信息（信号）和模拟信息（信号）" class="headerlink" title="数字信息（信号）和模拟信息（信号）"></a>数字信息（信号）和模拟信息（信号）</h2><p><strong>接下来出现的就是数字时代的设备了，在数字信息出现之前，磁带和黑胶唱片是典型的储存模拟信息的介质</strong>。那什么是模拟和数字信息（包括信号，下同），为什么我们现在都是用数字信息，它有什么优势？</p><h3 id="模拟信息"><a href="#模拟信息" class="headerlink" title="模拟信息"></a>模拟信息</h3><p>我们生活在一个现实世界，<strong>很多信息是无限连续的</strong>，比如我们听到的声音、我们看到的风景、电压电流的变化……如果你把它们细分开来，你会发现它们无穷无尽。所以早期人们如果想通过设备处理和储存这些信息，就必须用另一种可以无限连续的介质去代表它，甚至汽车上的转速表、游戏机上的手柄等都是显示传递模拟信息的例子，所以在存储设备上模拟信息就是<strong>用可储存的机械量的连续改变，模拟不可储存信息的连续变化</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/09f5404a7ff14387bf86ef02d2f122ba.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>模拟信息用电压表示应该是平滑的曲线，没有任何离散值变化</p><p>比如黑胶唱片的轨道和磁带上的磁颗粒信息都是连续的，<strong>我们能够在上面取到无限的值</strong>，而且在每一瞬间它都会有一个确定的值。</p><p>模拟信息的特性让它的优点和缺点都非常明显。</p><p>优点有：</p><ul><li><strong>信息密度和精细度非常高</strong>，毕竟是无限的值。</li><li><strong>非常适合用来记录表示现实世界的变化</strong>，比如最常用到的电压电流、声音、温度、速度等。</li><li><strong>读取和保存都非常容易</strong>，像是磁带黑胶唱片它们的原理其实都非常直观，直接采用宏观的方式就可以写入读取。</li><li><strong>对传输要求比较低</strong>，使用很少的带宽就可以传输相对丰富的信息，像是我们之前的有线电视很多年来都是模拟信号。</li></ul><p>但它的缺点催生出了人们现在主要使用的数字信号：</p><ul><li><strong>很容易受到噪声影响</strong>，<strong>噪声指的是与我们想要处理的信息无关的信息</strong>，由于精度、干扰等问题，在模拟信息中噪音基本不可避免，信噪比（xx dB）这个单位就是用来形容信息&#x2F;噪声的比例，大于 1dB 代表信息比噪声多，所以这个数字越大越好。</li><li><strong>容易产生损耗和干扰</strong>，现实世界不存在绝对稳定的介质，无论是有线还是无线传输和储存，随着距离和时间的增加，模拟信息里面的噪声一定是会越来越多的，这就是我们常说的损耗和干扰。如果因为功率密度等原因保存传输的信息读取时需要放大，那信息的完整性就更差了，因为<strong>放大信息的同时也会放大噪声</strong>。</li><li><strong>与数字设备的工作原理相斥</strong>，这个会在下面介绍数字信号时讲到。</li></ul><p>我们上面说到的沙沙声和爆豆声，其实就是各种意义上的噪声，模拟信号里面的电压电流也会产生噪声，这破坏了信息的完整性与准确性。<strong>最重点的是这些噪声的来源太随机了</strong>，电路里面一个不稳定的电压，空气中的灰尘，不同的材料甚至今天天气的温湿度、不同的宇宙辐射强度，都会让不同设备处理同一段模拟信息时产生不同的结果，比如你小时候在家看西游记，电视上的雪花和邻居是不一样的，<del>所以严格来讲，你和邻居看的是不一样的西游记</del>。</p><p><img src="https://cdn.sspai.com/2021/09/12/de46aa32aa314363d4b98aaadff7a749.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>充满噪点的电视</p><p>噪声越多保存传输的数据越难读取恢复，如果低信噪比的数据来进行科学计算，结果甚至会是反的。随着时代发展人们对于传输速度和准确性的要求越来越高，模拟信号在大部分领域都是无法让人接受的。</p><h3 id="数字信息"><a href="#数字信息" class="headerlink" title="数字信息"></a>数字信息</h3><p>模拟信号的缺点和更高效新设备的出现，促进了数字信号的诞生。我们都知道计算机里面处理和储存的都是 0 和 1 的<strong>有限数据</strong>，这是由处理器晶体管组成的逻辑门物理特性决定的，这代表它们基本没办法处理储存无限连续数据。举个简单的例子，各家编程语言里面都有提供圆周率 兀 作为常数变量，而如果你查看底层代码就会发现，它们都是直接预设一个几十位精度的 兀 值，<del>不然用程序算一个圆的面积就能让电脑爆炸</del>。</p><p>加上现代计算机领域（处理、储存、加密、传输……）基本都是基于离散数学的，对无限连续的数据非常不友好。<strong>这个时候我们就需要按不同精度对现实世界连续的数据进行取样了</strong>，这基本就是数字信息的原理。</p><p>如果说上面模拟信息用电压表示是连续曲线，那么数字信息用电压表示就是一段一段的（虽然每段可能非常短，看起来是连续的）：</p><p><img src="https://cdn.sspai.com/2021/09/12/76aa42da1258c4f04995582af979672b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>简单的理解它们的区别：<strong>如果模拟信息是一条线，那么数字信息就是用很多密集的点尽量完整模拟出这条线。</strong></p><p>举一个我们大家很经常接触的例子，还是音乐。不同于之前设备直接录制声音的连续变化，现代的数字录音机，录制的时候会将声音按照不同的频率采样，比如我们常常听说的 CD 44.1Khz 采样率就是每秒对声音采集 44100 次，记录下每次采集到的信息。</p><p><img src="https://cdn.sspai.com/2021/09/12/3652df4d716dfc7b9cc00f4b3a68c5e8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CD 级音质</p><p>我们听歌的时候，播放器会将这些离散的数据用算法处理成连续的，这样我们就不会听到一卡一卡的歌（其实这就是经常听理科男们说的数模转换了）。采样率还有其他的一些规定采集读取数据的方式合起来就变成了数字信息编码规则，我们经常看到的文件扩展名（.jpg、.mp3、.apk）这些其实就是不同的编码规则，用来规定不同编码规则弄出来的文件怎么放在物理储存设备上，并提供增删查改方法的东西就是我们每天都会用到的文件系统。</p><p>数字信息的优势基本弥补了模拟信号的不足：根本优势是<strong>数字信息把现实世界的各种类型信息统一成一个虚拟层（0&#x2F;1 二进制），实现一种设备处理储存各种类型的信息</strong>。</p><ul><li><strong>噪声非常少，更加准确</strong>，数字信息保存处理的是经过采样的数据，在信噪比低于一定程度的情况下，可以通过把编码和纠错算法逐个纠错把丢失信息完整还原回来。</li><li><strong>通用保存</strong>，不像是模拟信号一般都要对应的存储介质，数字信号经过转换，可以很方便地储存在任何介质上（包括磁带、黑胶、胶卷甚至打孔纸带）。</li><li><strong>复制转换非常简单</strong>，大家都是数字信息，复制转换自然不用说，利用不同的算法还能让数据变成不同类型，比如视频转图片，也能很方便地加密压缩数据。</li><li><strong>处理更灵活</strong>，数字信息让我们能够更方便的处理它们，比如用 Photoshop 编辑一张图片，实际上就是编辑里面虚拟化的像素信息，在之前需要在胶片上物理修改。</li><li><strong>方便远距离传输</strong><br>等等等等……</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/1a50c6c976ffdddb8589c54b39aeca64.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>文件系统其实是很复杂的一样东西</p><p>但数字信号也有属于自己的缺点：</p><ul><li>由于需要附加各种复杂的编码信息，数字信号一般对带宽要求更高。</li><li>对硬件的要求更加复杂，我们能够比较无压力的看懂模拟电路，甚至每个人都能自制一个矿石收音机，但数字电路看起来<del>就跟小学三年级学大学英语那样</del>。</li><li>在硬件层上还要经过复杂的系统和算法处理。</li></ul><p>所以现在模拟信号还是在某些领域被广泛使用，根据它们各自优缺点安排最合适的用途。</p><h2 id="截然不同的命运：软盘与光盘"><a href="#截然不同的命运：软盘与光盘" class="headerlink" title="截然不同的命运：软盘与光盘"></a>截然不同的命运：软盘与光盘</h2><p>虽然我们现在仍然在广泛使用各种光盘，软盘却已经成为时代的眼泪，但软盘和光盘其实兴起于同一个时代，只不过软盘的命运停步于千禧年，而光盘不断焕发新机直到现在。它们都曾经是最广泛使用的储存设备，但最后的结果却相差甚远，这与它们的原理和特点是离不开关系的。</p><p>上面我们了解完了模拟信息和数字信息的变化，由于数据的本质形式发生了变化，人们需要容量更加大同时体积更加小的储存设备，软盘和光盘就是数字信息时代应运而生的载体。</p><p><img src="https://cdn.sspai.com/2021/09/12/bc48c26ff3fac521319b60f39afb30ee.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>光盘和软盘</p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p>光盘在中国的覆盖可谓是全年龄段的，千禧年之后基本家家户户都会有一台先科的 DVD 机，小孩子的童年是《猫和老鼠》《哆啦 A 梦》等等的正（盗）版 DVD，年轻人把落伍的磁带机换掉，用上了随身 CD 播放器听伍佰周杰伦（千禧年左右 MP3 还是个稀罕玩意儿）。爸妈们常备一套新年歌曲合集和交响乐，全家人还能经常欣赏到充满翻译腔的欧美引进大片，要是家里条件比较好，能有台电脑，那在网络都没有的年代，装软件和驱动都得靠光盘……在信息高速公路直通车前光盘可谓无所不能。</p><p><img src="https://cdn.sspai.com/2021/09/12/ecb107055ab851152cc138f4bb686fc1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>先科的 DVD 机，来源：先科官网</p><p>光盘有很多种类型，常见的几大类就是 CD，DVD 还有我们常听见的 BD 也就是蓝光光盘 Blu-ray Disc。</p><p><img src="https://cdn.sspai.com/2021/09/12/1806a0f7cd644b3eff20d7bf8cd9630f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>音乐光盘</p><h3 id="光盘的原理"><a href="#光盘的原理" class="headerlink" title="光盘的原理"></a>光盘的原理</h3><p><strong>写入</strong>：通过厂家设定好的轨道，按固定的速度把表面材料烧掉，烧出不同间隔长度不一的凹点。这些凹点就代表了不同的信息。</p><p><img src="https://cdn.sspai.com/2021/09/12/7d9aed89ff9b77f457eca7d92712859e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>放大的光盘表面是这个样子的，图片来源：Youtube@Applied Science</p><p><strong>读取</strong>：传统的是采用近红外线纳米二极管，把红外线射到轨道上，有凹点的地方反射率会不同，从而读取数据。为了提高识别率，没有凸点的地方反射率要尽量得高，所以光盘会添加一个镜面反射层，这也是光盘看起来亮亮的原因，同时由于上面有很多个小凹槽，光线会发生折射与衍射，光盘上便有了那种很独特很漂亮的彩虹纹。</p><p><img src="https://cdn.sspai.com/2021/09/12/545b1ae7d546f78349951f2b7be61076.gif"></p><p>光驱读取的激光头，图片来源：佳能 Canon Global</p><p>这种方式有点像是盲文，通过一个个不同长度的点表示文字，然后盲人用手去触摸感受凹凸从而读出文字。</p><p>市面上还有一种可擦写光盘，可以反复擦写数据，是 20 年代大众经常使用的「移动硬盘」，价格相对来讲很贵。这种光盘的原理是将数据记录的盘片层换成可相变合金，这种金属的特性是在不同功率激光的照射下能够在晶体与非晶体结构之间转换。</p><p>可以用高功率激光，像普通刻录光盘那样照射可擦写光盘，上面金属变成的晶体结构具有良好的反射性，就相当于凹点。而用中等功率激光照射后，就可以把它还原回来。这种光盘由于材料的问题，反射率一般不够一次性光盘高，所以那个时候好的可刻录光盘，价格一般很贵，而且刻录也比较容易翻车（多次刻录后反射性不够，导致无法识别）。</p><p><img src="https://cdn.sspai.com/2021/09/12/ae925805ba0129e16788e7827aee6361.gif"></p><p>可以反复读写的光盘原理，图片来源：佳能 Canon Global</p><h3 id="蓝光光盘的由来"><a href="#蓝光光盘的由来" class="headerlink" title="蓝光光盘的由来"></a>蓝光光盘的由来</h3><p>那我们现在常听到的蓝光光盘，说的就是把镜红外线纳米二极管换成波长更短的蓝光，也就是说在盘片上的凹点能烧得更加密集，提升了数据密度，一个盘自然也就能塞下更多的内容。能够比普通 DVD ROM 容量翻倍。</p><p><img src="https://cdn.sspai.com/2021/09/12/deac9796ebc06d80b39571409620ed0b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>蓝光光盘的技术</p><p>光盘的速度和容量一直随着技术发展在提升，从原本 700MB&#x2F;150KB&#x2F;s 的容量速度飙升到现在多层蓝光盘（通过不同折射率的透过率来区分不同层盘片）的最高 128G&#x2F;72MB&#x2F;s，在商用领域更是有索尼 2015 年推出的 Archival Disc，单盘容量来到了 300GB ，最高速度去到 250MB&#x2F;s 读 125MB&#x2F;s 写。</p><p>但随着最近互联网流媒体的发展，<strong>人们对光盘的需求越来越低，光盘的容量速度提升也随之放缓</strong>。比如 2013 年的研究通过新型技术可以将光盘的容量提升到 TB 级，但直到现在仍没有落地产品。</p><p><strong>相关文献</strong>：<br>[1]. CD（Compact Disc）最初的样子可以看一下这篇<a href="https://patents.google.com/patent/US3501586A/en">激光唱片发明者 James T Russell 的专利</a>。</p><p>[2]. 关于光盘的刻录使用维护，可以参考我们国家的<a href="https://www.saac.gov.cn/daj/hybz/201903/46c3b37764814570a83b43891fb639e3/files/6be1b6b5ff744dfa9a2d5e0345cadd03.pdf">《电子档案储存用可录类蓝光光盘（BD-R）技术要求和应用规范》</a>。</p><p>[3]. 关于光盘如何提升用量到 TB 级的技术，可以查看这篇<a href="https://www.nature.com/articles/ncomms3061.pdf">发表在 Nature 的论文</a>。</p><p>[4]. 原理动图来自于佳能科学实验室，完整内容可以查看<a href="https://global.canon/en/technology/s_labo/light/003/06.html">原文</a>。</p><p>[5]. 对大容量光盘感兴趣的朋友可以看看<a href="https://pro.sony/s3/cms-static-content/file/49/1237494482649.pdf">索尼的 Archival Disc 第二代白皮书</a>。</p><p>[6]. 微观图片截取自 Applied Science 的视频，大家可以看看完整版，点击<a href="https://www.youtube.com/watch?v=xbo8xi1zgVo">「Tools and Tips #2 from Applied Science」</a>观看。</p><h3 id="软盘"><a href="#软盘" class="headerlink" title="软盘"></a>软盘</h3><p>相比起光盘能给大家的生活带来多姿多彩的应用，大部分对软盘的印象应该是比较正式的，感觉就是用来存软件驱动和工作资料啥的。我猜是因为没有什么公司做家用的软盘读取器，然后那个时候大家电脑用途还是比较正经的，所以软盘就变成了比较专业的一种东西。但大部分人对它的主要印象还有另外一个：特别容易坏。</p><p><img src="https://cdn.sspai.com/2021/09/12/7d756a962d26a8405030fd9c0489c9e9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>像是前面提到的所有设备一样，软盘也有很多个尺寸和型号，甚至早期各家的软盘虽然长得一样，但是并不能互相读取（比如苹果和其他家的），我们下面提到的基本都是以大家常见的 3.5 寸软盘为主。</p><p><img src="https://cdn.sspai.com/2021/09/12/c46216f8c3cf8ed41a81ab8ffefd0d48.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SONY 家的 3.5 寸软盘</p><h3 id="软盘工作的原理"><a href="#软盘工作的原理" class="headerlink" title="软盘工作的原理"></a>软盘工作的原理</h3><p>我们可以把软盘看成一个，<strong>用着磁带的材料但却有着机械硬盘工作原理的东西</strong>。它的身上已经出现了扇区和磁道的概念，甚至可以把原理无缝放到机械硬盘上，虽然它比机械硬盘转得慢，并且装到一个软软的塑料盒子里（所以叫软盘）。</p><p>为了解决磁带不能随机读取的缺点，软盘用上了磁带相同的材料却做成了一个圆片，然后被分成了下面这样的同心圆环（磁道）而被切成很多小块的扇区，扇区是由软件定义的，不同品牌都不一样，<strong>扇区是软盘保存读取的基本单位</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/e7327b64a5d82ee59df1b517850e1d7d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>软盘的分区</p><p><strong>保存&#x2F;读取数据</strong>：（某些软盘第一次用之前必须格式化）计算机发出保存或写入数据命令时，软驱（软盘读取器）会让磁盘转起来，同时用电机让读写磁头移动到对应磁道正上方，等盘片转到要写入的扇区，和读写磁头同一块地方的擦除磁头会把这个扇区的数据清除掉（会清除比写入的扇区更大的区域，防止周围的数据干扰空白扇区的磁性），然后写磁头通过不同的电流永久改变底下区域的磁性来写入数据。读取的时候则是读磁头感应底下区域的磁性产生不同的电流，转换成数据返回给计算机，同时会发出指令让磁盘停止旋转。</p><p><img src="https://cdn.sspai.com/2021/09/12/182473df7330e4fef35971c828e6e789.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁头读写原理，图片来源：MIT</p><h3 id="软盘为什么容易坏"><a href="#软盘为什么容易坏" class="headerlink" title="软盘为什么容易坏"></a>软盘为什么容易坏</h3><p>软盘容易坏几乎是用过软盘的小伙伴达成的共识，这主要是因为<strong>盘片直接暴露在空气中并且和外壳有接触</strong>，而且读取的时候需要磁头直接接触盘片，就跟磁带那样。虽然软盘里面有一块软绒材质的布来减少盘片和外壳的摩擦，同时还具有清理作用，防止摩擦产生的磁颗粒干扰扇区或者粘到磁头上，但盘片依然会被不断磨损，上面的磁性材料全都磨掉就没办法读写数据了。加上软盘的壳子比较软，平时携带时容易导致盘片形变，加剧旋转时的摩擦。</p><p><img src="https://cdn.sspai.com/2021/09/12/ee97efd9a01ed237bf26592869b77a43.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>我的手甚至能直接摸到盘片</p><p>这也是机械硬盘要做成全封闭不可拆卸，并且盘片悬浮的原因。其实软盘如果仅仅日常数据也没有大家想象中那么脆弱，毕竟磁带和它类似但很耐用，我自己存着的软盘现在大多数还能够读取。一般都是携带过程中损坏，还有就是后期厂家制造质量下降（最早出产的 3.5 寸软盘质量都很好）。</p><p>软盘的容量最初是几十到几百 KB，到淘汰前索尼的软盘已经能做到 1~3 MB 了，还有更特殊的几百 MB 的软盘。读写速度方面，软盘一般在十几到几十 KB&#x2F;s 左右，不过每次都要等盘片转到满速才行。</p><p><strong>相关文献</strong>：</p><p>[1]. 3.5 寸软盘和软驱的结构可以参考<a href="https://patents.google.com/patent/US3668658A/en">软盘的专利</a>和<a href="https://patents.google.com/patent/US5629819A/en">软驱的专利</a>。</p><p>软盘和光盘它们俩出现截然不同命运的根本原因，就是在于介质的鲁棒性。光盘使用非接触的方式读取，不会因为使用时间增长而对盘片本身产生磨损，同时密度不高的光盘即时盘片被划损也能通过纠错算法补全数据。也就是说日常大众在使用存储设备的时候，并不会像实验室那样小心翼翼的保存，只有真正持久耐用的设备才会成为大众日常使用的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结束了软盘和光盘的介绍，再往下就是我们熟知的设备：机械硬盘、固态硬盘、内存、内存卡、U 盘……的时代，本章的内容已经基本结束了。本章节中，我带大家了解了历史上著名的储存设备，回忆了一下不同年代的情怀（还有历史的眼泪），也让大家了解到人类为了保存自己的信息做出了多大的努力，当然历史上还有很多很多不同类型的储存设备因为篇幅原因没有办法提到，感兴趣的小伙伴可以去网上搜一下储存设备发展的历史时间轴，然后找找相关专利和论文。</p><p>热身完毕之后，下一章就开始介绍大家熟悉的设备，第一个当然是现在还在大范围使用的机械硬盘了。下一章我会介绍机械硬盘是怎么来的，它的原理是什么，常见参数代表的意义，以及接下来几章的选购与使用指南。</p><p>[[02：机械硬盘的原理与参数详解]]</p><p>[[03 ：固态硬盘的历史、结构与原理]]</p><p>[[04：固态硬盘的参数解读与实际性能]]</p><p>[[05：运行内存都在运行什么？]]</p><p>[[06：理解 U 盘、内存卡、移动硬盘和手机储存芯片构造]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储器体系拓展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>巴赫与埃舍尔</title>
    <link href="/Blogs/2025/08/28/%E5%B7%B4%E8%B5%AB%E4%B8%8E%E5%9F%83%E8%88%8D%E5%B0%94/"/>
    <url>/Blogs/2025/08/28/%E5%B7%B4%E8%B5%AB%E4%B8%8E%E5%9F%83%E8%88%8D%E5%B0%94/</url>
    
    <content type="html"><![CDATA[<p><strong>巴赫和埃舍尔的作品里的类似对应物</strong></p><p><strong>① 埃舍尔</strong></p><p>埃舍尔的作品，充满了矛盾图形，悖论，无限循环，自指等元素，给了本书概念极好的视觉表示，举几个例子说明</p><p><strong>《龙》：跳出系统，超越自己也许是注定做不到的事情</strong></p><p><img src="https://picx.zhimg.com/v2-a014c8352cd6eea7cb8a97a494380f33_1440w.jpg"></p><p>这条在二位平面中的龙极正在力挣脱自己的二维性，将头和尾巴穿过了自己平面的身体，但在我们三维世界的人看来，它是徒劳的，它在二维之中模拟了三维，但这不意味着它就能跳出二维，它始终只是个二维的生物</p><p><strong>《画廊》：为哥德尔不完全定理定制的图像说明</strong></p><p><img src="https://picx.zhimg.com/v2-e6b8833d3a2ea604ad11b01001705f39_1440w.jpg"></p><p>青年在欣赏一副幅画，画的是一个小镇，小镇里有一座画廊…..在这个循环中。画里有画自己，青年在画中能看到在看画的青年。。。。。画与青年都以某种方式包含了自己，然我们想到那个谈论自己的公式“G”。而整幅画的中心处有个空白点，那是一个不可避免的缺陷，作者没办法完成因为他是必须存在，这就是不完全的象征，《画廊》系统是不完全的，但是身在系统内青年看不到，只有身在系统外的我们理解</p><p><strong>《画手》：画出来的说谎者悖论</strong></p><p><img src="https://pic3.zhimg.com/v2-023a2379ebf8f0fd87e880c3b75fcc20_1440w.jpg"></p><p>埃舍尔的手画出了互画的左手和右手，让人不经意间陷入究竟是哪只手画的哪只手的迷思，这和双句版 说谎者悖论如出一辙</p><p>下面这句话是假的</p><p>上面这句话是真的</p><p>画中的左右手是一个相互缠结的怪圈结构，也是人脑的心智层的一个同构表示，而埃舍尔本人的手就像是心智底层的神经元结构，是<strong>不受高层干扰的硬件层次，</strong>画中则是缠结的软件层次，软件层符号间相互作用难以捉摸，如同画中那样难以捉摸的两只手。但是底层的硬件处在不受这些复杂结构干扰的层次上，埃舍尔和我们能在这幅画的层次之外清楚地观察这纠缠的怪圈</p><p><strong>② 巴赫</strong></p><p><strong>人类的思维就像一曲美妙的多声部赋格曲</strong>，这样的想法让作者把巴赫作一个大主角写进书里</p><p>巴赫的音乐，或明或暗地涉及到了本书讨论的那些关于思维，结构的重大概念，举例介绍：</p><blockquote><p>1,音乐与同构：卡农曲是一种结构复杂的曲式，由主题和不同声部主题的副本组成。副本在音高或时间上和主题相互交错，虽于原主题有差异，但却包含所有原来主题的信息，这种保存了信息的转换就称为同构</p></blockquote><blockquote><p>2,音乐与自指：自指现象体现在巴赫成就最高的赋格曲作品《音乐的奉献》中，里面有的乐曲不但穷尽了巴赫所有的变奏技巧，而且其中的形式相互交织让整部作品也呈现出赋格的样貌，它是一部关于赋格的赋格 ，在另一个层次上谈论自己，这不就是自指的含义吗</p></blockquote><blockquote><p>3,音乐与怪圈：<strong>怪圈指往一个方向穿越层次却又回到原点的现象。</strong>是贯穿全书的一个重要概念。巴赫有一首“canon per Tonos”被称为无穷升高的卡农，它的结尾音以某种巧妙的方式回到了开头的音，而整首曲子的曲调是不断网上走的，如果不间断低单曲循环这一首就能给人一种无限地升高的感觉。<br>它所用的技巧原理如下图</p></blockquote><p><img src="https://pic3.zhimg.com/v2-ec15bab6b416af99507d4de613de132c_1440w.jpg"></p><blockquote><p>整个旋律走向是在往上，随着音调升高音符的强度减弱最终到消失，而同时逐渐增强最下面的声部，这就能让曲子的结尾回到起始的音高</p></blockquote><blockquote><p>4,音乐与心智层次：书中有一篇关于如何听赋格曲的对话，赋格由多条不同的旋律线同时演奏，旋律交织却能产生和谐的效果。里面就讨论欣赏赋格是应该把旋律作为整体感受还是作为多条旋律线的组合感受，两种不同层次的感受方式会带给你不同的聆听体验。这里实质上是说心智的层次结构，这两种聆方式是在讲同一事物在不同层次上的表现。也是大脑和思维的类比，思维即在不同层次上做同一件事，在低层被描述为神经信号的传递，中间层次责备描述成符号的相互作用，高层便是心智</p></blockquote><blockquote><p>5,音乐的美：在这本讨论思维的书中作者还关心一个问题：美感是不是大脑过程？美是能被计算机程序化的东西吗？一个事物的美是它固有的属性吗？还是它只是触发了我们大脑的某些符号让我们产生美的体验？这种触发是必然的吗？或者说美是一种确定存在或不存在的东西吗？如果特定的人在特定的时间地点看听到一首乐曲的话。.。关于美的问题，作者持有一种偏浪漫主义的看法，他认为即使大脑过程都可以被程序化，但是美却是可以延伸的。一段音乐进入大脑，我们会为之构件一个心智表示的结构，并会和其他过去经验里形成的符号结构发生联系而显露出意义，这种联系历久弥新，四方延伸的，因此美可能是一种在时空中流动的东西</p></blockquote><p><strong>③ 巴赫和埃舍尔</strong></p><p>作者有时甚至会让巴赫和埃舍尔直接形成同构，如书中的《螃蟹卡农》</p><p>螃蟹卡农是《音乐的奉献》其中的一首，巴赫把一个主题正向和反向地罗列交织在一起。让人联想到螃蟹行走的样子。。而埃舍尔也有一幅主题正向和反向地罗列交织的作品。巧的是，他所用的主题就是螃蟹！我们可以看出这二者的同构关系，而且还是多个层次上的同构</p><p><img src="https://picx.zhimg.com/v2-cb02a19509c6dda17196ba9d8ad87d79_1440w.jpg"></p><p>如此巧合堪称神来之笔。在次基础上侯世达构造了一段名为《螃蟹卡农》的对话。用对话结构模拟逆行卡农，倆主人公分别谈论巴赫和埃舍尔，一起谈论作品的逆行结构。中途螃蟹又作为一个角色加入进来。。。这是一篇高度自指的对话，像墙上挂满各式镜子封笔房间，许多映射在其中共振回荡。。如此精妙绝伦，值得原文呈现！</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>巴赫与埃舍尔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发硬件</title>
    <link href="/Blogs/2025/08/28/%E5%BC%80%E5%8F%91%E7%A1%AC%E4%BB%B6/"/>
    <url>/Blogs/2025/08/28/%E5%BC%80%E5%8F%91%E7%A1%AC%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="常用引脚"><a href="#常用引脚" class="headerlink" title="常用引脚"></a>常用引脚</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>通用型之输入输出的简称，这也将是整个嵌入式学习中最常用的引脚之一，它的作用主要就是负责输出高低电平和读入高低电平，此外还有一些其他的简单功能，是一个很灵活的引脚。</p><h2 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h2><p>STM32的时钟系统，很重要，是整个STM32的心脏，主要功能是发生时钟信号推动单片机内各个部分执行相应的指令。</p><h2 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h2><p>通用同步&#x2F;异步串行接收&#x2F;发送器，USART是一个全双工通用同步&#x2F;异步串行收发模块，该接口是一个高度灵活的串行通信设备。它就相当于板子与板子，板子与电脑之间沟通的纽带，是一个十分灵活的通讯设备。</p><h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><p>外部中断&#x2F;事件控制器，中断是一个比较复杂晦涩的一个概念，后面会详细讲解，这里大概了解一下，它就好像是一个if else语句一样，有一个判断条件，只要判定结果为真，就会执行相应的语句，但是它判断的条件一般都是硬件状态，并且只要板子运行时引起中断，那么它会立刻做出反应。而EXIT则是来管理这些中断的。</p><h2 id="IWDG"><a href="#IWDG" class="headerlink" title="IWDG"></a>IWDG</h2><p>独立看门狗，一般用来检测程序错误。</p><h2 id="WWDG"><a href="#WWDG" class="headerlink" title="WWDG"></a>WWDG</h2><p>跟独立看门狗很像，不同的地方是窗口看门狗的计数器的值在减到某一个数之前喂狗的话也会产生复位，这个值叫窗口的上限，上限值由用户独立设置。窗口看门狗计数器的值必须在上窗口和下窗口之间才可以喂狗，这就是窗口看门狗中窗口两个字的含义。也是用来检测程序硬件问题。</p><h2 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h2><p>定时器，zet6一共有8个定时器，可以说是一个高级的IO引脚，作用也有很多，后面也会详细讲解。</p><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>脉冲宽度调制，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。简单一点，就是对脉冲宽度的控制，实现模拟电压</p><h2 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h2><p>模&#x2F;数转换器或者模拟&#x2F;数字转换器。是指将连续变量的模拟信号转换为离散的数字信号的器件。典型的模拟数字转换器将模拟信号转换为表示一定比例电压值的数字信号。</p><h2 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h2><p>与ADC刚好相反。</p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>直接存储器访问，DMA 传输将数据从一个地址空间复制到另外一个地址空间。 DMA 传输方式无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路， 能使 CPU 的效率大为提高。</p><h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2><p>IIC(Inter－Integrated Circuit)总线是一种由 PHILIPS 公司开发的两线式串行总线，用于连接微控制器及其外围设备。它是由数据线 SDA 和时钟 SCL 构成的串行总线，可发送和接收数据。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI 是英语 Serial Peripheral interface 的缩写，顾名思义就是串行外围设备接口。SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为 PCB 的布局上节省空间，提供方便，正是出于这种简单易用的特性，现在越来越多的芯片集成了这种通信协议</p><h1 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h1><h2 id="引脚注意"><a href="#引脚注意" class="headerlink" title="引脚注意"></a>引脚注意</h2><p>（结合STM32 NUCLEO-L432KC</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z3qVeQVLrJWLItMlNVSicgv6YLV4icVLxAW7ZnCHRduZqM8Y1xz8fzZBBzyl5YM2Wq3UvHicicGUxia8ctfIklqoC1A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>每个针脚的准确名字应该是最靠边缘框内里的字符，如PA_2,但是因为这样很麻烦，我们一般都直接叫板子上面刻的字母，比如PA_2针脚我们就叫它A7</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z3qVeQVLrJWLItMlNVSicgv6YLV4icVLxAlaurL6zQDxzqFV2tuv7pBJQeWKXEJP9Svdp6gJ0UK8NqIPB4gRASqQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">PX_Y</td><td align="center">每个引脚的标注名称，浅蓝色表明没有冲突，深蓝色表示两引脚可能有冲突，如A7和D13最好别一起用</td></tr><tr><td align="center">Arduino connector</td><td align="center">针脚的名字，一般来说开头为A的支持模拟输出，开头为D的支持数字输出。</td></tr><tr><td align="center">LED</td><td align="center">板载的小灯，一般用来看代码跑通没有，在调试代码的时候很好用</td></tr><tr><td align="center">UART SPI I2C CAN</td><td align="center">这些都是传输协议，就是两个设备之间通信的几种规定，比如这次实验我们会用到SPI，在这门课程中我们不需要过多了解</td></tr><tr><td align="center">PWMOut</td><td align="center">输出一种脉冲宽度可控的方波，经常用作控制信号，在MS中非常常用</td></tr><tr><td align="center">AnalogInAnalogOut</td><td align="center">支持模拟信号输入输出的针脚，可以当作ADC、DAC使用</td></tr><tr><td align="center">Power GND</td><td align="center">最基本功能，供电(如3v3)和接地(GND)，一般就连接在面包板两侧最长的插孔</td></tr></tbody></table><p>标黄的几个标签在MS实验中非常常用</p><h1 id="开发硬件"><a href="#开发硬件" class="headerlink" title="开发硬件"></a>开发硬件</h1><h2 id="示波器"><a href="#示波器" class="headerlink" title="示波器"></a>示波器</h2><p>示波器最常用的按钮就是Auto键，一般接上线之后摁Auto就好</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/z3qVeQVLrJWLItMlNVSicgv6YLV4icVLxA9bL4eHKbGpJpsn1eHR4XPibad9eB6w9bF76kb8uCLVyqJch0sp9dh0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分</title>
    <link href="/Blogs/2025/08/28/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    <url>/Blogs/2025/08/28/%E5%BE%AE%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>[[05微积分基本概念]]</p><p>微积分的两大支柱</p><p>[[01微分]]</p><p>[[02积分]]</p><p>[[03场论统一]]</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步爬虫和模拟登录</title>
    <link href="/Blogs/2025/08/28/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    <url>/Blogs/2025/08/28/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%92%8C%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Ajax？"><a href="#什么是-Ajax？" class="headerlink" title="什么是 Ajax？"></a>什么是 Ajax？</h1><p>Ajax，全称为 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML。它不是一门编程语言，而是利用 JavaScript 在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p><p>对于传统的网页，如果想更新其内容，那么必须刷新整个页面，但有了 Ajax，便可以在页面不被全部刷新的情况下更新其内容。在这个过程中，页面实际上是在后台与服务器进行了数据交互，获取到数据之后，再利用 JavaScript 改变网页，这样网页内容就会更新了。</p><p>可以到 W3School 上体验几个示例感受一下：<a href="http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp">http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp</a>。</p><h2 id="1-实例引入"><a href="#1-实例引入" class="headerlink" title="1. 实例引入"></a><a href="https://cuiqingcai.com/202251.html#1-%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5" title="1. 实例引入"></a>1. 实例引入</h2><p>浏览网页的时候，我们会发现很多网页都有下滑查看更多的选项。比如，拿微博来说，以我的主页为例：<a href="https://m.weibo.cn/u/2830678474">https://m.weibo.cn/u/2830678474</a>，切换到微博页面，一直下滑，可以发现下滑几个微博之后，再向下就没有了，转而会出现一个加载的动画，不一会儿下方就继续出现了新的微博内容，这个过程其实就是 Ajax 加载的过程，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/2jqaq.png"></p><p>我们注意到页面其实并没有整个刷新，也就意味着页面的链接没有变化，但是网页中却多了新内容，也就是后面刷出来的新微博。这就是通过 Ajax 获取新数据并呈现的过程。</p><h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a><a href="https://cuiqingcai.com/202251.html#2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" title="2. 基本原理"></a>2. 基本原理</h2><p>初步了解了 Ajax 之后，我们再来详细了解它的基本原理。发送 Ajax 请求到网页更新的这个过程可以简单分为以下 3 步：</p><ol><li>发送请求</li><li>解析内容</li><li>渲染网页</li></ol><p>下面我们分别来详细介绍一下这几个过程。</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a><a href="https://cuiqingcai.com/202251.html#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" title="发送请求"></a>发送请求</h3><p>我们知道 JavaScript 可以实现页面的各种交互功能，Ajax 也不例外，它也是由 JavaScript 实现的，</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>var xmlhttp;  <br>if (window.XMLHttpRequest) {  <br>  &#x2F;&#x2F;code for IE7+, Firefox, Chrome, Opera, Safari  <br>  xmlhttp &#x3D; new XMLHttpRequest();  <br>} else {  <br>  &#x2F;&#x2F;code for IE6, IE5  <br>  xmlhttp &#x3D; new ActiveXObject(“Microsoft.XMLHTTP”);  <br>}  <br>xmlhttp.onreadystatechange &#x3D; function () {  <br>  if (xmlhttp.readyState &#x3D;&#x3D; 4 &amp;&amp; xmlhttp.status &#x3D;&#x3D; 200) {  <br>    document.getElementById(“myDiv”).innerHTML &#x3D; xmlhttp.responseText;  <br>  }  <br>};  <br>xmlhttp.open(“POST”, “&#x2F;ajax&#x2F;“, true);  <br>xmlhttp.send();</td></tr></tbody></table><p>这是 JavaScript 对 Ajax 最底层的实现，实际上就是新建了 <code>XMLHttpRequest</code> 对象，然后调用 <code>onreadystatechange</code> 属性设置了监听，然后调用 <code>open</code> 和 <code>send</code> 方法向某个链接（也就是服务器）发送了请求。前面用 Python 实现请求发送之后，可以得到响应结果，但这里请求的发送变成 JavaScript 来完成。由于设置了监听，所以当服务器返回响应时，<code>onreadystatechange</code> 对应的方法便会被触发，然后在这个方法里面解析响应内容即可。</p><h3 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a><a href="https://cuiqingcai.com/202251.html#%E8%A7%A3%E6%9E%90%E5%86%85%E5%AE%B9" title="解析内容"></a>解析内容</h3><p>得到响应之后，<code>onreadystatechange</code> 属性对应的方法便会被触发，此时利用 <code>xmlhttp</code> 的 <code>responseText</code> 属性便可取到响应内容。这类似于 Python 中利用 requests 向服务器发起请求，然后得到响应的过程。那么返回内容可能是 HTML，可能是 JSON，接下来只需要在方法中用 JavaScript 进一步处理即可。比如，如果是 JSON 的话，可以进行解析和转化。</p><h3 id="渲染网页"><a href="#渲染网页" class="headerlink" title="渲染网页"></a><a href="https://cuiqingcai.com/202251.html#%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5" title="渲染网页"></a>渲染网页</h3><p>JavaScript 有改变网页内容的能力，解析完响应内容之后，就可以调用 JavaScript 来针对解析完的内容对网页进行下一步处理了。比如，通过 <code>document.getElementById().innerHTML</code> 这样的操作，便可以对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这样的操作也被称作 DOM 操作，即对网页文档进行操作，如更改、删除等。</p><p>上例中，<code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText</code> 便将 ID 为 <code>myDiv</code> 的节点内部的 HTML 代码更改为服务器返回的内容，这样 <code>myDiv</code> 元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。</p><p>我们观察到，这 3 个步骤其实都是由 JavaScript 完成的，它完成了整个请求、解析和渲染的过程。</p><p>再回想微博的下拉刷新，这其实就是 JavaScript 向服务器发送了一个 Ajax 请求，然后获取新的微博数据，将其解析，并将其渲染在网页中。</p><p>因此，我们知道，真实的数据其实都是一次次 Ajax 请求得到的，如果想要抓取这些数据，需要知道这些请求到底是怎么发送的，发往哪里，发了哪些参数。如果我们知道了这些，不就可以用 Python 模拟这个发送操作，获取到其中的结果了吗？</p><h1 id="Ajax分析方法"><a href="#Ajax分析方法" class="headerlink" title="Ajax分析方法"></a>Ajax分析方法</h1><p>这里还以前面的微博为例，我们知道拖动刷新的内容由 Ajax 加载，而且页面的 URL 没有变化，那么应该到哪里去查看这些 Ajax 请求呢？</p><h2 id="1-分析案例"><a href="#1-分析案例" class="headerlink" title="1. 分析案例"></a><a href="https://cuiqingcai.com/202252.html#1-%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B" title="1. 分析案例"></a>1. 分析案例</h2><p>这里还需要借助浏览器的开发者工具，下面以 Chrome 浏览器为例来介绍。</p><p>首先，用 Chrome 浏览器打开微博的链接 <a href="https://m.weibo.cn/u/2830678474">https://m.weibo.cn/u/2830678474</a>，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择，随后在页面中点击鼠标右键，从弹出的快捷菜单中选择) “检查” 选项，此时便会弹出开发者工具，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/7040b.png"></p><p>前面也提到过，这里其实就是在页面加载过程中浏览器与服务器之间发送请求和接收响应的所有记录。</p><p>Ajax 其实有其特殊的请求类型，它叫作 xhr。在图中我们可以发现一个名称以 getIndex 开头的请求，其 Type 为 xhr，这就是一个 Ajax 请求。用鼠标点击这个请求，可以查看这个请求的详细信息。</p><p><img src="https://cdn.cuiqingcai.com/1kiqe.png"></p><p>在右侧可以观察到其 Request Headers、URL 和 Response Headers 等信息。其中 Request Headers 中有一个信息为 <code>X-Requested-With:XMLHttpRequest</code>，这就标记了此请求是 Ajax 请求，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/t4hm0.png"></p><p>随后点击一下 Preview，即可看到响应的内容，它是 JSON 格式的。这里 Chrome 为我们自动做了解析，点击箭头即可展开和收起相应内容。</p><p>观察可以发现，这里的返回结果是我的个人信息，如昵称、简介、头像等，这也是用来渲染个人主页所使用的数据。JavaScript 接收到这些数据之后，再执行相应的渲染方法，整个页面就渲染出来了。</p><p><img src="https://cdn.cuiqingcai.com/kah0s.png"></p><p>另外，也可以切换到 Response 选项卡，从中观察到真实的返回数据，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/l1z1j.png"></p><p>接下来，切回到第一个请求，观察一下它的 Response 是什么，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/yfn4s.png"></p><p>这是最原始的链接 <a href="https://m.weibo.cn/u/2830678474">https://m.weibo.cn/u/2830678474</a> 返回的结果，其代码只有不到 50 行，结构也非常简单，只是执行了一些 JavaScript。</p><p>所以说，我们看到的微博页面的真实数据并不是最原始的页面返回的，而是后来执行 JavaScript 后再次向后台发送了 Ajax 请求，浏览器拿到数据后再进一步渲染出来的。</p><h2 id="2-过滤请求"><a href="#2-过滤请求" class="headerlink" title="2. 过滤请求"></a><a href="https://cuiqingcai.com/202252.html#2-%E8%BF%87%E6%BB%A4%E8%AF%B7%E6%B1%82" title="2. 过滤请求"></a>2. 过滤请求</h2><p>接下来，再利用 Chrome 开发者工具的筛选功能筛选出所有的 Ajax 请求。在请求的上方有一层筛选栏，直接点击 XHR，此时在下方显示的所有请求便都是 Ajax 请求了，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/0xqyh.png"></p><p>接下来，不断滑动页面，可以看到页面底部有一条条新的微博被刷出，而开发者工具下方也一个个地出现 Ajax 请求，这样我们就可以捕获到所有的 Ajax 请求了。</p><p>随意点开一个条目，都可以清楚地看到其 Request URL、Request Headers、Response Headers、Response Body 等内容，此时想要模拟请求和提取就非常简单了。</p><p>下图所示的内容便是我的某一页微博的列表信息：</p><p><img src="https://cdn.cuiqingcai.com/3gv1x.png"></p><p>到现在为止，我们已经可以分析出 Ajax 请求的一些详细信息了，接下来只需要用程序模拟这些 Ajax 请求，就可以轻松提取我们所需要的信息了。</p><h1 id="Ajax实战"><a href="#Ajax实战" class="headerlink" title="Ajax实战"></a>Ajax实战</h1><p>在上一节中我们已经学习了 Ajax 的基本原理和分析方法，这一节我们来结合一个实际的案例来看一下 Ajax 分析和爬取页面的具体实现。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a><a href="https://cuiqingcai.com/202253.html#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1. 准备工作"></a>1. 准备工作</h2><p>在本节开始之前，我们需要做好如下准备工作：</p><ul><li>安装好 Python 3（最低为 3.6 版本），并成功运行 Python 3 程序。</li><li>了解 Python HTTP 请求库 requests 的基本用法。</li><li>了解 Ajax 基础知识和分析 Ajax 的基本方法。</li></ul><p>以上内容在前面的章节中均有讲解，如尚未准备好，建议先熟悉一下这些内容。</p><h2 id="2-爬取目标"><a href="#2-爬取目标" class="headerlink" title="2. 爬取目标"></a><a href="https://cuiqingcai.com/202253.html#2-%E7%88%AC%E5%8F%96%E7%9B%AE%E6%A0%87" title="2. 爬取目标"></a>2. 爬取目标</h2><p>本节我们以一个示例网站来试验一下 Ajax 的爬取，其链接为：<a href="https://spa1.scrape.center/%EF%BC%8C%E8%AF%A5%E7%A4%BA%E4%BE%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%98%AF%E9%80%9A%E8%BF%87">https://spa1.scrape.center/，该示例网站的数据请求是通过</a> Ajax 完成的，页面的内容是通过 JavaScript 渲染出来的，页面如图所示：</p><p><img src="https://cdn.cuiqingcai.com/add5o.png" alt="image-20210705004644681"></p><p>可能大家看着这个页面似曾相识，心想这不就是上一个案例的网站吗？但其实不是。这个网站的后台实现逻辑和数据加载方式完全不同。只不过最后呈现的样式是一样的。</p><p>这个网站同样支持翻页，可以点击最下方的页码来切换到下一页，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/lyy4e.png" alt="image-20210705004704636"></p><p>点击每一个电影的链接进入详情页，页面结构也是完全一样的，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/y712p.png" alt="image-20210705004718813"></p><p>我们需要爬取的数据也是和原来相同的，包括电影的名称、封面、类别、上映日期、评分、剧情简介等信息。</p><p>本节中我们需要完成的目标如下。</p><ul><li>分析页面数据的加载逻辑。</li><li>用 requests 实现 Ajax 数据的爬取。</li><li>将每部电影的数据保存成一个 JSON 数据文件。</li></ul><p>由于本节主要讲解 Ajax，所以对于数据存储和加速部分就不再展开详细实现，主要是讲解 Ajax 的分析和爬取实现。</p><p>好，我们现在就开始吧。</p><h2 id="3-初步探索"><a href="#3-初步探索" class="headerlink" title="3. 初步探索"></a><a href="https://cuiqingcai.com/202253.html#3-%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2" title="3. 初步探索"></a>3. 初步探索</h2><p>首先，我们先尝试用之前的 requests 来直接提取页面，看看会得到怎样的结果。用最简单的代码实现一下 requests 获取首页源码的过程，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>url &#x3D; ‘<a href="https://spa1.scrape.center/">https://spa1.scrape.center/</a>‘  <br>html &#x3D; requests.get(url).text  <br>print(html)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=/favicon.ico><title>Scrape | Movie</title><link href=/css/chunk-700f70e1.1126d090.css rel=prefetch><link href=/css/chunk-d1db5eda.0ff76b36.css rel=prefetch><link href=/js/chunk-700f70e1.0548e2b4.js rel=prefetch><link href=/js/chunk-d1db5eda.b564504d.js rel=prefetch><link href=/css/app.ea9d802a.css rel=preload as=style><link href=/js/app.1435ecd5.js rel=preload as=script><link href=/js/chunk-vendors.77daf991.js rel=preload as=script><link href=/css/app.ea9d802a.css rel=stylesheet></head><body><noscript><strong>We’re sorry but portal doesn’t work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id=app></div><script src=/js/chunk-vendors.77daf991.js></script><script src=/js/app.1435ecd5.js></script></body></html></td></tr></tbody></table><p>可以看到，爬取结果就只有这么一点 HTML 内容，而我们在浏览器中打开这个页面，却能看到如图所示的结果：</p><p><img src="https://cdn.cuiqingcai.com/p2u8d.png" alt="image-20210705004644681"></p><p>在 HTML 中，我们只能看到在源码中引用了一些 JavaScript 和 CSS 文件，并没有观察到有任何电影数据信息。</p><p>如果遇到这样的情况，这说明我们现在看到的整个页面便是 JavaScript 渲染得到的，浏览器执行了 HTML 中所引用的 JavaScript 文件，JavaScript 通过调用一些数据加载和页面渲染方法，才最终呈现了图中所示的结果。</p><p>在一般情况下，这些数据都是通过 Ajax 来加载的， JavaScript 在后台调用这些 Ajax 数据接口，得到数据之后，再把数据进行解析并渲染呈现出来，得到最终的页面。所以说，要想爬取这个页面，我们可以直接爬取 Ajax 接口获取数据就好了。</p><p>在上一节中，我们已经了解了 Ajax 分析的基本方法，下面我们就来分析一下 Ajax 接口的逻辑并实现数据爬取吧。</p><h2 id="4-爬取列表页"><a href="#4-爬取列表页" class="headerlink" title="4. 爬取列表页"></a><a href="https://cuiqingcai.com/202253.html#4-%E7%88%AC%E5%8F%96%E5%88%97%E8%A1%A8%E9%A1%B5" title="4. 爬取列表页"></a>4. 爬取列表页</h2><p>首先我们来分析一下列表页的 Ajax 接口逻辑，打开浏览器开发者工具，切换到 Network 面板，勾选上 Preserve Log 并切换到 XHR 选项卡，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/dpns6.png" alt="image-20210705004826230"></p><p>接着重新刷新页面，再点击第二页、第三页、第四页的按钮，这时候可以观察到页面上的数据发生了变化，同时开发者工具下方就监听到了几个 Ajax 请求，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/x22b1.png" alt="image-20210705004904893"></p><p>由于我们切换了 4 页，每次翻页也出现了对应的 Ajax 请求，我们可以点击查看其请求详情。观察其请求的 URL 和参数以及响应内容是怎样的，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/1ro2i.png" alt="image-20210705004957327"></p><p>这里我们点开了最后个结果，观察到其 Ajax 接口请求的 URL 地址为：<a href="https://spa1.scrape.center/api/movie/?limit=10&amp;offset=40%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF">https://spa1.scrape.center/api/movie/?limit=10&offset=40，这里有两个参数，一个是</a> <code>limit</code>，这里是 10；一个是 <code>offset</code>，这里也是 40。</p><p>通过多个 Ajax 接口的参数，我们可以观察到这么一个规律：<code>limit</code> 一直为 10，这就正好对应着每页 10 条数据；<code>offset</code> 在依次变大，页面每加 1 页，<code>offset</code> 就加 10，这就代表着页面的数据偏移量，比如第二页的 <code>offset</code> 为 10 则代表着跳过 10 条数据，返回从 11 条数据开始的结果，再加上 <code>limit</code> 的限制，那就是第 11 条至第 20 条数据的结果。</p><p>接着我们再观察一下响应的数据，切换到 Preview 选项卡，结果如图所示：</p><p><img src="https://cdn.cuiqingcai.com/0ldhk.png" alt="image-20210705005115792"></p><p>可以看到，结果就是一些 JSON 数据，它有一个 <code>results</code> 字段，是一个列表，列表中每一个元素都是一个字典。观察一下字典的内容，这里我们正好可以看到有对应的电影数据的字段了，如 <code>name</code>、<code>alias</code>、<code>cover</code>、<code>categories</code>，对比下浏览器中的真实数据，各个内容完全一致，而且这个数据已经非常结构化了，完全就是我们想要爬取的数据，真的是得来全不费工夫。</p><p>这样的话，我们只需要把所有页面的 Ajax 接口构造出来，所有列表页的数据我们都可以轻松获取到了。</p><p>我们先定义一些准备工作，导入一些所需的库并定义一些配置，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>import logging  <br>  <br>logging.basicConfig(level&#x3D;logging.INFO,  <br>                    format&#x3D;’%(asctime)s - %(levelname)s: %(message)s’)  <br>  <br>INDEX_URL &#x3D; ‘<a href="https://spa1.scrape.center/api/movie/?limit=%7Blimit%7D&offset=%7Boffset%7D">https://spa1.scrape.center/api/movie/?limit={limit}&amp;offset={offset}</a>‘</td></tr></tbody></table><p>这里我们引入了 requests 和 logging 库，并定义了 logging 的基本配置，接着我们定义了 <code>INDEX_URL</code>，这里把 <code>limit</code> 和 <code>offset</code> 预留出来了变成了占位符，可以动态传入参数构造一个完整的列表页 URL。</p><p>下面我们来实现一下详情页的爬取。还是和原来一样，我们先定义一个通用的爬取方法，其代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>def scrape_api(url):  <br>    logging.info(‘scraping %s…’, url)  <br>    try:  <br>        response &#x3D; requests.get(url)  <br>        if response.status_code &#x3D;&#x3D; 200:  <br>            return response.json()  <br>        logging.error(‘get invalid status code %s while scraping %s’, response.status_code, url)  <br>    except requests.RequestException:  <br>        logging.error(‘error occurred while scraping %s’, url, exc_info&#x3D;True)</td></tr></tbody></table><p>这里我们定义了一个 <code>scrape_api</code> 方法，和之前不同的是，这个方法专门用来处理 JSON 接口，最后的 <code>response</code> 调用的是 <code>json</code> 方法，它可以解析响应的内容并将其转化成 JSON 字符串。</p><p>接着在这个基础之上，我们定义一个爬取列表页的方法，其代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>LIMIT &#x3D; 10  <br>  <br>def scrape_index(page):  <br>    url &#x3D; INDEX_URL.format(limit&#x3D;LIMIT, offset&#x3D;LIMIT * (page - 1))  <br>    return scrape_api(url)</td></tr></tbody></table><p>这里我们定义了一个 <code>scrape_index</code> 方法，它接收一个参数 <code>page</code>，该参数代表列表页的页码。</p><p>这里我们先构造了一个 <code>url</code>，通过字符串的 <code>format</code> 方法，传入 <code>limit</code> 和 <code>offset</code> 的值。这里 <code>limit</code> 就直接使用了全局变量 <code>LIMIT</code> 的值；<code>offset</code> 则是动态计算的，就是页码数减一再乘以 <code>limit</code>，比如第一页 <code>offset</code> 就是 0，第二页 <code>offset</code> 就是 10，以此类推。构造好了 <code>url</code> 之后，直接调用 <code>scrape_api</code> 方法并返回结果即可。</p><p>这样我们就完成了列表页的爬取，每次请求都会得到一页 10 部的电影数据。</p><p>由于这时爬取到的数据已经是 JSON 类型了，所以我们不用像之前那样去解析 HTML 代码来提取数据了，爬到的数据就是我们想要的结构化数据，因此解析这一步就可以直接省略啦。</p><p>到此为止，我们能成功爬取列表页并提取出电影列表信息了。</p><h2 id="5-爬取详情页"><a href="#5-爬取详情页" class="headerlink" title="5. 爬取详情页"></a><a href="https://cuiqingcai.com/202253.html#5-%E7%88%AC%E5%8F%96%E8%AF%A6%E6%83%85%E9%A1%B5" title="5. 爬取详情页"></a>5. 爬取详情页</h2><p>这时候我们已经可以拿到每一页的电影数据了，但是看看这些数据实际上还缺少了一些我们想要的信息，如剧情简介等信息，所以需要进一步进入到详情页来获取这些内容。</p><p>这时候点击任意一部电影，如《教父》，进入其详情页，这时可以发现页面的 URL 已经变成了 <a href="https://spa1.scrape.center/detail/40">https://spa1.scrape.center/detail/40</a>，页面也成功展示了详情页的信息，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/tuum6.png" alt="image-20210705005243372"></p><p>另外，我们也可以观察到在开发者工具中又出现了一个 Ajax 请求，其 URL 为 <a href="https://spa1.scrape.center/api/movie/40/">https://spa1.scrape.center/api/movie/40/</a>，通过 Preview 选项卡也能看到 Ajax 请求对应响应的信息，如图 所示。</p><p><img src="https://cdn.cuiqingcai.com/y1o4n.png" alt="image-20200601141202684"><br>稍加观察就可以发现，Ajax 请求的 URL 后面有一个参数是可变的，这个参数就是电影的 <code>id</code>，这里是 40，对应《教父》这部电影。</p><p>如果我们想要获取 <code>id</code> 为 50 的电影，只需要把 URL 最后的参数改成 50 即可，即 <a href="https://spa1.scrape.center/api/movie/50/">https://spa1.scrape.center/api/movie/50/</a>，请求这个新的 URL 我们就能获取 <code>id</code> 为 50 的电影所对应的数据了。</p><p>同样，响应结果也是结构化的 JSON 数据，字段也非常规整，我们直接爬取即可。</p><p>现在分析好了详情页的数据提取逻辑，那么怎么和列表页关联起来呢？这个 <code>id</code> 哪里来呢？我们回过头来再看看列表页的接口返回数据，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/bzc8x.png"></p><p>可以看到，列表页原本的返回数据就带了 <code>id</code> 这个字段，所以我们只需要拿列表页结果中的 <code>id</code> 来构造详情页的 Ajax 请求的 URL 就好了。</p><p>接着，我们就先定义一个详情页的爬取逻辑，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>DETAIL_URL &#x3D; ‘<a href="https://spa1.scrape.center/api/movie/%7Bid%7D">https://spa1.scrape.center/api/movie/{id}</a>‘  <br>  <br>def scrape_detail(id):  <br>    url &#x3D; DETAIL_URL.format(id&#x3D;id)  <br>    return scrape_api(url)</td></tr></tbody></table><p>这里我们定义了一个 <code>scrape_detail</code> 方法，它接收一个参数 <code>id</code>。这里的实现也非常简单，先根据定义好的 <code>DETAIL_URL</code> 加 <code>id</code> 构造一个真实的详情页 Ajax 请求的 URL，然后直接调用 <code>scrape_api</code> 方法传入这个 <code>url</code> 即可。</p><p>接着，我们定义一个总的调用方法，将以上方法串联调用起来，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>TOTAL_PAGE &#x3D; 10  <br>  <br>def main():  <br>    for page in range(1, TOTAL_PAGE + 1):  <br>        index_data &#x3D; scrape_index(page)  <br>        for item in index_data.get(‘results’):  <br>            id &#x3D; item.get(‘id’)  <br>            detail_data &#x3D; scrape_detail(id)  <br>            logging.info(‘detail data %s’, detail_data)  <br>  <br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:  <br>    main()</td></tr></tbody></table><p>这里我们定义了一个 <code>main</code> 方法，首先遍历获取了页码 <code>page</code>，然后把 <code>page</code> 当参数传递给了 <code>scrape_index</code> 方法，得到列表页的数据。接着我们遍历每个列表页的每个结果，获取到每部电影的 <code>id</code>，然后把 <code>id</code> 当作参数传递给 <code>scrape_detail</code> 方法来爬取每部电影的详情数据，并将其赋值为 <code>detail_data</code>，输出即可。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>2020-03-19 02:51:55,981 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/?limit=10&offset=0">https://spa1.scrape.center/api/movie/?limit=10&amp;offset=0</a>…  <br>2020-03-19 02:51:56,446 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/1">https://spa1.scrape.center/api/movie/1</a>…  <br>2020-03-19 02:51:56,638 - INFO: detail data {‘id’: 1, ‘name’: ‘霸王别姬’, ‘alias’: ‘Farewell My Concubine’, ‘cover’: ‘<a href="https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c">https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c</a>‘, ‘categories’: [‘剧情’, ‘爱情’], ‘regions’: [‘中国大陆’, ‘中国香港’], ‘actors’: [{‘name’: ‘张国荣’, ‘role’: ‘程蝶衣’, …}, …], ‘directors’: [{‘name’: ‘陈凯歌’, ‘image’: ‘<a href="https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c'%7D]">https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c&#39;}]</a>, ‘score’: 9.5, ‘rank’: 1, ‘minute’: 171, ‘drama’: ‘影片借一出《霸王别姬》的京戏，牵扯出三个人之间一段随时代风云变幻的爱恨情仇。段小楼（张丰毅 饰）与程蝶衣（张国荣 饰）是一对打小一起长大的师兄弟，…’, ‘photos’: […], ‘published_at’: ‘1993-07-26’, ‘updated_at’: ‘2020-03-07T16:31:36.967843Z’}  <br>2020-03-19 02:51:56,640 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/2">https://spa1.scrape.center/api/movie/2</a>…  <br>2020-03-19 02:51:56,813 - INFO: detail data {‘id’: 2, ‘name’: ‘这个杀手不太冷’, ‘alias’: ‘Léon’, ‘cover’: ‘<a href="https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c">https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c</a>‘, ‘categories’: [‘剧情’, ‘动作’, ‘犯罪’], ‘regions’: [‘法国’], ‘actors’: [{‘name’: ‘让·雷诺’, ‘role’: ‘莱昂 Leon’, …}, …], ‘directors’: [{‘name’: ‘吕克·贝松’, ‘image’: ‘<a href="https://p0.meituan.net/movie/0e7d67e343bd3372a714093e8340028d40496.jpg@128w_170h_1e_1c'%7D]">https://p0.meituan.net/movie/0e7d67e343bd3372a714093e8340028d40496.jpg@128w_170h_1e_1c&#39;}]</a>, ‘score’: 9.5, ‘rank’: 3, ‘minute’: 110, ‘drama’: ‘里昂（让·雷诺 饰）是名孤独的职业杀手，受人雇佣。一天，邻居家小姑娘马蒂尔德（纳塔丽·波特曼 饰）敲开他的房门，要求在他那里暂避杀身之祸。…’, ‘photos’: […], ‘published_at’: ‘1994-09-14’, ‘updated_at’: ‘2020-03-07T16:31:43.826235Z’}  <br>…</td></tr></tbody></table><p>由于内容较多，这里省略了部分内容。</p><p>可以看到，其实整个爬取工作就已经完成了，这里会顺次爬取每一页列表页 Ajax 接口，然后去顺次爬取每部电影的详情页 Ajax 接口，打印出每部电影的 Ajax 接口响应数据，而且都是 JSON 格式。这样，所有电影的详情数据都会被我们爬取到啦。</p><h2 id="6-保存数据"><a href="#6-保存数据" class="headerlink" title="6. 保存数据"></a><a href="https://cuiqingcai.com/202253.html#6-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE" title="6. 保存数据"></a>6. 保存数据</h2><p>好，成功提取到详情页信息之后，我们下一步就要把数据保存起来了。在前面我们学习了 MongoDB 的相关操作，接下来我们就把数据保存到 MongoDB 吧。</p><p>在这之前，请确保现在有一个可以正常连接和使用的 MongoDB 数据库，这里我就以本地 localhost 的 M 哦能够 DB 数据库为例来进行操作，其运行在 27017 端口上，无用户名和密码。</p><p>将数据导入 MongoDB 需要用到 PyMongo 这个库。接下来我们把它们引入一下，然后同时定义一下 MongoDB 的连接配置，实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>MONGO_CONNECTION_STRING &#x3D; ‘mongodb:&#x2F;&#x2F;localhost:27017’  <br>MONGO_DB_NAME &#x3D; ‘movies’  <br>MONGO_COLLECTION_NAME &#x3D; ‘movies’  <br>  <br>import pymongo  <br>client &#x3D; pymongo.MongoClient(MONGO_CONNECTION_STRING)  <br>db &#x3D; client[‘movies’]  <br>collection &#x3D; db[‘movies’]</td></tr></tbody></table><p>在这里我们声明了几个变量，介绍如下：</p><ul><li>MONGO_CONNECTION_STRING：MongoDB 的连接字符串，里面定义了 MongoDB 的基本连接信息，如 host、port，还可以定义用户名密码等内容。</li><li>MONGO_DB_NAME：MongoDB 数据库的名称。</li><li>MONGO_COLLECTION_NAME：MongoDB 的集合名称。</li></ul><p>这里我们用 MongoClient 声明了一个连接对象，然后依次声明了存储的数据库和集合。</p><p>接下来，我们再实现一个将数据保存到 MongoDB 的方法，实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>def save_data(data):  <br>    collection.update_one({  <br>        ‘name’: data.get(‘name’)  <br>    }, {  <br>        ‘$set’: data  <br>    }, upsert&#x3D;True)</td></tr></tbody></table><p>在这里我们声明了一个 save_data 方法，它接收一个 data 参数，也就是我们刚才提取的电影详情信息。在方法里面，我们调用了 update_one 方法，第一个参数是查询条件，即根据 name 进行查询；第二个参数就是 data 对象本身，就是所有的数据，这里我们用 <code>$set</code> 操作符表示更新操作；第三个参数很关键，这里实际上是 upsert 参数，如果把这个设置为 True，则可以做到存在即更新，不存在即插入的功能，更新会根据第一个参数设置的 name 字段，所以这样可以防止数据库中出现同名的电影数据。</p><blockquote><p>注：实际上电影可能有同名，但该场景下的爬取数据没有同名情况，当然这里更重要的是实现 MongoDB 的去重操作。</p></blockquote><p>好的，那么接下来 main 方法稍微改写一下就好了，改写如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>def main():  <br>    for page in range(1, TOTAL_PAGE + 1):  <br>        index_data &#x3D; scrape_index(page)  <br>        for item in index_data.get(‘results’):  <br>            id &#x3D; item.get(‘id’)  <br>            detail_data &#x3D; scrape_detail(id)  <br>            logging.info(‘detail data %s’, detail_data)  <br>            save_data(detail_data)  <br>            logging.info(‘data saved successfully’)</td></tr></tbody></table><p>这里就是加了 save_data 方法的调用，并加了一些日志信息。</p><p>重新运行，我们看下输出结果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>2020-03-19 02:51:06,323 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/?limit=10&offset=0">https://spa1.scrape.center/api/movie/?limit=10&amp;offset=0</a>…  <br>2020-03-19 02:51:06,440 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/1">https://spa1.scrape.center/api/movie/1</a>…  <br>2020-03-19 02:51:06,551 - INFO: detail data {‘id’: 1, ‘name’: ‘霸王别姬’, ‘alias’: ‘Farewell My Concubine’, ‘cover’: ‘<a href="https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c">https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c</a>‘, ‘categories’: [‘剧情’, ‘爱情’], ‘regions’: [‘中国大陆’, ‘中国香港’], ‘actors’: [{‘name’: ‘张国荣’, ‘role’: ‘程蝶衣’, ‘image’: ‘<a href="https://p0.meituan.net/movie/5de69a492dcbd3f4b014503d4e95d46c28837.jpg@128w_170h_1e_1c'%7D">https://p0.meituan.net/movie/5de69a492dcbd3f4b014503d4e95d46c28837.jpg@128w_170h_1e_1c&#39;}</a>, …, {‘name’: ‘方征’, ‘role’: ‘嫖客’, ‘image’: ‘<a href="https://p1.meituan.net/movie/39687137b23bc9727b47fd24bdcc579b97618.jpg@128w_170h_1e_1c'%7D]">https://p1.meituan.net/movie/39687137b23bc9727b47fd24bdcc579b97618.jpg@128w_170h_1e_1c&#39;}]</a>, ‘directors’: [{‘name’: ‘陈凯歌’, ‘image’: ‘<a href="https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c'%7D]">https://p0.meituan.net/movie/8f9372252050095067e0e8d58ef3d939156407.jpg@128w_170h_1e_1c&#39;}]</a>, ‘score’: 9.5, ‘rank’: 1, ‘minute’: 171, ‘drama’: ‘影片借一出《霸王别姬》的京戏，牵扯出三个人之间一段随时代风云变幻的爱恨情仇。段小楼（张丰毅 饰）与程蝶衣（张国荣 饰）是一对打小一起长大的师兄弟，两人一个演生，一个饰旦，一向配合天衣无缝，尤其一出《霸王别姬》，更是誉满京城，为此，两人约定合演一辈子《霸王别姬》。但两人对戏剧与人生关系的理解有本质不同，段小楼深知戏非人生，程蝶衣则是人戏不分。段小楼在认为该成家立业之时迎娶了名妓菊仙（巩俐 饰），致使程蝶衣认定菊仙是可耻的第三者，使段小楼做了叛徒，自此，三人围绕一出《霸王别姬》生出的爱恨情仇战开始随着时代风云的变迁不断升级，终酿成悲剧。’, ‘photos’: [‘<a href="https://p0.meituan.net/movie/45be438368bb291e501dc523092f0ac8193424.jpg@106w_106h_1e_1c">https://p0.meituan.net/movie/45be438368bb291e501dc523092f0ac8193424.jpg@106w_106h_1e_1c</a>‘, …, ‘<a href="https://p0.meituan.net/movie/0d952107429db3029b64bf4f25bd762661696.jpg@106w_106h_1e_1c']">https://p0.meituan.net/movie/0d952107429db3029b64bf4f25bd762661696.jpg@106w_106h_1e_1c&#39;]</a>, ‘published_at’: ‘1993-07-26’, ‘updated_at’: ‘2020-03-07T16:31:36.967843Z’}  <br>2020-03-19 02:51:06,583 - INFO: data saved successfully  <br>2020-03-19 02:51:06,583 - INFO: scraping <a href="https://spa1.scrape.center/api/movie/2">https://spa1.scrape.center/api/movie/2</a>…</td></tr></tbody></table><p>由于输出内容较多，这里省略了部分内容。</p><p>我们可以看到这里我们成功爬取到了数据，并且提示了数据存储成功的信息，没有任何报错信息。</p><p>接下来我们使用 Robo 3T 连接 MongoDB 数据库看下爬取的结果，由于我使用的是本地的 MongoDB，所以在 Robo 3T 里面我直接输入 localhost 的连接信息即可，这里请替换成自己的 MongoDB 连接信息，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/imum3.png"></p><p>连接之后我们便可以在 movies 这个数据库，movies 这个集合下看到我们刚才爬取的数据了，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/ammal.png"></p><p>可以看到数据就是以 JSON 格式存储的，一条数据就对应一部电影的信息，各种嵌套信息也一目了然，同时第三列还有数据类型标识。</p><p>这样就证明我们的数据就成功存储到 MongoDB 里了。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><a href="https://cuiqingcai.com/202253.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>本节中我们通过一个案例来体会了 Ajax 分析和爬取的基本流程，希望大家通过本节能够更加熟悉 Ajax 的分析和爬取实现。</p><p>另外，我们也观察到，由于 Ajax 接口大部分返回的是 JSON 数据，所以在一定程度上可以避免一些数据提取的工作，这也在一定程度上减轻了工作量。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/ScrapeSpa1%E3%80%82">https://github.com/Python3WebSpider/ScrapeSpa1。</a></p><h1 id="经典动态渲染工具-Selenium-的使用"><a href="#经典动态渲染工具-Selenium-的使用" class="headerlink" title="# 经典动态渲染工具 Selenium 的使用"></a># 经典动态渲染工具 Selenium 的使用</h1><p>前面我们讲解了 Ajax 的分析方法，利用 Ajax 接口我们可以非常方便地完成数据爬取。只要我们能找到 Ajax 接口的规律，就可以通过某些参数构造出对应的请求，数据自然就能轻松爬取到。</p><p>但是在很多情况下，一些 Ajax 请求的接口通常会包含加密参数，如 <code>token</code>、<code>sign</code> 等，如：<a href="https://spa2.scrape.center/%EF%BC%8C%E5%AE%83%E7%9A%84">https://spa2.scrape.center/，它的</a> Ajax 接口是包含一个 <code>token</code> 参数的，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/y6w4q.png" alt="包含 `token` 参数的 Ajax 接口"></p><p>由于请求接口时必须加上 <code>token</code> 参数，所以我们如果不深入分析找到 <code>token</code> 的构造逻辑，是难以直接模拟这些 Ajax 请求的。</p><p>此时解决方法通常有两种：一种就是深挖其中的逻辑，把其中 <code>token</code> 的构造逻辑完全找出来，再用 Python 复现，构造 Ajax 请求；另外一种方法就是直接通过模拟浏览器的方式来绕过这个过程，因为在浏览器里我们可以看到这个数据，如果能把看到的数据直接爬取下来，当然也就能获取对应的信息了。</p><p>由于第一种方法难度较高，这里我们就先介绍第二种方法：模拟浏览器爬取。</p><p>这里使用的工具为 Selenium，这里就来先了解一下 Selenium 的基本使用方法。</p><p>Selenium 是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些 JavaScript 动态渲染的页面来说，此种抓取方式非常有效。本节中，就让我们来感受一下它的强大之处吧。</p><h2 id="1-准备工作-1"><a href="#1-准备工作-1" class="headerlink" title="1. 准备工作"></a><a href="https://cuiqingcai.com/202261.html#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1. 准备工作"></a>1. 准备工作</h2><p>本节以 Chrome 为例来讲解 Selenium 的用法。在开始之前，请确保已经正确安装好了 Chrome 浏览器并配置好了 ChromeDriver。另外，还需要正确安装好 Python 的 Selenium 库。</p><p>安装方法可以参考：<a href="https://setup.scrape.center/selenium%EF%BC%8C%E5%85%A8%E9%83%A8%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BE%BF%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E6%9C%AC%E8%8A%82%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%86%E3%80%82">https://setup.scrape.center/selenium，全部配置完成之后，我们便可以开始本节的学习了。</a></p><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a><a href="https://cuiqingcai.com/202261.html#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" title="2. 基本用法"></a>2. 基本用法</h2><p>准备工作做好之后，首先来大体看一下 Selenium 的功能。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver.common.by import By  <br>from selenium.webdriver.common.keys import Keys  <br>from selenium.webdriver.support import expected_conditions as EC  <br>from selenium.webdriver.support.wait import WebDriverWait  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>try:  <br>    browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>    input &#x3D; browser.find_element_by_id(‘kw’)  <br>    input.send_keys(‘Python’)  <br>    input.send_keys(Keys.ENTER)  <br>    wait &#x3D; WebDriverWait(browser, 10)  <br>    wait.until(EC.presence_of_element_located((By.ID, ‘content_left’)))  <br>    print(browser.current_url)  <br>    print(browser.get_cookies())  <br>    print(browser.page_source)  <br>finally:  <br>    browser.close()</td></tr></tbody></table><p>运行代码后发现，会自动弹出一个 Chrome 浏览器。浏览器首先会跳转到百度，然后在搜索框中输入 Python，接着跳转到搜索结果页，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/fu94j.png"></p><p>此时在控制台的输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=Python&rsv_pq=c94d0df9000a72d0&rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F+CQ&rqlang=cn&rsv_enter=1&rsv_sug3=6&rsv_sug2=0&inputT=87&rsv_sug4=87">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=Python&amp;rsv_pq=c94d0df9000a72d0&amp;rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F%2BCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=6&amp;rsv_sug2=0&amp;inputT=87&amp;rsv_sug4=87</a>  <br>[{‘secure’: False, ‘value’: ‘B490B5EBF6F3CD402E515D22BCDA1598’, ‘domain’: ‘.baidu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘BDORZ’, ‘expiry’: 1491688071.707553}, {‘secure’: False, ‘value’: ‘22473_1441_21084_17001’, ‘domain’: ‘.baidu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘H_PS_PSSID’}, {‘secure’: False, ‘value’: ‘12883875381399993259_00_0_I_R_2_0303_C02F_N_I_I_0’, ‘domain’: ‘.<a href="http://www.baidu.com/">www.baidu.com</a>‘, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘__bsi’, ‘expiry’: 1491601676.69722}]  <br><!DOCTYPE html><!--STATUS OK-->…</html></td></tr></tbody></table><p>源代码过长，在此省略。可以看到，我们得到的当前 URL、Cookies 和源代码都是浏览器中的真实内容。</p><p>所以说，如果用 Selenium 来驱动浏览器加载网页的话，就可以直接拿到 JavaScript 渲染的结果了，不用担心使用的是什么加密系统。</p><p>下面来详细了解一下 Selenium 的用法。</p><h2 id="3-声明浏览器对象"><a href="#3-声明浏览器对象" class="headerlink" title="3. 声明浏览器对象"></a><a href="https://cuiqingcai.com/202261.html#3-%E5%A3%B0%E6%98%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1" title="3. 声明浏览器对象"></a>3. 声明浏览器对象</h2><p>Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器。我们可以用如下方式初始化：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser &#x3D; webdriver.Firefox()  <br>browser &#x3D; webdriver.Edge()  <br>browser &#x3D; webdriver.Safari()</td></tr></tbody></table><p>这样就完成了浏览器对象的初始化并将其赋值为 <code>browser</code> 对象。接下来，我们要做的就是调用 <code>browser</code> 对象，让其执行各个动作以模拟浏览器操作。</p><h2 id="4-访问页面"><a href="#4-访问页面" class="headerlink" title="4. 访问页面"></a><a href="https://cuiqingcai.com/202261.html#4-%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2" title="4. 访问页面"></a>4. 访问页面</h2><p>我们可以用 <code>get</code> 方法来请求网页，其参数传入链接 URL 即可。比如，这里用 <code>get</code> 方法访问淘宝，然后打印出源代码，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>print(browser.page_source)  <br>browser.close()</td></tr></tbody></table><p>运行后发现，此时弹出了 Chrome 浏览器并且自动访问了淘宝，然后控制台输出了淘宝页面的源代码，随后浏览器关闭。</p><p>通过这几行简单的代码，我们可以实现浏览器的驱动并获取网页源码，非常便捷。</p><h2 id="5-查找节点"><a href="#5-查找节点" class="headerlink" title="5. 查找节点"></a><a href="https://cuiqingcai.com/202261.html#5-%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9" title="5. 查找节点"></a>5. 查找节点</h2><p>Selenium 可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。比如，我们想要完成向某个输入框输入文字的操作，总需要知道这个输入框在哪里吧？而 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便下一步执行一些动作或者提取信息。</p><h3 id="单个节点"><a href="#单个节点" class="headerlink" title="单个节点"></a><a href="https://cuiqingcai.com/202261.html#%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9" title="单个节点"></a>单个节点</h3><p>比如，想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/lwmpo.png" alt="源代码"></p><p>可以发现，它的 <code>id</code> 是 <code>q</code>，<code>name</code> 也是 <code>q</code>。此外，还有许多其他属性，此时我们就可以用多种方式获取它了。比如，<code>find_element_by_name</code> 是根据 <code>name</code> 值获取，<code>find_element_by_id</code> 是根据 <code>id</code> 获取。另外，还有根据 XPath、CSS 选择器等获取的方式。</p><p>下面我们用代码实现一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>input_first &#x3D; browser.find_element_by_id(‘q’)  <br>input_second &#x3D; browser.find_element_by_css_selector(‘#q’)  <br>input_third &#x3D; browser.find_element_by_xpath(‘&#x2F;&#x2F;*[@id&#x3D;”q”]’)  <br>print(input_first, input_second, input_third)  <br>browser.close()</td></tr></tbody></table><p>这里我们使用 3 种方式获取输入框，分别是根据 ID、CSS 选择器和 XPath 获取，它们返回的结果完全一致。运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”5e53d9e1c8646e44c14c1c2880d424af”, element&#x3D;”0.5649563096161541-1”)&gt;  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”5e53d9e1c8646e44c14c1c2880d424af”, element&#x3D;”0.5649563096161541-1”)&gt;  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”5e53d9e1c8646e44c14c1c2880d424af”, element&#x3D;”0.5649563096161541-1”)&gt;</td></tr></tbody></table><p>可以看到，这 3 个节点都是 <code>WebElement</code> 类型，是完全一致的。</p><p>下面列出所有获取单个节点的方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>find_element__id  <br>find_element__name  <br>find_element__xpath  <br>find_element__link_text  <br>find_element__partial_link_text  <br>find_element__tag_name  <br>find_element__class_name  <br>find_element__css_selector</td></tr></tbody></table><p>另外，Selenium 还提供了通用方法 <code>find_element</code>，它需要传入两个参数：查找方式 <code>By</code> 和值。实际上，它就是 <code>find_element_by_id</code> 这种方法的通用函数版本，比如 <code>find_element_by_id(id)</code> 就等价于 <code>find_element(By.ID, id)</code>，二者得到的结果完全一致。我们用代码实现一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver.common.by import By  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>input_first &#x3D; browser.find_element(By.ID, ‘q’)  <br>print(input_first)  <br>browser.close()</td></tr></tbody></table><p>实际上，这种查找方式的功能和上面列举的查找函数完全一致，不过参数更加灵活。</p><h3 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a><a href="https://cuiqingcai.com/202261.html#%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9" title="多个节点"></a>多个节点</h3><p>如果查找的目标在网页中只有一个，那么完全可以用 <code>find_element</code> 方法。但如果有多个节点，再用 <code>find_element</code> 方法查找，就只能得到第一个节点了。如果要查找所有满足条件的节点，需要用 <code>find_elements</code> 这样的方法。注意，在这个方法的名称中，element 多了一个 s，注意区分。</p><p>比如，要查找淘宝左侧导航条的所有条目，就可以这样来实现：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>lis &#x3D; browser.find_elements_by_css_selector(‘.service-bd li’)  <br>print(lis)  <br>browser.close()</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-1”)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-2”)&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-3”)&gt;…&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”c26290835d4457ebf7d96bfab3740d19”, element&#x3D;”0.09221044033125603-16”)&gt;]</td></tr></tbody></table><p>这里简化了输出结果，中间部分省略。</p><p>可以看到，得到的内容变成了列表类型，列表中的每个节点都是 <code>WebElement</code> 类型。</p><p>也就是说，如果我们用 <code>find_element</code> 方法，只能获取匹配的第一个节点，结果是 <code>WebElement</code> 类型。如果用 <code>find_elements</code> 方法，则结果是列表类型，列表中的每个节点都是 <code>WebElement</code> 类型。</p><p>这里列出所有获取多个节点的方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>find_elements_by_id  <br>find_elements_by_name  <br>find_elements_by_xpath  <br>find_elements_by_link_text  <br>find_elements_by_partial_link_text  <br>find_elements_by_tag_name  <br>find_elements_by_class_name  <br>find_elements_by_css_selector</td></tr></tbody></table><p>当然，我们也可以直接用 <code>find_elements</code> 方法来选择，这时可以这样写：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>lis &#x3D; browser.find_elements(By.CSS_SELECTOR, ‘.service-bd li’)</td></tr></tbody></table><p>结果是完全一致的。</p><h2 id="6-节点交互"><a href="#6-节点交互" class="headerlink" title="6. 节点交互"></a><a href="https://cuiqingcai.com/202261.html#6-%E8%8A%82%E7%82%B9%E4%BA%A4%E4%BA%92" title="6. 节点交互"></a>6. 节点交互</h2><p>Selenium 可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用 <code>send_keys</code> 方法，清空文字时用 <code>clear</code> 方法，点击按钮时用 <code>click</code> 方法。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>import time  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>input &#x3D; browser.find_element_by_id(‘q’)  <br>input.send_keys(‘iPhone’)  <br>time.sleep(1)  <br>input.clear()  <br>input.send_keys(‘iPad’)  <br>button &#x3D; browser.find_element_by_class_name(‘btn-search’)  <br>button.click()</td></tr></tbody></table><p>这里首先驱动浏览器打开淘宝，然后用 <code>find_element_by_id</code> 方法获取输入框，然后用 <code>send_keys</code> 方法输入 iPhone 文字，等待一秒后用 <code>clear</code> 方法清空输入框，再次调用 <code>send_keys</code> 方法输入 iPad 文字，之后再用 <code>find_element_by_class_name</code> 方法获取搜索按钮，最后调用 <code>click</code> 方法完成搜索动作。</p><p>通过上面的方法，我们完成了一些常见节点的操作，更多的操作可以参见官方文档的交互动作介绍 ：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement。</a></p><h2 id="7-动作链"><a href="#7-动作链" class="headerlink" title="7. 动作链"></a><a href="https://cuiqingcai.com/202261.html#7-%E5%8A%A8%E4%BD%9C%E9%93%BE" title="7. 动作链"></a>7. 动作链</h2><p>在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按钮，就调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。</p><p>比如，现在实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处，可以这样实现：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver import ActionChains  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable">http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable</a>‘  <br>browser.get(url)  <br>browser.switch_to.frame(‘iframeResult’)  <br>source &#x3D; browser.find_element_by_css_selector(‘#draggable’)  <br>target &#x3D; browser.find_element_by_css_selector(‘#droppable’)  <br>actions &#x3D; ActionChains(browser)  <br>actions.drag_and_drop(source, target)  <br>actions.perform()</td></tr></tbody></table><p>首先，打开网页中的一个拖曳实例，然后依次选中要拖曳的节点和拖曳到的目标节点，接着声明 <code>ActionChains</code> 对象并将其赋值为 <code>actions</code> 变量，然后通过调用 <code>actions</code> 变量的 <code>drag_and_drop</code> 方法，再调用 <code>perform</code> 方法执行动作，此时就完成了拖曳操作，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/7650u.jpg" alt="拖曳前页面"></p><p><img src="https://cdn.cuiqingcai.com/z8xjy.jpg" alt="拖曳后页面"></p><p>更多的动作链操作可以参考官方文档的动作链介绍：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains。</a></p><h2 id="8-执行-JavaScript"><a href="#8-执行-JavaScript" class="headerlink" title="8. 执行 JavaScript"></a><a href="https://cuiqingcai.com/202261.html#8-%E6%89%A7%E8%A1%8C-JavaScript" title="8. 执行 JavaScript"></a>8. 执行 JavaScript</h2><p>对于某些操作，Selenium API 并没有提供。比如，下拉进度条，它可以直接模拟运行 JavaScript，此时使用 <code>execute_script</code> 方法即可实现，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.zhihu.com/explore">https://www.zhihu.com/explore</a>‘)  <br>browser.execute_script(‘window.scrollTo(0, document.body.scrollHeight)’)  <br>browser.execute_script(‘alert(“To Bottom”)’)</td></tr></tbody></table><p>这里就利用 <code>execute_script</code> 方法将进度条下拉到最底部，然后弹出 alert 提示框。</p><p>所以说有了这个方法，基本上 API 没有提供的所有功能都可以用执行 JavaScript 的方式来实现了。</p><h2 id="9-获取节点信息"><a href="#9-获取节点信息" class="headerlink" title="9. 获取节点信息"></a><a href="https://cuiqingcai.com/202261.html#9-%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF" title="9. 获取节点信息"></a>9. 获取节点信息</h2><p>前面说过，通过 <code>page_source</code> 属性可以获取网页的源代码，接着就可以使用解析库（如正则表达式、Beautiful Soup、pyquery 等）来提取信息了。</p><p>不过，既然 Selenium 已经提供了选择节点的方法，返回的是 <code>WebElement</code> 类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，我们就可以不用通过解析源代码来提取信息了，非常方便。</p><p>接下来，我们就来看看怎样获取节点信息吧。</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a><a href="https://cuiqingcai.com/202261.html#%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7" title="获取属性"></a>获取属性</h3><p>我们可以使用 <code>get_attribute</code> 方法来获取节点的属性，但是其前提是先选中这个节点，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘  <br>browser.get(url)  <br>logo &#x3D; browser.find_element_by_class_name(‘logo-image’)  <br>print(logo)  <br>print(logo.get_attribute(‘src’))</td></tr></tbody></table><p>运行之后，程序便会驱动浏览器打开该页面，然后获取 <code>class</code> 为 <code>logo-image</code> 的节点，最后打印出它的 <code>src</code>。</p><p>控制台的输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”7f4745d35a104759239b53f68a6f27d0”, element&#x3D;”cd7c72b4-4920-47ed-91c5-ea06601dc509”)&gt;  <br><a href="https://spa2.scrape.center/img/logo.a508a8f0.png">https://spa2.scrape.center/img/logo.a508a8f0.png</a></td></tr></tbody></table><p>通过 <code>get_attribute</code> 方法，然后传入想要获取的属性名，就可以得到它的值了。</p><h3 id="获取文本值"><a href="#获取文本值" class="headerlink" title="获取文本值"></a><a href="https://cuiqingcai.com/202261.html#%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%80%BC" title="获取文本值"></a>获取文本值</h3><p>每个 <code>WebElement</code> 节点都有 <code>text</code> 属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于 pyquery 的 <code>text</code> 方法，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘  <br>browser.get(url)  <br>input &#x3D; browser.find_element_by_class_name(‘logo-title’)  <br>print(input.text)</td></tr></tbody></table><p>这里依然先打开页面，然后获取 <code>class</code> 为 <code>logo-title</code> 这个节点，再将其文本值打印出来。</p><p>控制台的输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Scrape</td></tr></tbody></table><h3 id="获取-ID、位置、标签名和大小"><a href="#获取-ID、位置、标签名和大小" class="headerlink" title="获取 ID、位置、标签名和大小"></a><a href="https://cuiqingcai.com/202261.html#%E8%8E%B7%E5%8F%96-ID%E3%80%81%E4%BD%8D%E7%BD%AE%E3%80%81%E6%A0%87%E7%AD%BE%E5%90%8D%E5%92%8C%E5%A4%A7%E5%B0%8F" title="获取 ID、位置、标签名和大小"></a>获取 ID、位置、标签名和大小</h3><p>另外，<code>WebElement</code> 节点还有一些其他属性，比如 <code>id</code> 属性可以获取节点 ID，<code>location</code> 属性可以获取该节点在页面中的相对位置，<code>tag_name</code> 属性可以获取标签名称，<code>size</code> 属性可以获取节点的大小，也就是宽高，这些属性有时候还是很有用的。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘  <br>browser.get(url)  <br>input &#x3D; browser.find_element_by_class_name(‘logo-title’)  <br>print(input.id)  <br>print(input.location)  <br>print(input.tag_name)  <br>print(input.size)</td></tr></tbody></table><p>这里首先获得 <code>class</code> 为 <code>logo-title</code> 这个节点，然后调用其 <code>id</code>、<code>location</code>、<code>tag_name</code>、<code>size</code> 属性来获取对应的属性值。</p><h2 id="10-切换-Frame"><a href="#10-切换-Frame" class="headerlink" title="10. 切换 Frame"></a><a href="https://cuiqingcai.com/202261.html#10-%E5%88%87%E6%8D%A2-Frame" title="10. 切换 Frame"></a>10. 切换 Frame</h2><p>我们知道网页中有一种节点叫作 iframe，也就是子 Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。Selenium 打开页面后，它默认是在父级 Frame 里面操作，而此时如果页面中还有子 Frame，它是不能获取到子 Frame 里面的节点的。这时就需要使用 <code>switch_to.frame</code> 方法来切换 Frame。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import time  <br>from selenium import webdriver  <br>from selenium.common.exceptions import NoSuchElementException  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>url &#x3D; ‘<a href="http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable">http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable</a>‘  <br>browser.get(url)  <br>browser.switch_to.frame(‘iframeResult’)  <br>try:  <br>    logo &#x3D; browser.find_element_by_class_name(‘logo’)  <br>except NoSuchElementException:  <br>    print(‘NO LOGO’)  <br>browser.switch_to.parent_frame()  <br>logo &#x3D; browser.find_element_by_class_name(‘logo’)  <br>print(logo)  <br>print(logo.text)</td></tr></tbody></table><p>控制台输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>NO LOGO  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”4bb8ac03ced4ecbdefef03ffdc0e4ccd”, element&#x3D;”0.13792611320464965-2”)&gt;  <br>RUNOOB.COM</td></tr></tbody></table><p>这里还是以前面演示动作链操作的网页为实例，首先通过 <code>switch_to.frame</code> 方法切换到子 Frame 里面，然后尝试获取子 Frame 里的 logo 节点（这是找不到的），如果找不到的话，就会抛出 <code>NoSuchElementException</code> 异常，异常被捕捉之后，就会输出 <code>NO LOGO</code>。接下来，重新切换回父级 Frame，然后再次重新获取节点，发现此时可以成功获取了。</p><p>所以，当页面中包含子 Frame 时，如果想获取子 Frame 中的节点，需要先调用 <code>switch_to.frame</code> 方法切换到对应的 Frame，然后再进行操作。</p><h2 id="11-延时等待"><a href="#11-延时等待" class="headerlink" title="11. 延时等待"></a><a href="https://cuiqingcai.com/202261.html#11-%E5%BB%B6%E6%97%B6%E7%AD%89%E5%BE%85" title="11. 延时等待"></a>11. 延时等待</h2><p>在 Selenium 中，<code>get</code> 方法会在网页框架加载结束后结束执行，此时如果获取 <code>page_source</code>，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的 Ajax 请求，我们在网页源代码中也不一定能成功获取到。所以，这里需要延时等待一定时间，确保节点已经加载出来。</p><p>这里等待方式有两种：一种是隐式等待，一种是显式等待。</p><h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a><a href="https://cuiqingcai.com/202261.html#%E9%9A%90%E5%BC%8F%E7%AD%89%E5%BE%85" title="隐式等待"></a>隐式等待</h3><p>当使用隐式等待执行测试的时候，如果 Selenium 没有在 DOM 中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，当查找节点而节点并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.implicitly_wait(10)  <br>browser.get(‘<a href="https://spa2.scrape.center/">https://spa2.scrape.center/</a>‘)  <br>input &#x3D; browser.find_element_by_class_name(‘logo-image’)  <br>print(input)</td></tr></tbody></table><p>这里我们用 <code>implicitly_wait</code> 方法实现了隐式等待。</p><h3 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a><a href="https://cuiqingcai.com/202261.html#%E6%98%BE%E5%BC%8F%E7%AD%89%E5%BE%85" title="显式等待"></a>显式等待</h3><p>隐式等待的效果其实并没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响。</p><p>这里还有一种更合适的显式等待方法，它指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver.common.by import By  <br>from selenium.webdriver.support.ui import WebDriverWait  <br>from selenium.webdriver.support import expected_conditions as EC  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com/</a>‘)  <br>wait &#x3D; WebDriverWait(browser, 10)  <br>input &#x3D; wait.until(EC.presence_of_element_located((By.ID, ‘q’)))  <br>button &#x3D; wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, ‘.btn-search’)))  <br>print(input, button)</td></tr></tbody></table><p>这里首先引入 <code>WebDriverWait</code> 这个对象，指定最长等待时间，然后调用它的 <code>until</code>方法，传入等待条件 <code>expected_conditions</code>。比如，这里传入了 <code>presence_of_element_located</code> 这个条件，代表节点出现的意思，其参数是节点的定位元组，也就是 ID 为 <code>q</code> 的节点搜索框。</p><p>这样可以做到的效果就是，在 10 秒内如果 ID 为 <code>q</code> 的节点（即搜索框）成功加载出来，就返回该节点；如果超过 10 秒还没有加载出来，就抛出异常。</p><p>对于按钮，可以更改一下等待条件，比如改为 <code>element_to_be_clickable</code>，也就是可点击，所以查找按钮时查找 CSS 选择器为 <code>.btn-search</code> 的按钮，如果 10 秒内它是可点击的，也就是成功加载出来了，就返回这个按钮节点；如果超过 10 秒还不可点击，也就是没有加载出来，就抛出异常。</p><p>运行代码，在网速较佳的情况下是可以成功加载出来的。</p><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”07dd2fbc2d5b1ce40e82b9754aba8fa8”, element&#x3D;”0.5642646294074107-1”)&gt;  <br>&lt;selenium.webdriver.remote.webelement.WebElement (session&#x3D;”07dd2fbc2d5b1ce40e82b9754aba8fa8”, element&#x3D;”0.5642646294074107-2”)&gt;</td></tr></tbody></table><p>可以看到，控制台成功输出了两个节点，它们都是 <code>WebElement</code> 类型。</p><p>如果网络有问题，10 秒内没有成功加载，那就抛出 <code>TimeoutException</code> 异常，此时控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>TimeoutException Traceback (most recent call last)  <br><ipython-input-4-f3d73973b223> in <module>()  <br>      7 browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com/</a>‘)  <br>      8 wait &#x3D; WebDriverWait(browser, 10)  <br>—-&gt; 9 input &#x3D; wait.until(EC.presence_of_element_located((By.ID, ‘q’)))</td></tr></tbody></table><p>关于等待条件，其实还有很多，比如判断标题内容，判断某个节点内是否出现了某文字等。下表列出了所有的等待条件。</p><table><thead><tr><th>等待条件</th><th>含义</th></tr></thead><tbody><tr><td><code>title_is</code></td><td>标题是某内容</td></tr><tr><td><code>title_contains</code></td><td>标题包含某内容</td></tr><tr><td><code>presence_of_element_located</code></td><td>节点加载出来，传入定位元组，如 <code>(By.ID, &#39;p&#39;)</code></td></tr><tr><td><code>visibility_of_element_located</code></td><td>节点可见，传入定位元组</td></tr><tr><td><code>visibility_of</code></td><td>可见，传入节点对象</td></tr><tr><td><code>presence_of_all_elements_located</code></td><td>所有节点加载出来</td></tr><tr><td><code>text_to_be_present_in_element</code></td><td>某个节点文本包含某文字</td></tr><tr><td><code>text_to_be_present_in_element_value</code></td><td>某个节点值包含某文字</td></tr><tr><td><code>frame_to_be_available_and_switch_to_it frame</code></td><td>加载并切换</td></tr><tr><td><code>invisibility_of_element_located</code></td><td>节点不可见</td></tr><tr><td><code>element_to_be_clickable</code></td><td>节点可点击</td></tr><tr><td><code>staleness_of</code></td><td>判断一个节点是否仍在 DOM，可判断页面是否已经刷新</td></tr><tr><td><code>element_to_be_selected</code></td><td>节点可选择，传入节点对象</td></tr><tr><td><code>element_located_to_be_selected</code></td><td>节点可选择，传入定位元组</td></tr><tr><td><code>element_selection_state_to_be</code></td><td>传入节点对象以及状态，相等返回 <code>True</code>，否则返回 <code>False</code></td></tr><tr><td><code>element_located_selection_state_to_be</code></td><td>传入定位元组以及状态，相等返回 <code>True</code>，否则返回 <code>False</code></td></tr><tr><td><code>alert_is_present</code></td><td>是否出现 Alert</td></tr></tbody></table><p>更多等待条件的参数及用法介绍可以参考官方文档：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions。</a></p><h2 id="12-前进后退"><a href="#12-前进后退" class="headerlink" title="12. 前进后退"></a><a href="https://cuiqingcai.com/202261.html#12-%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80" title="12. 前进后退"></a>12. 前进后退</h2><p>平常使用浏览器时，都有前进和后退功能，Selenium 也可以完成这个操作，它使用 <code>back</code> 方法后退，使用 <code>forward</code> 方法前进。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import time  <br>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com/</a>‘)  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com/</a>‘)  <br>browser.get(‘<a href="https://www.python.org/">https://www.python.org/</a>‘)  <br>browser.back()  <br>time.sleep(1)  <br>browser.forward()  <br>browser.close()</td></tr></tbody></table><p>这里我们连续访问 3 个页面，然后调用 <code>back</code> 方法回到第二个页面，接下来再调用 <code>forward</code> 方法又可以前进到第三个页面。</p><h2 id="13-Cookies"><a href="#13-Cookies" class="headerlink" title="13. Cookies"></a><a href="https://cuiqingcai.com/202261.html#13-Cookies" title="13. Cookies"></a>13. Cookies</h2><p>使用 Selenium，还可以方便地对 Cookies 进行操作，例如获取、添加、删除 Cookies 等。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.zhihu.com/explore">https://www.zhihu.com/explore</a>‘)  <br>print(browser.get_cookies())  <br>browser.add_cookie({‘name’: ‘name’, ‘domain’: ‘<a href="http://www.zhihu.com/">www.zhihu.com</a>‘, ‘value’: ‘germey’})  <br>print(browser.get_cookies())  <br>browser.delete_all_cookies()  <br>print(browser.get_cookies())</td></tr></tbody></table><p>首先，我们访问了知乎。加载完成后，浏览器实际上已经生成 Cookies 了。接着，调用 <code>get_cookies</code> 方法获取所有的 Cookies。然后，我们添加一个 Cookie，这里传入一个字典，有 <code>name</code>、<code>domain</code> 和 <code>value</code> 等内容。接下来，再次获取所有的 Cookies。可以发现，结果就多了这一项新加的 Cookie。最后，调用 <code>delete_all_cookies</code> 方法删除所有的 Cookies。再重新获取，发现结果就为空了。</p><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[{‘secure’: False, ‘value’: ‘“NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY&#x3D;|1491604091|236e34290a6f407bfbb517888849ea509ac366d0”‘, ‘domain’: ‘.zhihu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘l_cap_id’, ‘expiry’: 1494196091.403418}, …]  <br>[{‘secure’: False, ‘value’: ‘germey’, ‘domain’: ‘.<a href="http://www.zhihu.com/">www.zhihu.com</a>‘, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘name’}, {‘secure’: False, ‘value’: ‘“NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY&#x3D;|1491604091|236e34290a6f407bfbb517888849ea509ac366d0”‘, ‘domain’: ‘.zhihu.com’, ‘path’: ‘&#x2F;‘, ‘httpOnly’: False, ‘name’: ‘l_cap_id’, ‘expiry’: 1494196091.403418}, …]  <br>[]</td></tr></tbody></table><p>通过以上方法来操作 Cookies 还是非常方便的。</p><h2 id="14-选项卡管理"><a href="#14-选项卡管理" class="headerlink" title="14. 选项卡管理"></a><a href="https://cuiqingcai.com/202261.html#14-%E9%80%89%E9%A1%B9%E5%8D%A1%E7%AE%A1%E7%90%86" title="14. 选项卡管理"></a>14. 选项卡管理</h2><p>在访问网页的时候，会开启一个个选项卡。在 Selenium 中，我们也可以对选项卡进行操作。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import time  <br>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>browser.execute_script(‘window.open()’)  <br>print(browser.window_handles)  <br>browser.switch_to.window(browser.window_handles[1])  <br>browser.get(‘<a href="https://www.taobao.com/">https://www.taobao.com</a>‘)  <br>time.sleep(1)  <br>browser.switch_to.window(browser.window_handles[0])  <br>browser.get(‘<a href="https://python.org/">https://python.org</a>‘)</td></tr></tbody></table><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[‘CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435’, ‘CDwindow-6e05f076-6d77-453a-a36c-32baacc447df’]</td></tr></tbody></table><p>这里首先访问了百度，然后调用了 <code>execute_script</code> 方法，这里传入 <code>window.open</code>这个 JavaScript 语句新开启一个选项卡。接下来，我们想切换到该选项卡。这里调用 <code>window_handles</code> 属性获取当前开启的所有选项卡，返回的是选项卡的代号列表。要想切换选项卡，只需要调用 <code>switch_to.window</code> 方法即可，其中参数是选项卡的代号。这里我们将第二个选项卡代号传入，即跳转到第二个选项卡，接下来在第二个选项卡下打开一个新页面，然后切换回第一个选项卡重新调用 <code>switch_to.window</code> 方法，再执行其他操作即可。</p><h2 id="15-异常处理"><a href="#15-异常处理" class="headerlink" title="15. 异常处理"></a><a href="https://cuiqingcai.com/202261.html#15-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" title="15. 异常处理"></a>15. 异常处理</h2><p>在使用 Selenium 的过程中，难免会遇到一些异常，例如超时、节点未找到等错误，一旦出现此类错误，程序便不会继续运行了。这里我们可以使用 <code>try except</code> 语句来捕获各种异常。</p><p>首先，演示一下节点未找到的异常，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>browser.find_element_by_id(‘hello’)</td></tr></tbody></table><p>这里首先打开百度页面，然后尝试选择一个并不存在的节点，此时就会遇到异常。</p><p>运行之后控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>NoSuchElementException Traceback (most recent call last)  <br><ipython-input-23-978945848a1b> in <module>()  <br>      3 browser &#x3D; webdriver.Chrome()  <br>      4 browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>—-&gt; 5 browser.find_element_by_id(‘hello’)</td></tr></tbody></table><p>可以看到，这里抛出了 <code>NoSuchElementException</code> 异常，这通常是节点未找到的异常。为了防止程序遇到异常而中断，我们需要捕获这些异常，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.common.exceptions import TimeoutException, NoSuchElementException  <br>  <br>browser &#x3D; webdriver.Chrome()  <br>try:  <br>    browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>except TimeoutException:  <br>    print(‘Time Out’)  <br>try:  <br>    browser.find_element_by_id(‘hello’)  <br>except NoSuchElementException:  <br>    print(‘No Element’)  <br>finally:  <br>    browser.close()</td></tr></tbody></table><p>这里我们使用 <code>try except</code> 来捕获各类异常。比如，我们对 <code>find_element_by_id</code>查找节点的方法捕获 <code>NoSuchElementException</code> 异常，这样一旦出现这样的错误，就进行异常处理，程序也不会中断了。</p><p>控制台的输出如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>No Element</td></tr></tbody></table><p>关于更多的异常类，可以参考官方文档：：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.common.exceptions。</a></p><h2 id="16-反屏蔽"><a href="#16-反屏蔽" class="headerlink" title="16. 反屏蔽"></a><a href="https://cuiqingcai.com/202261.html#16-%E5%8F%8D%E5%B1%8F%E8%94%BD" title="16. 反屏蔽"></a>16. 反屏蔽</h2><p>现在很多网站都加上了对 Selenium 的检测，来防止一些爬虫的恶意爬取。即如果检测到有人在使用 Selenium 打开浏览器，那就直接屏蔽。</p><p>在大多数情况下，检测的基本原理是检测当前浏览器窗口下的 <code>window.navigator</code> 对象是否包含 <code>webdriver</code> 这个属性。因为在正常使用浏览器的情况下，这个属性是 <code>undefined</code>，然而一旦我们使用了 Selenium，Selenium 会给 <code>window.navigator</code> 设置 <code>webdriver</code> 属性。很多网站就通过 JavaScript 判断如果 <code>webdriver</code> 属性存在，那就直接屏蔽。</p><p>这边有一个典型的案例网站：<a href="https://antispider1.scrape.center/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%B0%B1%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%8A%E8%BF%B0%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%BA%86">https://antispider1.scrape.center/，这个网站就使用了上述原理实现了</a> WebDriver 的检测，如果使用 Selenium 直接爬取的话，那就会返回如图所示的页面。</p><p><img src="https://cdn.cuiqingcai.com/l13mw.png" alt="image-20210705014022028"></p><p>这时候我们可能想到直接使用 JavaScript 语句把这个 <code>webdriver</code> 属性置空，比如通过调用 <code>execute_script</code> 方法来执行如下代码：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Object.defineProperty(navigator, “webdriver”, { get: () &#x3D;&gt; undefined });</td></tr></tbody></table><p>这行 JavaScript 语句的确可以把 <code>webdriver</code> 属性置空，但是 <code>execute_script</code> 调用这行 JavaScript 语句实际上是在页面加载完毕之后才执行的，执行太晚了，网站早在最初页面渲染之前就已经对 <code>webdriver</code> 属性进行了检测，所以用上述方法并不能达到效果。</p><p>在 Selenium 中，我们可以使用 CDP（即 Chrome Devtools-Protocol，Chrome 开发工具协议）来解决这个问题，通过它我们可以实现在每个页面刚加载的时候执行 JavaScript 代码，执行的 CDP 方法叫作 <code>Page.addScriptToEvaluateOnNewDocument</code>，然后传入上文的 JavaScript 代码即可，这样我们就可以在每次页面加载之前将 <code>webdriver</code> 属性置空了。另外，我们还可以加入几个选项来隐藏 WebDriver 提示条和自动化扩展信息，代码实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver import ChromeOptions  <br>  <br>option &#x3D; ChromeOptions()  <br>option.add_experimental_option(‘excludeSwitches’, [‘enable-automation’])  <br>option.add_experimental_option(‘useAutomationExtension’, False)  <br>browser &#x3D; webdriver.Chrome(options&#x3D;option)  <br>browser.execute_cdp_cmd(‘Page.addScriptToEvaluateOnNewDocument’, {  <br>    ‘source’: ‘Object.defineProperty(navigator, “webdriver”, {get: () &#x3D;&gt; undefined})’  <br>})  <br>browser.get(‘<a href="https://antispider1.scrape.center/">https://antispider1.scrape.center/</a>‘)</td></tr></tbody></table><p>这样整个页面就能被加载出来了，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/tywxa.png"></p><p>对于大多数情况，以上方法均可以实现 Selenium 反屏蔽。但对于一些特殊网站，如果它有更多的 WebDriver 特征检测，可能需要具体排查。</p><h2 id="17-无头模式"><a href="#17-无头模式" class="headerlink" title="17. 无头模式"></a><a href="https://cuiqingcai.com/202261.html#17-%E6%97%A0%E5%A4%B4%E6%A8%A1%E5%BC%8F" title="17. 无头模式"></a>17. 无头模式</h2><p>我们可以观察到，上面的案例在运行的时候，总会弹出一个浏览器窗口，虽然有助于观察页面爬取状况，但在有时候窗口弹来弹去也会形成一些干扰。</p><p>Chrome 浏览器从 60 版本已经支持了无头模式，即 Headless。无头模式在运行的时候不会再弹出浏览器窗口，减少了干扰，而且它减少了一些资源的加载，如图片等，所以也在一定程度上节省了资源加载时间和网络带宽。</p><p>我们可以借助于 ChromeOptions 来开启 Chrome Headless 模式，代码实现如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from selenium import webdriver  <br>from selenium.webdriver import ChromeOptions  <br>  <br>option &#x3D; ChromeOptions()  <br>option.add_argument(‘–headless’)  <br>browser &#x3D; webdriver.Chrome(options&#x3D;option)  <br>browser.set_window_size(1366, 768)  <br>browser.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>browser.get_screenshot_as_file(‘preview.png’)</td></tr></tbody></table><p>这里我们通过 ChromeOptions 的 <code>add_argument</code> 方法添加了一个参数 <code>--headless</code>，开启了无头模式。在无头模式下，我们最好设置一下窗口的大小，接着打开页面，最后我们调用 <code>get_screenshot_as_file</code> 方法输出了页面的截图。</p><p>运行代码之后，我们发现 Chrome 窗口就不会再弹出来了，代码依然正常运行，最后输出的页面如图所示。</p><p><img src="https://cdn.cuiqingcai.com/8h0oa.png" alt="输出的页面"></p><p>这样我们就在无头模式下完成了页面的抓取和截图操作。</p><h2 id="18-总结"><a href="#18-总结" class="headerlink" title="18. 总结"></a><a href="https://cuiqingcai.com/202261.html#18-%E6%80%BB%E7%BB%93" title="18. 总结"></a>18. 总结</h2><p>现在，我们基本上对 Selenium 的常规用法有了大体的了解。使用 Selenium，处理 JavaScript 渲染的页面不再是难事，后面我们会用一个实例来演示 Selenium 爬取网站的流程。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/SeleniumTest%E3%80%82">https://github.com/Python3WebSpider/SeleniumTest。</a></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步爬虫和模拟登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分基本概念</title>
    <link href="/Blogs/2025/08/28/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/Blogs/2025/08/28/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h1><blockquote><p>如何理解宏观与微观的关系</p></blockquote><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>从极限推到瞬时变化率，即为导数</p><p>宏观整体的规律和微观瞬间的规律并非孤立</p><p>导数是衡量函数变化快慢的工具</p><h2 id="微分-1"><a href="#微分-1" class="headerlink" title="微分"></a>微分</h2><p>趋于零时瞬间变化的大小</p><h2 id="奇点"><a href="#奇点" class="headerlink" title="奇点"></a>奇点</h2><p>连续：一条曲线在一个点是连续的，光滑的，那么就可导（光滑：两边切线相同</p><h1 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h1><blockquote><p>从微观变化了解宏观趋势</p></blockquote><p>微分的逆运算</p><h2 id="积分的意义"><a href="#积分的意义" class="headerlink" title="积分的意义"></a>积分的意义</h2><p>函数值的动态变化在一段时间内的累积效应</p><p><strong>滞后效应</strong>：凡是需要积分获得的数量，他的结果变化之后于瞬间变化</p><p>这种由积分获得的数量，一旦大到被观察到之后，要逆转趋势是很难的</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微积分基本概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微分</title>
    <link href="/Blogs/2025/08/28/%E5%BE%AE%E5%88%86/"/>
    <url>/Blogs/2025/08/28/%E5%BE%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="微分（Differentiation）​​"><a href="#微分（Differentiation）​​" class="headerlink" title="微分（Differentiation）​​"></a><strong>微分（Differentiation）​</strong>​</h3><blockquote><p>极限是否存在 -&gt;是否连续 -&gt; 是否可导 -&gt; 导数是否连续</p><p>极限 → 导数 → 积分 → 级数 → 微分方程</p></blockquote><p>​<strong>​核心目标：​</strong>​ 研究函数的变化率与局部行为（如切线斜率、极值点）。  </p><h4 id="​​1-基础准备​​"><a href="#​​1-基础准备​​" class="headerlink" title="​​1. 基础准备​​"></a>​<strong>​1. 基础准备​</strong>​</h4><ul><li>​<strong>​Chap 1.1–1.3：函数与图像​</strong>​<ul><li>函数定义域、值域、奇偶性、周期性（1.1）。</li><li>函数复合、平移伸缩变换（1.2）。</li><li>三角函数基本性质（1.3）。</li></ul></li></ul><h4 id="​​2-极限理论（Chap-2）​​"><a href="#​​2-极限理论（Chap-2）​​" class="headerlink" title="​​2. 极限理论（Chap 2）​​"></a>​<strong>​2. 极限理论（Chap 2）​</strong>​</h4><ul><li>​<strong>​导数根基：​</strong>​<ul><li>平均变化率 → 瞬时变化率（2.1）。</li><li>极限定义（limx→c​f(x)&#x3D;L）、极限法则（四则运算）（2.2）。</li><li>ε-δ 精确定义（2.3）、单侧极限（2.4）。</li><li>连续性判断（2.5）：limx→c​f(x)&#x3D;f(c)。</li><li>无穷极限与渐近线（2.6）。</li></ul></li></ul><h4 id="​​3-导数计算（Chap-3）​​"><a href="#​​3-导数计算（Chap-3）​​" class="headerlink" title="​​3. 导数计算（Chap 3）​​"></a>​<strong>​3. 导数计算（Chap 3）​</strong>​</h4><ul><li>​<strong>​定义与规则：​</strong>​<ul><li>点导数：f′(a)&#x3D;limh→0​hf(a+h)−f(a)​（3.1）。</li><li>导函数 f′(x) 的求解（3.2）。</li><li>​<strong>​核心法则：​</strong>​<ul><li>幂函数、指数、对数函数导数（3.3）。</li><li>三角函数导数：dxd​sinx&#x3D;cosx，dxd​cosx&#x3D;−sinx（3.5）。</li><li>链式法则：dxdy​&#x3D;dudy​⋅dxdu​（3.6）。</li><li>隐函数求导（3.7）。</li></ul></li><li>相关变化率（3.8）：建立变量关联方程后求导。</li></ul></li><li>​<strong>​应用工具：​</strong>​<ul><li>线性近似：L(x)≈f(a)+f′(a)(x−a)（3.9）。</li><li>微分 dy&#x3D;f′(x)dx（3.9）。</li></ul></li></ul><h4 id="​​4-导数应用（Chap-4）​​"><a href="#​​4-导数应用（Chap-4）​​" class="headerlink" title="​​4. 导数应用（Chap 4）​​"></a>​<strong>​4. 导数应用（Chap 4）​</strong>​</h4><ul><li>​<strong>​函数性态分析：​</strong>​<ul><li>闭区间最值定理（4.1）。</li><li>中值定理：f(b)−f(a)&#x3D;f′(c)(b−a)（4.2）。</li><li>单调性判别：f′&gt;0 增，f′&lt;0 减（4.3）。</li><li>凹凸性与拐点：f′′&gt;0 凹，f′′&lt;0 凸（4.4）。</li></ul></li><li>​<strong>​优化与数值方法：​</strong>​<ul><li>最优化建模（4.5）：设变量、建目标函数、求临界点。</li><li>牛顿法迭代：xn+1​&#x3D;xn​−f′(xn​)f(xn​)​（4.6）。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微纳工艺</title>
    <link href="/Blogs/2025/08/28/%E5%BE%AE%E7%BA%B3%E5%B7%A5%E8%89%BA/"/>
    <url>/Blogs/2025/08/28/%E5%BE%AE%E7%BA%B3%E5%B7%A5%E8%89%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="一、表面准备-Surface-Preparation"><a href="#一、表面准备-Surface-Preparation" class="headerlink" title="一、表面准备 (Surface Preparation)"></a>一、表面准备 (Surface Preparation)</h2><ol><li><p>​<strong>​清洗 (Cleaning)​</strong>​</p><ul><li>去除污染物：晶圆划片灰尘、大气颗粒、光刻胶残留等</li><li>方法：去离子水冲洗(DI Rinse)、丙酮(Acetone)、异丙醇(IPA Rinse)</li></ul></li><li><p>​<strong>​底膜涂抹 (Wafer Priming)​</strong>​</p><ul><li>使用HMDS增强光刻胶粘附性</li></ul></li></ol><h2 id="二、光刻工艺-Lithography"><a href="#二、光刻工艺-Lithography" class="headerlink" title="二、光刻工艺 (Lithography)"></a>二、光刻工艺 (Lithography)</h2><ol><li><p>​<strong>​光刻胶涂覆 (Resist Coating)​</strong>​</p><ul><li>旋转涂布(1000-6000rpm)，厚度约1微米</li><li>光刻胶类型：<ul><li>正性光刻胶：曝光后溶解</li><li>负性光刻胶：曝光后交联固化</li><li>LOR光刻胶：用于lift-off工艺</li></ul></li></ul></li><li><p>​<strong>​曝光 (Exposure)​</strong>​</p><ul><li>曝光剂量控制图案形成</li><li>分辨率：接触模式(0.7-2.5μm)、投影模式(更高分辨率)</li></ul></li><li><p>​<strong>​显影 (Development)​</strong>​</p><ul><li>正胶：溶解曝光区域</li><li>负胶：溶解未曝光区域</li></ul></li></ol><h2 id="三、蚀刻工艺-Etching"><a href="#三、蚀刻工艺-Etching" class="headerlink" title="三、蚀刻工艺 (Etching)"></a>三、蚀刻工艺 (Etching)</h2><ol><li><p>​<strong>​湿法蚀刻 (Wet Etching)​</strong>​</p><ul><li>各向同性蚀刻(如SiO2)</li><li>各向异性蚀刻(如KOH对Si晶体)</li></ul></li><li><p>​<strong>​干法蚀刻 (Dry Etching)​</strong>​</p><ul><li>反应离子刻蚀(RIE)：结合化学和物理蚀刻</li><li>ICP-RIE：独立控制离子密度和能量</li></ul></li><li><p>​<strong>​关键参数​</strong>​</p><ul><li>选择性 &#x3D; 刻蚀深度&#x2F;光刻胶损失</li><li>各向异性因子(RI)：0为完全各向异性，1为完全各向同性</li></ul></li></ol><h2 id="四、沉积工艺-Deposition"><a href="#四、沉积工艺-Deposition" class="headerlink" title="四、沉积工艺 (Deposition)"></a>四、沉积工艺 (Deposition)</h2><ol><li><p>​<strong>​化学气相沉积(CVD)​</strong>​</p><ul><li>PECVD：低温沉积SiO2、Si3N4等</li><li>原子层沉积(ALD)：原子级厚度控制</li></ul></li><li><p>​<strong>​物理气相沉积(PVD)​</strong>​</p><ul><li>蒸发(E-beam)：高纯度但台阶覆盖率差</li><li>溅射(Sputtering)：更好的台阶覆盖率</li></ul></li></ol><h2 id="五、掺杂工艺-Doping"><a href="#五、掺杂工艺-Doping" class="headerlink" title="五、掺杂工艺 (Doping)"></a>五、掺杂工艺 (Doping)</h2><ol><li><p>​<strong>​热扩散 (Thermal Diffusion)​</strong>​</p><ul><li>两步过程：沉积→驱动扩散</li><li>菲克扩散定律描述浓度分布</li></ul></li><li><p>​<strong>​离子注入 (Ion Implantation)​</strong>​</p><ul><li>精确控制掺杂剂量和深度</li><li>需后续退火修复晶格损伤</li></ul></li></ol><h2 id="六、封装工艺-Packaging"><a href="#六、封装工艺-Packaging" class="headerlink" title="六、封装工艺 (Packaging)"></a>六、封装工艺 (Packaging)</h2><ol><li><p>​<strong>​基本流程​</strong>​</p><ul><li>晶圆减薄→切割→芯片粘接→键合→密封</li></ul></li><li><p>​<strong>​键合技术​</strong>​</p><ul><li>线键合(金&#x2F;铝线)</li><li>倒装芯片键合(焊料凸点)</li></ul></li></ol><h2 id="七、先进光刻技术"><a href="#七、先进光刻技术" class="headerlink" title="七、先进光刻技术"></a>七、先进光刻技术</h2><ol><li><p>​<strong>​电子束光刻(EBL)​</strong>​</p><ul><li>纳米级分辨率</li><li>邻近效应是主要挑战</li></ul></li><li><p>​<strong>​纳米压印光刻(NIL)​</strong>​</p><ul><li>机械压印图案</li><li>高分辨率(约100nm)、低成本</li></ul></li></ol><h2 id="八、表征技术"><a href="#八、表征技术" class="headerlink" title="八、表征技术"></a>八、表征技术</h2><ol><li><p>​<strong>​扫描电镜(SEM)​</strong>​</p><ul><li>表面形貌分析</li><li>分辨率达纳米级</li></ul></li><li><p>​<strong>​原子力显微镜(AFM)​</strong>​</p><ul><li>三维表面形貌</li><li>可在大气&#x2F;液体环境工作</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>制造工艺</category>
      
      <category>微纳工艺</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微纳工艺</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>意义</title>
    <link href="/Blogs/2025/08/28/%E6%84%8F%E4%B9%89/"/>
    <url>/Blogs/2025/08/28/%E6%84%8F%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p><strong>③哥德尔定理要告诉我们什么呢？</strong></p><p>歌德尔定理最直接意义是在说：</p><blockquote><p>1.可证的一定是真的，但真的不一定可证：<br>这是哥德尔定理最直接的一层意思，因为系统中有一句真话不可证，所以可证性弱于真理性，可证和真是两回事 。从古希腊开始人们就普遍相信数学能和真理划上等号，希望从数学中可以证明一切命题的真假，但哥德尔定理粉碎了两千年来数学家们的信念，他说数学甚至都不能证明数学本身的性质。</p></blockquote><blockquote><p>进一步可以说明：<br>2，任何系统在本质上都是有缺陷的：<br>整个证明的关键在于歌德尔<strong>构建了一个自指的陈述，自指（谈论自身）是整本书最重要的概念，因为它是许多悖论的根源</strong>  </p><p>著名的说谎者悖论：“我说的这句话是假的”。就是因为这句话指涉了自身而引起了悖论  </p><p>墨子驳“言尽悖”: 墨子指出：“真理是无法用语言表达清楚的”这句话也有同样的悖论，也是因为它隐含地指涉了自己（这句话自己不就在用语言表达真理吗）  </p><p>公式<strong>G</strong>：”我不是一条定理“ 也是因为其自指性而出现了悖论  </p><p>自指的存在让所有系统都具有不可避免缺陷，<strong>任何系统只要有谈论自身的能力，内部就存在不可消除的矛盾，不完全性成了所有系统的固有性质。</strong>这就告诉我们，不能指望有系统可以解决所有的问题，鉴别所有句子的真假，因为他们都是不完全的漏洞系统。因此在物理学，社会学，哲学或者任何领域，所有构建大一统理论体系的努力是注定要失败的  </p><p><strong>须知：人类认知世界过程就是人类在各学科构造形式系统并在其中推演定理解释世界的过程！</strong></p></blockquote><blockquote><p>联系到这本书的主题——思维和大脑，作者告诉我们：<br>3.人的认知是有局限的，矛盾其实是我们思维的固有性质<br><strong>人脑与思维，也是一个形式系统。</strong>因此我们注定无法认识所有客观真理，哥德尔定理的悖论就就是我们认知的界限，我们头脑里无法同时容纳一句话既是真的有是假的这两件事,侯世达猜想这是因为我们面对矛盾时是让大脑做一件物理层面上相互冲突的事情，好比你不能让神经元电流既向左走又向右走。矛盾性是根植与我们大脑的物理结构的属性</p></blockquote><blockquote><p>4.跳出系统，超越自己也许是注定做不到的事情<br>在苹果表面爬行的蚂蚁以为苹果表面是没有尽头平面，因为他无法跳出来观察到自己只是在绕圈子。蚂蚁无法超越自己的认知维度，人类也一样，哥德尔定理就是我们无法超越的界限。1931年哥德尔定理发表，直接打击了那些妄图用数学系统内部的方法去证明数学系统是完备的人，这种想法好比拽着自己的头发把自己举起来。任何系统只要强到能谈论自身就逃不过哥德尔定理的打击，就算你把那个打击的漏洞吸收进原来的系统内变成看似更完备的系统，但补漏后的新系统又会有新的漏洞被哥德尔定理抓住。这说明所谓的超越自我可能只是从一个系统跳到另一个系统时产生的错觉，因为跳出系统自身只能是一场徒劳 ， TNT系统只可谈论自身，但不可超越自身，人最多只能理解自我，却不能超越自我</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>哥德尔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>意义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是编程高手</title>
    <link href="/Blogs/2025/08/28/%E6%88%91%E6%98%AF%E7%BC%96%E7%A8%8B%E9%AB%98%E6%89%8B/"/>
    <url>/Blogs/2025/08/28/%E6%88%91%E6%98%AF%E7%BC%96%E7%A8%8B%E9%AB%98%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>[[编程素养]]</p><p>[[编程学习基础]]</p><p>高级语言 [[C语言]] [[Python]]</p><p>还有一些乱七八糟的子技能</p><p>[[Docker]]，[[信息安全：网页运作原理]]</p><p>[[编程实战]] </p><p>[[编程杂谈]]</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>我是编程高手</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>封装</title>
    <link href="/Blogs/2025/08/28/%E5%B0%81%E8%A3%85/"/>
    <url>/Blogs/2025/08/28/%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<ol><li><h1 id="Fundamentals-of-Packaging-CH1-CH9"><a href="#Fundamentals-of-Packaging-CH1-CH9" class="headerlink" title="Fundamentals of Packaging (CH1,CH9)"></a>Fundamentals of Packaging (CH1,CH9)</h1></li></ol><h2 id="1-1-Introduction-Function-and-classification-of-packages"><a href="#1-1-Introduction-Function-and-classification-of-packages" class="headerlink" title="1.1 Introduction, Function and classification of packages"></a>1.1 Introduction, Function and classification of packages</h2><h3 id="1-1-1-IntroE"><a href="#1-1-1-IntroE" class="headerlink" title="1.1.1 IntroE"></a>1.1.1 IntroE</h3><p>Microsystems and the technologies they constitute are the building blocks of information technology. These systems require a set of fundamental technologies that include not only microelectronics but also photonics, MEMS, RF and wireless. For these functions to be integrated into systems, they have to be designed, fabricated, tested, cooled and reliability assured.</p><p><strong>Microsystems:</strong> microminiaturized and integrated systems based on microelectronics, photonics, RF, micro-electro-mechanical systems (MEMS) and packaging technologies.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzExNzZlNTA4YzllMzQwODhhMWI1ZjVkYzAxZDE3MjFfQVVwSlBZUGpEUEg0aWxqNmxSbTNrT0I3OXk2Qm5qa21fVG9rZW46VmRNTmJ4dFFCb3pHcjl4bmVwU2Nnb21CbmNnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzExNzZlNTA4YzllMzQwODhhMWI1ZjVkYzAxZDE3MjFfQVVwSlBZUGpEUEg0aWxqNmxSbTNrT0I3OXk2Qm5qa21fVG9rZW46VmRNTmJ4dFFCb3pHcjl4bmVwU2Nnb21CbmNnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzEyYjkwOWFlNWU3YWViMmMxZTIyMWY4Y2Q4OWY1MjBfYk5KMWlBQ1dUNXA0VUZPYjMzTDk0VXNkQ3F5SUlWcWNfVG9rZW46VTRkdmJXaDRSb0pyNW54NXNXN2M5ajlWblVjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>Packaging:</strong> the bridge that interconnects the ICs and other components into a system-level board to form electronic products</p><p><strong>Microelectronics:</strong> typically refers to those micro devices, such as ICs, which are fabricated in sub-micron dimensions, and which form the basis of all electronic products</p><h3 id="1-1-2-Functions"><a href="#1-1-2-Functions" class="headerlink" title="1.1.2 Functions"></a>1.1.2 Functions</h3><ol><li><p>protect the encapsulated microsystems device from the environment;</p></li><li><p>provides pathways for various input and output signals, these pathways can be electrical, mechanical, chemical, optical, etc.; package allows the microsystems die to be more easily handled for assembly onto boards and into systems;</p></li><li><p>Designed as a mechanism to transport away the heat generated by the die, allowing the die temperature to be maintained at a desired level. Otherwise, microsystem devices can heat up during operation and can cause drift and&#x2F;or reliability issues.</p></li><li><p>Protect and Preserve the quality of the product, provide Information to the customer, facilitate Transport and Distribution</p></li></ol><h2 id="1-2-Moore’s-Law-Prediction"><a href="#1-2-Moore’s-Law-Prediction" class="headerlink" title="1.2 Moore’s Law Prediction"></a>1.2 Moore’s Law Prediction</h2><p>The concept of Moore’s Law for Packaging or interconnections (MLP) that can be viewed as interconnecting and integrating smaller chips with the highest transistor density and highest performance at the lowest cost.</p><p>Just as Moore’s Law for ICs has two components:</p><ol><li><p>the number of transistors</p></li><li><p>cost of each transistor.</p></li></ol><p>Law predicts the IC integration to double every 18 months.</p><p>The latest update of the roadmap is posted on the ITRS website. Figure shows the ITRS roadmap for printed CMOS Moore‘s Law and beyond, which more recently has been called ―More than Moore‖ or its abbreviation, MtM.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZlNzYzM2FiN2YwZGY1Yjk2YzM1NWJmYTZiMDgzYTRfQldHVUVpbk9yOUVIanB6RERGenZxRUJCUEF1clluVnpfVG9rZW46QklTc2JTWWt6b1FObU14Q0dRcGNQc3lmbnpjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="1-3-MSP-Microsystems-Packaging-overview"><a href="#1-3-MSP-Microsystems-Packaging-overview" class="headerlink" title="1.3 MSP (Microsystems Packaging) overview"></a>1.3 MSP (Microsystems Packaging) overview</h2><h3 id="1-3-1-Three-major-technologies"><a href="#1-3-1-Three-major-technologies" class="headerlink" title="1.3.1 Three major technologies"></a>1.3.1 Three major technologies</h3><ol><li><p>Microelectronics, Photonics, MEMS and RF&#x2F;Wireless Devices</p></li><li><p>Systems Engineering</p></li><li><p>Systems Packaging</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFkODc3ODE1NWNiOTM2ODM2ODQ2MzQ2Mjg1OTUyMmJfNGFxUG1CODcwcVo4M0RlTnRhWGREUnczbHViRjdqaEZfVG9rZW46T1FNN2JWS2Jsb2RIYWt4TGg4VWNIMDZlbmhiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Overlap of ICs and systems: Sub-Products子产品</p><p>Overlap of packaging and systems: incomplete system-level Boards(since Boards do not contain the devices)非智能系统级电路板</p><p>Overlap of ICs and Packaging: Packaged devices &#x2F; IC Packaging</p><h3 id="1-3-2-Examples-of-Microsystems-Packaging-and-IC’s"><a href="#1-3-2-Examples-of-Microsystems-Packaging-and-IC’s" class="headerlink" title="1.3.2 Examples of Microsystems Packaging and IC’s"></a>1.3.2 Examples of Microsystems Packaging and IC’s</h3><p>Electronic product contains</p><p>(1) semiconductor devices such as ICs</p><p>(2) packaging to integrate these ICs and other devices into components</p><p>(3) system-level boards which integrate these components to form the system-level assemblies</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc1ZGFmNThjMjY1NDQ5NTJjMTVlNjhlNWRiOGNiZDFfbVozQTRadEI3MERvUHFZZXJrNDgwbTh1eUY0ejFZRjVfVG9rZW46T0lSZmJvWG5Mb1JFS054cWJwUGNaRmVXbnVkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc1ZGFmNThjMjY1NDQ5NTJjMTVlNjhlNWRiOGNiZDFfbVozQTRadEI3MERvUHFZZXJrNDgwbTh1eUY0ejFZRjVfVG9rZW46T0lSZmJvWG5Mb1JFS054cWJwUGNaRmVXbnVkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Examples of system Packaging (a) Inside a computer, (b) Inside a Cellular Phone, and (c) Inside an Automobile</p><h3 id="1-3-3-IC-System-Packaging-Overview"><a href="#1-3-3-IC-System-Packaging-Overview" class="headerlink" title="1.3.3 IC &amp; System Packaging Overview"></a>1.3.3 IC &amp; System Packaging Overview</h3><p>Microsystem packaging involves two major functions</p><p><strong>1. at the IC or device level</strong> <strong>第一级封装</strong></p><p>involves interconnecting, powering, cooling and protecting ICs</p><p><strong>2. at the system-level</strong> <strong>第二级封装</strong></p><p>involves interconnection of all these components to be assembled on the system-level board, called motherboard母板</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTExYWJiYjA3NTdlYmNkOGE3N2JkOTNmYmU2ZWNhMDJfVUgyZ252aVk0SXFkSVExTVVUSGt3Uk84MkoyQ0R0a3ZfVG9rZW46TzNjQmJsYzZob1YwVXF4RU5HTGNnbzdObjJmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-3-4-Systems-Packaging-Involves-Electrical-Mechanical-and-Materials-Technologies"><a href="#1-3-4-Systems-Packaging-Involves-Electrical-Mechanical-and-Materials-Technologies" class="headerlink" title="1.3.4 Systems Packaging Involves Electrical, Mechanical and Materials Technologies"></a>1.3.4 Systems Packaging Involves Electrical, Mechanical and Materials Technologies</h3><ol><li><h4 id="Electrical-Packaging-Technology"><a href="#Electrical-Packaging-Technology" class="headerlink" title="Electrical Packaging Technology:"></a>Electrical Packaging Technology:</h4></li></ol><p>Electrical problems relate to</p><ol><li><p>signal propagation btw the transistors</p></li><li><p>power distribution required to operate these transistors.</p></li></ol><p>Electrical parameters such as R,C,L are always present and cause signal delays and signal distortions.</p><p>引线电阻引起电压降，增加渡越时间；</p><p>电源分配问题：开关噪声</p><ol><li><h4 id="Mechanical-Packaging-Technology"><a href="#Mechanical-Packaging-Technology" class="headerlink" title="Mechanical Packaging Technology:"></a>Mechanical Packaging Technology:</h4></li></ol><p>The combination of power distribution through all levels of system packaging, and the use and fabrication of materials with the above diversity of properties, invariably lead to the development of thermomechanical stresses at every interface.</p><p>通过各级系统封装的功率分布的组合，以及具有上述特性多样性的材料的使用和制造，总是导致每个界面上的热机械应力的发展。</p><ol><li><h4 id="Materials-Packaging-Technology"><a href="#Materials-Packaging-Technology" class="headerlink" title="Materials Packaging Technology:"></a>Materials Packaging Technology:</h4></li></ol><p>The signal and power distribution requires appropriate use of materials to form the system-level packaging hierarchy.</p><p>e.g. Power distribution requires metals of highest electrical conductivity for least voltage drop. Heat transfer requires materials of highest thermal conductivity.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE1NjBkMGZmNTFmYWZjYmQ1ZmQwMGM1MDA4YmQ1YjVfY3FxUGJsaVJ5aElpWFowMFpSV0RQRElET3o5WEJvQ1VfVG9rZW46RE11U2I0dWhPb2pCYXh4UzdXbGN3Z1k1bjdnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE1NjBkMGZmNTFmYWZjYmQ1ZmQwMGM1MDA4YmQ1YjVfY3FxUGJsaVJ5aElpWFowMFpSV0RQRElET3o5WEJvQ1VfVG9rZW46RE11U2I0dWhPb2pCYXh4UzdXbGN3Z1k1bjdnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="1-4-The-importance-of-microsystem-packaging"><a href="#1-4-The-importance-of-microsystem-packaging" class="headerlink" title="1.4 The importance of microsystem packaging"></a>1.4 The importance of microsystem packaging</h2><h3 id="1-4-1-Every-IC-and-Device-Has-to-Be-Packaged"><a href="#1-4-1-Every-IC-and-Device-Has-to-Be-Packaged" class="headerlink" title="1.4.1 Every IC and Device Has to Be Packaged"></a>1.4.1 Every IC and Device Has to Be Packaged</h3><p>All of ICs and devices have to be packaged at the IC-level to form IC packages, and at system-level to form system-level boards.</p><h3 id="1-4-2-Controls-Performance-of-Computers"><a href="#1-4-2-Controls-Performance-of-Computers" class="headerlink" title="1.4.2 Controls Performance of Computers"></a>1.4.2 Controls Performance of Computers</h3><p>The num of ICs and their interconnections required to form a processor&#x2F;CPU determine the cycle-determining path from IC through package interconnections, thus control the speed &#x2F; clock freq of CPU</p><h3 id="1-4-3-Controls-Size-of-Electronics"><a href="#1-4-3-Controls-Size-of-Electronics" class="headerlink" title="1.4.3 Controls Size of Electronics"></a>1.4.3 Controls Size of Electronics</h3><p>The num and size of ICs in a given system, such as a cellular phone, tend to be small.</p><h3 id="1-4-4-Controls-Reliability-of-Electronics"><a href="#1-4-4-Controls-Reliability-of-Electronics" class="headerlink" title="1.4.4 Controls Reliability of Electronics"></a>1.4.4 Controls Reliability of Electronics</h3><p>Solid-state devices such as ICs are extremely reliable, with failure rates in parts-per million (ppm). The failure mainly due to the packaging of devices</p><h3 id="1-4-5-Controls-Cost-of-Electronic-Products"><a href="#1-4-5-Controls-Cost-of-Electronic-Products" class="headerlink" title="1.4.5 Controls Cost of Electronic Products"></a>1.4.5 Controls Cost of Electronic Products</h3><p>The cost of producing today’s ICs and MEMS devices is low due to a variety of factors such as large-scale and high throughput wafer starts-per-day and automation. <strong>However,</strong> system-level packaging cost. With all the packaging components to form system-level boards, si much higher</p><h3 id="1-4-6-Required-in-Nearly-Everything"><a href="#1-4-6-Required-in-Nearly-Everything" class="headerlink" title="1.4.6 Required in Nearly Everything"></a>1.4.6 Required in Nearly Everything</h3><p>Electronics are now a part of nearly all industries such as automotive, telecommunication, computer, consumer, medical, aerospace and military</p><h2 id="1-5-Previous-future-development-in-packaging-technology"><a href="#1-5-Previous-future-development-in-packaging-technology" class="headerlink" title="1.5 Previous, future development in packaging technology"></a>1.5 Previous, future development in packaging technology</h2><h3 id="1-5-1-ME-The-First-Technology-Wave"><a href="#1-5-1-ME-The-First-Technology-Wave" class="headerlink" title="1.5.1 ME: The First Technology Wave"></a>1.5.1 ME: The First Technology Wave</h3><ol><li><p>The invention of the transistor in 1949 by Brattain, Bardeen and Shockley at Bell Labs. The development of planar transistor technology by Bob Noyce in 1959</p></li><li><p>The first integrated circuit (IC), which incorporated two transistors and a resistor, developed by Jack Kilby in 1959.</p></li><li><p>The microsystems packaging as starting with a wafer and ending up with a finished system like a cellular phone. This is a very good example of technologies and systems in the 20th century.</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdkNjljOTJiMmE0NDJjOGJmNjdlNzM3YTQ3OTYzZTNfUmtEQ2NKYW9sc0J6OGZ4VHp6Q3M0MmphZTBoek94cU5fVG9rZW46Q2hGUGJmRjBVb2NpZUx4NmJ0S2NxbGVibndkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2Y3NGFlOWFjMmIzYTMxNmM4YTdjNDBhM2EyOTU1M2NfaGoxZEcxUHB4cEdmSGhGRm51VkllT2JzYVBOeGVYTkFfVG9rZW46TUZZUmI4U2E3b1V1Nmd4VEdWNWNOQXdkbjNmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-5-2-RF-and-Wireless-The-Second-Technology-Wave"><a href="#1-5-2-RF-and-Wireless-The-Second-Technology-Wave" class="headerlink" title="1.5.2 RF and Wireless: The Second Technology Wave"></a>1.5.2 RF and Wireless: The Second Technology Wave</h3><ol><li><p>A whole new industry has emerged with applications that span AM and FM radio to cellular phone to satellite to microwave communications, across the entire electromagnetic spectrum.</p></li><li><p>The main advantage of wireless is the fact that it cuts the cables. If the wireless equipment is small enough that it can actually be carried around everywhere. This is where Systems packaging applies. Wireless technology is also increasingly used for non-communications functions (GPS).</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU3YmJlNDgyZTM0MWYzZDcwYjZmMjJlY2FkYmRiYzZfWDIzbDJ5QlhXYkRnRGtRYjJiZ2NtUkpHYlVXbEJZUVRfVG9rZW46TVZ3MWJweDdvb09NcnR4SGo1dWNmNEVrbjNlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-5-3-Photonics-The-Third-Technology-Wave"><a href="#1-5-3-Photonics-The-Third-Technology-Wave" class="headerlink" title="1.5.3 Photonics: The Third Technology Wave"></a>1.5.3 Photonics: The Third Technology Wave</h3><ol><li><p>Highly transparent fibers, and semiconductor lasers that established the feasibility of fiber optic communications. These discoveries are the fundamental building block technologies of today’s Internet networks.</p></li><li><p>Fortunately, we have a ways to go to reach the data transport limit of fiber. For example, with the current state of device technology, a good laser source can emit 10 photons&#x2F;s, and a good detector—which can detect a bit with 10 photons on a single fiber.</p></li><li><p>Fiber optics is a future-proof technology. With wavelength-division multiplexing (WDM), it is now possible to transmit different colors of light over the same fiber. Thus, optics will play a key role in next-generation network modes and eventually at customers’ premises.</p></li></ol><h3 id="1-5-4-MEMS-The-Fourth-Technology-Wave"><a href="#1-5-4-MEMS-The-Fourth-Technology-Wave" class="headerlink" title="1.5.4 MEMS:The Fourth Technology Wave"></a>1.5.4 MEMS:The Fourth Technology Wave</h3><p>MEMS are the next logical step in the silicon revolution. We believe that the next step in the silicon revolution will be different and more important than simply packaging more transistors onto the silicon.</p><h3 id="1-5-5-System-packaging-A-Fifth-wave"><a href="#1-5-5-System-packaging-A-Fifth-wave" class="headerlink" title="1.5.5 System packaging: A Fifth wave"></a>1.5.5 System packaging: A Fifth wave</h3><p><strong>A fifth wave</strong>, consisting of Systems Packaging that integrates and engineers all these into products (microelectronics, RF, photonics, MEMS, packaging)</p><h2 id="1-6-Introduction-to-assembly-and-package-processing"><a href="#1-6-Introduction-to-assembly-and-package-processing" class="headerlink" title="1.6 Introduction to assembly and package processing"></a>1.6 Introduction to assembly and package processing</h2><h3 id="1-6-1-Packaging-Hierarchy"><a href="#1-6-1-Packaging-Hierarchy" class="headerlink" title="1.6.1 Packaging Hierarchy"></a>1.6.1 Packaging Hierarchy</h3><p>Essentially, every electronic product contains:</p><p>(1) semiconductor devices such as ICs</p><p>(2) packaging to integrate these ICs and other devices into components</p><p>(3) system-level boards which integrate these components to form the system-level assemblies.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWMzYjBkMzM3ZWE1OGNlZmNlODY0NTk2YWM1Njg5YjZfbEw1QjRybEJuQmNld2gwVkhmNG1Od29uVnVUVHVXWmdfVG9rZW46RHFVWmJrUXFYb3VkdUd4SkMyZWNSZG1mbmZiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ul><li><p>Level 0 – Gate-to-gate interconnections on the silicon die</p></li><li><p>Level 1 – Connections from the chip to its package</p></li><li><p>Level 2 – PCB&#x2F;PWB, from component to component &#x2F; to external connector</p></li><li><p>Level 3 – Connections between PCBs, including backplanes or motherboards</p></li><li><p>Level 4 – Connections between subassemblies, for example a rack</p></li><li><p>Level 5 – Connections between physically separate systems, using for example an Ethernet LAN</p></li></ul><h3 id="1-6-2-Process"><a href="#1-6-2-Process" class="headerlink" title="1.6.2 Process"></a>1.6.2 Process</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBmZjhiNTQ5MWEwN2E5MDdiYmFmOWZhYzliMjQ2ZmFfSFFKRHlUMUR4Mk1nNHhZWTJCV3U4VzQwbUdFQjljaVNfVG9rZW46VVFzYWI4ekpnbzNudlR4SVkwOGNhdDNSbnRRXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-6-3-IC-Assembly-and-package-processing"><a href="#1-6-3-IC-Assembly-and-package-processing" class="headerlink" title="1.6.3 IC Assembly and package processing"></a>1.6.3 IC Assembly and package processing</h3><p>IC assembly process involves three interfaces:</p><p><strong>(1) metallurgical bond pad interface(金属键合区) on the IC</strong></p><p><strong>(2) metallurgical bond pad interface on the package</strong></p><p>*primary concerns of (1),(2): interdiffusion of metals into each other.</p><p>Effect of the diffusion on thermomechanical reliability (热机械可靠性) and electrical stability, the formation of brittle intermetallic compounds(脆性金属间化合物), volumetric change(体积变化) occurring due the formation of some intermetallic compounds (such as AuAl2), and corrosion of the bond pad metallurgy.</p><p>Possible diffusion mechanisms:</p><ol><li><p>atomic diffusion where atoms jump into neighbouring vacant lattice sites; 原子扩散，原子跃迁到邻近的空晶格位</p></li><li><p>interstitial diffusion which occurs only for small atoms in the solid; 只对固体中的小原子发生的间隙扩散</p></li><li><p>interstitial pushing of an atom from its lattice site to an interstitial site; 原子从晶格位置向间隙位置的间隙推力</p></li><li><p>atomic diffusion, where two neighbouring atoms swap positions directly; 原子扩散，两个相邻的原子直接交换位置</p></li><li><p>and ring rotation of four atoms.四个原子的环旋转</p></li></ol><p><strong>(3) electrical interconnection between these two interfaces</strong></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmIxMWRiMzYyZTAxMWZmNTcyZjdjNzFjZjZiYjQzYmZfYnZKcGgzZ29RM1lwUHZ5R25KdFRBRUJDTXRnUjBHN25fVG9rZW46WGYxVGJzbHRBbzhtRHV4MXcwV2NOVXIxbmRjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-6-4-Purpose-and-Requirements-of-IC-Assembly"><a href="#1-6-4-Purpose-and-Requirements-of-IC-Assembly" class="headerlink" title="1.6.4 Purpose and Requirements of IC Assembly"></a>1.6.4 Purpose and Requirements of IC Assembly</h3><ol><li><h4 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose:"></a><strong>Purpose:</strong></h4><ol><li><p>provide the signal and power distribution of the packaged IC to the system; 向系统提供封装IC的信号和功率分配</p></li><li><p>provide mechanical support and robustness to the fragile IC; 为易碎的集成电路提供机械支持和坚固性</p></li><li><p>provide for environmental protection of the IC.</p></li></ol></li><li><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements:"></a><strong>Requirements:</strong></h4><ol><li><p>provide <strong>acceptable electrical properties</strong>, including R,C,L.</p></li><li><p>provide <strong>a low-cost solution</strong> for the electrical interface between the chip and package. 为芯片和封装之间的电接口提供一种低成本的解决方案</p></li><li><p><strong>high throughput manufacturing</strong>高通量制造. For finer pitch packaging applications, tape automated bonding provides (TAB) a low cycle time, high throughput IC assembly approach.对</p></li><li><p><strong>high reliability</strong>. Flip chip on ceramic technology has been a highly reliable interconnection technique.</p></li><li><p><strong>repairability or replaceability</strong> where the interconnection between the IC and package should provide for removal of a failed IC, and replacement with a new high quality IC or a new part number.</p></li></ol></li></ol><h2 id="1-7-IC-组装技术（3个）need-to-be-more-specific"><a href="#1-7-IC-组装技术（3个）need-to-be-more-specific" class="headerlink" title="1.7 IC 组装技术（3个）need to be more specific"></a>1.7 IC 组装技术（3个）need to be more specific</h2><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU1NzliZWVhODFiZGYzMWE4MjZiNWFiMzk1MWIyYjdfcmMwNE1iNXNVRXVEazVpSURuUE1PN0VqS0IyV2g0bUFfVG9rZW46TGtsOGJ4WWczb1YxZjV4cUg5S2NSd3A1bkJkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTMzNmEzM2NkODY1Zjk0MjdmZjE4NWQyZGFiMDlmMDNfVVRWYXhqVHQ2Ynp1ODFSdWtxNFVMNXNYMDJ0OXdqRHlfVG9rZW46TnhTZmJaVHNFb1gyQmV4eGF5MmM1S3dvbjdkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-7-1-Wire-Bonding"><a href="#1-7-1-Wire-Bonding" class="headerlink" title="1.7.1 Wire Bonding"></a>1.7.1 Wire Bonding</h3><ol><li><h4 id="Define："><a href="#Define：" class="headerlink" title="Define："></a><strong>Define：</strong></h4></li></ol><p>A chip-to-package interconnection technique where a fine metal wire is attached between each of the I &#x2F;O pads on the chip and its associated package pin(在芯片上的每个I&#x2F;O焊盘与其相关的封装引脚之间连接一根细金属线).</p><p>A fine wire—typically gold wire 25 μm in thickness—is bonded using <strong>ultrasonic bonding</strong>（超声波焊）between the IC bond pad and the matching package or substrate bond pad.</p><ol><li><h4 id="Pros"><a href="#Pros" class="headerlink" title="Pros:"></a><strong>Pros:</strong></h4></li></ol><ul><li><p>Highly flexible chip-to-package interconnection process 灵活性&#x2F;工艺兼容性强</p></li><li><p>Low defect rates or high yield interconnection processing (40–1000 ppm)</p></li><li><p>Easily programmed or taught bonding cycles</p></li><li><p>High reliability interconnection structure</p></li><li><p>Very large industry infrastructure supporting the technology</p></li><li><p>Rapid advances in equipment, tools, and materials technology</p></li></ul><ol><li><h4 id="Cons"><a href="#Cons" class="headerlink" title="Cons:"></a><strong>Cons:</strong></h4></li></ol><ul><li><p><strong>Slower</strong> interconnection rates due to point-to-point processing of each wirebond</p></li><li><p>Long chip-to-package interconnection lengths, degrading electrical performance</p></li><li><p>Larger footprint required for chip to package interconnection</p></li><li><p>Potential for wire sweep during encapsulation overmolding</p></li></ul><ol><li><h4 id="IC-Bond-Pad-Interface"><a href="#IC-Bond-Pad-Interface" class="headerlink" title="IC Bond Pad Interface"></a><strong>IC Bond Pad Interface</strong></h4></li></ol><ul><li><p>Aluminum metallization</p></li><li><p>Copper metallization</p></li></ul><ol><li><h4 id="Package-Bond-Pad-Interface"><a href="#Package-Bond-Pad-Interface" class="headerlink" title="Package Bond Pad Interface"></a><strong>Package Bond Pad Interface</strong></h4></li></ol><ul><li><p>a metallized lead frame</p></li><li><p>a metallized chip carrier—organic laminate, polymer film, or ceramic</p></li><li><p>a metallized PCB</p></li></ul><ol><li><h4 id="Overall-Processes-–-wirebonded-plastic-package"><a href="#Overall-Processes-–-wirebonded-plastic-package" class="headerlink" title="Overall Processes – wirebonded plastic package"></a><strong>Overall Processes – wirebonded plastic package</strong></h4></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFlN2FiYTI3NzY5ZDk5NzM3ZDY4YmExNmE2MjI3NDFfZU5SZ1gwYmhSSXdVZklzY3dEME4xV3ZkdEo2NFVDaW9fVG9rZW46S2ZTWmJvTzBub3FiTkt4TG5nc2NweDA2bnhnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>A. 冲切出引线框模型</p><p>B. 在引线框上合电镀键金属</p><p>C. The chip is mounted onto the lead frame or chip carrier using a die attach process</p><ul><li><p>highly automated and uses high precision, high speed chip bonders</p></li><li><p>using a variety of materials including conductive epoxies and solders.</p></li></ul><p>D. Fine wires are bonded between each chip I&#x2F;O and the package lead frame pads or chip carrier traces</p><ul><li>Thermosonic and ultrasonic welding methods</li></ul><p>E. The package is overmolded with a polymer encapsulant to provide mechanical support and environmental protection, while presenting a cooling surface for heat transfer.</p><p>Molding: a transfer molding or injection molding process</p><p>F. The packages are singulated from the lead frame carrier</p><p>G. The leads are bent to form the package leads</p><p>J lead or gull wing leads</p><p>H. The lead frame carrier or chip carrier pallet, configured in a multiple up format整齐排列</p><p>I. Next subject to functional test and burn-in testing</p><p>J. 装运</p><ol><li><h4 id="Electrical-Performance-–-lowest"><a href="#Electrical-Performance-–-lowest" class="headerlink" title="Electrical Performance – lowest"></a><strong>Electrical Performance – lowest</strong></h4></li></ol><p>Reason: the relatively long lengths of the wires interconnecting the chip and package lead frame. This tends to increase impedance, promote inductive coupling, and slow package operating speeds.</p><ol><li><h4 id="Reliability-–-high"><a href="#Reliability-–-high" class="headerlink" title="Reliability – high"></a><strong>Reliability – high</strong></h4></li></ol><p>Common failures:</p><ul><li><p>Delamination of the encapsulant molding compound or die attach</p></li><li><p>Highly localized stress concentrations in the wirebonds, causing fatigue failures in the wire or bond.</p></li><li><p>A number of other failures</p></li></ul><ol><li><h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a><strong>Applications</strong></h4></li></ol><ul><li><p>all forms of plastic packaging</p></li><li><p>multichip modules</p></li><li><p>hermetic packaging 气密性封装</p></li><li><p>ceramic packaging</p></li></ul><h3 id="1-7-2-Tape-Automated-Bonding"><a href="#1-7-2-Tape-Automated-Bonding" class="headerlink" title="1.7.2 Tape Automated Bonding"></a>1.7.2 Tape Automated Bonding</h3><ol><li><h4 id="Define"><a href="#Define" class="headerlink" title="Define"></a><strong>Define</strong></h4></li></ol><p>An IC assembly technique based on mounting and interconnecting ICs on metallized flexible polymer tapes(将IC安装和互连到柔性金属化聚合物有载带上). It is based on the fully auto-mated bonding of one end of an etched copper beam lead to an IC, and the other end of the lead to a conventional package or PWB（蚀刻铜束一端[内引线]连接到IC，另一端[外引线]连接到常规封装或PWB的全自动连接）</p><ol><li><h4 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros:"></a><strong>Pros:</strong></h4></li></ol><p>Ability to handle <strong>small bond pads and finer pitches</strong> on the IC</p><ul><li><p>Elimination of large wire loops</p></li><li><p>Low profile interconnection structures for thin packages</p></li><li><p>Improved conduction heat transfer for thermal management</p></li><li><p>Improved electrical performance</p></li><li><p>Ability to handle high I&#x2F;O counts</p></li><li><p>Ability to burn-in on tape before device commitment</p></li><li><p>Reduced weight</p></li></ul><ol><li><h4 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons:"></a><strong>Cons:</strong></h4></li></ol><ul><li><p>Basically a peripheral interconnection technique with no active circuitry under the chip bond pads</p></li><li><p>Package size tends to increase with larger I&#x2F;O counts</p></li><li><p>Process inflexibility due to hard tooling requirements of the flex circuit, bond heads, etc.</p></li><li><p>Relatively little production infrastructure</p></li><li><p>Additional wafer processing steps required for bumping</p></li><li><p>Gang bonding群键合 no longer useful for the larger chips; replaced by single point thermosonic bonding</p></li><li><p>Large capital equipment investment required</p></li><li><p>Difficulty in assembly rework</p></li><li><p>Additional engineering requirements</p></li><li><p>Specialty materials and equipment requirements</p></li><li><p>Coplanarity of the beam leads with the chip and substrate</p></li><li><p>Long parallel interconnections with poor electricalperformance</p></li><li><p>System testability</p></li></ul><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjcxNDY4YjE0Mzk2MjI3MzUwZTc0OTgwMDQ3MmE3N2RfN3ZVNnJ6UHVQVm1UQm5QUzNaSmxKVVY4WENIMk83aUVfVG9rZW46WXNYUWJHdDBXb1o5bGl4Wng1MmNuM29pbjBmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTYyYmI1ZTRhZTYwYTk0NjEwYTc0N2VlZmI0NjRlYmVfbE43cURzcldiUnhUQ2I4YWtFOVB2bWVkQkVhMHpOTWFfVG9rZW46QTZqUmJvTUVab3AzMVN4VkRZN2M2VWV1bmtmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h4 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a><strong>Structure</strong></h4></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRhNWZjN2JkZmViZmNkODMwM2QzMmNiNTU4NDJmNjNfSVFXRUh4elhIRW42bXdQUzBLejY1d0VTQjdxNDhGenZfVG9rZW46QVlxM2JJallpb0liZEV4N1pLZGMyb2VsbkdlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a><strong>Process</strong></h4></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQ4YWVmMTE5ZjQ0MTI0MWIxMjhhYzlkNDkyMzE4MWRfV29YM1liUldyRnp6c2lTS1lkZFF1R0ZXdktwdURhcWpfVG9rZW46UFYyY2J3cHlWb0laenN4SUpzcGM4VFRPbnFiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>A. 加工圆片凸点</p><p>B. 将圆片粘在一个弹性胶带上进行划片</p><p>C. 加工载带(多层)</p><p>D. 芯片和载带对准</p><p>E. 内引线键合(ILB)</p><p>F. 测试</p><p>G. 包封</p><p>H. 分割</p><p>I. 测试&#x2F;老化</p><p>J. 引脚成型</p><p>K. 外引线键合(OLB)</p><ol><li><h4 id="Electrical-Performance-–-Improved"><a href="#Electrical-Performance-–-Improved" class="headerlink" title="Electrical Performance – Improved"></a>Electrical Performance – Improved</h4></li></ol><p>Reason: short circuit lead lengths between the chip, and substrate reducing impedance and signal delays.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzc4NzJiYjE0NmRiZWQ5OTc2MWQyNTI3YzYxYzI0YTdfVjJ5WExmOWZaUjc2U2VMSGZFWHFyQzhMbXI4QWZsRmVfVG9rZW46VkdYU2JvN3NFb0s5NTB4Vk1SQ2NjUnNqbnljXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="1-7-3-Flip-Chip"><a href="#1-7-3-Flip-Chip" class="headerlink" title="1.7.3 Flip Chip"></a>1.7.3 Flip Chip</h3><ol><li><h4 id="Define-1"><a href="#Define-1" class="headerlink" title="Define:"></a><strong>Define:</strong></h4></li></ol><p>an advanced form of surface mount technology, in which bare semiconductor chips are turned upside down, and hence called flip chip (i.e., active face down), and bonded directly to a printed circuit board or chip carrier substrate.</p><p>下图展示两种主流键合方法:焊料互连&#x2F;电胶连接</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U4NzY1MGJlY2U1OTY4ODA3Zjg4Njg4MjZjZDgwOWRfTFV5clY3REl3Qm5iUDV3WkRic1BqendLTmNBaEN5TE9fVG9rZW46TjNzUWJDaEVTb1FMRHB4NDkyRWNoQmxUbm11XzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJjYzY0MmY5MjA2ODQ4MjI1NTFhNmNlZWZlM2U2OGJfdmQ5YzU0UnFrcnZFendLMERvZDhRVFBxeFhhZG1VN2pfVG9rZW46WWFzcmJNT04xb0tPc1p4UlFpemM1SjkybnhmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h4 id="IC-Bond-Pad-Interface-1"><a href="#IC-Bond-Pad-Interface-1" class="headerlink" title="IC Bond Pad Interface"></a><strong>IC Bond Pad Interface</strong></h4></li></ol><p>The interconnection system can be subdivided into four functional areas:</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjYwMGZmOGUxNjQ5ZmQ4OGZiZTAxMWIxYmNkZTE0MTlfaFl4N3o2Wmg5NkhQa3Fmd2VFdTZYMDIzYW1yc2ZsSTdfVG9rZW46UGJ4WWJ6QnlTb1owM2Z4RnU5UWNaZEI5bmFmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk4N2I4ZDA1YmUxMThjZGRiNzQ1ZWE0NGVlNDBiMzZfYVNWeGRrQzFEa3Z6QWNGSnROVGZ0bWJNNHVjeDV3RWlfVG9rZW46UFFZcGJEc01qb2lWUVJ4dHlPV2N0TFhNbmhzXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><em>(1)under bump metallization</em> (UBM)</p><p>a compatible layer between the bump metallization and final chip metallization.</p><p>The structure of the UBM consists of an <em>adhesion layer</em> covering the chip metallization, a <em>barrier layer,</em> a <em>wetting layer,</em> and an <em>anti-oxidation barrier</em></p><p><em>(2)chip bumps,</em> bond materials between the bump and substrate metallization</p><p><em>(3)encapsulant</em></p><p><em>(4)substrate metallization.</em></p><p>IC键合区主要指前3部分</p><ol><li><h4 id="Bump"><a href="#Bump" class="headerlink" title="Bump"></a>Bump</h4></li></ol><p><strong>(1) Funtctions</strong></p><p>A. electrical connection between the chip and the substrate</p><p>B. a heat dissipation path from the chip</p><p>C. environmental protection</p><p>D. a structural link between the chip and the substrate</p><p><strong>(2)Types</strong></p><p>a) Wire Stud Bump</p><p>b) Plated Stud Bump</p><p>c) Solder Bump</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmEzMTdiZmEwZTY2YTNmOGU2NmRlZDZmN2QzMzVmYzNfUHdBdFVsVFphZE05QTZrYVg0UzdpNlRSYm1CQlhoalFfVG9rZW46RmhNcWJVdzJYb3p2c294NlNFWmM2MXRCblJoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>(3)Primary material systems</strong></p><p>A. High temperature with melting points in excess of 250 C (examples include 95% Pb–5% Sn and 97% Pb–3% Sn)</p><p>B. Moderate temperature with melting points between 200 and 250 C (examples include 95.5% Sn–3.5% Ag–1.0% Cu, CASTIN Cu-Ag-Sb-Sn, and 85.9% Sn– 3.1% Ag–10% In–1.0% Cu, and 96.5% Sn–3.5% Ag)</p><p>C. Low temperature with melting points less then 200 C (examples include 37% Pb–63% Sn eutectic, 88% In–12% Pb, 100% In, and 48% Sn–52% In).</p><p><strong>(4) Deposition Processes</strong></p><p>A. Evaporation</p><p>B. Electroplating</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNhYjIyZTQ2MzVjN2NiNTkxNmZkYTYzODEzYjBjODdfVFh6bTdPQnlyYmpGMDRGVGpxMmgzVlVadmVkVjBhaXJfVG9rZW46V0hqUGJEanh3bzczUHp4RGROM2NsRGgzbnliXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>C. Solder paste screening or printing</p><ol><li><h4 id="Flip-Chip-Processing"><a href="#Flip-Chip-Processing" class="headerlink" title="Flip Chip Processing"></a>Flip Chip Processing</h4></li></ol><p>(1) Solder Interconnection processing</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q4YTE5MjBkOWNhMzY5NDZkNjhhM2VmNGZjZDUyZjNfZW5tbjY1bmNSeWxSVVZXaEFKeFlXSnZQR1dQekNiNGlfVG9rZW46RG55dWIwSTBqb2U0QlF4ZmVyTWM0NGhMbm5mXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>(2) <em>Conductive Adhesive Interconnection Systems</em></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMyODhiNTBkZGY1OTUwMjQ5MDRjNzVkMWM2MTQ0YjRfR3dsOVBhc3QxSjN0eFh6cHJxcU1NOTJBZ2RGR1JFUlpfVG9rZW46T1RzdGJwWm5Eb1RHaFl4d0Q0amNCdGxnbmdiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h4 id="Flip-Chip-Assembly-Processes"><a href="#Flip-Chip-Assembly-Processes" class="headerlink" title="Flip Chip Assembly Processes"></a>Flip Chip Assembly Processes</h4></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFkODBkMjJiNTMzOGI4NTE5MzQ1OTE4ZDdmZWQxZmZfQ3lHem85bVFlOXpSQVFjV21iMDhyUkJ2akEyYlZ2SjRfVG9rZW46TWFpTGJJcmlYb2VPZ094WHc1R2Njd2ZIbndkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h4 id="Electrical-Performance-–-Best"><a href="#Electrical-Performance-–-Best" class="headerlink" title="Electrical Performance – Best"></a>Electrical Performance – Best</h4></li></ol><p>Reason: provides the shortest possible chip-to-package interconnection distance.</p><p>in terms of minimum impedance, minimum resistance, minimum capacitance, and minimum inductance.</p><ol><li><h4 id="Reliability-–-High"><a href="#Reliability-–-High" class="headerlink" title="Reliability – High"></a>Reliability – High</h4></li></ol><h2 id="MEMS-Microsystems-Packaging"><a href="#MEMS-Microsystems-Packaging" class="headerlink" title="*MEMS Microsystems Packaging"></a>*MEMS Microsystems Packaging</h2><h3 id="Comparing-MEMS-and-IC’s"><a href="#Comparing-MEMS-and-IC’s" class="headerlink" title="Comparing MEMS and IC’s:"></a>Comparing MEMS and IC’s:</h3><p>Complicated and Cost: MEMS packaging &gt;ICs Packaging</p><p>While MEMS packaging shares many of the same objectives as IC packaging, there are important differences that make packaging for MEMS difficult. One difference is that with IC packaging, input and output signals are electrical, while the inputs to MEMS devices can be a wide variety of physical stimuli. Consequently, the packaging for MEMS devices not only needs to encapsulate the device and protect it from the environment; it must also allow the device to interact with the environment in a very limited and controlled fashion. Another difference relates to the market sizes. In the case of IC microsystems packaging, it is very common that a packaging solution can be used for a relatively large number of different IC device types thereby enabling large economies of scale and lower costs. MEMS often require customized and costly packaging solutions and thereby higher costs.</p><p>*<strong>IC assembly</strong> is the most important first step in the use of ICs.</p><p>Wire-bonding is the most used technology today, and will remain so in the foreseeable future, at least up to 700 I &#x2F;Os on a single IC. For higher I &#x2F;Os, flip chip or TAB are the dominant technologies.</p><ol><li><h1 id="Basic-Design-Considerations-in-Microelectronic-Packaging-Chapter-4-5-19-21-22"><a href="#Basic-Design-Considerations-in-Microelectronic-Packaging-Chapter-4-5-19-21-22" class="headerlink" title="Basic Design Considerations in Microelectronic Packaging (Chapter 4, 5, 19, 21, 22)"></a>Basic Design Considerations in Microelectronic Packaging (Chapter 4, 5, 19, 21, 22)</h1></li></ol><h2 id="2-1-Electrical-package-design-SPICE-Model"><a href="#2-1-Electrical-package-design-SPICE-Model" class="headerlink" title="2.1 Electrical package design, SPICE Model"></a>2.1 Electrical package design, SPICE Model</h2><p><strong>Electrical package design</strong>：the process that defines the electrical signal and power paths through the package in a way that meets the overall system requirements. Ultimately, the design process is the geometrical layout of interconnects and the specification of materials.</p><p>获得满足系统要求的互连线集合版图、材料特性以及它们的几何尺寸</p><h3 id="2-1-1-Package-Functions"><a href="#2-1-1-Package-Functions" class="headerlink" title="2.1.1 Package Functions"></a>2.1.1 Package Functions</h3><p>provide semiconductor ICs with</p><ol><li><p>signal and power distribution</p></li><li><p>physical support</p></li><li><p>chemical protection against the environment</p></li><li><p>the capability to remove heat produced by the chip, to enhance the reliability of the packaging structures, and to secure the operation of the chip（否则，芯片中器件性能会随T上升而退化）</p></li></ol><h3 id="2-1-2-Electrical-Functions：信号分配和功率分配"><a href="#2-1-2-Electrical-Functions：信号分配和功率分配" class="headerlink" title="2.1.2 Electrical Functions：信号分配和功率分配"></a>2.1.2 Electrical Functions：信号分配和功率分配</h3><ol><li><p>Providing <strong>signal paths</strong> between the chips, including wiring that acts as a space transformer between the chip and board to match the dimensions of the interconnections and the design of embedded passive lumped components.</p></li><li><p>Providing <strong>suitable power distribution</strong> to enable the circuits to function.</p></li></ol><p>*Two aspects of electrical design: providing suitable communication paths for signals and providing suitable channels for power distribution.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJjZTg1Y2RmMzI3MjlhYjNlMzk1YmJiODg5MjQ5MGRfMXF2Wlh1a0ZCQmtYYXVWQThCNXF1TWxMM1Q0T0xUWjhfVG9rZW46Q1Rpd2JVTUtjbzA5NWV4YU1POWNIRnp3bkFBXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The primary technical challenge for electrical design is driven by the frequency spectrum of signals.</p><p>At low frequencies, signal and power paths are easily realized since the physical geometry of the interconnects has little effect.</p><p>At higher frequencies (1 GHz and up), the realization of appropriate interconnections is much more difficult. Interconnects are physically longer than the packets of energy routed along them, and their behaviour depends on the properties of the materials and the electromagnetic fields that comprise the signal.在高频范围,互连线实际上比沿着它们走线的能量路线更长,它们的特性与互连线材料特性以及构成信号的电磁场有关。一些效应,如传输延迟、互连线结构相关的特征阻抗及寄生电抗等决定了信号的特性。因此,信号的失真度和信号到达目的地所需的时间都是互连线参数的函数。由于信号的频谱确定了芯片需要电源的速率,所以也要关心电源和地线的路径</p><p>*<strong>Parasitic Structure</strong>:</p><p>The passive components that are mounted on the package or board have equivalent circuits that define them. One example is the decoupling capacitor, which is represented as a series RLC circuit in Figure below.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQ3ZGIxODkxYWMzNzcxNmU0N2RkYTg4MTZlMDVhNjRfYWpndWY3clQ5Sjdma1hlN2JtNnpNaThQWEt6MXFJSWlfVG9rZW46SWc3OWI2d3RMbzJSZ0R4VGdLYmNJVkM0bmlmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="2-2-Electrical-Anatomy-of-System-Packaging"><a href="#2-2-Electrical-Anatomy-of-System-Packaging" class="headerlink" title="2.2 Electrical Anatomy of System Packaging"></a>2.2 Electrical Anatomy of System Packaging</h2><h3 id="2-2-1-Ohm’s-Law-voltage-across-a-resistor-is-V-IR"><a href="#2-2-1-Ohm’s-Law-voltage-across-a-resistor-is-V-IR" class="headerlink" title="2.2.1 Ohm’s Law (voltage across a resistor is V&#x3D;IR)"></a>2.2.1 Ohm’s Law (voltage across a resistor is V&#x3D;IR)</h3><p>Electrical design involves electricity: The movement of electrons in a conductor.</p><p>In packaging applications, electricity is used in both its fundamental forms: DC &amp; AC.</p><p>Power supplied to a chip: DC</p><p>Signals in and out of the chip vary with time.</p><p>Most electrical signals are neither DC nor AC; instead, they vary with time in some nonconstant, nonsinusoidal manner. R dissipates electrical power by converting it to heat; consequently, it is usually desirable to <strong>minimize R of wires and conducting traces</strong>.</p><h3 id="2-2-2-Skin-Effect-I-C-dV-dt-V-L-dI-dt"><a href="#2-2-2-Skin-Effect-I-C-dV-dt-V-L-dI-dt" class="headerlink" title="2.2.2 Skin Effect (I &#x3D; C dV&#x2F; dt; V &#x3D; L dI&#x2F; dt)"></a>2.2.2 Skin Effect (I &#x3D; C dV&#x2F; dt; V &#x3D; L dI&#x2F; dt)</h3><p>At DC, current flows uniformly within a conductor.</p><p>At higher frequencies, current tends to crowd along the surface of the conductors. (Skin effect)</p><p>Because of this, the AC R of conductors is considerably higher than the DC R. For AC signals, V and current sinusoids may also be out of phase with each other indicating the presence of C or L within the circuit.</p><h3 id="2-2-3-Kirchhoff’s-Voltage-Laws"><a href="#2-2-3-Kirchhoff’s-Voltage-Laws" class="headerlink" title="2.2.3 Kirchhoff’s Voltage Laws"></a>2.2.3 Kirchhoff’s Voltage Laws</h3><p>KVL: the voltage drops around any closed loop within the circuit must add to zero.</p><p>KCL: the sum of the individual currents into a node of the circuit must add to zero.</p><h3 id="2-2-4-Noise"><a href="#2-2-4-Noise" class="headerlink" title="2.2.4 Noise"></a>2.2.4 Noise</h3><p>The presence of any undesired signal within a system can prevent that system from operating as intended.</p><h3 id="2-2-5-Time-Delay-time-constant-τ-RC-and-time-delay-τ-L-R"><a href="#2-2-5-Time-Delay-time-constant-τ-RC-and-time-delay-τ-L-R" class="headerlink" title="2.2.5 Time Delay (time constant τ&#x3D;RC and time delay τ&#x3D;L&#x2F;R)"></a>2.2.5 Time Delay (time constant τ&#x3D;RC and time delay τ&#x3D;L&#x2F;R)</h3><p>The combination of R with either C or L introduces time delay into the system.</p><p>RC delay is of considerable concern to chip and package designers, 制约系统的速度</p><p>L&#x2F;R delay affects the ability of an on-chip power supply.影响电源对芯片发出变化指令的瞬间响应能力，并产生SSN</p><h3 id="2-2-6-Simultaneous-Switching-Noise-SSN"><a href="#2-2-6-Simultaneous-Switching-Noise-SSN" class="headerlink" title="2.2.6 Simultaneous Switching Noise (SSN)"></a>2.2.6 Simultaneous Switching Noise (SSN)</h3><p>the fluctuation in signals that result from a brief reduction of the local DC supply voltage at some point within the system due to the power supply’s inability to instantly respond. 由于电源不能即时响应而造成系统中某点的局部DC电源电压暂时减小引起的信号波动</p><p>One remedy to the SSN problem is to place decoupling capacitors 补偿系统中的L.</p><h3 id="2-2-7-Transmission-Lines"><a href="#2-2-7-Transmission-Lines" class="headerlink" title="2.2.7 Transmission Lines"></a>2.2.7 Transmission Lines</h3><p>Although the time delays associated with electrical signals, modeled as RC and L&#x2F;R delays, electricity is carried by electromagnetic waves.</p><p>Electromagnetic waves travel at the velocity of light in a particular material. In air, c&#x3D;1ft&#x2F;ns. For most packaging applications, it is sufficient to consider EM waves that travel in 1D. These waves can be modeled by voltages and currents on transmission lines.</p><h3 id="2-2-8-Crosstalk"><a href="#2-2-8-Crosstalk" class="headerlink" title="2.2.8 Crosstalk"></a>2.2.8 Crosstalk</h3><p>The result of a signal on one line inducing a signal on a nearby line, despite the absence of any physical connection.</p><p>Caused by parasitic R and L.</p><h3 id="2-2-9-Electromagnetic-Interference-EMI-电磁干扰"><a href="#2-2-9-Electromagnetic-Interference-EMI-电磁干扰" class="headerlink" title="2.2.9 Electromagnetic Interference (EMI)电磁干扰"></a>2.2.9 Electromagnetic Interference (EMI)电磁干扰</h3><p>Undesired electrical effects that disrupt a system’s performance or interfere with nearby systems</p><h3 id="2-2-10-SPICE-Model"><a href="#2-2-10-SPICE-Model" class="headerlink" title="2.2.10 SPICE Model"></a>2.2.10 SPICE Model</h3><p>A number of general-purpose circuit analysis tools exist for simulating electronic circuits. One of these is SPICE (Simulation Program with Integrated Circuit Emphasis). This type of simulation tool contains models for all common circuit elements and many active devices, and can perform time-domain and frequency domain simulations.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDI5Y2M5NWU2MDU0ZGI4Mjk0ODcxNWY0MGZhMmI4ZDVfeDRNUUVSNHViN2pCb2hpQzNDSnhwajJDMUlaVEtTWXZfVG9rZW46U1ZhWWI0M2hTb3Q3dDV4ZG1YNGMyZW41blNoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU4ODI0NjZiMWYyZTY1ODk2Y2ExYmI4N2NiNjAxMWZfUVk4RVg4Z2JuNTVPenRCRW9PemNRYmhjME56eXlJQ2FfVG9rZW46SDJQdGJScWRrb3JUWDl4eGpQWWMwSXZLbmdoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2QxOTRlZjhiNTQwNmM1MDcxODAyNmFmODAyMzZjOGNfWFJwQW9Nb0VYa0pad05JZVN0Z0twOHpFaXpnblFkdU1fVG9rZW46VzIxTmI4NGVob3Y2bTR4bUpJOWNVa0pvbmJnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>In the future, the package will contain lumped passive circuit elements such as R，L，C (集总的无源电路元件).</p><p>C in the package may be used to</p><ol><li><p>supply charge to the power line of the chip</p></li><li><p>isolate the inductive parasitics of bonding structures.</p></li></ol><p>Lumped chip capacitors that are currently mounted on the surface or at the bottom of the package may be <strong>replaced</strong> with embedded capacitors buried inside the multi layer package.</p><p>The embedded resistors may be used for the termination of signal lines to <strong>avoid signal reflections from the ends</strong> that cause unwanted high-frequency noise and signal propagation delay.</p><p>Since the termination resistors of the signal lines determine the power consumption of the drivers, signal propagation delay and package complexity, their design can become very important.</p><h2 id="2-3-Electrical-Anatomy-of-System-Packaging"><a href="#2-3-Electrical-Anatomy-of-System-Packaging" class="headerlink" title="2.3 Electrical Anatomy of System Packaging"></a>2.3 Electrical Anatomy of System Packaging</h2><p>Electrical design involves the estimation of package performance.</p><p>The electrical system specifications for the package include parameters such as delay, skew失真, loading负载, impedance阻抗, reflections反射, crosstalk串扰 and power&#x2F;ground fluctuations.</p><p>To estimate the electrical performance, circuit simulation methods are often used which require the circuit models of packaging structures.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzZiNDY3MDE3MWZlZGJlMWYyZmYzNjY0ZmQzZDU4NTRfUlVOczlEbEtYdGNTMzVBUzBTR3p2cWY0SE1wUVRMM2JfVG9rZW46WHdMT2JHS1Zib2x2VDN4NFF3RWNPaHozbmdoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The signal lines within the package are used for the transmission of signals between chips. Based on the characteristics of the signal lines, the driver and the receiver circuitry, they can cause delay, skew and reflections, which degrade the transmitted signal.To evaluate the signal line performance, they are represented by their characteristic impedance Z0 and propagation velocity vp.</p><p>During signal transmission, the signal line can couple energy to adjacent signal lines, which results in crosstalk. Crosstalk can cause false switching of circuits and can increase delay. Crosstalk can be simulated by extracting the coupling between signal lines, such as mutual inductance Lm and mutual capacitance Cm</p><p>The chips are connected to the signal lines through bonding structures and vias. Similarly, signals exiting the package pass through pins and connectors. These structures add parasitics to the signal lines due to their R and reactance and can degrade the signal.</p><p>The passive components that are mounted on the package or board have equivalent circuits that define them. One example is the decoupling C, which is represented as a series RLC circuit</p><h2 id="2-4-Design-for-reliability-Thermomechanically-Electrically-and-Chemically-Induced-Failures"><a href="#2-4-Design-for-reliability-Thermomechanically-Electrically-and-Chemically-Induced-Failures" class="headerlink" title="2.4 Design for reliability, Thermomechanically, Electrically and Chemically Induced Failures"></a>2.4 Design for reliability, Thermomechanically, Electrically and Chemically Induced Failures</h2><h3 id="2-4-1-Design-for-reliability"><a href="#2-4-1-Design-for-reliability" class="headerlink" title="2.4.1 Design for reliability"></a>2.4.1 Design for reliability</h3><p><strong>Reliable</strong>: When a product performs the functions for which it is designed.</p><p>To ensure that the electronic systems packaging will be reliable over an extended period, two approaches need to be followed:</p><ol><li><p>design the systems packaging up-front for reliability</p><ol><li><p>predetermine various potential failure mechanisms that could result in product failure.</p></li><li><p>create designs and select materials and processes that would minimize or eliminate the chances for failures</p></li></ol></li><li><p>conduct an accelerated test on the systems packaging for reliability after the system is designed, fabricated, and assembled</p><ol><li><p>subjected to accelerated test conditions for short periods of time by applying ⬆ T, ⬆ humidity, ⬆ V, ⬆ pressure, and more to accelerate the failure process</p></li><li><p>such as thermal cycling, temperature and humidity cycling and power cycling</p></li></ol></li></ol><ul><li><p>Plastic packages are best suited for controlled environments</p></li><li><p>Ceramic packages offer the best performance in terms of thermal characteristics, moisture absorption and endurance in harsh environments.</p></li></ul><p>The package must provide a good long-term reliability even in the harshest environments</p><p>The underlying cause or failure mechanism, the net result is that the system is not reliable or usable. Design for reliability aims to understand, identify and prevent such underlying failures even before the packages are built.</p><p><strong>Methods</strong> of design against failures:</p><ol><li><p>by reducing the stresses that cause the failure</p></li><li><p>by increasing the strength of the component.</p></li></ol><h3 id="2-4-2-MICROSYSTEMS-FAILURES-AND-FAILURE-MECHANISMS"><a href="#2-4-2-MICROSYSTEMS-FAILURES-AND-FAILURE-MECHANISMS" class="headerlink" title="2.4.2 MICROSYSTEMS FAILURES AND FAILURE MECHANISMS"></a>2.4.2 <strong>MICROSYSTEMS FAILURES AND FAILURE MECHANISMS</strong></h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2EwMjAwMTk4ZmEzY2JkNjAwMjEyYWU3MzIxZTEyOGJfV2hDSTlLNDVDclVLMFY1ek05Z2dJT3FnQjJyUWVYdFBfVG9rZW46T1JneWJYbWZXb3pYbHl4eTc0MGNnT1FRbnBjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJkZmE5ZDRkY2EzN2E0ODg1MmQwMGNhMDBiMDNkOWNfYWoyb1NReWw0U2VPUE9pOWRYUUZWSVRIZVFselV5WFpfVG9rZW46Wk9MemJtWWJlbzFhbVF4MUtkUWNRcGZKbkdoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzYzNWI1YTlhNzhmMTk5ZjViMWJjNjhkY2I5NWExM2VfaENyVVRRUXdrSjFhVHVhcXhrT2gzSFNiSUl1V1FsT0FfVG9rZW46TnNkdmJyZ0ZWb25DVVB4Y2ZBOGNhMGF0bmJjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>Brittle脆性</strong>: hard but liable to break easily</p><p><strong>Fragile易碎</strong>:(of an object) easily broken and damaged</p><p><strong>Corrosion</strong>: a natural process that causes the transformation of pure metals into undesirable substances when they react with substances like water or air</p><p><strong>Dendritic枝晶</strong>: when a metal, or an alloy of multiple metals, in liquid form freezes</p><p><strong>Creep蠕变</strong>: a complex failure mode that describes how material deform on an atomic scale</p><p><strong>Delamination分层</strong>: Any moisture in the material would certainly cause delamination and very expensive damage. These defects, suchas bubbles, cracks, and delaminations, are not necessarily visible, even under a microscope. Delamination tends to destroy coating strength and durability</p><h3 id="2-4-3-Thermomechanically-Induced-Failures"><a href="#2-4-3-Thermomechanically-Induced-Failures" class="headerlink" title="2.4.3 Thermomechanically-Induced Failures"></a>2.4.3 Thermomechanically-Induced Failures</h3><p>caused by stresses and strains (应力和应变) generated within an electronic package due to thermal loading from the environment or internal heating in service operation.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkxM2NhZDA3NTE3YzFlOWUxZjliOTE1YWEzOWZjNzNfblBxWXVmSHAzeWY0TnlLcWJXSjhaU2QxeVQ4eDN6T0NfVG9rZW46V2VjWmJVVWJxb0NsMWR4SU0xeWN5NXhabm1mXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTEwNzVjMmM4MGE2YWQ4YWNiM2ZmN2VmYWU2ZDdkYzZfekx5alZEZ2VyTzU2akg3WmtWdHhGZFdzOGFWYVFScHNfVG9rZW46UWcwZmJBR3ltb3dEMzF4a2tUOWNmT3B2bmRmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTEwNzVjMmM4MGE2YWQ4YWNiM2ZmN2VmYWU2ZDdkYzZfekx5alZEZ2VyTzU2akg3WmtWdHhGZFdzOGFWYVFScHNfVG9rZW46UWcwZmJBR3ltb3dEMzF4a2tUOWNmT3B2bmRmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="2-4-4-Design-against-Fatigue"><a href="#2-4-4-Design-against-Fatigue" class="headerlink" title="2.4.4 Design against Fatigue"></a>2.4.4 Design against Fatigue</h3><p>Fatigue is the most common mechanism of failure and is believed to be either fully or partially responsible for 90% of all structural and electrical failures. The failure mechanism is known to occur in metals, polymers and ceramics</p><h2 id="2-5-Design-of-Testability-Scan-Design-Interconnection-Tests-CH19-7"><a href="#2-5-Design-of-Testability-Scan-Design-Interconnection-Tests-CH19-7" class="headerlink" title="2.5 Design of Testability (Scan Design), Interconnection Tests (CH19.7)"></a>2.5 Design of Testability (Scan Design), Interconnection Tests (CH19.7)</h2><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2I5MTJmMTBhZTNkMWZkMGZlYTBjMTg3YmU1Zjk4YTBfeFZQSnZ2SWVTN2k5c2hHUW1hQ0dONThpc3NQUEs4cDFfVG9rZW46UzIzZGJvR2VobzZwY0V4NFBQOGM2SGNLbnRkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Today’s ICs may contain several million&#x2F;billion transistors that need to be tested to verify their gate-level functions. As the transistor count increases, the complexity of functional tests (cost of testing) also increases.</p><p><strong>Design for testability (DFT)</strong>: To reduce these cost, need to be incorporated test features into the circuit itself during the design phase.</p><p>Electrical testing: the process by which an electronic, photonic, or MEMS device, or the systems in which they are used, is guaranteed to be electrically functional before it is put to end-product use. To check if all pins have been correctly soldered. It is also about its prototyping capabilities. The two most popular DFT techniques employed are scan design and built-in self-test (BIST).</p><h3 id="2-5-1-Scan-Design"><a href="#2-5-1-Scan-Design" class="headerlink" title="2.5.1 Scan Design"></a>2.5.1 Scan Design</h3><p>Scan circuitry greatly enhances a design’s testability, facilitates faster and improved test generation, and reduces external tester usage.</p><p>Two main types of scan circuitry: <strong>internal scan</strong> and <strong>boundary scan</strong></p><h4 id="2-5-1-1-Internal-Scan"><a href="#2-5-1-1-Internal-Scan" class="headerlink" title="2.5.1.1 Internal Scan"></a>2.5.1.1 Internal Scan</h4><ol><li><p>involves the internal modification of a design’s circuitry to increase its testability.</p></li><li><p>Scan design uses either a full or partial scan technique, depending on design criteria.</p></li><li><p>Aim: make a difficult-to-test sequential circuit behave like an easier-to-test combinational circuit.</p><ol><li><p>Achieving this goal involves replacing sequential elements with scannable sequential elements (scan cells) and then stitching the scan cells together into scan registers, or scan chains. 串行</p></li><li><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y2MjlkZDZkYmRjNGUxYjcwZTgwN2Y3ZWY0NDhmNTJfQm9WNjQ3UmtEMlJ5bEpZZFkxcklad1Q3UU5sWUZPcnJfVG9rZW46Rmt1WmJBTlhjb2ZWdk14NkhReGNYdTk3bnljXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p></li></ol></li></ol><p>Before adding scan, the design had <strong>four inputs</strong> and <strong>two outputs</strong>. After adding scan circuitry, the design has two additional inputs, <strong>scan-in and scan-shift</strong>, and one additional output <strong>scan-out</strong>. <strong>Scan memory elements</strong> replace the original memory elements so that when shifting is enabled, scan data is read in from the scan-in line.</p><ol><li><p>Operation:</p><ol><li><p>Shift data into scan chains</p></li><li><p>Apply stimulus to the primary inputs</p></li><li><p>Measure primary outputs</p></li><li><p>Pulse system clock to capture new values into scan cells</p></li><li><p>Scan data out to measure the captured values while simultaneously loading new values into the scan chains</p></li></ol></li></ol><h4 id="2-5-1-2-Boundary-Scan-BS-JTAG"><a href="#2-5-1-2-Boundary-Scan-BS-JTAG" class="headerlink" title="2.5.1.2 Boundary Scan (BS&#x2F;JTAG)"></a>2.5.1.2 Boundary Scan (BS&#x2F;JTAG)</h4><ol><li><p>Define: a DFT technique that facilitates the testing of PWB and MCM interconnect circuitry and the chips on those boards.</p></li><li><p>Function: detect the vast majority of board manufacturing process faults. e.g. wrong components, missing components, mis-oriented components, and components with stuck pins, shorts, and opens.</p></li><li><p>Explanation: When used on a board, BS stitches the I&#x2F;O ports of the chips together into a long scan path. It associates a memory cell with each IO of a chip. These memory cells are connected serially to form a shift register. The architecture also contains a four-port standard connection, the <em><strong>test access port</strong></em> <strong>(TAP)</strong>, which provides access to this shift register and controls the various chip test modes.</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTkxYzQzZDRjNDIyNmQ1MDdiNDc2ZTRjNzE2YTU2NmRfZGlNOWMzc1ZWUFlMMHN1aUJPNk5zUlZKeVh5OGtNbmZfVG9rZW46QnV3cmJic0xrb0R3UUd4ajJiVmNjbktDbllkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The test circuitry consists of the boundary scan register, a 1-bit bypass register, an instruction register, several miscellaneous registers, and the TAP.</p><p>The TAP consists of four lines</p><ol><li><p>the <em>test clock</em> (TCK)</p></li><li><p>the <em>test mode select</em> (TMS)</p></li><li><p>the <em>test data in</em> (TDI)</p></li><li><p>the <em>test data out</em> (TDO) lines</p></li></ol><p>Test instructions and data are sent over the TDI line. Test results and status information are sent from the chip over the TDO line. The state of the test circuitry in the chip is defined by the state transitions on the TMS line, which are decoded by the TAP controller.</p><ol><li><p>Operation:</p><ol><li><p>An instruction is sent serially over TDI into the instruction register.</p></li><li><p>Then the selected test circuitry is configured to respond to the instruction. This involves sending a test vector over TDI into the register selected by the instruction.</p></li><li><p>Execute the test instruction</p></li><li><p>Test results are latched into the selected register and shifted out over TDO to the external tester. Simultaneously, new data is shifted in.</p></li></ol></li><li><p>Modes</p></li></ol><p>The two most popular modes of BS standard based test are INTEST and EXTEST. BYPASS, IDCODE, SAMPLE, PRELOAD are some of the other test modes used.</p><p>A. EXTEST: allows testing of off-chip circuitry and board-level interconnects. Boundary scan cells at the output pins are used to apply test stimuli, while those at input pins capture test results.</p><p>B. INTEST is used to test the circuit inside a chip.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDg0YzdiY2Y5NDVjMzkyZTk5ZWIwODFkYjcwYmVmNjRfRmJPbVphbHExMXJ0Yjg5NDMxc2M1REp4MEZvQ21OQVBfVG9rZW46TkV1NGIwZnlRb1FPcHJ4SENHZWNvaFdMbjdpXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Test data shifts along the scan path, starting at TDI and ends at TDO. The scan path connects all devices on a board that contain BS circuitry.</p><p>The TDO of one chip feeds the TDI of the next, all the way around the board.</p><p>The other two inputs, TCK &amp; TMS, connect in parallel to each boundary scan device in the scan path.</p><p>With this configuration, board interconnects can be tested, a snapshot of the normal system data is taken and individual chips are tested.</p><h3 id="2-5-2-Built-in-Self-Test-BIST"><a href="#2-5-2-Built-in-Self-Test-BIST" class="headerlink" title="2**.5.2** Built-in Self-Test (BIST)"></a>2**.5.2** Built-in Self-Test (BIST)</h3><ol><li>Definition: a structured DFT technique that places a device’s testing function within the device itself. BIST structures can test various types of circuitry, from random logic to regular structures such as memory devices</li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkwZGJiYTEwZmZlOWQ5MjIxMjU4MjBjZGMyMTYxNDBfQTVhdmNJRXFiZkU1SDlucE9WMlpoWGgwMGlKVW5Fc2JfVG9rZW46WEJ1NmJvaXFOb0FEQlN4aGNJOWNuMFIwbkFjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="2-6-Microsystem-design-for-environment-traditional-design"><a href="#2-6-Microsystem-design-for-environment-traditional-design" class="headerlink" title="2.6 Microsystem design for environment, traditional design"></a>2.6 Microsystem design for environment, traditional design</h2><h3 id="2-6-1-Traditional-disign"><a href="#2-6-1-Traditional-disign" class="headerlink" title="2.6.1 Traditional disign"></a>2.6.1 Traditional disign</h3><ol><li><p>Traditional industrial practice involves testing for reliability after the IC and the system-level packages are fabricated and assembled. If problems are found in reliability testing, the IC and the system-level packages are redesigned, refabricated, reassembled, and retested.</p></li><li><p>Cons: expensive and time consuming</p></li><li><p>Aim of design for reliability: understand and fix the reliability problems up-front in the design process, even before the IC and the system-level packages are fabricated</p></li></ol><h3 id="2-6-2-Traditional-Design-Flow"><a href="#2-6-2-Traditional-Design-Flow" class="headerlink" title="2.6.2 Traditional Design Flow"></a>2.6.2 Traditional Design Flow</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJlMjcyOTczMDc0ZTlhMjY5ZDQ0MzZkNmYwYWVjMDlfaXN0VHRWT1JkOWlDemU3WFpvWHFuTEF1UmNxeWhhZk5fVG9rZW46V2d3UmJPQjRJb1BRdEt4WjBqamN3M3VGbkFiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWMwNjQ3Mzc1YjIxMzcwMGJkMzIzY2M5YmM3OGY5MDlfR2pXcVdDRWpLcExERWIydTJrbEtCUnpoaWkwdEM3UDNfVG9rZW46SkZWaWJKWkV5b2tQdVh4Rkg3WmNZQlBEbmRkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="2-6-3-Microsystem-Design-for-Environment"><a href="#2-6-3-Microsystem-Design-for-Environment" class="headerlink" title="2.6.3 Microsystem Design for Environment"></a>2.6.3 Microsystem Design for Environment</h3><p>Environmental issues can be divided into the following nine categories:</p><ol><li><p>Global warming</p></li><li><p>Depletion of natural resources</p></li><li><p>Ozone hole</p></li><li><p>Acid rain</p></li><li><p>Pollution of soil, subterranean sea, atmosphere and ecology</p></li><li><p>Decreasing number of rain forests</p></li><li><p>Increasing desert area</p></li><li><p>Decreasing species of wild animals</p></li><li><p>Transfer of harmful industrial waste from advanced nations to developing nations</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWIzNDljZTZmZmEwYjQwNThhZWM0OGUxYzU0N2U0ZDdfQXJxSDV2UktnenlZNFNLbzZNc3NpUWpGRnRuOWRkcFpfVG9rZW46U1lLMGJNVFljb0RuakR4MlNUQ2NmN1hMbkhmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWIzNDljZTZmZmEwYjQwNThhZWM0OGUxYzU0N2U0ZDdfQXJxSDV2UktnenlZNFNLbzZNc3NpUWpGRnRuOWRkcFpfVG9rZW46U1lLMGJNVFljb0RuakR4MlNUQ2NmN1hMbkhmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTU3ZTI3MzM4ODUzYjFlMDNhYjIzOTBlYmFmMGY0OWJfVUdjTHZxQ2RjT2x0WXVBM1NQZ1JaNkJLUHQ0ZzJDbndfVG9rZW46Slc5YmJLSG5Xb2xLNVN4U0tZZmNiZTZMbkFlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTU3ZTI3MzM4ODUzYjFlMDNhYjIzOTBlYmFmMGY0OWJfVUdjTHZxQ2RjT2x0WXVBM1NQZ1JaNkJLUHQ0ZzJDbndfVG9rZW46Slc5YmJLSG5Xb2xLNVN4U0tZZmNiZTZMbkFlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="2-6-4-LIFE-CYCLE-ASSESSMENT-LCA"><a href="#2-6-4-LIFE-CYCLE-ASSESSMENT-LCA" class="headerlink" title="2.6.4 LIFE-CYCLE ASSESSMENT (LCA)"></a>2.6.4 LIFE-CYCLE ASSESSMENT (LCA)</h3><p>The keystone to LCA is the inventory清单, consisting of the environmental influence of materials, processes, etc. These include</p><ol><li><p>Raw material</p></li><li><p>Components for assembly</p></li><li><p>Energy and water</p></li><li><p>Emissions into air</p></li><li><p>Emissions into water</p></li><li><p>Waste materials for recycling or landfill</p></li><li><p>Actual product</p></li><li><p>Transport</p></li><li><p>Use of Product</p></li><li><p>Scrapping and recycling</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGU4ZTI4ZWRhYWQwNWY2ZDI4ZjQ0ODcyNDU2YWE0MjVfblZNb0xQM0dYdGtZbjZjMFI2STNBTEZycDFpbFlTTXNfVG9rZW46RlFJaGJuZXVtb21IVFl4TmVCOGNLb1BEbldoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h1 id="Packaging-Materials-Ch9-18"><a href="#Packaging-Materials-Ch9-18" class="headerlink" title="Packaging Materials (Ch9,18)"></a>Packaging Materials (Ch9,18)</h1></li></ol><p>Materials provide several functions in microelectronic packaging. They</p><p>(1)transmit signals from IC to IC</p><p>(2)supply power to ICs</p><p>(3)provide interconnections to form the system-level hierarchy</p><p>(4)mechanically and environmentally protect ICs</p><p>(5)dissipate heat. These functions are schematically depicted in Figure 3.1.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUwZTIxYmJjYzgyMzczNzFiNjAxZmU0MzlmNGI0MjRfc0FmSlJnQTZCWHN3ZlIzc2ZCdmFycmVXdVdqU0hySnlfVG9rZW46UHBQNWIzT0l1b1hwc0l4cnhoZGN2WGxzbjNmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzkzMzU2YTBjYzk4OGNkMDljNTk0ZjE4MTkzM2U5OWZfWmkxamVzMXY0Q2lPcnFxeU5sVG1veEl3bWZGa3ZTTzBfVG9rZW46VENZNWIwT3pwb3pPalV4YjJhOGNlVEdCbjVBXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="3-1-Underfill-mold-compounds"><a href="#3-1-Underfill-mold-compounds" class="headerlink" title="3.1 Underfill&#x2F;mold compounds"></a>3.1 Underfill&#x2F;mold compounds</h2><p>The <strong>molding process</strong> aims to encapsulate the whole wire bonded die against exposure to contamination and other physical damages.</p><p>The lead frames that hold the dies are placed in individual cavities which are filled with liquid resin. (保持模具的引线框架被放置在充满液体树脂的单个腔中)</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmU0ZWNmMzUzNThiOGNkYjA4OTQyMDQwYTFkMzJlYjdfWU4wa0duWnZHSGd3dlB1eERnd1Q3YmU1QzBJSnlJcXhfVG9rZW46V2Z2ZWJTRFRub2NDZ2p4cTlWZGNiUE95bmtmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>Molded Underfill</strong>: Advanced silicon package manufacturers – enabling devices that are smaller, more powerful, more robust, more affordable. But all these advancements depend on techniques – such as molded underfill, Cu pillars and stacked dies – that make package inspection much more challenging than in the past.</p><h2 id="3-2-Solder焊料"><a href="#3-2-Solder焊料" class="headerlink" title="3.2 Solder焊料"></a>3.2 Solder焊料</h2><p>Solders for interconnects (Sn-Pb, Sn-Ag; gold wire bonds), copper lead frames(Kovar, CuBe, Alloy 42), copper traces in substrates; Tungsten钨, molybdenum钼 traces in co-fired ceramics Layer of Tin Lead solder on the lead frame for making the PCB assembly process easier. Lead free无铅 finishing with Tin Bismuth锡铋 plating or Tin Copper锡铜 dipping can also be used.</p><h2 id="3-3-Thermal-interface-materials"><a href="#3-3-Thermal-interface-materials" class="headerlink" title="3.3 Thermal interface materials"></a>3.3 Thermal interface materials</h2><p>These are designed to help remove the heat generated by an electronic device to the ambient environment to ensure reliable operation of electronic hardware, communication equipment and portable electronics.</p><p>Thermal interface materials provide a thermal path between the heat source and heat sink. Materials are Silicon (Si) Rubber硅橡胶, Si Foam泡沫硅, Si Sponge海绵硅, Solid Si sheet固体硅片 etc.</p><h2 id="3-4-Substrates"><a href="#3-4-Substrates" class="headerlink" title="3.4 Substrates"></a>3.4 Substrates</h2><p>Three alternative chip attachments to the package substrate:</p><ol><li><p>Soft Solder Die Attach: This process uses a solder material to bond the die to the lead frame. The solder is introduced as a wire preform and melted onto the hot lead frame surface as a liquid solder dot.</p></li><li><p>Epoxy Die Attach: (the most commonly used process) Usually silver-loaded polymers载银聚合物 are used, but the term generally encompasses the use of other adhesives, such as polyimide聚酰亚胺- or silicone-based materials.</p></li><li><p>Metal-filled glasses: Less used because of the high temperatures needed, but have been used in ceramic packages</p></li></ol><h2 id="3-5-Metal-Alloys"><a href="#3-5-Metal-Alloys" class="headerlink" title="3.5 Metal Alloys"></a>3.5 Metal Alloys</h2><ol><li>Definition: Alloys are compounds consisting of more than one metal</li></ol><p>–Adding other metals can affect the density, strength, fracture toughness断裂韧性, plastic deformation塑性变形, electrical conductivity and environmental degradation.</p><p>–have a melting range in which the material is a mixture</p><p>of solid and liquid phases.</p><p>–Alloys can be designed with a single melting point, and these are called eutectic mixtures低熔混合物e.g. 63%Sn, 37%Pb</p><ol><li>Properties of Metals and Metal Alloys:</li></ol><ul><li><p>excellent thermal andelectrical conductivities</p></li><li><p>Relatively high densities, especially compared topolymers</p></li></ul><p>–Materials with high densities often contain atoms with high atomic numbers, such as Au. However, some metals such as Al or Mg(magnesium) have low densities, and are used in applications that require other metallic properties but low weight.</p><ul><li>Fracture Toughness</li></ul><p>– Ability to avoid fracture, especially when a flaw is introduced</p><ul><li>Plastic deformation</li></ul><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzZkZjRhMjZjZGRkMGI1NDc3MmMwN2NiZjcyYWY0MjFfejRaU1JjdlUyV2dFd0JOOUoyT2hRSldSS0lRaTl2UjlfVG9rZW46UkNtQWJlYUpNb3NFRjN4VU5qaWNYOFV4bnVmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM1NWI0YzAwNTY2YjU3OWY1M2U1NzYyNWNkZGYzODFfbkZ2VW5oamJsNnV0Qzh6ZXlZc2hxRDJQTEFXeGJ3OHRfVG9rZW46VWFiQmJuZFhlbzVXZ3Z4RXRqamNZQ3djbkVlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VhN2VlYTRhOGNlMThlYTYxOWMxNDJmMmUyODE2NDJfZlZGRkdMZ0NHN29lVzdaVllhczF6b0w2V1V1TnNmbVJfVG9rZW46VmJXaWJRd1FSbzFHbGF4cGh6cGNGRkc2blVjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="I-IC-Pacakages"><a href="#I-IC-Pacakages" class="headerlink" title="*I IC Pacakages"></a>*I IC Pacakages</h2><p>Packaging of an IC should provide mechanical and environmental protection of the IC, remove the heat that is generated by the IC, and provide electrical connections to the rest of the components by means of a systems-level board.</p><p><strong>Ceramics</strong> such as alumina and glass ceramics offer good protection from the atmospheric moisture because of their <strong>hermiticity</strong>, have <strong>thermal conductivity</strong> that is high enough to help with heat dissipation and have <strong>CTE</strong> closely matching that of silicon, provides thermomechanical reliability.</p><p>Although ceramics are widely pursued by industry, they were almost completely eliminated by <strong>organic IC packages</strong>. Strongly driven by their <strong>low-cost and ease of processing</strong>, organic materials are widely used, in spite of their deficiencies when compared to ceramics. Polymers perform better electrically than ceramics because of their low dielectric constant. The materials, properties and processes for IC assembly are summarized in the first row in the above figure</p><h2 id="II-IC-Assembly"><a href="#II-IC-Assembly" class="headerlink" title="*II IC Assembly"></a>*II IC Assembly</h2><p>The electrical interconnections between the chip and package are provided by metal Wire bonding techniques, as indicated in the second row in the above figure. The conducting wire should have a <strong>high electrical conductivity</strong>, <strong>oxidation resistance</strong>, and <strong>good wetting</strong> to the bonding pads and <strong>mechanical properties to withstand creep and fatigue</strong>.</p><p>Al and Au are the most favoured materials for wiring because of their high electrical conductivity and corrosion resistance. Wire bonding needs any two of the three conditions that assist joining: heat, compression or ultrasonic vibration.</p><p>Wire bonding has been supplemented by TAB in instances where finer pitches are required节距较小的电气互联. TAB is a process where chips are joined to a patterned metal on polymer tape, using automated thermocompression bonding. A typical system is copper wiring on a polyimide tape. With ever-increasing input&#x2F;output connections from the chip, peripheral or side-connections are being replaced by area-array interconnection packages such as a BGA, or a flip chip assembly.</p><h3 id="III-Boards-and-Board-assembly"><a href="#III-Boards-and-Board-assembly" class="headerlink" title="*III Boards and Board assembly"></a>*III Boards and Board assembly</h3><p>System-level packaging provides wiring that forms an electrical interconnection for all components within the system. The organic substrate that provides these functions is called a PWB. MCM packages on PWB type laminates, referred to as MCM-L, limit the interconnection temperature to less than 200℃. An epoxy, reinforced with a glass cloth to provide enough stiffness, is widely used for making PWBs.</p><p>Surface mount technology (SMT) interconnections are achieved by soldering, with the most common soldering compound being an eutectic Pb-Sn alloy with a melting point of 183℃.</p><p>A huge CTE mismatch between the PWB and IC induces significant stresses that cause failure at the solder joints. This technical challenge increases with the chip size, power density and the drive to use low-cost board materials. The thermomechanical stresses that cause failure can be alleviated by using an underfill material such as epoxy, that mechanically couples the IC and substrate, hence reducing the strain on the solder.</p><h2 id="3-6-Surface-mount-technology表面贴装技术"><a href="#3-6-Surface-mount-technology表面贴装技术" class="headerlink" title="3.6 Surface mount technology表面贴装技术"></a>3.6 Surface mount technology表面贴装技术</h2><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDYzOTM4NDE4ZjU0YWFiZTJkMDU2OGJkN2VkYmYzOTFfQTYwTEk1Z01INUFranUzM1VJdE9iWGZaOTMwc0pZTWNfVG9rZW46R21mR2JRQVhVb1BNMG94Q2VmUmNQSFNzbkxjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="3-6-1-Wafer-Preparation-and-Dicing"><a href="#3-6-1-Wafer-Preparation-and-Dicing" class="headerlink" title="3.6.1 Wafer Preparation and Dicing"></a>3.6.1 Wafer Preparation and Dicing</h3><p>Wafers are mounted on a laminating tape that adheres to the back of the wafer. It holds the wafer throughout the dicing and the die attaching process.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDRkYmMzZWE3YmE5NmNlM2IyYzRkMmZiZjczZDFhMzFfTHJwM0hiWWNrNHY2WFRWdnJDNzZwZURoNGxldDhib2RfVG9rZW46TW5yN2JKNHlqb1Q4dGF4Mk9kUWNaZ0JJbnplXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The die-sawing machine using a diamond saw blade saws the wafer into the individual die&#x2F;pellet on the adhesive backing tape. Deionized water and CO2 bubbles are dispensed on the wafer to remove silicon dust&#x2F;debris besides lubricating(润滑) and cooling.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTBlN2UwZDAzMDU3YjJjOWFiZWZhY2JjOTI3YjAzYThfTGFiS1l2VnFFSTFuS1VLNTRUYUpoeHoxVXlhYnA5TGZfVG9rZW46UmdzQWJUYlVhb25KRER4Um9UeGNYVEg4bndoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="3-6-2-Die-Attach-and-Wire-Bonding"><a href="#3-6-2-Die-Attach-and-Wire-Bonding" class="headerlink" title="3.6.2 Die Attach and Wire Bonding"></a>3.6.2 Die Attach and Wire Bonding</h3><p>The die attach machine will pick up the die and deposit it on the frame. It may utilize the wafer mapping method to pick up only good die. For most processes, die attach materials like gold or lead-tin铅锡 based solder wires or silver epoxy paste 银环氧树脂膏 potting on the frame are required prior to die bonding process.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ5MDJiYTEyYmVmYmY3MGYxZTc0ODEzMTQ5N2ZiNDRfR1FyZ2N1WXNxOWN2UXBSRlI3ZTB6cE5KaVVWVk5ZS2lfVG9rZW46RkFFb2JhMWZvb3NvelV4NFFhVWNOY1lEbmJlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Either Au or Al wires are used depending on application. Bonded one at a time, the wire is fed through a ceramic capillary. With a good combination of temperature and ultrasonic energy，a good metalized wire bond is formed.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdlYTU3MmVhY2M2ODkyOWEzMDY0ZDgyMGI4N2EyZDdfSTJzZ3kwRm1HMTYwSmRvbVYyWU1wckI0eVNyb0lOQ0pfVG9rZW46SHhMUmJFU2h4b2VuM2N4elk1WWNMOExRbjhmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="3-6-3-Moulding-and-Solder-Plating"><a href="#3-6-3-Moulding-and-Solder-Plating" class="headerlink" title="3.6.3 Moulding and Solder Plating"></a>3.6.3 Moulding and Solder Plating</h3><p>The moulding process aims to encapsulate the whole wire bonded die against exposure to contamination and other physical damages.The lead frames that hold the dies a replaced in individual cavities which are filled with liquid resin.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg2YjRkNTQwZDRlODNjNGU0MTA1MzA3NDhmNDE3NjJfUlluUEt5b0NhSWxNd05hSGkyVHpxZXlSQWJ1Smk5YVhfVG9rZW46TVVUVGJIcHVSb2pUSUx4N01WTmNhUkFTbmRaXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>This step provides a layer of Tin-Lead solder on the lead frame for making easier the PCB assembly process. Lead free finishing with Tin Bismuth plating or Tin Copper dipping can also be used.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzEzOGRlOGQ5YmE4NDM0MjgwYWZmNmFlNjA4MmRmMGZfdUNvd29LYk9UblM0SHVxNWpZbVVVYjJCRVZGemVWMnRfVG9rZW46TzRnTGJ5QkxwbzVUV3p4aWNkdmNDMkdxbkplXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="3-6-4-Marking-and-Lead-Form"><a href="#3-6-4-Marking-and-Lead-Form" class="headerlink" title="3.6.4 Marking and Lead&#x2F;Form"></a>3.6.4 Marking and Lead&#x2F;Form</h3><p>Marking is the coding process that writes customer’s corporate and product identification code on a packaged device. It commonly uses a laser-based machine</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTllMjQ1NjNkNjBkM2Q5N2I5YzQzODhlNmYwNTEyMDlfRmsxVDlWczFZeVZDM0w1a1lmeTlkU0NvVWlRVXdOUDhfVG9rZW46WjJRRGJrb1Fkb1l2QUh4SkpTZWNVQ0Ezbk5nXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The final process is to trim away 修剪 the leads of the packaged device from the frame strip.The leads are cut and formed mechanically to the specified shape</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FiZjM3OGU0Nzg3MWFiOGViOTYyOTY5M2U2MzlmOWJfSkVSUUhzTzlCTWVVV0s0VGxsWkxNVUt3bWV6SmV3U2RfVG9rZW46QWp2bGI2Q1Rvb2J0aEN4ZEo0MWNmdGcxbkZmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="3-7-Chip-Package-Connection"><a href="#3-7-Chip-Package-Connection" class="headerlink" title="3.7 Chip-Package Connection"></a>3.7 Chip-Package Connection</h2><h3 id="3-7-1-Wire-Bonding"><a href="#3-7-1-Wire-Bonding" class="headerlink" title="3.7.1 Wire Bonding"></a>3.7.1 Wire Bonding</h3><ul><li>Connections are made from the chip to the pad frame via thin wires</li></ul><p>–Typically 100*100 um metal pads on 200 um pitch</p><p>–Mechanical bonding of one pin at a time(sequential)</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NmY3YTM4MWNkMmJhMDVhY2Q2M2Q3Y2M5NjI4NjQyMWVfdGdydWpUOUFTSjBWVm5CcUp1ak9vbkZQbnpzdXlUTmpfVG9rZW46TW5BeWI5cnY4bzc5Rzl4dlRVNmNMMnV0bk1oXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ul><li>The wires are made of low R alloys &#x2F; doped metals</li></ul><p>–Gold and Al</p><p>–Also copper and silver</p><p>–Typically 25um diameter for logic devices</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2E0MTRlMjY3Y2VkOTcxNWQ5Yjg5MWNmMjU1MTc5ZGVfVzBPUTZ5MW5CdkFTT3phdzdRUWRtN1NxY0RZWFZrbmdfVG9rZW46U3Z1OGJkR0dWb21oTzh4aXJ1MWNqMnB2bldHXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="3-7-2-TAB"><a href="#3-7-2-TAB" class="headerlink" title="3.7.2 TAB"></a>3.7.2 TAB</h3><ul><li>Tape automated bonding</li></ul><p>–The interconnections are patterned on a multilayer polymer tape.</p><p>–The tape is positioned above the ‘bare die’ so that the metal tracks (on the polymer tape) correspond to the bonding sites on the die</p><p>–After the chip leads are cut and soldered to the board, the chip is covered with a glob of epoxy or plastic</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjYxN2I1Y2I1NDEzOTYwZWMxNzFiNjMyODgxOTdiYzdfVXcxRzZJM1I2aUdISmpxaFEzS3QzTDlrUHhRejFXcTRfVG9rZW46RzNLbmJhYjZnbzZxc2t4ejZld2NDVEVxbllnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDMwMzJjNDM4MDIxMGRjYzQwYTBlYWRlY2YzOTM1NDBfbW50d1dBcmFvYkMwNWM0SnhSSFZTMUh4TktHaGFWbUhfVG9rZW46SnZGeWJETXV0bzZFdWJ4UVpOU2NEaTVwbkxmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>A bare chip that is mounted directly onto the PCB. After the wires are attached, a glob of epoxy or plastic is used to cover the chip and its connections. The TAB process is used to place the chip on the board.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzRhZDc0OTBjZmJlYzIwZmViYWQzNTdiMzYxY2ZmNjJfWG45QjEzRHJkeVJwTDdWUVltNHkyTjFKQjhtQmRTbkZfVG9rZW46TllRT2JJNUxGb2hpRWt4d1kxR2NKTDRKbmJlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>This side view shows how the wires connect the chip to the PCB</p><ul><li>Pros over wire bonding</li></ul><p>–Smaller and closer pads.</p><p>–higher density, up to 850 pins</p><p>–Better electrical characteristics</p><p>–Faster procedure but more expensive machinery</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2MwYzkxMWU4NzBmM2Y0NmY0ODQ0ZDM1OTJkNDc4M2NfREtIN3FnYmtWZThrNTVSSXA2NUdQcUx6VTNiM1JMaEhfVG9rZW46VDgzc2Jadklrb1EwVjl4d1JDR2NPYXpQblBmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="3-7-3-Flip-Chip"><a href="#3-7-3-Flip-Chip" class="headerlink" title="3.7.3 Flip-Chip"></a>3.7.3 Flip-Chip</h3><p>The chip is “soldered” to the package substrate using the solder balls “bumps” that have been grown over the die pads</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTdmZTc0NzQzNTZkNzYwZmM0ZTVkODdlZjM0YzllYjVfSmRJN2JDekZ3TUJHYklVTTZvV0N1ZjdRdnB2YnVKTWJfVG9rZW46SlFBWGJjVklzb1hFZWZ4ZEdreGN1blRybnRlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>Pros:</strong></p><ul><li><p>Lower cost than wire bonding since the bumping was done at wafer level and since all connections are made simultaneously</p></li><li><p>Higher reliability than wirebonding and beam lead bonding</p></li><li><p>Better electrical performance than wirebonding due to its lower R, C, L</p></li><li><p>Reparability: If an IC was defective, either during assembly or during usage, it can be removed and a new IC is flip chip bonded on the same ceramic substrate.</p></li><li><p>Improved chip designs may be substituted on multichip modules.</p></li></ul><p><strong>Cons:</strong></p><p>Flip Chip Defects and Failure Modes: Bulk Underfill Cracking, Solder Fatigue Cracking, Fillet Cracking, Center Die Cracks, Edge Cracking, Die Cracking, Delamination&#x2F;Void Growth, solder migration.</p><p>倒装芯片缺陷和失效模式:大块下填充裂纹、焊料疲劳裂纹、圆角裂纹、模具中心裂纹、边缘裂纹、模具裂纹、分层&#x2F;空洞生长、焊料迁移。</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE4OWU4N2IyNDU1OWMwZjY4ZWMzN2E0MDU0ODAxOGZfRDRtQ1RHeGtMS3BFRWFWU2dnZk9vNFlsQXlBMmdNWnZfVG9rZW46Q3ZsUWJ1QWd4b0R5ZEl4ZFVCdGNLMHRDbktiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE4OWU4N2IyNDU1OWMwZjY4ZWMzN2E0MDU0ODAxOGZfRDRtQ1RHeGtMS3BFRWFWU2dnZk9vNFlsQXlBMmdNWnZfVG9rZW46Q3ZsUWJ1QWd4b0R5ZEl4ZFVCdGNLMHRDbktiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="3-8-Packaging-Materials-and-Properties"><a href="#3-8-Packaging-Materials-and-Properties" class="headerlink" title="3.8 Packaging Materials and Properties"></a>3.8 Packaging Materials and Properties</h2><h3 id="3-8-1-Electrical-Properties-Conductivity"><a href="#3-8-1-Electrical-Properties-Conductivity" class="headerlink" title="3.8.1 Electrical Properties: Conductivity"></a>3.8.1 Electrical Properties: Conductivity</h3><p>When an electric field is applied onto a conductor, the electrons drift towards the positive potential, resulting in a current. Electrical conductivity is the ratio of current density and the applied electric field</p><p>J&#x3D;σE</p><p>where J is the current density [A&#x2F;m2], σ is the electrical conductivity [Ohm-1m-1] and E is the electric field [V&#x2F;m]. σ is a measure of the number of available electrons for conduction and their mobility. The inverse of electrical conductivity is resistivity. Electrical conductivity depends on the material and temperature.</p><h3 id="3-8-2-Thermal-Properties-Thermal-Conductivity"><a href="#3-8-2-Thermal-Properties-Thermal-Conductivity" class="headerlink" title="3.8.2 Thermal Properties: Thermal Conductivity:"></a>3.8.2 Thermal Properties: Thermal Conductivity:</h3><p>The amount of heat transferred through a material per unit of time, denoted as heat flux Q, is proportional to the temperature gradient (dT&#x2F;dx). The ratio of heat flux and temperature gradient is termed thermal conductivity:</p><p>Q_x&#x2F;A&#x3D;−K_xdt&#x2F;dx</p><p>A is the area of conduction medium and x is the direction of heat flow. It is expressed as W&#x2F;mK.</p><p>Heat flows from a high temperature to low temperature region, and therefore, a minus sign in the above equation makes the conductivity a positive number. Thermal conductivity is a very important property for dissipation of heat from an IC. The heat evolution from an IC may range from 1 watt for portable products to as much as 150 watts per chip for high-performance computer applications. The thermal conductivity is a measure of the ease with which heat can flow through a material. High thermal conductivity materials allow for easy heat dissipation from the chip, and hence, control the chip temperature.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNkZDEyNDljNjcxYjdjMzYwYjNiMzMwNzI1NDg0YThfbXNsNXFmc2tLOEdZYVBhS0JLWUxPTHFFcWNoZVVodmtfVG9rZW46WjB0SGI5UTZ4bzZzTzV4cDFZN2NBVWpEblZjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="*Definitions"></a>*Definitions</h2><ul><li><p>Resin: a generic term used to designate the polymer, polymer precursor material, and&#x2F;or mixture or formulation thereof with various additives or chemically reactive components. 树脂:用于指聚合物、聚合物前体材料和&#x2F;或其与各种添加剂或化学反应组分的混合物或配方的通称。</p></li><li><p>Molding: the process of duplicating topographic information in a functional material by solidifying its liquid precursor molecules on a master.通过将液态前体分子固化在母材上来复制功能材料的地形信息的过程</p></li></ul><p>Molding is a forming process using molds. Materials such as synthetic resins (plastics) are heated and melted, and then sent to the mold where they are cooled to form the designed shape. Due to the resemblance to the process of injecting fluids using a syringe, this process is called injection molding.成型是利用模具进行成型的过程。合成树脂(塑料)等材料被加热和熔化，然后送到模具中冷却，形成设计的形状。由于类似于用注射器注射液体的过程，这个过程被称为注射成型。</p><ol><li><h1 id="The-Role-of-Packaging-in-Microelectronics-CH2"><a href="#The-Role-of-Packaging-in-Microelectronics-CH2" class="headerlink" title="The Role of Packaging in Microelectronics (CH2)"></a>The Role of Packaging in Microelectronics (CH2)</h1></li></ol><h2 id="4-1-Definition-of-Microelectronics-and-the-characteristics-of-Semiconductor"><a href="#4-1-Definition-of-Microelectronics-and-the-characteristics-of-Semiconductor" class="headerlink" title="4.1 Definition of Microelectronics, and the characteristics of Semiconductor"></a>4.1 Definition of Microelectronics, and the characteristics of Semiconductor</h2><h3 id="4-1-1-Introduction"><a href="#4-1-1-Introduction" class="headerlink" title="4.1.1 Introduction"></a>4.1.1 Introduction</h3><p>ICs, based on microelectronic devices, form the basis of all modern electronic products. Continuous advances in reducing the size of the transistors allowed the progressive integration of tens, hundreds, then thousands of transistors on a single IC in technologies called small, medium, and large scale integration (SSI, MSI, and LSI). This led to the integration of up to a million transistors on an IC, called very large or ultra scale integration (VLSI or ULSI).</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZjYjc4MzlkN2ExMTg1OTAxNDViNjIyZTMwZmM3ZTRfSnlROWRFWDkyUWl3U1VMSkl4ZUNlT25VUjQ3WkNGekRfVG9rZW46QjhrcWJUSWZjb2VzTTd4YTNvaWNnbTV0bk5kXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM5ZTk5OTk0N2QzZmYzZDg0NWY3NDQyZDIyMjQzZGZfaGF5WDNodDczZlRZS3BYTHF5Wkl1bVRhUElOcmVFZzlfVG9rZW46SE1KbGJqMkJZb0cyNVd4QnNac2NpZ3V6blZnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM5ZTk5OTk0N2QzZmYzZDg0NWY3NDQyZDIyMjQzZGZfaGF5WDNodDczZlRZS3BYTHF5Wkl1bVRhUElOcmVFZzlfVG9rZW46SE1KbGJqMkJZb0cyNVd4QnNac2NpZ3V6blZnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="4-1-2-the-characteristics-of-Semiconductor"><a href="#4-1-2-the-characteristics-of-Semiconductor" class="headerlink" title="4.1.2 the characteristics of Semiconductor"></a>4.1.2 the characteristics of Semiconductor</h3><p>Semiconductors have four valence electrons, which require a moderate amount of external energy in order to be removed.</p><p>The valence shell of an atom represents a band of energy levels and the valence electrons are confined to that band. When an electron acquires enough additional energy from an external source, it can leave the valence shell and become a free electron and exist is what is known as the conduction band.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM5NmVkMjY3OWJjOGYyMjhlNWI4YTQwMDc1OWRhOGJfMlFibmlxVkZQNlZ1OVkzOTJneHFkcnVvNHZOV001WGJfVG9rZW46Q1hCbGJWNVVHb2dYOG94bElmRGNnVWtrbmZYXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIyMTgwMmVmMTY0YmUzN2ZiNDE3ODIwZWEyMGE2MDBfUktlNW1NdEFsRU55RzMzYXY3SG5vNWxibTZ0TDhOY09fVG9rZW46QjZpUmI2bnV2b0VpckN4TXVDZGNRTGU2bmhjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQxZDI3ZGMxZjAzMGU1ZWFhMDQ3NDZmZTMyNzg5ZWFfRUtLamdMUkRuSmdoaFpIMUlOQjQ5UjRENk4zRkFtUndfVG9rZW46VmpkTGJkeVBWb0FLMHV4MXRJUmNKa0M4bndUXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQxZDI3ZGMxZjAzMGU1ZWFhMDQ3NDZmZTMyNzg5ZWFfRUtLamdMUkRuSmdoaFpIMUlOQjQ5UjRENk4zRkFtUndfVG9rZW46VmpkTGJkeVBWb0FLMHV4MXRJUmNKa0M4bndUXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="4-1-3-Semiconductor-Devices"><a href="#4-1-3-Semiconductor-Devices" class="headerlink" title="4.1.3 Semiconductor Devices"></a>4.1.3 Semiconductor Devices</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E5ZDQyZGM3OWEzNDQwMWQ5MzUwZDBjZWYxYTdkOTlfcUQwRWZ4VTlLYkw5Wlh6WXRBZ1p2RGdCQnU2YUl1UU1fVG9rZW46TTF3WmJrd0Qwb0ZrcVZ4VGQ4V2NLa2RObm1kXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYwNTE1ZTQ0NmU2ZDI4MDY2ZWE5MzE2NzM0ZDhiNjJfR1dHWUVtSFFYVjV6dXROZ3hzWDVvSXBwcTJuZXhtWWtfVG9rZW46TEU0OGJRZ3NMb0V0cGl4eVhSVmNvVVFvbmxiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>MOSFET</p><p>CMOS</p><h3 id="4-1-4-IC-and-SOC"><a href="#4-1-4-IC-and-SOC" class="headerlink" title="4.1.4 IC and SOC"></a>4.1.4 IC and SOC</h3><ol><li><p><strong>IC Definition</strong>: The semiconductor materials constitute the devices, and the devices are interconnected to form functional circuits. An integration of many such circuits or components on a single chip is called an integrated circuit (IC).</p></li><li><p><strong>SoC Definition</strong>: a concept where electrical, optical, mechanical, chemical, and biological devices will be integrated together on a single chip.</p></li></ol><p>Figure 4.10 shows a personal handy phone system design by the SOC concept, where various components shown in the figure are integrated on a single chip.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTVmNDhkN2E5MGQ1MjM0Njc1YjBlNDA5ZTA4Njg5YWZfTTJ5MEZpRFhER2xCMlRJcUlkeGRKcklObTFPdVdYZG5fVG9rZW46VVV2Q2JIbjRLb1oyQ2V4V3NNd2NNMU9QbjllXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="4-1-5-Types-of-IC"><a href="#4-1-5-Types-of-IC" class="headerlink" title="4.1.5 Types of IC"></a>4.1.5 Types of IC</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDcxNDAxYTQ0MGMzNDhjOTBjN2I1YWE0MjlkY2EyNDZfWmtTd2EwN0w2amluT0oxaWhHTDFQbkFvbk1tOFpUYWdfVG9rZW46T0F2RmJnbWRlb0xkaGZ4THdyUGNjODg5bkdiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>ICs are roughly divided into two categories: (1) hybrid and (2) semiconductor</p><p>(1)A hybrid IC (HIC) contains interconnected diodes, capacitors and resistors fabricated on a single plastic, ceramic or insulated aluminium substrate and has the capability of performing a complete electronic circuit function. It is called hybrid since it involves two or more material types.</p><p>(2)Semiconductor ICs only contain devices fabricated from semiconductor materials.</p><h2 id="4-2-IC-Packaging-and-challenges"><a href="#4-2-IC-Packaging-and-challenges" class="headerlink" title="4.2 IC Packaging and challenges"></a>4.2 IC Packaging and challenges</h2><h3 id="4-2-1-Intro"><a href="#4-2-1-Intro" class="headerlink" title="4.2.1 Intro"></a>4.2.1 Intro</h3><p>The electronic packages are to protect, power, and cool the microelectronic chips and provide electrical and mechanical connection between the microelectronic part and the outside world. Whether a single transistor or a GSI chip, they have to be packaged.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNjMzZlYzMxZDhiMDA0YzI4NTRmZTFhZWNjZjAyOTBfNFp4Wjh1b085V2RBMzRaY3d5WjljYk9SMVd6OERyMXdfVG9rZW46VnFqV2JZeUpHb1NYWVJ4QUdHamN4STN5bmhoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>芯片到系统工艺步骤</p><h3 id="4-2-2-Different-Types-of-IC-Packaging"><a href="#4-2-2-Different-Types-of-IC-Packaging" class="headerlink" title="4.2.2 Different Types of IC Packaging"></a>4.2.2 Different Types of IC Packaging</h3><p>Many types of IC package technologies have been developed that vary in their structures, materials, fabrication methodology, bonding technologies, size, thickness, number of I &#x2F;O connections, heat removal capability, electrical performance, reliability, and cost.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNhOGUwOTg5YmRmNzY3MDZjMjczYjU2MzE0M2Q0MDJfS2pSV0ZXOW5XeWJWanF3NnNYd1U0azJJOTBjWWN3TGJfVG9rZW46RXN2d2JmT0lKb3JXQm54RWlCMGNaMHFqblRqXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>In general, IC packages can be classified into two categories: 1) <strong>through-hole</strong>, and 2) <strong>surface mount</strong>.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM4Nzk3ZWY5ODQyNzJjYTI3YWY0YTVkY2JlZDk4MTRfMU1Ob3Q2ZWdrMDBqRmp4YW1rR3M4NDVjMmNWWFB3d1FfVG9rZW46RGJxU2IxMVpnb0EyMlF4Z3ZYaWMzeVRObjBiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NThkZGQ3YTAwYzUyMDYzMGU0ZDVjOGY1NTZkMWViZDVfNWkwbFB5QXVkSW9SUzBBSkJWV2l4TEt6Nk13eDRtbXpfVG9rZW46RVozdGJpTE9Db09RTXF4V2k1TGNET01Fbk1jXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="4-2-3-IC-Packaging-Challenges"><a href="#4-2-3-IC-Packaging-Challenges" class="headerlink" title="4.2.3 IC Packaging Challenges"></a>4.2.3 IC Packaging Challenges</h3><ol><li>Reason:</li></ol><p>(a)the on-chip silicon system can out-perform the speed capability of the package.</p><p>(b)as volume production techniques continue to drive the cost of bare silicon chips down, the cost of the packaging constitutes a greater and greater proportion of the total system cost. 封装成本所占比例增大</p><p>For both of these reasons, the challenges for future electronic packages are becoming extremely complex and the demand for microelectronics packaging engineers is growing.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM0NGY0ZGIxYzE5ZjUxNjBkZjg3MzYzNWI1MTU2N2FfT3JjS1NwcXk0M2I1TUlLQjlGc3UwVDQxRkFWTERURHFfVG9rZW46RkZUMmJRNjdOb1lnWGt4b0ltSmNDSmx5bmdiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>These challenges of high performance and low-cost packages must be resolved by microelectronics packaging engineers and systems integration engineers. In order to find effective solutions to these problems, the engineers must acquire a solid educational background in multidisciplinary areas. These areas include electrical, mechanical, and thermal design, fabrication of systems based on materials (metals, ceramics, polymers), material interface challenges, testing, assembly, and package reliability.</p><h2 id="4-3-Semiconductor-Roadmap"><a href="#4-3-Semiconductor-Roadmap" class="headerlink" title="4.3 Semiconductor Roadmap"></a>4.3 Semiconductor Roadmap</h2><h3 id="4-3-1-The-international-Technology-Roadmap-for-Semiconductors-ITRS"><a href="#4-3-1-The-international-Technology-Roadmap-for-Semiconductors-ITRS" class="headerlink" title="4.3.1 The international Technology Roadmap for Semiconductors (ITRS)"></a>4.3.1 The international Technology Roadmap for Semiconductors (ITRS)</h3><p>Updated every two years by a group of semiconductor companies known as the Semiconductor Industry Association (SIA)</p><p>Projects the technology requirements for six different product categories up to 10–15 years ahead</p><p>These product categories are low-cost, hand-held, cost&#x2F;performance, high performance, memory, and harsh environment.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjFiNDhiYWNkYzAyMGUwZWM0ZTI3YTU2MzkxODVmZWZfUjNPSk94VXRLSW5XaUxrZXNJcjM1dDQzS0kyM1hVa2FfVG9rZW46QklEOWIydnZ3b01ZUzh4Y2hnUmNwN1I4bjdnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE1NDliZDdkZjdkNjNlNmVkNzRlODM2ODNmMGVhMzZfdlY2aXFWR1o1UmM5cW5BR2V3YnBTVkZQMTNkUXVWYVhfVG9rZW46VjBXMWJHUUVQb05xc2h4ckR6TWN0SlRJbjFnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="4-3-2-Most-Important-IC-Packaging-Parameters"><a href="#4-3-2-Most-Important-IC-Packaging-Parameters" class="headerlink" title="4.3.2 Most Important IC Packaging Parameters"></a>4.3.2 Most Important IC Packaging Parameters</h3><p>(1) I&#x2F;O引脚数目</p><p>原因：controls the pitch of the IC package as well as the wiring needs at the system level.</p><p>(2) size of the IC</p><p>原因：controls the reliability of the IC to package connection.</p><p>(3) power</p><p>原因：controls heat dissipation properties of IC and system-level packaging.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTY1OWUyYjc0MDA0NGJmNzQzYmU2YTM3NWZjMWE1ZDZfY21taHVNcmpJUHBJR1p4T0dGWEZmUXI4YnlPQTl6MjdfVG9rZW46U0ttbmJ2aVR5b3hUNmt4dDBWNWN6ZkxxblZZXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM4MGY4OTNjNDYwZDhhOGQxMDg1ZmMyOWQ5ODEzYmRfUVZ5U0J2eU9lTjRIcThMR0U2VzdRUHI4cVV4bmVVNGJfVG9rZW46TU55dWI5SnNTbzl3aDh4emdycWNGV25zbnloXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>*Why Silicon?</p><p>Silicon is the most widely used semiconductor material in microelectronics because of its material properties, and also because it can easily be extracted from naturally abundant silica (SiO2). The Si atom consists of a nucleus with 14 electrons revolving around it in a system, which may be compared to the sun and its planets moving in their orbits. Electrons have negative charge, and the Si nucleus has a positive charge, which offsets the charge on these 14 electrons, so the Si atom is electrically neutral. The electrons move in orbits around the nucleus. An atom which has eight electrons in its outermost orbit, or the outermost shell, is relatively stable, which it acquires by sharing one from each of four adjacent atoms in covalent bonds. Silicon has four electrons in its outermost shell, and it requires four additional electrons to become stable. Silicon can be easily doped to increase its electrical conductivity to create N-type or P-type material, which is then used to make various microelectronic devices.</p><ol><li><h1 id="The-Role-of-Packaging-in-Microelectronics-CH3"><a href="#The-Role-of-Packaging-in-Microelectronics-CH3" class="headerlink" title="The Role of Packaging in Microelectronics (CH3)"></a>The Role of Packaging in Microelectronics (CH3)</h1></li></ol><h2 id="5-1-Anatomy-of-a-Microsystem"><a href="#5-1-Anatomy-of-a-Microsystem" class="headerlink" title="5.1 Anatomy of a Microsystem"></a>5.1 Anatomy of a Microsystem</h2><p>Most of the microsystems can be classified into six categories: automotive, computer and business equipment, communications, consumer, industrial and medical, military and aerospace. The total market is illustrated in figure 5.1</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTZiMmQ4ZGNjZDJlNGUxZmU0MjExMGNhYjgxMTU0MzJfMHo4WnBhNFdJdmhJRXR1NkxjQlZsVnVmenJlYUFnbHdfVG9rZW46TXpUbWI5M3Fwb0hrQ054WUpHY2NiUWtIbnlmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTAwZGE2M2UwMGQwMzY5YTQyNzk1ZWYyZTgwZmZlZTlfdDhQTUdSd2FwZEd3ZDhXUVI4R1lzOWVHZlRrSzU4SGtfVG9rZW46TlA0VWJ0b2RGb1JxdGx4Zkc1VmNCNnJVbkdoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The pyramidal hierarchy spans from minerals to materials, processing these materials into ICs, devices and components, and electrically and mechanically designing, testing and assembling these components onto system-level boards as illustrated in Figure 5.2.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhkYzU3MDljZmRkZjVhNjg2ZTdhOWYwMDFlYzJkMzRfWHFHSU51bnlLUUpod0hoQUQzY0VhUzJFS0gzSHVlMXhfVG9rZW46WVJlNGJXN1dWb3ZOdDR4N2JTWWM1U09wbks3XzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhkYzU3MDljZmRkZjVhNjg2ZTdhOWYwMDFlYzJkMzRfWHFHSU51bnlLUUpod0hoQUQzY0VhUzJFS0gzSHVlMXhfVG9rZW46WVJlNGJXN1dWb3ZOdDR4N2JTWWM1U09wbks3XzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NThiNjYxMzQyZTI1YWIwMDAwYTMyNDkwNmNmMDA3YjhfMXRPRElhWU5JQTFTQU9JVHlUanAzcTJ2NFdzMnN2UldfVG9rZW46SmU2bGJUZmpsb2FmNmR4ZDR0TWNJU05ibktlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>Electronic components</strong> can be roughly characterized into active and passive components.</p><ol><li><p>Active components consume power in delivering functionality within a system</p></li><li><p>Passives provide connection, mechanical support, filtering, noise reduction, and other functions.</p></li></ol><h2 id="5-2-Role-of-Packaging-in-the-Computer-Industry"><a href="#5-2-Role-of-Packaging-in-the-Computer-Industry" class="headerlink" title="5.2 Role of Packaging in the Computer Industry"></a>5.2 Role of Packaging in the Computer Industry</h2><p>Microelectronics and computers are virtually synonymous. By the time electronic devices migrated from vacuum tubes to discrete transistors and finally to integrated circuits, the digital computer became the driving force for almost all new semiconductor-related technologies.</p><p>Microelectronics being challenged by network and portable communications products, where the need for low power, high performance and integration of passive components are becoming important.</p><p>Some important parameters are described below:</p><ul><li><p>Bandwidth Is the Most Important Parameter in Computing</p></li><li><p>How Do Computers Work?</p></li><li><p>Computer System Performance</p></li><li><p>How Does Packaging Affect System Performance?</p></li><li><p>How Does Microsystem Packaging Affect the Bus Design?</p></li></ul><h3 id="5-2-1-Bandwidth-–determines-the-computer’s-performance"><a href="#5-2-1-Bandwidth-–determines-the-computer’s-performance" class="headerlink" title="5.2.1 Bandwidth –determines the computer’s performance"></a>5.2.1 Bandwidth –determines the computer’s performance</h3><p><strong>Definition:</strong> the number of parallel datum bits (the width) delivered to destination multiplied by delivery frequency in digital systems. The units of bandwidth are bits per second (b&#x2F;s).</p><p>e.g., a 64 bit bus that uses a 100 MHz clock frequency but uses the up and down clock transitions to introduce data onto the bus is said to transmit 12.8 Gb&#x2F; s. In terms of bytes (eight bits to a byte) transmitted, it is a 1.6 GB&#x2F; s bus.</p><h3 id="5-2-2-How-Do-Computer-Work"><a href="#5-2-2-How-Do-Computer-Work" class="headerlink" title="5.2.2 How Do Computer Work?"></a>5.2.2 How Do Computer Work?</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk4ODliNDU5ZjE5MDNkODM1ZGEyNThiYjc0ZDU1NjFfRTJaZzRURWNsQ2UwbGs0SFNRSEVGRFNUbldhM3F3cGdfVG9rZW46SVQ2WGJJcWY2b3Y0aUh4aE1vMWM0dURBbkhoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>In the diagram, the data to be processed enters the computer through the input&#x2F;output (I&#x2F;O) subsystem. Data is moved through the memory cache hierarchy (L2 and L1) and delivered to the μP for processing.</p><p>The bandwidths of the various interconnection buses used determine the total amount of data that is moved between the levels of memory and the μP is. Bandwidth is important to packaging engineers because it is their contribution to the overall system performance.</p><h3 id="5-2-3-Computer-System-Performance"><a href="#5-2-3-Computer-System-Performance" class="headerlink" title="5.2.3 Computer System Performance"></a>5.2.3 Computer System Performance</h3><p>Computer system performance is a function of many different variables. A very simple expression for performance is:</p><p>Perf (performance)  &#x3D; (μP Speed) (MIPS&#x2F;MHz) (μP Utilization)</p><p>Performance (Perf) is commonly stated in terms of MIPS or millions of instructions per second. As expected, MIPS are directly proportional to the μP speed (in MHz).</p><h3 id="5-2-4-How-Does-Packaging-Affect-System-Performance"><a href="#5-2-4-How-Does-Packaging-Affect-System-Performance" class="headerlink" title="5.2.4 How Does Packaging Affect System Performance?"></a>5.2.4 How Does Packaging Affect System Performance?</h3><p>Microsystems packaging is the enabler for good bus performance. A good bus has to be very fast and very wide. It is important for the connection between the μP and the L2 to run at the μP ’s speed and deliver at least one cache word (8B for an Intel@Pentium) per cycle with no more delay than one cycle time. This will minimize the μP wait states caused by an L1 cache miss, need for a fast bus</p><h3 id="5-2-5-How-Does-Microsystems-Packaging-Affect-Bus-Design"><a href="#5-2-5-How-Does-Microsystems-Packaging-Affect-Bus-Design" class="headerlink" title="5.2.5 How Does Microsystems Packaging Affect Bus Design?"></a>5.2.5 How Does Microsystems Packaging Affect Bus Design?</h3><p>Package speed is important for high-performance bus design. Package attributes that support high speed are:</p><ul><li><p>High via and wiring densities for shorter line lengths</p></li><li><p>Low dielectric constant materials for high propagation speed and low capacitance. </p></li><li><p>A large count of vias in conjunction with thin dielectric layers and many power planes to support low noise and good power distribution</p></li></ul><h2 id="5-3-Role-of-Packaging-in-Telecommunication-Industry"><a href="#5-3-Role-of-Packaging-in-Telecommunication-Industry" class="headerlink" title="5.3 Role of Packaging in Telecommunication Industry"></a>5.3 Role of Packaging in Telecommunication Industry</h2><h3 id="5-3-1-The-Communication-Industry"><a href="#5-3-1-The-Communication-Industry" class="headerlink" title="5.3.1 The Communication Industry"></a>5.3.1 The Communication Industry</h3><p>Communications is the act of exchanging information. This exchange is done by dozens of different products that make up the second largest electronic and most technologically exciting industry.</p><h3 id="5-3-2-Multimedia-Arrives-at-Forefront"><a href="#5-3-2-Multimedia-Arrives-at-Forefront" class="headerlink" title="5.3.2 Multimedia Arrives at Forefront"></a>5.3.2 Multimedia Arrives at Forefront</h3><p>It refers to the combination of multiple types of content into the same message and into the same transmission medium, each type of content has different requirements for performance and service reliability.</p><p>e.g., voice content is delay-sensitive, but data content, which is not delay sensitive, but a single missing or wrong bit will render the entire message useless.</p><h3 id="5-3-3-Bandwidth-Is-the-Main-Problem-in-Communications"><a href="#5-3-3-Bandwidth-Is-the-Main-Problem-in-Communications" class="headerlink" title="5.3.3 Bandwidth Is the Main Problem in Communications:"></a>5.3.3 Bandwidth Is the Main Problem in Communications:</h3><p>The problem with mobile phones and other means of wireless communications is the very limited bandwidth. This is where photonics comes into play. It is best if that phone function is packaged as a fully integrated microsystem, either with emerging system-on-package (SOP), system-on-chip (SOC) technology or both.</p><h3 id="5-3-4-Battery-and-Weight"><a href="#5-3-4-Battery-and-Weight" class="headerlink" title="5.3.4 Battery and Weight:"></a>5.3.4 Battery and Weight:</h3><p><strong>Battery</strong>: Requirement is the life of the battery. It is necessary to design the circuits so that the life of the battery is maximized.</p><p><strong>Weight</strong>: One of the main system requirements is low weight of the unit, number of ICs and system level board.</p><h2 id="5-4-Role-of-Packaging-in-Automotive-Systems"><a href="#5-4-Role-of-Packaging-in-Automotive-Systems" class="headerlink" title="5.4 Role of Packaging in Automotive Systems"></a>5.4 Role of Packaging in Automotive Systems</h2><h3 id="5-4-1-Market-Size"><a href="#5-4-1-Market-Size" class="headerlink" title="5.4.1 Market Size"></a>5.4.1 Market Size</h3><p>approximately the same size as the electronics industry.</p><h3 id="5-4-2-Electronics-Content"><a href="#5-4-2-Electronics-Content" class="headerlink" title="5.4.2 Electronics Content"></a>5.4.2 Electronics Content</h3><p>In general, an automotive subsystem with an electronic content, such as an airbag deployment system, Sensors are included, but vehicle lighting is not.</p><p>Cost, size and weight reductions are also major factors that influence packaging of automotive electronics products.</p><h3 id="5-4-3-Characteristics-of-Automotive-is-Harsh-Environment"><a href="#5-4-3-Characteristics-of-Automotive-is-Harsh-Environment" class="headerlink" title="5.4.3 Characteristics of Automotive is Harsh Environment"></a>5.4.3 Characteristics of Automotive is Harsh Environment</h3><p>Automotive electronics presents some of the biggest challenges in system packaging. For example, under the hood the temperature in a car can be as low as 40℃, and 204℃ somewhere in the world.</p><p>At present, automotive electronic modules are designed for an operating temperature of 125℃. Technology advances in thermal management will help these challenges.</p><h3 id="5-4-4-Electronic-Packaging-Technologies"><a href="#5-4-4-Electronic-Packaging-Technologies" class="headerlink" title="5.4.4 Electronic Packaging Technologies"></a>5.4.4 Electronic Packaging Technologies</h3><p>IC and System Substrates Technologies (Substrates can be classified as Organic, Ceramic, and plastic)</p><h2 id="5-4-Role-of-Packaging-in-Medical-Electronics"><a href="#5-4-Role-of-Packaging-in-Medical-Electronics" class="headerlink" title="5.4 Role of Packaging in Medical Electronics"></a>5.4 Role of Packaging in Medical Electronics</h2><h3 id="5-4-1-Implantable-Electromedical-Devices"><a href="#5-4-1-Implantable-Electromedical-Devices" class="headerlink" title="5.4.1 Implantable Electromedical Devices"></a>5.4.1 Implantable Electromedical Devices</h3><p>There are several electronic devices used in the human body to regulate, monitor or enhance bodily functions, and thus enhance the quality of life of all ages. The devices are hearing aids and heart pacemakers (Implanted Pulse Generator) etc.</p><h3 id="5-4-2-Medical-Systems-Packaging-Has-to-Be-Ultra-reliable"><a href="#5-4-2-Medical-Systems-Packaging-Has-to-Be-Ultra-reliable" class="headerlink" title="5.4.2 Medical Systems Packaging Has to Be Ultra-reliable"></a>5.4.2 Medical Systems Packaging Has to Be Ultra-reliable</h3><p>The requirements of these medical devices are focused on reliability, size, functionality and longevity.</p><h3 id="5-4-3-Medical-Systems-Packaging-Has-to-Be-Ultra-compact"><a href="#5-4-3-Medical-Systems-Packaging-Has-to-Be-Ultra-compact" class="headerlink" title="5.4.3 Medical Systems Packaging Has to Be Ultra-compact:"></a>5.4.3 Medical Systems Packaging Has to Be Ultra-compact:</h3><p>The classic problem faced by the packaging engineer is finding a way to incorporate increasing functionality and performance into a smaller and less intrusive volume for the patients.</p><h3 id="5-4-4-Microsystems-Play-a-Dominant-Role-in-Medical-Electronics"><a href="#5-4-4-Microsystems-Play-a-Dominant-Role-in-Medical-Electronics" class="headerlink" title="5.4.4 Microsystems Play a Dominant Role in Medical Electronics"></a>5.4.4 Microsystems Play a Dominant Role in Medical Electronics</h3><p>e.g.,The functions of a representative cardiac device include:</p><ul><li><p>Sensing the heart’s electrical activity</p></li><li><p>Sensing the motions and activity level of the patient</p></li><li><p>Sensing the blood flow to and from the heart</p></li><li><p>Determining the required pacing algorithm from the sensed data.</p></li><li><p>……</p></li></ul><p>These functions require very low-voltage microprocessors, mixed-signal ASICs, analog, digital-to-analog and analog-to-digital converters, high-bandwidth telemetry, high-power diodes, protection circuits, long-lived batteries and high-voltage capacitors, all interconnected together in a hermetically-sealed titanium case.</p><h2 id="5-6-Role-of-Packaging-in-Micro-Electro-Mechanical-Systems-MEMS-Products"><a href="#5-6-Role-of-Packaging-in-Micro-Electro-Mechanical-Systems-MEMS-Products" class="headerlink" title="5.6 Role of Packaging in Micro-Electro-Mechanical Systems (MEMS) Products"></a>5.6 Role of Packaging in Micro-Electro-Mechanical Systems (MEMS) Products</h2><h3 id="5-6-1-Benefits-of-MEMS"><a href="#5-6-1-Benefits-of-MEMS" class="headerlink" title="5.6.1 Benefits of MEMS"></a>5.6.1 Benefits of MEMS</h3><p>The influence of MEMS is made possible through their benefits in cost, functionality, size, and reliability.</p><h3 id="5-6-2-MEMS-in-Microsystems"><a href="#5-6-2-MEMS-in-Microsystems" class="headerlink" title="5.6.2 MEMS in Microsystems"></a>5.6.2 MEMS in Microsystems</h3><p>Dozens of applications exist for MEMS.</p><p>e.g.The ink jet uses a MEMS chip that rapidly propels droplets when an electrical impulse is received.</p><p>The chip consists of microscopic jet nozzles that discharge droplets using piezoelectric or thermomechanical pumps inside the chip. The numerous micronozzles must be kept clean and yet it has to be packaged and protected. This can be done by selective packaging.</p><p>Hermetic packaging works well but it is expensive.</p><p>One concept is cap-on-chip illustrated in the following pic.</p><p>A silicon, metal or ceramic cap is bonded over the active area of MEMS chip while leaving wirebonds pads clear The capping must be done under cleanroom conditions in a vacuum, and the wafer is then singulated and the chips bonded and overmolded.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGZmZDUwN2ZhZjY4ZTkwMzgzZDg0ZDM3YjE1YmZiNzBfZ21ITXFYQjBUaUZRVk5adW1uM2Zja2RYVml1WnFjOUlfVG9rZW46S0hGamJ4VWhmb00wTjh4SDlPMmNYWXp6bm9yXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="5-6-3-MEMS-Play-a-Major-Role-in-Medical-Electronics"><a href="#5-6-3-MEMS-Play-a-Major-Role-in-Medical-Electronics" class="headerlink" title="5.6.3 MEMS Play a Major Role in Medical Electronics"></a>5.6.3 MEMS Play a Major Role in Medical Electronics</h3><p>MEMS are already an important part of the medical electronics markets. Soon, MEMS will go further to enable remote diagnostics and patient independence.</p><p>e.g., The micropump is a system in which a flow sensor measures the pumping rate and adjusts it accordingly to provide measured doses or correct dose of medication.</p><h3 id="5-6-4-MEMS-Applications"><a href="#5-6-4-MEMS-Applications" class="headerlink" title="5.6.4 MEMS Applications"></a>5.6.4 MEMS Applications</h3><p>MEMS accelerometers are currently used in industrial process control systems. Industrial MEMS accelerometers are applied in the measurement of gravity to determine orientation tilt and inclination; inertial measurement of velocity and position for motion control; and vibration and shock measurement for machine reliability.</p><ol><li><h1 id="Impact-of-Si-Processing-on-Microelectronic-Packaging-CH14"><a href="#Impact-of-Si-Processing-on-Microelectronic-Packaging-CH14" class="headerlink" title="Impact of Si Processing on Microelectronic Packaging (CH14)"></a>Impact of Si Processing on Microelectronic Packaging (CH14)</h1></li></ol><h2 id="6-1-Introduction-to-Si-processing"><a href="#6-1-Introduction-to-Si-processing" class="headerlink" title="6.1 Introduction to Si processing"></a>6.1 Introduction to Si processing</h2><p>Technology for (Si) wafer fabrication applications:</p><ul><li><p>CMOS electronic industry (ICs)</p></li><li><p>Micro-Electro-Mechanical Systems (MEMS)</p></li><li><p>Micro-Opto-Electro-Mechanical Systems (MOEMS)</p></li><li><p>Radiation&#x2F;particle detectors</p></li><li><p>Si technology is very much interested in photonics for solving its interconnect bottleneck problem if and only if photonic solutions are provided on Si platform</p></li><li><p>Photonics technology needs integration for continuing its growth. Si is the most mature technology for integration</p></li></ul><h3 id="6-1-1-MEMS-and-Microsystems"><a href="#6-1-1-MEMS-and-Microsystems" class="headerlink" title="6.1.1 MEMS and Microsystems"></a>6.1.1 MEMS and Microsystems</h3><p><strong>MEMS</strong>: the integration of mechanical elementssensors, actuators,and electronics on a common silicon substrate throughmicrofabrication technology</p><p><strong>Microsystems</strong>: Engineering systems that could contain MEMS components that are design to performspecific engineering functions</p><p>The MEMS revolution harnesses ICs know-how to build working microsystems from micromechanical and microelectronic elements.</p><p>MEMS is a multidisciplinary field involving challenges and opportunities for electrical, mechanical, chemical, and biomedical engineering as well as physics, biology, and chemistry.</p><p>As MEMS begin to permeate more and more industrial procedures, society as a whole will be strongly affected because MEMS provide a new design technology that could rival—perhaps surpass—the societal impact of integrated circuits.</p><h3 id="6-1-2-MEMS-封装方法"><a href="#6-1-2-MEMS-封装方法" class="headerlink" title="6.1.2 MEMS 封装方法"></a>6.1.2 MEMS 封装方法</h3><ol><li>陶瓷封装</li></ol><p>e.g. Packaging of MEMS comb-drive relays in a PGA ceramic package</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM3ZjQ3ZDNjYjRlYmFhOGIyNWZhNjNjMmMxNzg5YWFfMTR1b2IyVDZyNVhiREVPYlBCaTBmWnVLYmowU0x5dVNfVG9rZW46VFRWRWIzN0ZobzczT094WnkyaGNqM3IzbmNoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE2Zjc0NzJjMzQ2NDZiMmNjOWU5ZjY3NDFiZWMxOGNfTFRYZ1pWVHlCR3B6Tzc4QUNKQ0tHS0NWRTJqNnFobzFfVG9rZW46R0EzaWJrczJSb1drMnh4RDljcGNKbndPbldoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2QwM2IxOWQ2NmM1Njg2MGRkYmQyZmViYzllOTZiMzNfYkE3cnBnZnN3V0hqQVJ3eFlqQmFQVTFhTFUyN093aThfVG9rZW46QU9pb2JUbldpb1RPaFJ4VXZwRGNCaGRXbkxiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI2ZWQ0MjFlYjlhOGRlMWIxMTQ3ODM2MGJjMzIwM2ZfbHV5aFlXZ0EwRkhZRFBtWlRRTzFPV1Z0NlNjS3VZWEdfVG9rZW46R09ETGIzYVdXb1VCMHJ4eXVkNGNjQ0prbjlmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><p>塑料封装</p></li><li><p>金属封装</p></li></ol><h3 id="6-1-3-Si-Processing"><a href="#6-1-3-Si-Processing" class="headerlink" title="6.1.3 Si Processing"></a>6.1.3 Si Processing</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWIyNDJhNDliMDkyNDU0OGVlZThkOWNhNDgyOGQwOGFfR3hZWXF5T2RWSU8xeDNYaVdIMGlnOFp2a2diNmR6QVZfVG9rZW46Q3lqU2JxWWhmb25pcEt4TDFtdmNUa2sybnNnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNlOGZhNTNiZmU3N2E1NDVhOWI3MmEyYzBiMTcwMmRfZ0k0c0l5cUFXdUJDNUQzZnpJeUNZQUhvdHJKN1dvTDlfVG9rZW46RlhpT2JyaXBSb0RuUW94MFZQQmNINDlubkViXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcxYjljZDAwMGExNmM4N2UxMTYwYjliOTRiMjg0ZWFfSWROcXBCdEgzV1huRkFPOElZTG9uZmx5d1VUMW0yRGNfVG9rZW46RzZ2dWJTSDlJb1RWaXR4VXQ3RWNwbkNYblNoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmI0MDA3MmQ3YzQ4NzYyMmQ4YTM4NjQ3ZWI1YjNhMzBfWEpzT01ncmZDWndsdjVWZHpLczI1c1ZTRGY0TjBBeTdfVG9rZW46VVZIV2JZbEY1b3FiaHB4WHhVMmNEVHNxbjJnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="6-1-4-Si-Photonics"><a href="#6-1-4-Si-Photonics" class="headerlink" title="6.1.4 Si Photonics"></a>6.1.4 Si Photonics</h3><ol><li><strong>Future Packaging Si Photonics</strong></li></ol><p>Photonic crystals, also known as photonic bandgap materials, are periodic nanostructures. Photonic crystal basics is the periodic arrangements of two materials with different index of refraction.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDI0MWRmMmQyYjU5NmJhMTRkZjljNThkOGVkYzUyMjBfWGRIQ2ZzWUZmdUZkUzQ5RWFObHdpZ0Z1cE8yYXM4QVRfVG9rZW46VkhiY2JLYXk0bzV4UjJ4QXFieGN5Q0N1bnBkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU0N2FmYjdiNTFiZDdmMjg1Mzk0ZTEzY2RlNWNjMjlfU3o3dDFLdm81OWttV2pYSjFNdnpWVFhxS1dzWm1qeU5fVG9rZW46RnhPOGJjUkVzbzhmRjd4RWFqM2NCdmdqbmNnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Figure: Illustration showing data center connections. The shorter server-to-server connections within the server rack typically require &lt;5m (green) of routing, longer connections between the server racks may require up to 500m (orange), and long span connections within a building or between buildings can measure up to 2km (blue).</p><p>A “leaf” is typically the top-of-rack (ToR) switch that links to all servers within a common tower or rack. The next layer of switches is represented by the “spine.” The spine is a higher capacity switch (40 or 100 GB per link) that connects to leaf switches (across the server racks), to other spine switches, and to the next level of “Core” switches. “叶子”通常是连接到公共塔或机架内的所有服务器的机架顶部(ToR)交换机。下一层交换机由“主干”表示。主干交换机是一个更高容量的交换机(每条链路40或100千兆字节)，它连接到叶交换机(跨服务器机架)、其他主干交换机和下一级“核心”交换机。</p><ol><li><strong>Advanced Packaging with Si Photonic Die</strong></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFlODUxOGFiNmRiOGI4MGExOTI1YzQxZTdlOWJjZGNfbVJwcGxFR1lDUFByTWhubEVXVjgwaDh5YTlKalhDbnNfVG9rZW46T2tmSGJxWG91b2o0dlV4dnlNbWNhUHBhbkVlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Figure: Silicon photonic</p><p>a) a photonic integrated circuit (PIC) with flip-chip mounted laser die and edge-coupled waveguide; 采用倒装激光芯片和边缘耦合波导的光子集成电路(PIC);</p><p>b) logic, HMC(混合内存立方体,一种高性能内存) and PIC(光子集成电路) mounted directly to a BGA(Ball Grid Array，球栅阵列) substrate;</p><p>c) logic and HBM mounted on a high-density interposer with copper pillar micro-bumps that enable high-speed connectivity; 逻辑组件和高带宽内存（HBM）安装在具有铜柱微凸点的高密度中间层上，以实现高速连接</p><p>d) cut-away revealing copper pillar, flip-chip, BGA and optoelectronic interconnections. 剖开露出铜柱、倒装芯片、BGA和光电子互连。</p><ol><li>Silicon photonics market forecast</li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY5ODEwMTQ5YzEyY2I0OGZiMmU4ZDQwZGNlYzNlOWNfUjc1Nnc3RGRSbDVjNmRndlVPeHVLTXVHSWJhZThCcmRfVG9rZW46Tm9WaWJmMDUzb1diYzR4TGNFbGNWdHJXbnNlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Figure: Silicon photonics growth rates will initially be dominated by applications within the data center. The data center need for speed and capacity.</p><h2 id="6-2-Development-of-interconnects-and-impact-on-IMAX-Interconnection-Maximum"><a href="#6-2-Development-of-interconnects-and-impact-on-IMAX-Interconnection-Maximum" class="headerlink" title="6.2 Development of interconnects and impact on IMAX (Interconnection Maximum?)"></a>6.2 Development of interconnects and impact on IMAX (Interconnection Maximum?)</h2><h3 id="6-2-1-System-Interconnection"><a href="#6-2-1-System-Interconnection" class="headerlink" title="6.2.1 System Interconnection"></a>6.2.1 System Interconnection</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDU4YTVjMWZlZWU1OTBiM2YzYjdiODFjZTJmZDFmZTBfQWF6ZDdPT2tHOVRPRmczRlFBYWhzRzdWeUNRR0NnWUZfVG9rZW46SEhvdWIxd2xObzJCNTl4N0xkTWNId0JNbmdiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="6-2-2-Silicon-Interposers"><a href="#6-2-2-Silicon-Interposers" class="headerlink" title="6.2.2 Silicon Interposers"></a>6.2.2 Silicon Interposers</h3><p>An interposer can be defined as a silicon chip that can be used as a bridge or a conduit that allows electrical signals to pass through it and onto another element. Interposers are normally very frequently used in multi die chips or boards. 中间体可以定义为一个硅芯片，它可以用作桥或导管，使电信号通过它并进入另一个元件。中间体通常非常频繁地用于多模芯片或电路板。</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFjMTc2MDQ3Yjg4ZjE0NDUwNWE5ZTk4ZjdjMmNmZTNfQWVzc3poZldrWGNjUEJ4VXgxUFFvc0lyUllHNUNPMzFfVG9rZW46SmpqQmJwMVoybzVZYkd4Q0RDSWNJTWVvbjNjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODRmMjA3ZmNhODg3MzZjYzhkN2I4OGNkZjMzZGI5NjRfeDVZaEJ4MGtaUkpaNWR5RUo2QU1McVVGRWUyYnVqR1dfVG9rZW46UGRwQWJ5Zll5b3pSWXl4bHFPSmM4WTJzbmNoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU1MjBlZGMzNjNjZjIxNWMwMmFkMjMwZDI1OGQxZTVfV3AwSHhFekdLWnVmV0JaRHpxMFZUdXZwUkJOalRnTkJfVG9rZW46VUFUWmJHR0d2b3doeXB4MEJPQ2NuRmEwbmc4XzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFiNmUzODRhODc4NWYzZDVkMWE4MTE5ODMxNjkzYzdfYkw0R3k5MVBoRm16bGEwWjh1NjJWZmlsaXJiNDlvSllfVG9rZW46VGdORGJSMktsbzhmd1F4R0lXNmNvZXJabkdnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTVkZDUwNjQwNDc3ZTcxZmZlNDZjZGJlZjI4NTgwMGRfMGV4MnZQdFR1NjBlcHdpVHNZQzJHeTViUHhwWGdXUkFfVG9rZW46WThnUWJOY3Jsb3pKTzJ4OWQ4MmNPRFQzbjJnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="6-2-3-Through-Silicon-Vias-TSV"><a href="#6-2-3-Through-Silicon-Vias-TSV" class="headerlink" title="6.2.3 Through-Silicon Vias (TSV)"></a>6.2.3 Through-Silicon Vias (TSV)</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRlNzRhNGUxNzE3NWE2YzYwNDc4ODZmZDZmNmU2M2RfZ1hZZVBmdkR5WHUwbDdzbW90STFMb1JpRlQyRUVOdm5fVG9rZW46T0dWMGJzQmkyb0hGMGd4VGNFOGNkaXdXbjZnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE3NjU2NzgwNTc5YTk0MDA5NTZlYmY1MWIwNDU2MzFfS3c1bVFwUGNKMG04SEhMeG5KdHNxSW44SG5mYjZzb1lfVG9rZW46SUxJRGJ2S1J4bzRybUp4bFdnS2NDc0VpblFlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>If the processor die is placed on the top, TSV requirements in both counts and size would cause significant mechanical concerns (e.g., crack, stress) for the memory dice at the bottom.</p><h2 id="6-3-Low-k-Intralayer-Dielectric-ILD-and-its-impact-on-electronic-assembly-and-packaging"><a href="#6-3-Low-k-Intralayer-Dielectric-ILD-and-its-impact-on-electronic-assembly-and-packaging" class="headerlink" title="6.3 Low-k Intralayer Dielectric (ILD) and its impact on electronic assembly and packaging"></a>6.3 Low-k Intralayer Dielectric (ILD) and its impact on electronic assembly and packaging</h2><p>The use of low κ materials as the final intralayer dielectric (ILD) layer can impact the integrity of edge seals, blown fuses, and even the interface integrity at lower levels. 使用低κ材料作为最终的层内介电层(ILD)层会影响边缘密封、熔断保险丝的完整性，甚至影响较低水平的界面完整性。</p><p>Furthermore, the influence of the final ILD on lower levels depends on the total number of metal levels in the product. This paper?? addresses the role of final ILD in both environmental and package reliability, and the use of predictive modeling of mechanical reliability.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWJjMjdlODQ4Njk1YzM3MzIwOWYwN2U2NzExYTNmNjhfYjZ3Y1BuNnBhVDR3THFEZjExM2xybFhFVVg3Nk1OY0JfVG9rZW46RkFENGJPRkVTb05ycGp4M2N1ZGN5VHRjblVnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>As described earlier, the use of low-κ ILD to reduce on-chip interconnect parasitic capacitance has exacerbated the difficulty of maintaining high thermomechanical reliability of die assembled on organic substrates in flip chip packages.</p><p>Due to the fragile nature of low-κ ILDs in the die and their relatively poor adhesion to the surrounding materials, it is becoming progressively critical to minimize stresses imparted on the chip during thermal cycling and wafer-level probing.</p><p>The large CTE(“Coefficient of Thermal Expansion”，即热膨胀系数) mismatch between the silicon die (3 ppm&#x2F;°C) and the organic substrate (17 ppm&#x2F;°C) have been shown to be destructive for ILD materials and their interfaces.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA2NWQxNmE0OGNlNDNjYjU4ZGM4NDY3YjQ5M2U3MjZfWlRUNEZ1RDhTbjhJUEVQNWZwcHB6YVVVSXljU1RJSXVfVG9rZW46Tm9GNmJKTVdpb0pzOGp4S0VVWmNtNFNLbklnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="6-4-Impact-of-die-thinning-on-electronic-assembly-and-packaging"><a href="#6-4-Impact-of-die-thinning-on-electronic-assembly-and-packaging" class="headerlink" title="6.4 Impact of die thinning on electronic assembly and packaging."></a>6.4 Impact of die thinning on electronic assembly and packaging.</h2><h3 id="6-4-1-Benefits-of-Thinning"><a href="#6-4-1-Benefits-of-Thinning" class="headerlink" title="6.4.1 Benefits of Thinning"></a>6.4.1 Benefits of Thinning</h3><ol><li><p>Reducing thermal resistance</p></li><li><p>Improving device performance</p></li><li><p>Increasing reliability</p></li><li><p>Lowering overall package height</p></li><li><p>Minimizing die stress, which occurs due to mismatches in the coefficient of thermal expansion (CTE) between the silicon die and the board materials</p></li></ol><h3 id="6-4-2-Die-Packaging"><a href="#6-4-2-Die-Packaging" class="headerlink" title="6.4.2 Die Packaging"></a>6.4.2 Die Packaging</h3><p>Definition: embedded die packaging, the idea is to embed components inside the substrate using a multi-step manufacturing process. Die preparation is a step of semiconductor device fabrication during which a wafer is prepared for IC packaging and IC testing. [embed – to envelope, to enclose]</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE3NTI5ZTE4OTI1MWE2YjlmMzMxYmE3MjNjMjJmZmNfRFZnaWpZSzVjajdBR2oyTVN2MXdvem1heFlMZjlKZk1fVG9rZW46VmFhQWJCRXI2b0pCS1Z4SnhPSGNrMUp0bnprXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="6-4-3-Die-or-Wafer-Thinning-Process-Part-of-Die-Prep"><a href="#6-4-3-Die-or-Wafer-Thinning-Process-Part-of-Die-Prep" class="headerlink" title="6.4.3 Die or Wafer Thinning Process(Part of Die Prep)"></a>6.4.3 Die or Wafer Thinning Process(Part of Die Prep)</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTEwMTcyYzYzMTlhNWY4ZTY2OWE4ODBhYzllMDg5OWFfbHNsN0MyWDlFNG42Z0hnYkFPVmhXb2w3dTRkUjZYWVZfVG9rZW46Vld4cmJRMG92b05DdDl4NGVWdGNBNGJIbkJmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The <strong>Die Prep process</strong> essentially involves multiple steps and encompasses wafer thinning (backgrinding), wafer singulation and pick &amp; place in a nut-shell.</p><p>Optimum Die Prep process not only ensures quality of the dies but also helps to lower the cost and also prevents unexpected assembly hiccups.</p><p>Wafer backgrinding is a process of removing material from the backside of a wafer to a desired final target thickness while active devices are already fabricated on the wafer front side.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDU0YTM1M2VhMTlmMGJmNWJmM2FiNzU0ZWQ5ZThhZjhfQ0hlaWxQZnhzQU9tbnpqdDNxbEliVDA3WlU1aGU5UnZfVG9rZW46R0lRUGJCbXcybzFzNmx4Rk52aGNwSmxpblplXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="6-4-4-Chip-Attachment-to-the-Package-Substrate"><a href="#6-4-4-Chip-Attachment-to-the-Package-Substrate" class="headerlink" title="6.4.4 Chip Attachment to the Package Substrate"></a>6.4.4 Chip Attachment to the Package Substrate</h3><ol><li>The die attachment compound should provide</li></ol><p>– Electrical grounding</p><p>– Thermal dissipation</p><ol><li>There are three alternatives</li></ol><p>– Soft Solder Die Attach: This process uses a solder material to bond the die to the lead frame. The solder is introduced as a wire preform and melted onto the hot lead frame surface as a liquid solder dot.</p><p>– Epoxy Die Attach: Epoxy die attach is the most commonly used process. Usually silver-loaded polymers are used, but the term generally encompasses the use of other adhesives, such as polyimide- or silicone-based materials.</p><p>– Metal-filled glasses: Less used because of the high temperatures</p><p>needed, but have been used in ceramic packages</p><h2 id="6-5-Integrated-Circuit-Packaging"><a href="#6-5-Integrated-Circuit-Packaging" class="headerlink" title="6.5 Integrated Circuit Packaging"></a>6.5 Integrated Circuit Packaging</h2><ol><li><strong>Classification</strong></li></ol><ul><li><p>SSI (Small-Scale Integration) – few transistors</p></li><li><p>MSI (Medium-Scale Integration) – hundreds</p></li><li><p>LSI (Large-Scale Integration) – thousands</p></li><li><p>VLSI (Very Large-Scale Integration) – millions</p></li><li><p>ULSI (Ultra Large-Scale Integration)</p></li></ul><ol><li><strong>IC package engineering assembly services include:</strong></li></ol><ul><li><p>Die attach</p></li><li><p>Ultra-fine pitch wire bond (Al &amp; Au)</p></li><li><p>Flip Chip</p></li><li><p>Encapsulation and transfer mold</p></li><li><p>Substrate solder ball attach</p></li><li><p>Device Singulation</p></li></ul><ol><li>Methods of interconnections</li></ol><p>In electronics manufacturing, IC packaging is the final stage of semiconductor device fabrication, in which the block of semiconductor material is encapsulated in a supporting case that prevents physical damage and corrosion. The case, known as a “package”, supports the electrical contacts which connect the device to a circuit board.</p><p><strong>Wire bonding:</strong> the method of making interconnections between an IC or other semiconductor device and its packaging during semiconductor device fabrication. Although less common, wire bonding can be used to connect an IC to other electronics or to connect from one PCB to another</p><p>Thermosonic bonding is widely used to wire bond silicon integrated circuits into computers.</p><h2 id="6-6-Mechanical-and-Thermal"><a href="#6-6-Mechanical-and-Thermal" class="headerlink" title="6.6 Mechanical and Thermal"></a>6.6 Mechanical and Thermal</h2><p>The IC package must <strong>resist physical breakage</strong>, <strong>keep out moisture</strong>, and also <strong>provide effective heat dissipation</strong> from the chip. Moreover, for RF applications, the package is commonly required to shield electromagnetic interference, that may either degrade the circuit performance or adversely affect neighbouring circuits.</p><p>Finally, the package must <strong>permit interconnecting the chip</strong> to a PCB. The materials of the package are either plastic (thermoset热固性 or thermoplastic热塑性), metal (commonly Kovar) or ceramic.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmExNjU1NWVkZWUxZGVlZTM4NjVjY2QzYjI5ODgzMzBfZkpZckFvVXNWVmMyekljanZJUGtkZmloMjhtY0xFNG5fVG9rZW46T3I1cmJxQmppb3Z0cll4OHQ2cGNRNFdMbklnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmExNjU1NWVkZWUxZGVlZTM4NjVjY2QzYjI5ODgzMzBfZkpZckFvVXNWVmMyekljanZJUGtkZmloMjhtY0xFNG5fVG9rZW46T3I1cmJxQmppb3Z0cll4OHQ2cGNRNFdMbklnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>For top side heat flow path, potential thermal management options.:</p><p>a) use of higher conductive molding compound</p><p>b) embedded heat spreaders</p><p>c) improved package to casing thermal interface material</p><p>For bottom side, i.e. board side, heat flow path, thermal performance enhancement options include:</p><p>a) use of thermally conductive under-fill between package and board</p><p>b) dummy solder balls between package and board</p><p>c) embedded heat spreader within the package substrate</p><p>d) high conductive die attach between die and die to substrate.</p><p>System Level enhancement options include use of thermally conductive enclosure, venting grill, and active moving device close to the device</p><p>The thermal cycles and specific use cases for many consumer products impose mechanical stresses that require test to ensure reliability of the products.</p><p>The “drop test” approaches that have been used for cell phones and some other consumer products need to be replaced by new approaches that test a wider range of stresses including those associated with the thermal cycles experienced in the use cases.</p><p>In addition, we need tests that fit in a production flow without excessive test time or test cost. This remains a challenge not yet met.</p><h1 id="SIP-System-in-Package-structures"><a href="#SIP-System-in-Package-structures" class="headerlink" title="*SIP(System in Package ) structures"></a>*SIP(System in Package ) structures</h1><p>Definition: a combination of multiple active electronic components of different functionality, assembled in a single unit, which provides multiple functions associated with a system or sub-system. A SiP may optionally contain passives, MEMS, optical components, and other packages and devices.</p><p>Quad flat packages (QFP)</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTMzOGM2MjU0NGI5NTY5MTJjMGZlYTRkZjM1YTk4ZGFfcHdqTE5MT2xYMEM0anRXVExvaHkxR0tNcTZ6V0duMllfVG9rZW46V1Q4cWIzWVlob2QyUnF4cHA2bGNuSnlqbnBmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><h1 id="Advanced-Thermal-Management-Technologies-CH6"><a href="#Advanced-Thermal-Management-Technologies-CH6" class="headerlink" title="Advanced Thermal Management Technologies (CH6)"></a>Advanced Thermal Management Technologies (CH6)</h1></li></ol><h2 id="7-1-Basic-concepts-in-thermal-analysis-and-thermal-design"><a href="#7-1-Basic-concepts-in-thermal-analysis-and-thermal-design" class="headerlink" title="7.1 Basic concepts in thermal analysis and thermal design"></a>7.1 Basic concepts in thermal analysis and thermal design</h2><h3 id="7-1-1-Thermal-Management"><a href="#7-1-1-Thermal-Management" class="headerlink" title="7.1.1 Thermal Management"></a>7.1.1 Thermal Management</h3><p>The resistance to the flow of electrical current through the leads, poly-silicon layers, and transistors comprising a semiconductor device, results in significant internal heat generation within an operating microelectronic component.</p><p>In the absence of cooling(heat removal mechanisms), the temperature of such an operating component would rise at a constant rate until it reaches a value at which the electronic operation of the device ceases or the component loses its physical integrity.</p><p>Placing the device in contact with a lower temperature solid or fluid, facilitates heat flow away from the component. Due to this cooling, the temperature rise is moderated as it asymptotically approaches an acceptable steady-state value. Thermal conduction, convection, and radiation, as well as phase change processes, all play a role in electronics cooling.</p><p>Despite the wide variety in size, power dissipation, and sensitivity to temperature, the thermal management of all microelectronic components is motivated by similar concerns and a common hierarchy of design considerations.</p><p><strong>Primary and foremost aim of electronic thermal control</strong>: The prevention of catastrophic failure (an immediate and total loss of electronic function and package integrity)</p><p>An understanding of the catastrophic vulnerability of the specified component(s) makes it possible to select the appropriate fluid, heat transfer mode, and inlet coolant temperature, and thus establish the required thermal control strategy early in the design process.</p><h3 id="7-1-2-Packaging-Levels-and-Heat-Removal"><a href="#7-1-2-Packaging-Levels-and-Heat-Removal" class="headerlink" title="7.1.2 Packaging Levels and Heat Removal"></a>7.1.2 Packaging Levels and Heat Removal</h3><p>The commonly accepted categorization places the chip package, which houses and protects the chip, at the bottom of the packaging hierarchy (<strong>level 1</strong>)</p><p>The PWB, which provides the means for chip-to-chip communication, constitutes <strong>level 2</strong></p><p>The backplane or ‘‘motherboard,’’ which interconnects the printed wiring boards, is termed <strong>level 3</strong> packaging.</p><p>The box, rack, or cabinet which houses the entire system is generally referred to as <strong>level 4</strong></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFiZjc4NDIyYTI1ODJjMDU1YmFlY2EyMDUwZDEyM2NfY1ZBaUVENW1ENkY5Um1RNUQyTWxWZHZhcXJVaWFkV0NfVG9rZW46VGQ5WmI1S0N3b3dmaEJ4ZFFpVWNWNTZObmxjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFiZjc4NDIyYTI1ODJjMDU1YmFlY2EyMDUwZDEyM2NfY1ZBaUVENW1ENkY5Um1RNUQyTWxWZHZhcXJVaWFkV0NfVG9rZW46VGQ5WmI1S0N3b3dmaEJ4ZFFpVWNWNTZObmxjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VhNzYwYjk0OWYyZTBjNzZkNWQxYTgzMThlMTM5MzZfdnZ6b1Q2eUdubVZpdE9sYVdNaDJRZFdJZ0hBMWhjZ3JfVG9rZW46WVYweWJobXBGb2tYbXp4cEJUZWNwcGZmbnBlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="7-2-Thermal-Management-Fundamentals"><a href="#7-2-Thermal-Management-Fundamentals" class="headerlink" title="7.2 Thermal Management Fundamentals"></a>7.2 Thermal Management Fundamentals</h2><p>In order to determine the T differences encountered in the flow of heat within electronic systems, it is necessary to recognize the relevant heat transfer mechanisms and their governing relations.</p><p>In a typical system, heat removal from the active regions of the microcircuit(s) or chip(s) may require the use of several mechanisms, some operating in series and others in parallel, to transport the heat generated by the chip to the coolant or ultimate heat sink.</p><p>In electronic cooling, it is generally necessary to deal with three basic thermal transport modes: <strong>conduction</strong> (including contact resistance), <strong>convection</strong>, and <strong>radiation</strong>.</p><h3 id="7-2-1-1-D-Conduction"><a href="#7-2-1-1-D-Conduction" class="headerlink" title="7.2.1 1-D Conduction"></a>7.2.1 1-D Conduction</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE1MmFhZDQ1NDMzYmI5MjA2YzRiMmE0YWZlNjRlNWVfcXJMYjlHaXNZZUZxNndyNDU5c0c5TDA1MVkzNTJET3dfVG9rZW46WlljQmJkaDFJb09NN1l4MHgycmNGNXA4blRmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The flow of heat from a region of higher T to a region of lower T within a solid, stationary liquid, or static gaseous medium(固体、静止液体或静止气体介质), as depicted in Figure, is termed conduction heat transfer, and occurs as a result of direct energy exchange among molecules. Conduction is governed by the Fourier equation, which in one-dimensional form, is expressed as:</p><p>$$q&#x3D;-kA\frac{dT}{dx}$$ (6.1)</p><p>where q is the heat flow (W), k is the thermal conductivity (W&#x2F;mK), A is the cross-sectional area for heat flow (m^2), and dT&#x2F;dx is the temperature gradient in the direction of heat flow (K&#x2F;m).</p><p>Integration of Equation (6.1) will yield the temperature difference resulting from the steady conduction of heat across a distance, L, through a medium, as:</p><p>$$T_{1}-T_{2}&#x3D;\frac{qL}{kA}$$ (6.2)</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTliMjBlMWE4OTVmZWZjMTExNmY2MmNjZGUzZDEwOTBfZlEzMGdDbndQTzhTSEtoOHRiekFtWlhadTJiY0VYcWtfVG9rZW46TjdudGJzUVFkb3FhMnJ4ZWVKQWNDQ0NMbndsXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFjODY0OWE2ZTdkODQzMWZlMDJiMmQzZjQxZjBhZWVfT01VeVkzWXNkazY1b0tONEI4NXJmc2NRR2VxczZyR2xfVG9rZW46RktxV2IxcjV4bzFPWEF4bU5LRGNFZHk4bldiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="7-2-2-Heat-Flow-across-Solid-Interfaces"><a href="#7-2-2-Heat-Flow-across-Solid-Interfaces" class="headerlink" title="7.2.2 Heat Flow across Solid Interfaces"></a>7.2.2 Heat Flow across Solid Interfaces</h3><p>Heat transfer across an interface, formed by the joining of two solids, is usually accompanied by a measurable T difference, which can be associated with a contact or interface resistance.</p><p>For perfectly adhering solids, geometrical differences in the crystal structure (lattice mismatch) can impede the flow of phonons and electrons across the interface.</p><p>However, when real surfaces are abutted, as shown in Figure, asperities on each of the surfaces limit actual contact between the two solids to a very small fraction of the apparent interface area. As a consequence, the flow of heat across such an interface involves solid-to-solid conduction in the area of actual contact, <em>Ac</em>, and fluid conduction across the open spaces, <em>Av</em>. At elevated T or in vacuum, radiation heat transfer across the open spaces may also play an important role.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjAzNmMwMTJhM2E3ODU1NDgyNmQzZGQ1Y2ZiM2ExYWNfTm9uc0t2MVlyMGRBQll5cEVNQXI1cDRjQURZYzVpdVZfVG9rZW46Qjl2Y2JzcDdyb1Blemh4YXhFV2NURTVSbmRjXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>If each of the solids has surface irregularities of average height δ&#x2F; 2, heat flows across the interface in two parallel paths, that is, through the solids and through the fluid. The heat flow across the interface can be written as:</p><p>$$\color{bleck}{q&#x3D;\frac{T_1-T_2}{\delta&#x2F;(2k_1A_c)+\delta&#x2F;(2k_2A_c)}+\frac{T_1-T_2}{\delta&#x2F;(k_fA_v)}}$$ (6.3)</p><p>where k1 and k2 are the thermal conductivities of solid blocks 1 and 2, respectively, and kƒ is the conductivity of the fluid occupying the gap between the two solids.</p><p>Equation (6.3) reveals that the contact area, asperity height, and the thermal conductivities of the media forming the interface all play important roles in establishing the interfacial heat transfer rate.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjkzZDNjOTEzMjQ2NGRmMDBkYmE5NjkyZTNhZDhhZTlfOXVFeTdKb0wzOHgyeHRkWjM5ejZKYjBsdThhZlFQdmlfVG9rZW46TWpRQWJGWDZ1b0x2YlZ4RTh3aWNLZnEwbnhmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="7-2-3-Heat-Flow-from-Solid-to-Fluid-Convection"><a href="#7-2-3-Heat-Flow-from-Solid-to-Fluid-Convection" class="headerlink" title="7.2.3 Heat Flow from Solid to Fluid: Convection"></a>7.2.3 Heat Flow from Solid to Fluid: Convection</h3><p>The transfer of heat from a solid to a fluid in motion occurs by a mode termed convection, as depicted in Figure.</p><p>Heat transfer by convection includes <strong>two mechanisms</strong>:</p><ol><li><p>exchange among nearly stationary molecules adjacent to the solid surface, as occurs in heat conduction</p></li><li><p>the transport of heat away from the solid surfaces by the bulk motion of the fluid.</p></li></ol><p><strong>Newton’s Law of Cooling:</strong> Convective heat transfer presumes a linear dependence of heat flow on the temperature difference between the surface and fluid.</p><p>$$q&#x3D;hA(T_{s}-T_{f})$$ (6.4)</p><p>where <em>h</em> (W&#x2F;m^2* K) is the heat transfer coefficient, <em>A</em> is the wetted surface area, <em>Ts</em> is the surface temperature and <em>Tƒ</em> is the bulk temperature of the nearby fluid.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM4YjA0MzMyZWMxZWM3ZjhlMjA0ODFlOTk1NGYyZGRfdGVlT1VzeXFiTnA3eGNDYkRTMGNjdTNwVXNma3o0YWhfVG9rZW46SEhiamJXbU11bzlVazZ4ZFlKVmNCWTU1bnRkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg1YTJhNTUzMzMwOGNhYzQyZWE2MjUxYmUyMzUxODBfN0dKZXl2RXg2YjhyU3VDSkNpYnRrekpoblB0S2tsUmdfVG9rZW46UmMyQ2JqT0VIb001VjJ4ZHVrR2NLQUtjbmVhXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="7-2-4-Thermal-Radiation"><a href="#7-2-4-Thermal-Radiation" class="headerlink" title="7.2.4 Thermal Radiation"></a>7.2.4 Thermal Radiation</h3><p>Radiation heat transfer occurs as a result of the emission and absorption of the energy contained in electromagnetic waves or photons. Thermal radiation can occur across a vacuum or any medium that is transparent to infrared wavelengths (typically larger than 1 μm). Thermal radiation is governed by the difference between the source and sink T raised to the fourth power, as:</p><p>$$Q&#x3D;\varepsilon \sigma A(T_1^4-T_2^4) F_{12}$$ (6.5)</p><p>where 𝜀 is the emissivity, 𝞼 is the Stefan-Boltzmann constant, equal to 5.67 *10^-8 W&#x2F;m^2K^4 and F12 is the so-called radiation ‘‘view factor’’ between surfaces 1 and 2. For highly-absorbing and emitting surfaces placed in close proximity to each other, F12 is close to unity.</p><p>For modest temperature differences, Equation (6.5) can be linearized to the form:</p><p>$$\color{black}{\mathrm{Q&#x3D;h_rA~(T_1-T_2)}}$$ (6.6)</p><p>where hr is the effective radiation heat transfer coefficient, and is approximately equal to:</p><p>$$\color{black}{\mathrm{h_r&#x3D;4\varepsilon<del>\sigma</del>F_{12}<del>(T_1</del>T_2)^{3&#x2F;2}}}$$ (6.7)</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q1M2VkYzAzMDJmYTA0YmI0NDJiZTdhYmYzZjg3NmJfRDJNVWRKRUZTQXYxdlNiZE5vbWxSZHFKNTR3Y0FXbWlfVG9rZW46RXhpTGJsT3BJb2t5WnR4ckdrWWNSSDN3blBmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="7-2-5-Lumped-Capacity-Heating-and-Cooling"><a href="#7-2-5-Lumped-Capacity-Heating-and-Cooling" class="headerlink" title="7.2.5 *Lumped Capacity Heating and Cooling"></a>7.2.5 *Lumped Capacity Heating and Cooling</h3><p>For an internally-heated solid of relatively high thermal conductivity, which is experiencing no external cooling, the temperature will undergo a constant rise rate, according to:</p><p>$$\frac{dT}{dt}&#x3D;\frac{q}{mC_{\rm p}}$$ (6.9)</p><ul><li><p><em>q</em> (heat flow): the rate of internal heating (W)</p></li><li><p><em>m:</em> the mass of the solid (kg)</p></li><li><p><em>Cp:</em> the specific heat of the solid (J&#x2F; kgK)</p></li></ul><p>When this same solid is externally-cooled, the temperature rises asymptotically towards the steady state temperature.</p><p>$$T(t)&#x3D;T(0)+\bigtriangleup T_{\rm ss}(1-e^{-\frac{hAt}{mC_{\rm p}}})$$ (6.10)</p><ul><li>$$\bigtriangleup T_{\rm ss}$$: the steady-state temperature determined by the convection relation (Equation 6.4).</li></ul><p>Heat flow from such a convectively-cooled solid to the surrounding fluid encounters two resistances: <strong>a conduction resistance within the solid</strong> and <strong>a convection resistance at the external surface.</strong></p><p>When the internal resistance $$\ll $$ the external resistance, the temperature variations within the solid may be neglected and the lumped capacity solution may be used.</p><p>The Biot Number, Bi, can be used to determine the suitability of this assumption:</p><p>$$Bi&#x3D;\frac{\rm Internal~ Conduction~ Resistance}{\rm External <del>Surface</del> Convection ~Resistance}&#x3D;\frac{(\frac{L}{kA})}{\frac{1}{hA}}&#x3D;\frac{hL}{k}$$ (6.11)</p><ul><li><p><em>h</em>: the heat transfer coefficient at the external surface</p></li><li><p><em>k</em>: thermal conductivity of the solid</p></li><li><p><em>L</em>: the characteristic dimension is defined by volume of the object per unit external surface area.</p></li><li><p>For Bi 0.1, it is generally acceptable to determine the solid temperature with the lumped capacity approximation.</p></li></ul><h3 id="7-2-6-Thermal-Resistances"><a href="#7-2-6-Thermal-Resistances" class="headerlink" title="7.2.6 Thermal Resistances"></a>7.2.6 Thermal Resistances</h3><ol><li><strong>Thermal ‘‘Ohm’s Law’’</strong></li></ol><p>The temperature-difference form of <em>Fourier’s Law,</em> Equation (6.2), it is possible to define a <em>thermal resistance</em> (_R_th), as:</p><p>$$R_{th}&#x3D;\frac{\bigtriangleup T}{q}&#x3D;\theta_{ja}&#x3D;\frac{T_{j}-T_{a}}$$ (6.12)</p><ul><li><p><em>Tj:</em> the junction temperature in ℃</p></li><li><p><em>Ta:</em> the ambient temperature in ℃</p></li><li><p>_q：_the power of the component</p></li></ul><p>Strictly speaking, this analogy applies only to conduction heat transfer, it is</p><p>possible to generalize this definition to cover all forms of thermal transport</p><p>As a first approximation, the package’s total thermal resistance can be separated into two components: $$\theta _{jc}$$—depending on the internal construction of the package and largely due to <strong>thermal conduction</strong>; and $$\theta _{ca}$$—depending on mounting and cooling techniques and due largely to <strong>thermal convection</strong>.</p><p><strong>Conduction</strong>: $$R_{th}&#x3D;\frac{L}{kA}&#x3D;\frac{1}{k(\frac{A}{L})}&#x3D;\frac{1}{kS}$$ S:<em>conduction shape factor</em></p><p><strong>Convection</strong>: $$R_{th}&#x3D;\frac{1}{hA}$$</p><ol><li><strong>Interface Resistances</strong></li></ol><p>Based on $$\color{bleck}{q&#x3D;\frac{T_1-T_2}{\delta&#x2F;(2k_1A_c)+\delta&#x2F;(2k_2A_c)}+\frac{T_1-T_2}{\delta&#x2F;(k_fA_v)}}$$, the interfacial heat flow is related to the separation gap between the two surfaces.</p><p><strong>The pressure</strong> imposed across the interface and the surface <strong>hardness</strong>, as well as the surface <strong>roughness</strong> characteristics of the solids, determine the interfacial gap, $$\delta$$, and the contact area, <em>Ac</em>.</p><p>the area-weighted interfacial gap, <em>Y:</em></p><p>$$Y&#x3D;1.185\sigma\left[-\ln\left(\frac{3.132P}H\right)\right]^{0.547}$$ (6.18)</p><ul><li><p>$$\sigma$$: the effective RMS surface roughness, $$(\sigma_1^2+\sigma_2^2)^{0.5}$$(m)</p></li><li><p><em>P</em> : the contact pressure (Pa)</p></li><li><p><em>H</em> : the surface hardness (Pa).</p></li></ul><p>*Please note that $$\sigma$$ in Equation (6.18) is different from the Stefan-Boltzmann constant introduced for the determination of radiation heat transfer earlier in this chapter.</p><p>So, $$R_{\mathrm{int}} &#x3D; \left[ 1.25k_s \left(\frac{m}{\sigma}\right)\left(\frac{P}{H}\right)^{0.95} + \frac{k_g}{Y}\right]^{-1}$$ (6.19)</p><p><em>m</em>: the effective RMS absolute surface slope $$(m_1^2+m_2^2)^{0.5}$$</p><p><em>ks</em>: the harmonic mean thermal conductivity, defined as $$\frac{2k_{1}k_{2}}{k_{1}+k_{2}}$$.</p><ol><li><strong>Thermal Resistances in Series</strong></li></ol><p>$$R_t&#x3D;R_1+R_2+R_3+R_4&#x3D;\frac{L_1}{k_1A}+\frac{L_2}{k_2A}+\frac{L_3}{k_3A}+\frac1{hA}$$ (6.20)</p><p>The wall temperature _T_1: $$T_1 &#x3D; R_tq+T_a$$ (6.21)</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJhYWQ4MjcxYjU1OTZjM2YzNDk0ZjlmMWQ5MTZjMTBfZUQzT1NtVmlOUjJ0RHdmSmNBM0RieUlHOHg2M0pDNzhfVG9rZW46S3FkUWJJdkJDbzRHYnl4VGFVMGNOR2pvbnpoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzFiODU4YTA5MjM0MmVmOWEyMjA2ZWNlNDQ4NzU0ZmNfcUhhVDhUT1BlUlRMa3M1V3RZVzJxMzNvcVgwcE9hbDhfVG9rZW46TThCWGJPTnV6b1k3bzF4OVNPdGNvSGM2blVmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li><strong>Thermal Resistances in Parallel</strong></li></ol><p>$$\frac1{R_t}&#x3D;\frac1{R_1}+\frac1{R_2}+\frac1{R_3}&#x3D;\frac{L_1k_1}W+\frac{L_2k_2}W+\frac{L_3k_3}W$$</p><p>$$R_t &#x3D; \frac{W}{L_1k_1 + L_2k_2 + L_3k_3}$$</p><h3 id="7-2-7-Thermal-Management-of-IC-and-PWB-Packages"><a href="#7-2-7-Thermal-Management-of-IC-and-PWB-Packages" class="headerlink" title="7.2.7 Thermal Management of IC and PWB Packages"></a>7.2.7 Thermal Management of IC and PWB Packages</h3><p>Top: a heat sink, using a thermally conducting grease, is used for cooling</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdhOWIxYzY1MDdkODlmOGZkMjA0YTI5YTEwYmJjYzNfMlk2eG03bTEwQ1FCZG4zN0lDSW1Uakh3SE82cGRNWXBfVG9rZW46RjdCVGIzNnpxb3JJM2x4a3FOMmN0cUJibnhlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdhOWIxYzY1MDdkODlmOGZkMjA0YTI5YTEwYmJjYzNfMlk2eG03bTEwQ1FCZG4zN0lDSW1Uakh3SE82cGRNWXBfVG9rZW46RjdCVGIzNnpxb3JJM2x4a3FOMmN0cUJibnhlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUwMjkyM2EyNGQ4OTViZDlhZmY3ZmQ5MTdkNDM4YzJfSnVXeUNlSXhwTkE5SE14Q2VoMmI2Z05UOE12bzlhZTVfVG9rZW46VGM5MWJndTl6b2oza2J4RDNWWWNaelBwbnNiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQzMmY1OWFmYmUzNmI5YjQ4YzI2MzlmMzk5YThlM2JfNFk0Y1BJaFNpMkk1bEV3Z2h2cWxteWNsNlVtdzhLYnBfVG9rZW46SU4xOGJjQXNPb095OGJ4NGt4QWM5cFhXbldsXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Equivalent thermal resistance for the chip package.</p><h2 id="7-3-Current-technologies-for-thermal-management"><a href="#7-3-Current-technologies-for-thermal-management" class="headerlink" title="7.3 Current technologies for thermal management"></a>7.3 Current technologies for thermal management</h2><h3 id="7-3-1-Heat-Sinks"><a href="#7-3-1-Heat-Sinks" class="headerlink" title="7.3.1 Heat Sinks"></a>7.3.1 Heat Sinks</h3><p>由$$q&#x3D;hA(T_{s}-T_{f})$$可知，</p><p>the convective thermal resistance can be decreased, either by increasing the heat transfer coefficient or by increasing the heat transfer area.</p><p>Thus, in practical applications, an increase in the heat transfer area offers the only means to reduce the convective thermal resistance. This is accomplished through the use of extended surfaces or fins</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg5ZGZlNjhjOTNiZDQwNTM5ZWRiODY4YjY0MTUzYmFfSlQ2M3lkcUVxZDNXOXVRUDRydEs1eEtlWlZLazVqTDRfVG9rZW46VlZMZ2JhRjdFb1FYY3J4clg1bmM4ZERKbnNlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>The rectangular fin shown in Figure has a height <em>L</em>, width <em>W</em> and thickness $$\delta$$</p><p>The rectangular fin shown in Figure 6.19 has a height <em>L</em>, width <em>W</em> and thickness</p><p>The temperature of the base surface to which the fin is attached is <em>Tb</em> and the ambient temperature is <em>Ta</em>.</p><p>散热片底板面积$$A_b&#x3D;W\delta$$ &#x3D;&gt; $$2WL+sL\delta + W \delta$$</p><p>A rigorous analysis shows that, for the rectangular fin, the total heat transfer from the fin area can be written as:$$\mathrm{q&#x3D;\eta~hA_f(T_b-T_a)}$$</p><p>where Aƒ is the base area of the fin and η is the fin efficiency which can be calculated as:$$\eta&#x3D;\tanh(\mathrm{mL})&#x2F;(\mathrm{mL})&#x3D;\frac{e^{mL}-e^{-mL}}{e^{mL}+e^{-mL}}\quad&#x2F;mL$$</p><p>And $$m&#x3D;\sqrt{\frac{2h(W+\delta)}{kW\delta}}$$</p><p>The quantity m can be defined as follows:</p><p>$$m&#x3D;\sqrt{\frac{hP}{kA_b}}$$</p><p>where P is the perimeter of the fin shape, and Ab is the cross-sectional area of the base of the fin.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2RiZTEyYTZiOTI4MWUyMDUwODk5NmM2NzVlY2FlNzNfdzVXbGJLdlpzUWtVRm1rN3VGQTJsWHpTeVE0WThWWlJfVG9rZW46WGFuTmJxOVFkbzRqVHF4VEY5amNCS21Ybm9mXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjI3Yjc5NmYxNGExNzgzYjc5ZDkyOTZmNzMwMzZhZjVfQkp0cEV1VWpHeVNncld0QlVRSmdNbnM3SEx3WllubE1fVG9rZW46RzhXcWJMTkVsbzNuVHR4NXEwRWNSeXZYblRqXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="7-3-2-Thermal-Vias"><a href="#7-3-2-Thermal-Vias" class="headerlink" title="7.3.2 *Thermal Vias"></a>7.3.2 *Thermal Vias</h3><p>Thermal vias embedded in the board may help to reduce the resistance to heat flow, especially in the direction perpendicular to the plane of the PWB.</p><h3 id="7-3-3-Heat-Pipe-Cooling"><a href="#7-3-3-Heat-Pipe-Cooling" class="headerlink" title="7.3.3 *Heat Pipe Cooling"></a>7.3.3 *Heat Pipe Cooling</h3><h3 id="7-3-4-Jet-Impingement-Cooling"><a href="#7-3-4-Jet-Impingement-Cooling" class="headerlink" title="7.3.4 Jet Impingement Cooling"></a>7.3.4 Jet Impingement Cooling</h3><p>Jet impingement has been widely used in many applications where <strong>high convective heat transfer rates are required</strong>.</p><p>In confined jet impingement, the spent fluid from a single nozzle, or an array of nozzles, flows outward in a narrow channel bounded by the plate containing the nozzle and the impingement surface.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI2ODBmNGI2NTk4ZWZkOThiOTdiZTFkZjhkNTkxMGFfNkdvdTZ6UUhFeEUwaWdnVWF3eURVc002ejVIZUdGTE9fVG9rZW46RU54ZmJmYTZ2b0dxOHl4MFVBYmNmUk1VbnZoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk0MjFhZmZkZjNkYTM0NzAzM2JmN2I5NmJhZmU3MWFfM095TVlpbTZDMm1yRUx5V084c1lUT0dmbVQ0T0trdFJfVG9rZW46VDladGJZMTdIb3ROdGd4UHFSTWNJWFhvblRmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="7-3-5-Immersion-Cooling"><a href="#7-3-5-Immersion-Cooling" class="headerlink" title="7.3.5 Immersion Cooling"></a>7.3.5 Immersion Cooling</h3><p>Thermal control of operational electronic components by direct immersion, in low boiling point dielectric liquids, dates back to the late 1940s.</p><p>In the mid-1980s, use of immersion cooling for the Cray 2 and ETA-10 supercomputers, as well as substantial research on jet impingement and spray cooling, led to renewed interest in this technology.</p><p>Due to <strong>the elimination of the solid-solid interface resistance</strong>, immersion cooling is well suited to the cooling of advanced electronic systems now under development.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTNlYmVlOTNlMWMxZTZiYjYyMjA1ZGM1ZjJmMDgxNjBfdmR4SnVNS0x3ZDhEcVJod1NoM2thZUZVR3RsbWhVU0pfVG9rZW46SjNmTmJJUUNPbzd4Zkp4SHVYamNUcnBQbnZiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>In (a), a ‘‘remote’’ condenser, external to the electronic enclosure and cooled by water, air, or other fluid, condenses the vapor leaving the enclosure and directs the condensate back to the enclosure for reuse.</p><p>In (b), the condenser is located in the vapor space above the liquid, producing a more compact immersion module design, and the condensate drips back into the liquid</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZiOWU4MThlN2QzNTY2ZTQ5OWM5MjhlYTk2MGRjY2RfUzV6OXFybHFFemxTMnFGRHJ4dzlEWVcydXZFY3FSb2RfVG9rZW46SzM0M2JHOVBJb2NHRTZ4c3dSQ2NwblRMbnhlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>Due to the high solubility of air in the perfluorinated fluorocarbons, often used as immersion cooling liquids, it is not uncommon for vapor space condensers to be adversely affected by a buildup of noncondensable gas. Such difficulties can be avoided by submerging the condenser (heat exchanger tubes) in the liquid as shown in (a)</p><p>As a further modification of this approach, it is possible to use the side and top walls of the liquid-filled enclosure to serve as the submerged condenser, which can then be externally air-cooled or liquid-cooled, as shown in (b).</p><p>Immersion cooling is one of the most reliable thermal management techniques, since it eliminates the problematic solid-solid interface, and since all the components reside in a completely sealed liquid environment.</p><h3 id="7-3-6-Thermoelectric-Cooling"><a href="#7-3-6-Thermoelectric-Cooling" class="headerlink" title="7.3.6 Thermoelectric Cooling"></a>7.3.6 Thermoelectric Cooling</h3><p>The Peltier Effect is the basis for the <em>thermal electric cooler</em> (TEC), which is a solidstate heat pump.</p><p>If a potential is placed across two junctions, heat will be absorbed into one junction, and expelled from the other, in proportion to the current.</p><p>Most material combinations exhibit the Peltier Effect to some degree.</p><p>However, it is most obvious across a p-n junction as shown in figure.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQwMjI1NjZhMjc2MTZkMzNiYWQwYjY3MTUyZjhjYTdfTWRMazFtYnBTVG04UU1iOWZMUThSakFlUGppVG4yOWhfVG9rZW46SlR2dWJHVXNLb3c2NUV4emduamNoOGRyblpmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>As electrons are transported from the p-side of a junction to the n-side, they are elevated to a higher energy state and thus absorb heat, resulting in cooling the surrounding area. When they are transported from the p-side to the n-side, they release heat.</p><p>A TEC device is constructed by placing one to several hundred <em>thermocouples</em> electrically in series, and thermally in parallel, between two pieces of metallized, thermally conductive ceramic acting as an electrical insulator.</p><ol><li><h1 id="System-Level-Integration-in-Package"><a href="#System-Level-Integration-in-Package" class="headerlink" title="System Level Integration in Package"></a>System Level Integration in Package</h1></li></ol><h2 id="8-1-introduction-to-SOC-SIP-SOP"><a href="#8-1-introduction-to-SOC-SIP-SOP" class="headerlink" title="8.1 introduction to SOC&#x2F;SIP&#x2F;SOP"></a>8.1 introduction to SOC&#x2F;SIP&#x2F;SOP</h2><ol><li>SIP</li></ol><p>Def: a combination of multiple active electronic components of different functionality, assembled in a single unit, which provides multiple functions associated with a system or sub-system. A SiP may optionally contain passives, MEMS, optical components, and other packages and devices.</p><h2 id="8-2-Difficult-challenges-for-SiP-SiP-Thermal-Management"><a href="#8-2-Difficult-challenges-for-SiP-SiP-Thermal-Management" class="headerlink" title="8.2 Difficult challenges for SiP, SiP Thermal Management"></a>8.2 Difficult challenges for SiP, SiP Thermal Management</h2><p>System integration is aimed at higher performance, miniaturization, heterogeneous integration, and eventual cost reduction at the package level. Many critical technology challenges must be solved to achieve the ultimate performance goals and other benefits of SiP. The difficult challenges for SiP are presented in Table below.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzBmMmIzNTlmMjM3ZmVjMmIzOTk5NmRmOGI3ZmQyYWNfdGdKaXVKZFBMNXgzQUh3dFdyam9BcDkzVXB2VzVGMFdfVG9rZW46WFlFTWJWUzJFb0RhRnJ4UVREUWNlQTlqblhiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="8-3-System-Package"><a href="#8-3-System-Package" class="headerlink" title="8.3 System Package"></a>8.3 System Package</h2><h3 id="8-3-1-SoC-System-on-Chip-and-SiP-System-in-Package"><a href="#8-3-1-SoC-System-on-Chip-and-SiP-System-in-Package" class="headerlink" title="8.3.1 SoC (System-on-Chip) and SiP (System-in-Package)"></a>8.3.1 SoC (System-on-Chip) and SiP (System-in-Package)</h3><ol><li><p><strong>SoC</strong> refers to a very large-scale IC, which integrates an electronic system on a single chip. The embedded electronic system can combine all needed functions, including microprocessor, memory, optical, oscillator, and often radio-frequency, etc.</p><ol><li><p>SoC has a couple of advantages. Normally <strong>the overall performance for SoC is better than SiP due to the compact connection</strong>.</p></li><li><p>Issues posed by SoC technology, such as <strong>very high design and prototyping cost</strong>, <strong>long development cycle time</strong>.</p></li><li><p>Given the high cost of SoC early development, SiP provides an alternative method to make up a complete electronic system. In contrast to SoC, SiP incorporates multiple chips into a single package. Each incorporated chip handles a part of functions in the whole system, and the combined system can operate the same as if it was integrated by SoC.</p></li></ol></li><li><p><strong>SIP</strong> is a broader sense of an old concept called multi-chip-module (MCM). <strong>MCM</strong> normally refers to assembly of multiple chips side-by-side on a single ceramic substrate using traditional connecting processes, such as wire bonding and flip chip. SiPs can be found in mobile, internet of things (IoT) and wireless combo applications.</p><ol><li><p>Regarded as the next level of MCM technology, SiP is designed with the ability to assembly multiple chips not only horizontally, but vertically as well. The above-mentioned 3D die stacking and package stacking technology are encompassed in the concept of SiP.</p></li><li><p>With SiP technology, electronic companies can drastically reduce development time and risk, which overcomes the limitations of SoC development.</p></li></ol></li></ol><p><strong>SoC and SiP have their own pros and cons</strong>. It’s believed that SoC is more suitable for high volume production of systems with low complexity. And SiP is a good choice for low volume production of high complex systems.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMxOTNjMDIyNzZlYjNjMDNiZTJkYzQzYTdmMmE2OTFfd1lSMnBudFJHR2FJNW9Cc2dGRWxaOEw5SDhJMjBWdERfVG9rZW46U2U2N2JqWGVEbzlnV2F4ekU5aGNNQXdmbjBiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZkODJiMjIzN2NmNzFiMjA1ZDg0NjhjYTc3NDRiNzBfZFRmNldQeUVtdHdyQ09TeWhvWXV1cm1YMDdhZ1BzSUVfVG9rZW46VlE0M2JsakJjb05ZNkR4SW1PU2N3cGFLbmFlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmY0NWQxM2NiMDhlM2UyYjQ3MTZmOGI3OWUyNzkzYTZfb3BITWVPaEc2STJ6VHVURWpERXhJaDRhdHZ3ZmpCQTlfVG9rZW46SjJ5VWJXRE5wb2hrSVV4YWxrQWNEWEVYbjVkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="8-3-2-System-on-Chip-SoC-Test"><a href="#8-3-2-System-on-Chip-SoC-Test" class="headerlink" title="8.3.2 System-on-Chip (SoC) Test"></a>8.3.2 System-on-Chip (SoC) Test</h3><p>SoC technology is based on using embedded cores to reduce time-to-market and save overall cost of the chip. These embedded cores may have been designed by different vendors, may have varying degrees of readiness for reuse in SoC design and may have been developed at a different time from the SoC that will use them.</p><h3 id="8-3-3-3D-Packaging"><a href="#8-3-3-3D-Packaging" class="headerlink" title="8.3.3 3D Packaging"></a>8.3.3 3D Packaging</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTgwMTY3ZWI0N2IxOWVmYzRjZmNkYjIyMGVkNDZmZDRfbXNrZ25aY09UN1BjTHhNdUwybXZFa0l3TjFwSFhjTG9fVG9rZW46T1NPcWJwVmtIb2U2Q0h4d094YmN0bUZxbmFnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="8-3-4-UTCP"><a href="#8-3-4-UTCP" class="headerlink" title="8.3.4 UTCP"></a>8.3.4 UTCP</h3><p>The UTCP can be used independently or serves as an interposer, which can be further embedded inside PCB or FCB (flexible circuit board) and replace the needs for directly embedding of bare die. The KGD problem is solved, because the functionality of UTCP can be easily tested before embedding it in the main board. Fig. 7.4 shows a functional electrocardiography (ECG) measurement circuit, where a TI microcontroller was packaged using UTCP technology and embedded inside FCB.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDZjYjg1NGFhMWI1N2IxOGM4YTQzNjg5N2FmMDJiNDVfVXlJVW1FcFJJVWNtbGlBc3BGaHZWRU5xRlRGVFRRMk9fVG9rZW46RHN4UmJ1TWlrb2NpdEd4MkR2R2NXOExDbnpiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="8-4-Introduction-to-CSP-and-WLP-WLP-Technologies-and-Reliability"><a href="#8-4-Introduction-to-CSP-and-WLP-WLP-Technologies-and-Reliability" class="headerlink" title="8.4 Introduction to CSP and WLP, WLP Technologies, and Reliability"></a>8.4 Introduction to CSP and WLP, WLP Technologies, and Reliability</h2><h3 id="8-4-1-SCP-WLP-Single-Chip-Wafer-Level-packaging"><a href="#8-4-1-SCP-WLP-Single-Chip-Wafer-Level-packaging" class="headerlink" title="8.4.1 SCP,WLP (Single-Chip Wafer-Level packaging)"></a>8.4.1 SCP,WLP (Single-Chip Wafer-Level packaging)</h3><p>The single-chip WLP is similar to a Chip-scale package (CSP) in package configuration.</p><p>The <strong>main difference</strong> btw a single-chip WLP and a CSP is the <strong>packaging assembly process</strong>. Single-chip WLPs are made using wafer-level packaging technology in which the interconnection bumping and testing is performed on the wafer.</p><p>The common and pervasive requirements in all of electronics are (1) ultra-low-cost, (2) thin, light, and portable, (3) very high performance, (4) diverse functions involving a variety of semiconductor chips and packaging, and (5) user friendliness.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJlMTBmNzVjNTBjODdjZmFjZjY3M2U5NGMxOWExZjNfNXhWTzRxWTd4dVhCZmd0Q2t5b2Jtcm1PSU0yTkJtaGtfVG9rZW46UnVxUWJjTTdGb2ZsdTJ4d2pyRWNIcW9vbjdiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="8-4-2-CSP-Chip-Scale-Package"><a href="#8-4-2-CSP-Chip-Scale-Package" class="headerlink" title="8.4.2 CSP (Chip Scale Package)"></a>8.4.2 CSP (Chip Scale Package)</h3><p>The trend in microelectronics has been toward ever-increasing numbers of I&#x2F;Os on packages, which is, in turn, driving the packaging configuration of semiconductors.</p><p><strong>CSP</strong> can combine the strengths of various packaging technologies, such as the size and performance advantage of bare die assembly and the reliability of encapsulated devices.</p><p><strong>Advantages of CSP</strong></p><ol><li><p>smaller size (reduced footprint and thickness)</p></li><li><p>lesser weight</p></li><li><p>a relatively easier assembly process</p></li><li><p>lower overall production costs</p></li><li><p>improvement in electrical performance.</p></li></ol><h3 id="8-4-3-Fan-in-and-Fan-out"><a href="#8-4-3-Fan-in-and-Fan-out" class="headerlink" title="8.4.3 Fan-in and Fan-out"></a>8.4.3 Fan-in and Fan-out</h3><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzY0Mzk4OTE5NThiNzVjNzJkM2E4OTE3YTBhNGVkODZfWmN0NEdCcjY3U1UwZXJKQjNKQnlmZFMwUGZVSUl3Z1RfVG9rZW46VGtEcmJnUmdvbzJiZ0d4a1Z4d2MzTFh6bnJmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>This figure shows the purpose of microelectronics package from BGA to wafer level package (WLP)-molded and a more recent fan-out configurations. An interposer is used to accommodate the fine pitch of the chip as well as the next level interconnection, e.g. PCB.</p><ol><li>FI-WLP (Fan-in Wafer-Level Package)</li></ol><p>–refers to the technology of packaging an IC at the wafer level, instead of the traditional process of assembling individual dies into packages after dicing them from a wafer.</p><p>–an extension of the wafer fabrication process and uses the traditional fabrication processes and tools.</p><ol><li>FO-WLP (Fan-out Wafer)</li></ol><p>–an enhancement of standard WLPs, enabling a greater number of I&#x2F;O connections.</p><p>–This package involves dicing chips from a silicon wafer, precisely positioning the KGD (known-good-die) on a “reconstituted” or “carrier” wafer &#x2F; panel, which is then molded.</p><p>Fan-in is mainly applied to the mobile market (90% of its market)</p><p>Fan-out has also found applications in the high-end market (networking and computing applications) due to its ability to address higher I&#x2F;O count and larger package form factors; it also has improved reliability performance and increased capability for 3D integration using PoP (Package on Package) and SiP heterogeneous integration.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZjZmY5NTEyMDk5MjdlYTc2MDQyMzFiZWNmMjg3NzdfMmhHc2wyOHVyc2lGN2JuRXR0ODhXeWlsbnpJRHRNaGhfVG9rZW46S1RUV2JLd3FLb3o3RkN4d1FyTGNaeHBWbm1iXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODAzYTUzMzdmYjk2ZGU2YTdhYjEyM2MwMzFlMWM2YTdfbjd2ZTVSdHJjbmdkQWIzV2Qya0tnVnVvNVNYWnBKSFRfVG9rZW46RzZvWWJPMGQwb01TQ2V4Sm90Q2NmMFdxbm1iXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>This Fig shows single-chip microelectronic packaging technologies into three key technologies: (1) plastic ball grid arrays (PBGAs), (2) ceramic column grid arrays (CGAs or CCGAs), and (3) and smaller foot-print wafer-level packages. PBGAs and chip scale packages (CSPs) are now widely used for many commercial electronic applications, including portable and telecommunication products.</p><h2 id="8-5-WLP"><a href="#8-5-WLP" class="headerlink" title="8.5 WLP"></a>8.5 WLP</h2><h3 id="8-5-1-Overview"><a href="#8-5-1-Overview" class="headerlink" title="8.5.1 Overview"></a>8.5.1 Overview</h3><ol><li>Definition</li></ol><p>WLP is IC packaging formed at the wafer level on the wafer in the wafer foundry. This is in contrast to conventional packaging that is done in two parts — wafer and singulation of that wafer into ICs and the subsequent packaging of these ICs into QFP, BGA, CSP or other packages.</p><p>工艺思路：</p><p>\1. 先在圆片上完成IC加工</p><p>\2. 才有一定工艺直接在圆片上加工出IC互连接口</p><p>\3. 利用该接口进行测试、老化</p><p>\4. 再分割圆片，直到得到IC成品</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg4ZWM2NjQ2ZjA4ZTkzYjk5M2ZhOWFkOTQxODVlNDNfYjE3elBJUEh4WDV1ZDJLenFoVERSeUxseGVXTnNMZ2tfVG9rZW46R3JJRmJHUEtjb29WWGV4MnI1SmNxYVZvbnpoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>WLP provides many benefits — the two most important being the lowest cost and smallest size.</p><ol><li><strong>WLP Pros:</strong></li></ol><ul><li><p><strong>Smallest system size</strong>, because it is truly a chip size package</p></li><li><p>Enabling interconnect continuum from IC to PWB because of thin-film processing</p></li><li><p>Reduced cost of packaging, because all the connections are done at wafer level</p></li><li><p>Reduced cost of testing, because testing is done at the wafer level once for all ICs</p></li><li><p>Reduced cost of burn-in, because the burn-in is done at the wafer level once</p></li><li><p>Elimination of underfill because of compliancy of the leads or other ways to achieve reliability</p></li><li><p>Improved electrical performance because of short lead lengths</p></li></ul><ol><li><strong>WLP Cons:</strong></li></ol><ul><li><p>与PWB不兼容</p><ul><li><p>Since the interconnect must be located in the active area of the die, very high I &#x2F;O ICs would require very small solder balls on very tight pitch.</p></li><li><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdkYThmMzgzZjIzNGMzYTcyOWZhZjM2MjI2MWY4MzhfQWF6TmZ1Q0NPMFd1SVUxcnc2MGpwbTQ3d29nRGtWZU9fVG9rZW46VDhkZWJubWlab2JvZG54eGpYOWNtd0d2blVoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p></li><li><p>Figure shows an area array of 30 micron solder balls on 100 micron pitch. It is technically feasible to manufacture such small solder balls, they would require very high density PWB to interconnect, but it is very expensive.</p></li><li><p>The tightest board pitch currently in use today is 0.5 mm or 500 microns. So, the board pitch will have to be improved to 100 microns, requiring 25 micron lithography technology to be manufactured on a very large board.</p></li></ul></li><li><p>失效IC封装</p></li><li><p>WLP的焊球互连</p></li></ul><p>The two most important factors driving the WLP are size benefits for portable products and cost benefits for all products.</p><p>Lower cost and higher performance cannot be achieved without major changes in architecture, materials and manufacturing processes. Today, these new technologies include SiP, wafer level packaging (WLP), wafer thinning, and through silicon vias (TSVs). In the near future, we will see additional changes with the incorporation of nanomaterials.</p><p>The consumer’s demand for thin multifunctional products has led to increased pressure on alternative high density packaging technologies. High-density three-dimensional (3D) packaging of complete functional blocks has become the major challenge in the industry:</p><p> RF System-in-Package (SiP) applications have become the technology driver for small components, packaging, assembly processes, and high-density substrates.</p><p> The use of motion-gesture sensors in various consumer and portable devices has expanded the MEMS</p><p> Performance requirements such as increased bandwidth and lower power are driving 3D ICs designed with through silicon vias (TSV).</p><h3 id="8-5-2-WLP-Technologies"><a href="#8-5-2-WLP-Technologies" class="headerlink" title="8.5.2 WLP Technologies"></a>8.5.2 WLP Technologies</h3><p>WLP can integrate package process in wafer fab, which provides a streamline from the silicon start to customer shipment. The WLP cross section and a close-up backside image are presented in Fig. 8.6.</p><p>Sequence of processes from a bare wafer to IC fabrication to wafer-level packaging to burn-in and test to scribing into individual ICs to system board assembly. The burn-in and test at wafer level is a very important part of the WLP, since it allows all the ICs to be tested while still in wafer form, known good packages (KGP).</p><p>从空白圆片开始，经过IC加工，到圆片级封装、老化、测试，最后分割成单个IC成品进行系统电路板组装。</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQwNDFkM2VmOWM1NjlmMDJkYjE1NDZmYThjZmJjZjRfaXpDOWRiQ0RxajJiWkdnUU9BZEswWXhoUlRnUVFTWDBfVG9rZW46UWlkbGJJMzdhb2pDU0R4WEdKSWNpR0tybnJYXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>As can be seen, WLP does not use an interposer, and the solder balls are realized on the chip by wafer level processing. The solder ball pad is routed within the chip outline from the chip perimeter contact pad, which is so called a “fan-in” design. The ball pitch can be as small as 0.3 mm. But, as the WLP is directly mounted on PCB, ball pitch larger than 0.4 mm is necessary to ensure high yield and reliability.</p><p>Another limitation of WLP is the number of I&#x2F;O count. Since the package area and ball pitch are confined, the total number of I&#x2F;O count is normally no more than 100.</p><h3 id="8-5-3-WLP-Reliability"><a href="#8-5-3-WLP-Reliability" class="headerlink" title="8.5.3 WLP Reliability"></a>8.5.3 WLP Reliability</h3><p>The WLP reliability is achieved by one of several ways. The fundamentals of reliability are based on what is called Coffin-Manson or modified equation, which predicts that the thermal fatigue lifetime of a solder joint is proportional to the square of the bump height or standoff.</p><p>Four ways to provide a reliable connection:</p><ol><li><p>Compliant connection. 柔性互联结构 This concept provides an excellent reliability as with PGAs between IC package and the board (used for over 30 years). Wirebonding reliability is also based on this concept where the stresses are taken up by the compliant leads. 可以降低应力</p></li><li><p>Stacking solders. 满足高度需求，提高焊球的疲劳寿命</p></li><li><p>Increased solder ball size, the net effect of which is similar to the stacked solder balls in achieving the increased height.</p></li><li><p>TCE-matched, having matched thermal expansion of silicon IC and the board.</p></li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjQyMThlOTU4MzRiYWQ3MTVkNzA3MjQwMDVlY2UzY2NfMllhdGdLY0pJRHpDazYxRWxnU3NjVExLQzFYTjBOM0JfVG9rZW46VWN3YWJWTUJDb3c0RzR4V3NkSWNGTDNnbnRmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h4 id="8-5-3-1-Underfills-are-filled-epoxy-resins"><a href="#8-5-3-1-Underfills-are-filled-epoxy-resins" class="headerlink" title="8.5.3.1 Underfills are filled epoxy resins."></a>8.5.3.1 Underfills are filled epoxy resins.</h4><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzc0MmUyMjM4NDE2ZjJiN2FhMzAwMWYzOTEzNDhhZTFfdUU4dld6ZVJNamQzR3REbExWbG5sVjZaWXlrOHFQcktfVG9rZW46S2V6RmI2SW1Vb0E2ekh4U0tZQ2NxR09ZbldoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h3 id="8-5-4-Wafer-level-Burn-in-and-Test"><a href="#8-5-4-Wafer-level-Burn-in-and-Test" class="headerlink" title="8.5.4 Wafer-level Burn-in and Test"></a>8.5.4 Wafer-level Burn-in and Test</h3><p>Wafer-level burn-in and tests are <strong>a necessity for the adoption of low-cost WLP.</strong></p><p>Non-destructive probing technologies have been developed to deal with wafer-level testing and burn-in of bumped wafers.</p><ol><li>In the VS-contact technology, shown in Figure 8.8, the connection is made between the substrate and the wafer with an interposer composed of conductive isotropic rubber and a flexible polyimide sheet containing Ni plated vias that match up with the bumped wafer surface. Electrical testing is accomplished through these contacts. Microspring contact technology uses a controlled shape and height spring element. The microspring contact has been used previously on probe cards to test contact at Al wirebond pads, Au pads and solder balls.</li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM1OWY0OTVmMzM0MDFjZDViZThiOGIwOWU0MDU5MTBfR01Oc25GcmVMRDBZakxjbmZOTVd4b1dnbVdOZFA4MkpfVG9rZW46RXhZOGJjSmp3b29FVnh4N2NsR2N6MzhtbkpmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li>微弹簧接触技术 通过弹簧单元补偿待测位置间的高度差异</li></ol><h1 id="9-Additional-Lecture"><a href="#9-Additional-Lecture" class="headerlink" title="9. Additional Lecture"></a>9. Additional Lecture</h1><h2 id="9-1-Electronic-Packaging-Technology"><a href="#9-1-Electronic-Packaging-Technology" class="headerlink" title="9.1 Electronic Packaging Technology"></a>9.1 Electronic Packaging Technology</h2><p>The electronic packaging has <strong>six functions</strong>:</p><ol><li><p>Signal distribution, involving topological and electromagnetic considerations;</p></li><li><p>Power distribution, involving electromagnetic, structural, and material aspects;</p></li><li><p>Heat dissipation (thermal management), involving structural and material considerations;</p></li><li><p>Support and protection (mechanical, chemical, and electromagnetic) components and interconnections from the hostile environments;</p></li><li><p>Design (for performance, environment, manufacture ability, and reliability) at the front end and system test at the final stage prior to the system shipment;</p></li><li><p>System testing that involves every aspect of system reliabilities.</p></li></ol><h2 id="9-2-Chip-Connection-Wire-Bonding-TAB-Structure-Flip-Chip"><a href="#9-2-Chip-Connection-Wire-Bonding-TAB-Structure-Flip-Chip" class="headerlink" title="9.2 Chip Connection: Wire Bonding, TAB Structure, Flip-Chip"></a>9.2 Chip Connection: Wire Bonding, TAB Structure, Flip-Chip</h2><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg0NWIxNTk5NTYzZTUwYmQ2YmYxZjhjZjRmMGI2NzJfdlZiaGw1ejdUcnBUaUZuRVR6dHRxVHpyMnRQbXRFMXNfVG9rZW46QUxyY2I3c0ZDb1ViQXR4TmNkeWNDNzlnbnBkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li>Wire Bonding</li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg0Y2IxYTczMjEwOWM3OWFjNmIxMzgyYmM0ZGUxZTJfa2E5ZUo3Y2lCdTJrcjQ5Vk5pS3MwMm8yVzN4ZDZIU1NfVG9rZW46VzhJS2I3V1dObzc0OGh4UWtZemM5U1g0bmxlXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li>TAB</li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2M2M1YWQ3M2FkYzgxN2Y5YjhmOGZiMjc4YmQ5NDZfZ2p3MDRhczFDbGNWbTY1TTBWSUxIeVgxZ0NpWGpJbmJfVG9rZW46SUdtTmJabHBMbzhXelJ4QkVIS2NZbm5KbnJiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><ol><li>Flip-Chip</li></ol><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc4YmYyYTkyNmY0N2FhYWM1MmQ1YWQ5MzE2N2FlMjZfakt5Y3F4aTdIRmZnU3ZyRkFYT3o5SkxaMW9DbnpRZENfVG9rZW46Q1hrbWJ0OGlpb1oxMFR4NGhWRWNGeEFPbkhkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p>FC <strong>Advantages</strong>:</p><p>Smaller size, increased functionality, Improved</p><p>performance, Most rugged (high reliability), Improved thermal</p><p>capabilities, Low cost</p><p>FC <strong>Assembly</strong></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2ZkMjdhOTUxNjUxNzVjNTY1YTE0Zjk4Y2UxMzU0NWFfNGlYNEk3UmR2bVNFNzBTQVBnSVU0RzlIQ2JXb2E5dHlfVG9rZW46SjRDT2JJVFZrb0FpZFN4RU9kNWNCRzQ3bmZnXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="9-3-Introduction-to-3D-Packages-Ball-Grid-Array-BGA-Chip-Scale-Package-CSP-Wafer-Level-Package-WLP"><a href="#9-3-Introduction-to-3D-Packages-Ball-Grid-Array-BGA-Chip-Scale-Package-CSP-Wafer-Level-Package-WLP" class="headerlink" title="9.3 Introduction to 3D Packages, Ball Grid Array (BGA), Chip Scale Package (CSP), Wafer Level Package (WLP)."></a>9.3 Introduction to 3D Packages, Ball Grid Array (BGA), Chip Scale Package (CSP), Wafer Level Package (WLP).</h2><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VhYzMzNjQwZmRhNTZhNTUxNWNkMGY5MGEyN2I4NmZfM2RlT3c0QVVWRG9NTWFRQ2gwb1A1SFBNdDFjaGYyZ2NfVG9rZW46WEhnUGJaVTNJb3NZQjZ4eXg2cGNqMFhIbnJiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE3OTA3MzEzNDdjNjM0NzEyZDdiNDhmMWFhYThkZGZfbzJ4SlJoa0FYb3VGN21DT3gyMW9zcEpKVEF1UnJZZ09fVG9rZW46VUE1Q2JzNGt3b1Fvck14TXRIcmNuaURRbkhiXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><h2 id="9-4-BGA-CSP-WLA"><a href="#9-4-BGA-CSP-WLA" class="headerlink" title="9.4 BGA, CSP, WLA"></a>9.4 BGA, CSP, WLA</h2><p><strong>BGA</strong>: with 1.27-mm pitch (distance between adjacent ball centers) and finer pitch versions with 1- and 0.8-mm pitches, are the only choice for packages with higher than 300 I&#x2F;O counts, replacing leaded packages such as the quad flat pack (QFP). BGAs provide improved electrical and thermal performance, more effective manufacturing, and ease-of-handling compared to conventional surface mount (SMT) leaded parts.</p><p>Finer pitch area array packages (FPBGA), also known as CSPs, are further miniaturized versions of BGAs, or smaller configurations of leaded and leadless packages with features generally less than 0.8-mm pitches.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQwZGNjM2YxZjg3YjU4YTQxN2U1YjM1ZDc3NDkwOTBfaE5GSkwzdDlOMGpzWk9DRUZLNEhadWRJajI0QXNNWWpfVG9rZW46TmpMNWJNNzdzbzQyS2F4M2RsRWN6bkFPbnRkXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><strong>CSP</strong>: An improvement in packaging efficiency beyond BGAs is achieved by CSP. Most CSPs use substrate (interposer) or metal layer to redistribute the very fine-pith (as small as 0.075 mm) peripheral pads on the chip to a much larger pitch (1 mm, 0.8 mm, 0.75 mm, and 0.5 mm) area array pads on the PWB.</p><p><strong>WLP:</strong> the technology employed for the fabrication of ICs while still part of the wafer, in contrast to the more conventional method of slicing the wafer into individual circuits (dice) and then packaging them. This technique has grown rapidly in popularity in the IC industry due to advantages in terms of component size as well as production time and cost. WLP is essentially a type of chip-scale package (CSP) technology, since the resulting package is practically of the same size as the die.</p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTllM2NhYjMzMmU4YjI4OTM4YzMwNTYyZGRjMjFiMGVfYUZ4UHBEckVrbkszanUzRVd4OVZqd1VER1hKbmowM1dfVG9rZW46VHdNdWJiVmRJb1dGYzd4UUFUVGNhdUNnbmRoXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p><p><img src="https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGNjYTQ4YmJmYjdiN2IzYmRiNmU0ZWRkMWVhMTMxNzVfcmg5NHF2UW4yUVBIQkhrYWliYklia2VIRmNoa3k5YVVfVG9rZW46V1RWMmJXV0k1b243dUN4eVNEbGMwWnZ0bjNmXzE3NDAzMTkwMjI6MTc0MDMyMjYyMl9WNA" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>制造工艺</category>
      
      <category>封装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>封装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提问的艺术</title>
    <link href="/Blogs/2025/08/28/%E6%8F%90%E9%97%AE%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <url>/Blogs/2025/08/28/%E6%8F%90%E9%97%AE%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="提问之前"><a href="#提问之前" class="headerlink" title="提问之前"></a>提问之前</h1><p>在你准备要通过电⼦邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧⽂章中搜索答案。</li><li>尝试上⽹搜索以找到答案。</li><li>尝试阅读⼿册以找到答案。</li><li>尝试阅读常⻅问题⽂件（FAQ）以找到答案。</li><li>尝试⾃⼰检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><blockquote><p>我们更乐于回答那些表现出能从答案中学习的⼈的问题</p></blockquote><h1 id="提问时"><a href="#提问时" class="headerlink" title="提问时"></a>提问时</h1><h2 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h2><p>⼩⼼选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴⾮常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既⾮熟⼈也没有义务解决你问题的⼈发送私⼈电邮。</li></ul><h2 id="常见论坛"><a href="#常见论坛" class="headerlink" title="常见论坛"></a>常见论坛</h2><p>Stack Exchange 已经成⻓到超过⼀百个⽹站，以下是最常⽤的⼏个站：<br>Super User 是问⼀些通⽤的电脑问题，如果你的问题跟代码或是写程序⽆关，只是⼀些⽹络连线之类的，请到这⾥。<br>Stack Overflow 是问写程序有关的问题。<br>Server Fault 是问服务器和⽹管相关的问题</p><h2 id="使⽤有意义且描述明确的标题"><a href="#使⽤有意义且描述明确的标题" class="headerlink" title="使⽤有意义且描述明确的标题"></a>使⽤有意义且描述明确的标题</h2><p>编写 ⽬标 —— 差异式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是⿏标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯⽚组？或者只是其中的 MV1005 型号？ ⼀个⿊客只需瞄⼀眼就能够⽴即明⽩你的环境和你遇到的问题</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！<br>聪明问题：X.org 6.8.1 的⿏标光标会变形，某牌显卡 MV1005 芯⽚组。<br>更聪明问题：X.org 6.8.1 的⿏标光标，在某牌显卡 MV1005 芯⽚组环境下 - 会变形</p></blockquote><h2 id="⽤清晰、正确、精准且语法正确的语句"><a href="#⽤清晰、正确、精准且语法正确的语句" class="headerlink" title="⽤清晰、正确、精准且语法正确的语句"></a>⽤清晰、正确、精准且语法正确的语句</h2><p>如果英⽂是你的外语（Second language），提示潜在回复者你有潜在的语⾔困难是很好的<br>以下附上原⽂以供使⽤<br>English is not my native language; please excuse typing errors.<br>英⽂不是我的⺟语，请原谅我的错字或语法。<br>我把我的问题⽤某语⾔和英⽂写出来，如果你只⽤⼀种语⾔回答，我会乐意将其翻译成另⼀种</p><h2 id="使⽤易于读取且标准的⽂件格式发送问题"><a href="#使⽤易于读取且标准的⽂件格式发送问题" class="headerlink" title="使⽤易于读取且标准的⽂件格式发送问题"></a>使⽤易于读取且标准的⽂件格式发送问题</h2><p>如果你⼈为地将问题搞得难以阅读，它多半会被忽略，⼈们更愿读易懂的问题，所以：</p><ul><li>使⽤纯⽂字⽽不是 HTML (关闭 HTML 并不难）。</li><li>使⽤ MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），⽽不仅仅是邮件程序⽣成的模板（譬如只是信件内容的拷⻉）。</li><li>不要发送⼀段⽂字只是⼀⾏句⼦但⾃动换⾏后会变成多⾏的邮件（这使得回复部分内容⾮常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换⾏分割点⼩于 80字。</li><li>但是，对⼀些特殊的⽂件不要设置固定宽度（譬如⽇志档案拷⻉或会话记录）。数据应该原样包含，让回复者有信⼼他们看到的是和你看到的⼀样的东⻄。</li><li>在英语论坛中，不要使⽤ Quoted-Printable MIME 编码发送消息。这种编码对于张贴⾮ ASCII语⾔可能是必须的，但很多邮件程序并不⽀持这种编码。当它们处理换⾏时，那些⽂本中四处散布的 &#x3D;20 符号既难看也分散注意⼒，甚⾄有可能破坏内容的语意。</li><li>绝对，永远不要指望⿊客们阅读使⽤封闭格式编写的⽂档，像微软公司的 Word 或 Excel ⽂件等。⼤多数⿊客对此的反应就像有⼈将还在冒热⽓的猪粪倒在你家⻔⼝时你的反应⼀样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使⽤ Windows 的电脑发送电⼦邮件，关闭微软愚蠢的 智能引号 功能 （从[选项] &gt; [校订] [⾃动校正选项]，勾选掉 智能引号 单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥⽤ 表情符号和 HTML 功能（当它们提供时）。⼀两个表情符号通常没有问题，但花哨的彩⾊⽂本倾向于使⼈认为你是个⽆能之辈</li></ul><h2 id="精确地描述问题并⾔之有物"><a href="#精确地描述问题并⾔之有物" class="headerlink" title="精确地描述问题并⾔之有物"></a>精确地描述问题并⾔之有物</h2><p>仔细、清楚地描述你的问题或 Bug 的症状。</p><ul><li>描述问题发⽣的环境（机器配置、操作系统、应⽤程序、以及相关的信息），提供经销商的发⾏版和版本号（如： Fedora Core 4 、 Slackware 9.1 等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题⽽采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供⼀个可以重现这个问题的可控环境的⽅法</li></ul><h2 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h2><p>问题解决后，向所有帮助过你的⼈发个说明，让他们知道问题是怎样解决的，并再⼀次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了⼴泛关注，应该在那⾥贴⼀个说明⽐较恰当。</p><h1 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h1><h2 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h2><p>有⼀个古⽼⽽神圣的传统：如果你收到 RTFM （Read The Fucking Manual） 的回应，回答者认为你<br>应该去读他妈的⼿册。当然，基本上他是对的，你应该去读⼀读。RTFM 有⼀个年轻的亲戚。如果你收到 STFW（Search The Fucking Web） 的回应，回答者认为你应该到他妈的⽹上搜索。那⼈多半也是对的，去搜索⼀下吧。（更温和⼀点的说法是 Google 是你的朋友！）</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>01素养</category>
      
    </categories>
    
    
    <tags>
      
      <tag>提问的艺术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>放大器设计</title>
    <link href="/Blogs/2025/08/28/%E6%94%BE%E5%A4%A7%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E6%94%BE%E5%A4%A7%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="1-放大器类型对比​​"><a href="#1-放大器类型对比​​" class="headerlink" title="1. 放大器类型对比​​"></a><strong>1. 放大器类型对比​</strong>​</h4><table><thead><tr><th>​<strong>​类型​</strong>​</th><th>​<strong>​输入&#x2F;输出特性​</strong>​</th><th>​<strong>​增益公式​</strong>​</th><th>​<strong>​典型电路​</strong>​</th></tr></thead><tbody><tr><td>共源(CS)</td><td>高输入阻抗，电压放大</td><td>Av​&#x3D;−gm​(RD​∥ro​)</td><td>带源极电阻的NMOS</td></tr><tr><td>共漏(CD)</td><td>电压跟随器，低输出阻抗</td><td>Av​≈1</td><td>源极跟随器</td></tr><tr><td>共栅(CG)</td><td>低输入阻抗，电流缓冲</td><td>Av​&#x3D;gm​(RD​∥RL​)</td><td>高频放大器</td></tr></tbody></table><h4 id="​​2-差分放大器​​"><a href="#​​2-差分放大器​​" class="headerlink" title="​​2. 差分放大器​​"></a>​<strong>​2. 差分放大器​</strong>​</h4><ul><li>​<strong>​差模增益​</strong>​：Ad​&#x3D;gm​RD​</li><li>​<strong>​共模抑制比(CMRR)​</strong>​：CMRR&#x3D;​Acm​Ad​​​</li><li>​<strong>​半电路分析法​</strong>​：对称电路简化为单边分析</li></ul><h3 id="反馈与稳定性​​"><a href="#反馈与稳定性​​" class="headerlink" title="反馈与稳定性​​"></a><strong>反馈与稳定性​</strong>​</h3><h4 id="​​1-反馈拓扑​​"><a href="#​​1-反馈拓扑​​" class="headerlink" title="​​1. 反馈拓扑​​"></a>​<strong>​1. 反馈拓扑​</strong>​</h4><table><thead><tr><th>​<strong>​类型​</strong>​</th><th>​<strong>​采样信号​</strong>​</th><th>​<strong>​混合方式​</strong>​</th><th>​<strong>​阻抗变化​</strong>​</th></tr></thead><tbody><tr><td>电压-电压</td><td>输出电压</td><td>串联</td><td>Rin​↑, Rout​↓</td></tr><tr><td>电流-电流</td><td>输出电流</td><td>并联</td><td>Rin​↓, Rout​↑</td></tr></tbody></table><h4 id="​​2-稳定性判据​​"><a href="#​​2-稳定性判据​​" class="headerlink" title="​​2. 稳定性判据​​"></a>​<strong>​2. 稳定性判据​</strong>​</h4><ul><li>​<strong>​相位裕度​</strong>​：ϕm​&#x3D;180°−∠Aβ(fc​)（要求&gt;45°）</li><li>​<strong>​增益裕度​</strong>​：∣Aβ(f180​)∣&lt;1</li></ul><h3 id="频率响应​​"><a href="#频率响应​​" class="headerlink" title="频率响应​​"></a><strong>频率响应​</strong>​</h3><h4 id="​​1-单极点系统​​"><a href="#​​1-单极点系统​​" class="headerlink" title="​​1. 单极点系统​​"></a>​<strong>​1. 单极点系统​</strong>​</h4><ul><li>​<strong>​3dB带宽​</strong>​：fH​&#x3D;2πReq​Ceq​1​</li><li>​<strong>​主极点近似​</strong>​：主导极点决定系统带宽</li></ul><h4 id="​​2-密勒效应​​"><a href="#​​2-密勒效应​​" class="headerlink" title="​​2. 密勒效应​​"></a>​<strong>​2. 密勒效应​</strong>​</h4><ul><li>​<strong>​电容倍增​</strong>​：Cin​&#x3D;Cgd​(1+∣Av​∣)</li><li>​<strong>​高频限制​</strong>​：fT​&#x3D;2π(Cgs​+Cgd​)gm​​</li></ul>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>模拟电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>放大器设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建OutlineVPN</title>
    <link href="/Blogs/2025/08/28/%E6%90%AD%E5%BB%BAOutlineVPN/"/>
    <url>/Blogs/2025/08/28/%E6%90%AD%E5%BB%BAOutlineVPN/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-如何搭建Outline-VPN科学上网date-2020-04-03-15-17-03tags-工具categories-技术"><a href="#title-如何搭建Outline-VPN科学上网date-2020-04-03-15-17-03tags-工具categories-技术" class="headerlink" title="title: 如何搭建Outline-VPN科学上网date: 2020-04-03 15:17:03tags:- 工具categories: 技术"></a>title: 如何搭建Outline-VPN科学上网<br>date: 2020-04-03 15:17:03<br>tags:<br>- 工具<br>categories: 技术</h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Coronavirus期间回国，在网上继续上学校网课，需要使用Google docs还有Youtube. 幸好自己提前在米国部署了威PN。。。然后感觉写个科学上网指南是国内博客基操，就顺便写写。</p><p>注：科学上网一定是学习使用，不要不注意身体😯</p><span id="more"></span><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><p>Macos系统</p><p>5美元（支付宝）</p><p>有一定Terminal（终端）的基础</p><p>一个可以用的云主机（需要地址在国外）</p><p>注意，vultr可能需要翻墙后才能访问，建议大家在mac上下载<strong>windscribe</strong>之后蹭免费流量搞一波</p><h2 id="购置服务器"><a href="#购置服务器" class="headerlink" title="购置服务器"></a>购置服务器</h2><p>打开<a href="https://www.vultr.com/">Vult官网</a></p><p><img src="https://s1.ax1x.com/2020/04/04/GdBCLQ.png" alt="vultr"></p><p>注册就不用我多讲了吧。。。</p><p>然后这个是要充值10美元好像</p><p>不过比市面上的vpn便宜多了吧</p><p>而且云电脑还有很多其他的事可以干（立Flag）</p><p>进入账户后，点击products</p><p>点右上角</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0OII.png" alt="Server1"></p><p>然后选择<strong>服务器</strong></p><p>默认<strong>Cloud Compute</strong></p><p>我选的是<strong>新加坡</strong>的服务器</p><p>因为离中国近…</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0jit.png" alt="Server2"></p><p>然后Debian服务器</p><p>选5美元一月的就好</p><p>10美元太<strong>奢侈</strong></p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0vJP.png" alt="Server3"></p><p>其他设置都别管</p><p>默认</p><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><h3 id="远程连接主机"><a href="#远程连接主机" class="headerlink" title="远程连接主机"></a>远程连接主机</h3><p>回到Product</p><p>点击刚添加好的服务器</p><p>会弹出以下页面</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0xRf.png" alt="Server4"></p><p>点击眼睛查看<strong>ip password</strong></p><p>然后将<strong>IP Adress</strong>复制下来之后</p><p>打开terminal</p><p>右键点击Terminal图标</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0zz8.png" alt="Terminal1"></p><p>点击弹出窗口中的➕加号</p><p><img src="https://s1.ax1x.com/2020/04/04/GdBpQS.png" alt="Terminal2"></p><p>在前面加上一个ssh就可以点击链接</p><p><strong>User记得填 root</strong></p><p>看图</p><p><img src="https://s1.ax1x.com/2020/04/04/GdB9sg.png" alt="Terminal3"></p><h3 id="Outline准备"><a href="#Outline准备" class="headerlink" title="Outline准备"></a>Outline准备</h3><p><a href="https://www.getoutline.org/">Outline</a> 是一款基于 ss 的开源富强软件，来自于 Jigsaw 公司，致力于供新闻组织用自家服务器上设定从而富强，来保障新闻工作者的网络存储安全，并且号称不需要技术人员就能完成部署。</p><p>Jigsaw 前身为 Google Ideas，是 Google 旗下的技术孵化器公司，目标是以技术来客服全球的安全难题，包括地址网络神茶制度、降低网络攻击的威胁，以及防止大众收到网络骚扰等。Outline 即为 Jigsaw 的专案成果之一。</p><p>去官网下载<strong>Outline Manager</strong>之后（官网地址上方超链接）</p><p>国内点不进去。。。</p><p><del>用windscribe蹭</del></p><p>mac用户建议去app store搜索</p><p>windows还有Linux可以去Github找</p><p>（找不到的可以私信博主）</p><p>下载Outline Manager打开</p><p>点击➕加号</p><p>随便选一个进去（误</p><p><strong>别选第一个就对了</strong></p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0qZd.png" alt="Outline1"></p><p>可以看到这个</p><p>然后跟着指示走</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0LdA.png" alt="Outline2"></p><h3 id="SSH安装"><a href="#SSH安装" class="headerlink" title="SSH安装"></a>SSH安装</h3><p>回到先前的ssh链接窗口</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>Centos 7.4 64 位 安装 Docke</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum update  <br>curl -fsSL https://get.docker.com/ | sh   <br><span class="hljs-built_in">sudo</span> service docker start   <br><span class="hljs-comment">#验证 docker 是否安装成功并在容器中执行一个测试的镜像 </span><br><span class="hljs-built_in">sudo</span> docker run hello-world<br><br></code></pre></td></tr></table></figure><p>Ubuntu 17.04 ×64 Docker</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">apt-get install curl   <br>sudo apt update   <br>sudo apt install apt-transport-https ca-certificates curl software-properties-common   <br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key<span class="hljs-built_in"> add </span>–   <br>sudo<span class="hljs-built_in"> add-apt-repository </span><span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span>   <br>sudo apt update   <br>sudo apt -y install docker-ce<br></code></pre></td></tr></table></figure><h4 id="安装Outline在虚拟机上"><a href="#安装Outline在虚拟机上" class="headerlink" title="安装Outline在虚拟机上"></a>安装Outline在虚拟机上</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -qO- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/Jigsaw-Code/</span>outline-server<span class="hljs-regexp">/master/</span>src<span class="hljs-regexp">/server_manager/i</span>nstall_scripts/install_server.sh | bash<br></code></pre></td></tr></table></figure><p>会出现下列代码</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd07se.png" alt="Outline4"></p><p>复制URL</p><p>然后粘贴进Outline Manager</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>这个时候在手机还有电脑上下载Outline</p><p>方法不赘述</p><p>你能下载manager肯定可以下载这个</p><p>点击加号</p><p>加号在哪里看下面第二张图片</p><p>然后输入它生成的Access key</p><p>大功告成</p><p>不得不舔一下Outline真的好看</p><p>简洁无广告。。。</p><p>Manager：</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0HqH.png" alt="Outline3"></p><p>Server</p><p><img src="https://s1.ax1x.com/2020/04/04/Gd0TMD.png" alt="Outline5"></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搭建OutlineVPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路</title>
    <link href="/Blogs/2025/08/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    <url>/Blogs/2025/08/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>[[1数字电路基础（数字编码与逻辑]]</p><p>[[2时序电路设计]]</p><p>[[2组合电路设计]]</p><p>[[3硬件实现技术（MSI与Verilog]]</p><p>[[4存储器体系（拓展]]</p><p>讲数字IC之前，先讲讲数字和模拟之间的区别。</p><ul><li>数字和<a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF&zhida_source=entity">模拟电路</a>都是用来处理信号的</li><li>模拟信号是连续变化的，数字信号是非连续的</li><li>模拟电路所要处理的信号，是直接来自自然界的，例如光、声音、电磁波等等</li><li>数字电路所处理的信号，要么来自模拟电路采样之后的0101，或者来自其他数字电路</li></ul><h3 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a><strong>需求阶段</strong></h3><p>产品的需求是随着时代的发展变化的。<br>从早期的收音机，黑白电视，个人电脑，但后面的手机，多媒体设备，网络设备等等。  </p><p><img src="https://pic2.zhimg.com/v2-de3e37044a7f64f085c0b07d201b7703_1440w.jpg"></p><p>产品需求的变迁</p><p>产品需求的增加，也推动着芯片规模的不断扩张<br>数字IC（Integrated Circuit）规模划分是指将数字IC根据其晶体管数量或门数等特征进行分级，以便快速识别和比较芯片的复杂度和功耗。根据规模的不同，数字IC可以分为Small Scale Integration（<a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=SSI&zhida_source=entity">SSI</a>）、Medium Scale Integration（<a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=MSI&zhida_source=entity">MSI</a>）、Large Scale Integration（<a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=LSI&zhida_source=entity">LSI</a>）、Very Large Scale Integration（<a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=VLSI&zhida_source=entity">VLSI</a>）和Ultra Large Scale Integration（<a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=ULSI&zhida_source=entity">ULSI</a>）等几个不同的等级。  </p><p><img src="https://pic3.zhimg.com/v2-c36abf44d5ad0504731aa79c5d29d796_1440w.jpg"></p><p>晶体管数量的增长</p><ul><li><strong>SSI</strong><br>  通常指的是由1-10个逻辑门组成的集成电路，主要应用于数字时钟、计数器等简单电路；</li><li><strong>MSI</strong><br>  通常由10-100个逻辑门组成，主要应用于加法器、译码器、多路复用器等中等复杂的电路设计；</li><li><strong>LSI</strong><br>  通常由100-1000个逻辑门组成，主要应用于存储器、微处理器等更为复杂的电路设计；</li><li><strong>VLSI</strong><br>  通常由上千万个晶体管或甚至更多的逻辑门组成，主要应用于高速低功耗的微处理器、DSP等大规模复杂电路设计；</li><li><strong>ULSI</strong><br>  通常包含数十亿个晶体管，在现代CPU、GPU、FPGA等芯片的制造中被广泛应用。</li></ul><h3 id="规格制定"><a href="#规格制定" class="headerlink" title="规格制定"></a><strong>规格制定</strong></h3><p><img src="https://pic1.zhimg.com/v2-0a0f51a213514e3dbaabc97227d6ecb2_1440w.jpg"></p><p>intel i9 规格</p><p>规格的定制，可以从如下几个方面考虑：</p><ul><li>功能需求：规定 IC 芯片的功能和操作方式，包括输入、输出、时序、控制等方面的要求。</li><li>性能需求：规定 IC 芯片的性能指标，如工作频率、功耗、时延、抖动、误码率等参数。</li><li>特殊需求：特殊应用场景下的需求，如在高温、高压、低温、低电压等情况下的工作要求。</li><li>规格限制：指定 IC 芯片的物理限制，如大小、尺寸、引脚排布等要求。</li><li>接口要求：规定 IC 芯片与其他器件之间的物理和电学接口要求，如信号电平、阻抗、通信协议等。</li><li>可测试性要求：规定 IC 芯片测试的方法和要求，包括测试点的位置、测试时间、测试程序等。</li><li>生产要求：规定 IC 芯片的生产过程和质量控制要求，包括生产流程、工艺参数、测试标准等。</li><li>兼容性要求：规定 IC 芯片与其他设备和系统的兼容性要求，确保芯片能够与其他设备和系统进行交互操作。</li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a><strong>架构设计</strong></h3><p><img src="https://pic1.zhimg.com/v2-99f5ecfd1363f50525c23aa3b793e7c0_1440w.jpg"></p><p>架构设计</p><p>CPU 芯片设计的架构可以分为以下几个模块：<br>控制单元（Control Unit）：控制单元是中央处理器的核心部分，它主要负责控制整个 CPU 的操作，包括指令解码、指令寻址、分支控制、时序控制等。<br>算术逻辑单元（Arithmetic Logic Unit，ALU）：算术逻辑单元是 CPU 的重要部件，它主要负责各种算术和逻辑运算（如加、减、乘、除、与、或、非、异或等）。<br>存储单元（Memory Unit）：存储单元是 CPU 的重要组成部分，它主要负责 CPU 与主存储器和缓存之间的数据传输和交换。其中，缓存主要用于提高 CPU 访问主存储器的速度。<br>输入输出接口（I&#x2F;O Interface）：输入输出接口是 CPU 与外部设备进行通信的接口，它主要用于管理数据的输入输出，包括串口、并口、USB、网卡等接口。<br>浮点运算单元（Floating-point Unit，FPU）：浮点运算单元主要用于执行浮点运算任务，如科学计算、图形处理、音视频编解码等。<br>上述模块之间通过适当的接口和通信机制连接在一起，形成完整的 CPU 芯片的架构。  </p><h3 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a><strong>行为描述</strong></h3><p><img src="https://pic2.zhimg.com/v2-9b263b025f0dff8ebd7a555b3560eabb_1440w.jpg"></p><p>数字IC行为描述</p><p>VLSI (Very Large Scale Integration) 行为描述是指在数字 IC （集成电路）设计中，使用高级编程语言或其他形式的抽象化语言来描述数字电路的行为、功能、性能和约束等，并将其转换为实际的物理设计。该技术可以提供高层次的设计抽象和模块化设计方法，可以使设计工程师更加专注于设计的核心问题，提高设计效率和准确性。<br>在 VLSI 行为描述中，一般会包括以下元素：</p><ul><li>模块 (Module)：VLSI 设计通常由一个个模块组成，每个模块对应一个特定的逻辑功能。</li><li>输入 (Input)：模块外部输入的信号。</li><li>输出 (Output)：模块输出的信号。</li><li>内部信号 (Signal)：模块内部使用的信号，通常不直接与模块外交互。</li><li>寄存器 (Register)：用于存储状态的元素，通常用于时序相关的设计中。</li><li>电路组件 (Component)：由基本电路组件连接而成的电路部件，如门电路、触发器等。</li></ul><h3 id="RTL实现"><a href="#RTL实现" class="headerlink" title="RTL实现"></a><strong>RTL实现</strong></h3><p><img src="https://pic1.zhimg.com/v2-d91fc3af135dae212386adf845c838c8_1440w.jpg"></p><p>RTL实现</p><p><a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=RTL%E8%AE%BE%E8%AE%A1&zhida_source=entity">RTL设计</a>是数字电路设计的一种方法，它是基于寄存器传输级（Register Transfer Level）的设计方法。RTL设计要点如下：<br>了解同步电路的设计要求：同步电路是由时钟信号控制操作的电路，因此在RTL设计中也需要遵循同步电路的设计要求，例如流水线结构、寄存器插入等。<br>理解寄存器传送级的概念：RTL设计采用寄存器传送级表示状态转换和数据传输，设计人员需要对各个寄存器的角色和作用进行深入理解，以确保正确的数据传输和状态转换。<br>合理划分模块：在RTL设计中，不同功能的模块应该被合理地划分为子模块，以便于设计人员进行模块级别的测试和调试。<br>优化逻辑电路：在RTL设计中，需要优化逻辑电路以降低时延、功耗和面积。其中包括使用合适的逻辑门、避免冗余逻辑、减少时钟周期等。<br>遵循设计规范：RTL设计需要遵循一定的设计规范和标准，例如IEEE标准和公司内部的设计规范，以确保设计的正确性和可靠性。<br>模拟和验证：在RTL设计完成之后，需要进行模拟和验证测试以确保功能的正确性和稳定性。这个过程通常包括模拟验证、仿真测试、硬件验证等。  </p><h3 id="功能验证"><a href="#功能验证" class="headerlink" title="功能验证"></a><strong>功能验证</strong></h3><p><img src="https://pic2.zhimg.com/v2-292ffa45cbcb0a007529d2ed4eefcc67_1440w.jpg"></p><p>功能验证</p><p>数字芯片功能验证的要点包括：<br>功能规格：根据数字芯片的设计目标和需求，制定详细的功能规格，明确数字芯片应该实现的各项功能。<br>测试计划：制定测试计划，包括测试用例的编写、测试流程的设计、测试覆盖率的评估等。<br>功能仿真：使用仿真工具对数字芯片进行功能仿真，检测数字芯片的逻辑功能是否符合预期，包括输入输出信号的波形、时序等。<br>时序约束：在设计数字芯片时，需要设置各种时序约束，如时钟频率、数据传输时序等，测试时也需要注意这些时序约束。<br><a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=%E8%BE%B9%E7%95%8C%E6%89%AB%E6%8F%8F&zhida_source=entity">边界扫描</a>：边界扫描是一种常用的数字电路测试方法，通过向数字芯片的组合逻辑引入扫描链，将数字芯片的内部状态导出到芯片的边界上进行观测和控制，方便测试人员对数字芯片进行调试和验证。<br>异常情况测试：数字芯片在实际应用中可能会遇到各种异常情况，如电压变化、温度变化、电磁干扰等，因此在测试时也需要考虑这些异常情况的测试。  </p><h3 id="逻辑综合"><a href="#逻辑综合" class="headerlink" title="逻辑综合"></a><strong>逻辑综合</strong></h3><p><img src="https://pic1.zhimg.com/v2-ec9eec4f9e92185f02dee22151ee74e0_1440w.jpg"></p><p>逻辑综合</p><p>VLSI 逻辑综合步骤通常包括以下几个方面：<br>设计输入文件。设计人员通常使用硬件描述语言 (HDL)，如 VHDL 或 Verilog，来描述数字电路的逻辑功能。<br>代码分析和优化。在这一阶段，逻辑综合工具会对设计进行分析和优化，以便将其转换为更高效的门级电路。<br>门级综合。在这一阶段，逻辑综合器将将高级描述的电路转换为经过优化的门级电路，同时生成一个门级网表 (netlist) 文件。<br>时序约束和时序分析。对于大型电路，逻辑综合工具需要施加时序约束以确保电路能够正确地运行。时序分析则是检查电路的时序需求是否得到满足。<br>布局布线。在这一阶段，电路的物理布局和连线被确定。最终的产品质量和性能与此阶段的设计相关。  </p><h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a><strong>布局优化</strong></h3><p><img src="https://pic4.zhimg.com/v2-9170fb7715139af74764200fb2e97f3b_1440w.jpg"></p><p>placement</p><p><strong><a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=VLSI+placement&zhida_source=entity">VLSI placement</a></strong><br>不仅仅是将综合电路网表中的标准单元进行放置，还要对设计进行优化，也要考虑布线的可行性。放置的标准多样，有时间驱动、拥堵驱动和功率优化等不同的驱动方式。<br>在这个过程中，有一些注意事项需要遵守以确保成功的放置。首先考虑的是能够满足时序约束；其次是减小拥堵并最小化面积；第三是通过统计阻力方案来优化功耗，以及其他一些与特定应用相关的指标。<br>因此，VLSI placement的注意事项包括但不限于如下内容：</p><ul><li>满足时序约束</li><li>降低拥堵并最小化面积</li><li>优化功耗</li><li>根据特定应用调整策略</li></ul><p><strong><a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=VLSI+routing&zhida_source=entity">VLSI routing</a></strong><br>的主要目标是在放置时最小化芯片面积的同时满足电路性能指标。与 VLSI placement 类似，VLSI routing 也有许多注意事项需要遵守。<br>电路特性的保持。将电路移植到芯片上后，必须确保其内部结构不受破坏。因此，布线必须符合时序和信号完整性要求，例如最小化电源噪声、抑制串扰等。<br>路由规划。芯片中的路由路径必须进行正确规划，以避免出现拥堵或冲突。可以通过特定的算法来规划路由，例如迭代加深搜索 (IDS)、通路搜素 (Rip-up and Retry) 等。<br>优化布线。在进行布线时，需要根据具体的电路性能要求优化芯片布线。这包括提高路由速度以及减少路由的功耗和面积。<br>关注散热问题。芯片内部布线可能会导致电子设备产生很高的温度，这可能会影响电路的稳定性和寿命。因此，需要考虑热建模、散热技术和电源供应等问题，以确保芯片可以稳定运行。  </p><h3 id="时序分析"><a href="#时序分析" class="headerlink" title="时序分析"></a><strong>时序分析</strong></h3><p><img src="https://pic2.zhimg.com/v2-fb365f8c3d17b32ff914e1716576fa03_1440w.jpg"></p><p>sta</p><p>VLSI 时序分析的主要目标是确保芯片的逻辑与时序符合设计需求。<br>时钟分析。VLSI 设计中，时钟信号通常用来触发各个模块的操作。因此，对时钟信号的分析至关重要，需要确保它的频率和相位符合设计要求，同时不会产生过多的抖动。<br>延迟分析。在 VLSI 设计中，延迟会影响信号的稳定性和精确性。因此，需要进行延迟分析来确定各个模块之间传输数据所需的最大时延和最小时延等参数。<br>时序修复。在时序分析过程中，可能会出现一些违反时序约束的情况。为了解决这些问题，需要采取不同的时序修复策略，例如添加缓存器、修改时序约束等。<br>时序约束管理。在 VLSI 设计中，时序约束可以帮助工具理解设计规范。因此，需要管理时序约束，以确保其准确性和一致性  </p><h3 id="版图后验证"><a href="#版图后验证" class="headerlink" title="版图后验证"></a><strong>版图后验证</strong></h3><p><img src="https://pic1.zhimg.com/v2-a09beab9d8e800e10908e9d359f59f52_1440w.jpg"></p><p>layout</p><p>VLSI 验证流程主要包括 planning、execution、measurement 和 response 四个阶段。</p><ul><li>planning 阶段决定了需要进行哪些验证工作以及如何衡量验证的完成情况；</li><li>execution 阶段实际进行验证测试并记录结果；</li><li>measurement 阶段对测试结果进行分析和评估，检查是否满足设计需求；</li><li>response 阶段根据前三个阶段的结果反馈给设计人员，可能需要进行迭代优化。<br>  VLSI 验证技术包括仿真验证、物理验证以及后仿真验证三个方面。</li><li>仿真验证是通过计算机软件模拟电路行为、性能和可靠性，以验证电路是否按预期工作；</li><li>物理验证是将电路设计进行物理实验和测试，以验证电路是否符合物理性能和特性；</li><li>后仿真验证是通过将集成电路安装在目标系统中进行测试，以验证系统的性能和功能是否符合要求。</li></ul><h3 id="制造"><a href="#制造" class="headerlink" title="制造"></a><strong>制造</strong></h3><p><img src="https://picx.zhimg.com/v2-73682eaa1bbfe98500d581d8b705173d_1440w.jpg"></p><p>光刻制作流程</p><p>VLSI制造技术是在一个芯片上集成数十亿的晶体管，可以用于制造微处理器、内存等电子元件。其制造要点包括：<br><a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=CMOS%E5%B7%A5%E8%89%BA&zhida_source=entity">CMOS工艺</a>：CMOS是一种互补金属氧化物半导体技术，它使用p型和n型场效应晶体管来实现电路功能，具有低功耗、可靠性高等优点。<br><a href="https://zhida.zhihu.com/search?content_id=226029679&content_type=Article&match_order=1&q=%E5%85%89%E5%88%BB%E6%8A%80%E6%9C%AF&zhida_source=entity">光刻技术</a>：光刻技术是一种将芯片图案转移到硅片表面的方法，主要用于制作集成电路的图案和结构。<br>金属蒸发和化学气相沉积技术：这两种技术是制作集成电路金属导线的关键方法，可以制作出高精度的电路结构。<br>衬底材料：衬底材料是制造VLSI芯片的基本材料，目前主要采用的是单晶硅衬底。<br>清洗和检测：在制造过程中需要进行清洗和检测，以确保芯片质量和可靠性。  </p><h3 id="封装测试"><a href="#封装测试" class="headerlink" title="封装测试"></a><strong>封装测试</strong></h3><p><img src="https://pic3.zhimg.com/v2-24e23b317f46e1c996d7509772e29312_1440w.jpg"></p><p>封装</p><p>VLSI 后仿验证是指将集成电路芯片安装在目标系统中进行测试，以验证系统的性能和功能是否符合预期要求。<br>后仿验证一般包括三个步骤：芯片采样、芯片封装以及芯片测试。</p><ul><li>芯片采样是指从生产线上随机选取样品进行测试；</li><li>芯片封装是将芯片放入特定的外壳中以便于在实际系统中使用；</li><li>芯片测试是将芯片放入测试板或测试设备中进行电气和功能测试，以验证电路和系统是否在目标系统中工作正常。<br>  后仿验证需要先进行前仿验证，即在芯片设计完成之后，采用计算机仿真软件模拟电路行为、性能和可靠性，以验证电路是否按照预期工作。如果前仿验证通过，就会进行后仿验证，以验证芯片在实际系统中的性能和功能是否符合要求。</li></ul>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路基础数字编码与逻辑</title>
    <link href="/Blogs/2025/08/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E9%80%BB%E8%BE%91/"/>
    <url>/Blogs/2025/08/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、数字系统基础"><a href="#一、数字系统基础" class="headerlink" title="一、数字系统基础"></a>一、数字系统基础</h3><ol><li><p>​<strong>​数制与编码​</strong>​</p><ul><li>进制转换：r进制↔十进制（整数除r取余&#x2F;小数乘r取整）</li><li>[[位运算]]</li><li>特殊编码：<ul><li>BCD码（8421&#x2F;2421）</li><li>格雷码（相邻码仅1位不同）</li><li>余3码（二进制值&#x3D;十进制+3）</li><li>自补码（如2421码）</li></ul></li></ul></li><li><p>​<strong>​二进制运算​</strong>​</p><ul><li>有符号数表示：补码&#x3D;反码+1</li><li>溢出判断：同号相加得异号</li></ul></li></ol><h3 id="二、逻辑代数与电路设计"><a href="#二、逻辑代数与电路设计" class="headerlink" title="二、逻辑代数与电路设计"></a>二、逻辑代数与电路设计</h3><ol><li><p>​<strong>​逻辑门基础​</strong>​</p><ul><li>基本门：AND&#x2F;OR&#x2F;NOT</li><li>复合门：NAND&#x2F;NOR&#x2F;XOR&#x2F;XNOR</li><li>德摩根定律：¬(A∧B)&#x3D;¬A∨¬B</li></ul></li><li><p>​<strong>​逻辑函数简化​</strong>​</p><ul><li>卡诺图法（2^n单元格，格雷码排列）</li><li>代数化简：吸收律&#x2F;覆盖律&#x2F;幂等律</li><li>冒险消除：静态冒险（添加冗余项）</li></ul></li><li><p>​<strong>​组合电路设计​</strong>​</p><ul><li>标准形式：<ul><li>SOP（最小项之和）</li><li>POS（最大项之积）</li></ul></li><li>功能模块：<ul><li>加法器（全加器&#x2F;超前进位）</li><li>多路选择器（MUX）</li><li>编码器&#x2F;译码器</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字电路基础数字编码与逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学</title>
    <link href="/Blogs/2025/08/28/%E6%95%B0%E5%AD%A6/"/>
    <url>/Blogs/2025/08/28/%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>数学通识讲义奠定基础数学基础 [[数学通识讲义]]</p><p>[[Latexit使用方法]]</p><p>[[数学建模]]</p><p>[[高等数学]]</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字篇</title>
    <link href="/Blogs/2025/08/28/%E6%95%B0%E5%AD%97%E7%AF%87/"/>
    <url>/Blogs/2025/08/28/%E6%95%B0%E5%AD%97%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="数学的发展"><a href="#数学的发展" class="headerlink" title="数学的发展"></a>数学的发展</h1><h2 id="当前的难题"><a href="#当前的难题" class="headerlink" title="当前的难题"></a>当前的难题</h2><p>根源在于人类直观的认识于数学内在逻辑的矛盾</p><h2 id="新的工具"><a href="#新的工具" class="headerlink" title="新的工具"></a>新的工具</h2><p>在一个封闭的数学体系内无法做到一致性与完整，体系内所遇到的漏洞，在体系内是无法弥补的，所以需要找到新的工具，来使人类的认知范围扩大</p><h2 id="新的难题"><a href="#新的难题" class="headerlink" title="新的难题"></a>新的难题</h2><p>扩大后仍然会遇到新的难题，就需要再扩大</p><h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><h2 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h2><p>方程是一种工具，将原来用自然语言描述的数学问题变成数学上的等式</p><p>方程也是思维上的改变，本质上是逆向思维</p><h2 id="虚数"><a href="#虚数" class="headerlink" title="虚数"></a>虚数</h2><p>在推导三元一次方程时引入</p><p>本质上是抽象思维的能力</p><p>三个作用：</p><ul><li>完善数学体系</li><li>完善极坐标</li><li>许多物理引用的需要虚数</li></ul><h2 id="无穷大与无穷小"><a href="#无穷大与无穷小" class="headerlink" title="无穷大与无穷小"></a>无穷大与无穷小</h2><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><p>旅馆悖论：无限多房间的旅馆，可以无限移走房间，创造新的房间（无穷大加一还是无穷大）</p><h3 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h3><p>满足两个条件</p><ul><li>不是零</li><li>绝对值小于任何一个给定的数</li></ul><p>芝诺悖论：</p><ul><li>二分法悖论：A点到B点是不可能的（要到B点必结果中点，中点有无数个）</li><li>阿克琉斯悖论：阿克琉斯追不上乌龟</li><li>飞箭不动悖论：射出去的箭在一个时刻是静止的，时间由每一个时刻构成，所以箭是静止的</li><li>基本空间与相对运动悖论：两匹马跑的总距离等于一匹马的总距离</li></ul><p>比较无穷量：</p><p>看变化的趋势谁快</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>动态思维，定量思维</p><p>从无限逼近某个趋势的观点——》使用ε表示任意小的正数</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模</title>
    <link href="/Blogs/2025/08/28/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    <url>/Blogs/2025/08/28/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数学建模竞赛入门攻略（1）"><a href="#数学建模竞赛入门攻略（1）" class="headerlink" title="数学建模竞赛入门攻略（1）"></a>数学建模竞赛入门攻略（1）</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>优化类，预测类，评价类以及机理分析类<br><img src="https://pic2.zhimg.com/80/v2-c50208cdbec863245b312afdd1c32229_1440w.jpg"></p><ul><li><p>可以看出其实纯预测类和评价类的题目几乎已经很少啦，近几年的国赛题目都是一道机理分析类的题目和一道优化类的题目。  </p></li><li><p>其实不难理解，纯预测或者评价类题目都是一些套用的方法，比如预测类的灰色预测，BP预测等等，很难真正锻炼学生的建模和思考能力。  </p></li><li><p>机理分析+优化类的题目能够针对一个实际问题，利用所学知识建立数学模型，再利用数学方法进行求解，能够真正锻炼学习的建模能力和求解能力。</p></li></ul><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><p> MATLAB：数模的全能战士，优化类的算法，评价类的算法其实都可以编写，这也是参加数模前必须要了解的软件，缺点就是算法编写起来有时候比较复杂。<br>Lingo：主要用于求解一些线性优化，小型的非线性优化问题，优点是入门很容易，程序通俗易懂，缺点求解大规模优化问题速度较慢。<br>SPSS：主要用于求解评价类问题，比如层次分析法，主成分分析法等等，可以直接在SPSS用，不用编程。<br>CPLEX+yalmip：这个软件其实是我研究生才了解到的，Cplex是商业软件，可以直接在matlab中调用，在一些大规模的优化问题时可以有效提高求解速度。<br>Origin&#x2F;Visio：绘图软件，Visio主要用于绘制流程图，Origin绘图功能超级强大，比直接在MATLAB中绘图要好看的多。好看的排版和图片也是拿奖的很重要的条件呢。<br>Word&#x2F;LATEX：排版软件，就不多介绍了。一般来说，word就足够了。  </p><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><ul><li>关于数模所需的算法，其实网上已经总结过关于数学建模的十类算法，就是如下图所示：</li></ul><p><img src="https://pic4.zhimg.com/80/v2-fbfa1f7f5caec54a57064fe7c000630b_1440w.jpg"></p><p>数模常用的问题针对性<br><img src="https://pic2.zhimg.com/80/v2-7f69deaee5d6ff8da12650317bf9dd89_1440w.jpg"></p><p> <img src="https://pic4.zhimg.com/80/v2-1d01fd60ad73c4bedfc574bbc90aca2b_1440w.jpg"></p><p> 在看最近几年的优秀论文的时候，发现其实近几年许多题目的求解都采用的纯数学的方法，比如微分方程的求解等。所以如果有时间可以提前看一下数值分析这本书</p><ul><li>而对于大家一直迷恋的神算法：“模拟退火，粒子群，遗传算法”等几乎用不到，大家随便贴个智能算法原理，在去copy程序，甚至都不管程序能不能通的方法，真的已经行不通啦</li><li>切记不要迷恋智能算法！！！</li></ul><h2 id="如何分工"><a href="#如何分工" class="headerlink" title="如何分工"></a>如何分工</h2><p>一般一个队需要一个擅长建模的，一个擅长求解的，一个擅长写作的。当然更好的是两个人擅长建模，两个人擅长求解，建模和求解本来就很难分开，两个人可以相互合作（要有耐心</p><h2 id="如何论文撰写以及推荐书籍？"><a href="#如何论文撰写以及推荐书籍？" class="headerlink" title="如何论文撰写以及推荐书籍？"></a>如何论文撰写以及推荐书籍？</h2><p>基本都包括这几步：<br><img src="https://pic1.zhimg.com/80/v2-2c5dff77e5b43a26f17ad0ed3fd55e60_1440w.jpg"></p><p>我的内容</p><p>[[Matlab入门]]</p><p>[[Matlab计算]]</p><p>[[Matlab高级教程]]</p><p>[[优化理论]]</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学通识讲义</title>
    <link href="/Blogs/2025/08/28/%E6%95%B0%E5%AD%A6%E9%80%9A%E8%AF%86%E8%AE%B2%E4%B9%89/"/>
    <url>/Blogs/2025/08/28/%E6%95%B0%E5%AD%A6%E9%80%9A%E8%AF%86%E8%AE%B2%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>[[01基础篇]]</p><p>[[02数字篇]]</p><p>[[03几何篇]]</p><p>[[04代数篇]]</p><p>[[05微积分基本概念]]</p><p>[[06概率与数理统计篇]]</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学通识讲义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晶体管元件设计</title>
    <link href="/Blogs/2025/08/28/%E6%99%B6%E4%BD%93%E7%AE%A1%E5%85%83%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E6%99%B6%E4%BD%93%E7%AE%A1%E5%85%83%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>设计 [[04器件物理核心]]</p><h3 id="半导体基础​​"><a href="#半导体基础​​" class="headerlink" title="半导体基础​​"></a><strong>半导体基础​</strong>​</h3><h4 id="​​1-半导体材料​​"><a href="#​​1-半导体材料​​" class="headerlink" title="​​1. 半导体材料​​"></a>​<strong>​1. 半导体材料​</strong>​</h4><table><thead><tr><th>​<strong>​类型​</strong>​</th><th>​<strong>​特性​</strong>​</th><th>​<strong>​实例​</strong>​</th></tr></thead><tbody><tr><td>本征半导体</td><td>纯晶体结构（Si&#x2F;Ge），热激发产生电子-空穴对</td><td>硅晶体</td></tr><tr><td>P型半导体</td><td>掺入Ⅲ族元素（如硼），空穴为多子</td><td>硼掺杂硅</td></tr><tr><td>N型半导体</td><td>掺入Ⅴ族元素（如磷），电子为多子</td><td>磷掺杂硅</td></tr></tbody></table><h4 id="​​2-PN结特性​​"><a href="#​​2-PN结特性​​" class="headerlink" title="​​2. PN结特性​​"></a>​<strong>​2. PN结特性​</strong>​</h4><ul><li>​<strong>​形成机制​</strong>​：扩散→耗尽区→内建电场（V0​≈0.7V）</li><li>​<strong>​偏置状态​</strong>​：<ul><li>​<strong>​正向偏置​</strong>​：Vext​&lt;V0​ → 扩散电流主导（指数增长）</li><li>​<strong>​反向偏置​</strong>​：Vext​&gt;V0​ → 漂移电流极小（饱和电流IS​）</li></ul></li></ul><p>[[PN结]] 和 [[MOSFET]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>模拟电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晶体管元件设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序电路设计</title>
    <link href="/Blogs/2025/08/28/%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="时序电路设计"><a href="#时序电路设计" class="headerlink" title="时序电路设计"></a>时序电路设计</h3><ol><li><p>​<strong>​存储元件​</strong>​</p><ul><li>锁存器（电平触发）：<ul><li>SR锁存器（NOR&#x2F;NAND实现）</li><li>D锁存器（透明锁存）</li></ul></li><li>触发器（边沿触发）：<ul><li>D触发器（寄存器基础）</li><li>JK触发器（具有翻转功能）</li><li>T触发器（计数专用）</li></ul></li></ul></li><li><p>​<strong>​时序电路分析​</strong>​</p><ul><li>状态方程：<ul><li>激励方程（输入逻辑）</li><li>转移方程（次态函数）</li><li>输出方程（Moore&#x2F;Mealy）</li></ul></li><li>状态转换图&#x2F;表</li></ul></li><li><p>​<strong>​典型时序模块​</strong>​</p><ul><li>计数器（同步&#x2F;异步）</li><li>移位寄存器（SISO&#x2F;PIPO）</li><li>有限状态机设计</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时序电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机械硬盘的原理与参数详解</title>
    <link href="/Blogs/2025/08/28/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <url>/Blogs/2025/08/28/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="数字存储完全指南-02：机械硬盘的原理与参数详解"><a href="#数字存储完全指南-02：机械硬盘的原理与参数详解" class="headerlink" title="数字存储完全指南 02：机械硬盘的原理与参数详解"></a>数字存储完全指南 02：机械硬盘的原理与参数详解</h1><p>我们希望通过最简洁通俗的描述，带领大家了解信息储存设备的基本原理，知道那些复杂的参数，如何挑选购买适合自己的存储设备，又是如何更好地使用，更安全稳定地保存我们的数据，以及未来我们能够用上什么技术。 另本系列虽然与 aigo 联合发起，但所有内容不涉及任何品牌指导或要求的商业营销。</p><hr><p><a href="https://sspai.com/post/68711">上一章我们了解到了储存设备发展的历史，</a>认识到了人类是如何努力提升数据存储的量级与速度，我们在本篇介绍的机械硬盘的诞生，也离不开以前储存设备打下的基础。</p><p>说起储存设备，大部分人脑海中第一个闪现的估计都是机械硬盘，大部分人估计都没有想到，直到今年（2021）机械硬盘已经被人们使用大半个世纪（65 年，IBM 1956.09），即使现在固态硬盘已经普及多年，机械硬盘仍然是我们储存数据的主力。</p><p><img src="https://cdn.sspai.com/2021/09/12/b8173ce17a5321db26d3708cbd927b52.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>最初的机械硬盘</p><p>本章节就为大家来讲解我们以前很常使用，现在依然有很多人在使用的机械硬盘（HDD），了解它是如何诞生的，如何为我们工作，如何快速安全地保存大容量数据，常见的那些参数又是什么意思。为接下来的机械硬盘选购和使用指南奠定一个基础。</p><h2 id="机械硬盘的历史"><a href="#机械硬盘的历史" class="headerlink" title="机械硬盘的历史"></a>机械硬盘的历史</h2><p>机械硬盘正式被使用，应该是 1956 年 IBM 的 305 RAMAC：</p><p><img src="https://cdn.sspai.com/2021/09/12/f554eecccd25b8a9e28b8e745ddb1d6e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>IBM 305 RAMAC，就是上面那张图的完整体，图片来源：ed-thelen.org</p><p>它的体积十分庞大，基本就跟现在的双开门冰箱差不多，一吨+ 的重量容量只有 5MB 左右（据 IBM 自己的介绍，数据容量并不是不能加大，只是当时这个数据已经算是巨量，再大的话也没人买）。</p><p><img src="https://cdn.sspai.com/2021/09/12/c71ade587bc9e3fd0e19f6eb4869b05b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>IBM 还制作了它的宣传片</p><p>有了这个基础，接下来几个关键的技术都是由 IBM 或者它的员工自己创业（比如希捷 Seagate 就是 IBM 前员工创立的公司）后推出的，比如我们下面会提到的各种 MR 技术和各种尺寸的硬盘。</p><p>其实从原理上讲，我们现在日常使用的机械硬盘原理和 RAMAC 差不多，结构更是直接与 IBM 后来推出的 3340 一样，只不过利用新技术将盘片密度和磁头灵敏度做到了极致从而把体积缩小。</p><p><img src="https://cdn.sspai.com/2021/09/12/8f54df4f4e816923d4a666f388151b07.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>IBM 3340 就是现代机械硬盘的结构</p><p>IBM 3340 革新的点在于，它创新性地利用磁盘旋转产生的空气浮力，<strong>让磁头悬浮于盘片之上</strong>，从而避免了磁头对盘片的摩擦损耗，盘片也能实现更高速度的旋转从而提升读写速度。</p><p>IBM3340 有两个 30MB 的储存单元，不知道为啥跟另一个毫不相关的领域 —— .30-30 温切斯特步枪弹（美国人叫 Thirty-Thirty，前一个是口径后，一个是发射药重量，单位是格令 Krag）关联上了，然后大家都叫他温切斯特硬盘（搞不懂搞不懂～）。</p><p><img src="https://cdn.sspai.com/2021/09/12/c4a3c7628595c514d7b52f59c826b978.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>温切斯特步枪弹，大概是第 2 个，图片来源：winchester.com</p><p><strong>我们现在使用的所有机械硬盘其实跟 IBM 3340 没有任何本质上的区别，只是新技术带来的容量和速度提升而已</strong>，于是大家又把现代机械硬盘统称为做温切斯特（Winchester）硬盘。</p><p>随着磁盘容量和盘片数量以及新技术的发展，从技术上讲，机械硬盘甚至比固态硬盘还要来的精密复杂，加上固态硬盘的来袭，机械硬盘技术发展缓慢，<strong>我们现在上电商网站能买到的硬盘大部分用的还是 5,6 年前的技术</strong>。所以经过各种整合收购后，整个世界也只有 3 家机械硬盘制造商，<strong>西部数据（Western Digital）、希捷（Seagate）、东芝（Toshiba，接下来我拆的硬盘就是这个）</strong>。在之后的选购部分，我会来详细介绍一下这几家公司。</p><p><img src="https://cdn.sspai.com/2021/09/12/25bc19e53a91a42492c4a5444209ae98.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>三家公司的 Logo</p><p><strong>相关文献</strong>：<br>[1]. IBM 305 RAMAC 的<a href="http://bitsavers.trailing-edge.com/pdf/ibm/305_ramac/22-6264-1_305_RAMAC_Manual_of_Operation_Apr57.pdf">介绍和使用说明书</a>。</p><p>[2]. IBM 历史上重要的<a href="https://www.ibm.com/ibm/history/exhibits/storage/storage_magnetic.html">磁盘型号和参数列表</a>。</p><p>[3]. IBM 为 305 RAMAC 制作的宣传片 <a href="https://www.youtube.com/watch?v=zOD1umMX2s8">「ibm 305 ramac」</a></p><h2 id="机械硬盘的结构原理"><a href="#机械硬盘的结构原理" class="headerlink" title="机械硬盘的结构原理"></a>机械硬盘的结构原理</h2><p>作为最广泛使用的储存设备，加上原理和结构相对比较简单，机械硬盘（温切斯特硬盘）的物理结构和工作原理是非常容易查到的。但最直观的还是直接拆开看实物，我们找到一个坏的机械硬盘，然后把它拆开（千万别对自己的硬盘下手，拆开就坏了）。</p><p><img src="https://cdn.sspai.com/2021/09/12/30bdf49b18e12169d2fdf8ea88b1d4e3.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>机械硬盘正反面</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>观察机械硬盘，我们可以看到前面有一个<strong>金属固定板</strong>，固定板上面的螺丝自然是用来固定整个结构的，相当于一个盖子。通常关于机械硬盘的参数，都会用一张贴纸贴在固定板上，我们下面介绍的参数在实际选购的时候一般就是看这张纸。</p><p><img src="https://cdn.sspai.com/2021/09/12/609348fbd29d4b4e9041bb6968f201bd.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p> 机械硬盘的参数贴纸</p><p>这些硬盘外部另外一个需要注意的点就是<strong>通气孔</strong>，通常旁边会有<strong>不要遮盖通气孔的标注</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/f5f06806a8631f1cfdf128bfc7405c57.JPG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>就是这个小小的孔</p><p>这个孔是用来干什么的呢？学完下面机械硬盘的原理，大家就会知道机械硬盘对灰尘非常敏感，所以机械硬盘内部通常是要密封并做无尘处理，但是机械硬盘在工作时会产生热量，使内部的空气膨胀，如果整个机械硬盘完全密封，那么里面的气压就会变大，把磁头压向盘片，容易造成硬盘损坏。所以厂商会故意在机械硬盘上开一个小孔来保证内外气压平衡，但如果我们用放大镜或者显微镜观察这个孔，发现它并不是单纯的洞，也是有做防尘处理的（其实就是我们空气净化器里面的 HEPA 滤网），防止灰尘从这个孔进去。</p><p><img src="https://cdn.sspai.com/2021/09/12/2abbc695d3627e028a2ef43e19a48fa9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>显微镜下的通气孔</p><p>另外<strong>通气孔也可以用来分辨这个盘是空气盘还是氦气盘</strong>，因为氦气盘生产的时候需要充入氦气，然后用激光焊接等把硬盘完全密封起来，不能留通气孔，不然氦气就跑光了，这也是为什么大家常说氦气盘很难做数据恢复，因为一旦开盘基本报废，至于为什么用氦气我们留着下面再说。</p><p>而在机械硬盘的顶部，我们就可以看到这个<strong>硬盘的接口，这里以 SATA 接口为例</strong>，通常可以分为三个部分，一个供电接口给硬盘提供建立一个数据接口来传输数据，还有一个跳线接口。</p><p>其中供电和数据接口的用途就跟它们名字一样，跳线接口的用途就比较古老，一是因为以前没办法直接在 BIOS 里面确定硬盘启动顺序，所以需要通过插不同的跳线针脚来确定硬盘的启动顺序，二是有些设备需要通过跳线接口把 SATA2 切换成 SATA1 模式，也就是降速来使用，不然老设备识别不出来。还有些厂商会用作调试、固件更新、数据恢复接口等。现在基本没人用这么老的设备了，这个接口根本就不用插，<strong>跳线接口当没有就可以</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/297c4f1f90f4d259f0c36b79f5367d3f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>从左到右分别是跳线、数据、供电接口</p><p>外部剩下的就是<strong>控制电路板</strong>，基本上就是控制硬盘的各种芯片，RAM（用来做缓存），存储 ROM（用来放硬盘固件），电机驱动和主控芯片（微处理器）等，实现磁头驱动、定位、读写、接口控制等功能。</p><p><img src="https://cdn.sspai.com/2021/09/12/e254d83fe57dca72bcf8df8e41c4abc1.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>控制电路板与上面的芯片</p><p>介绍完外部结构，我们终于来到了机械硬盘的内部。其实机械硬盘的内部结构相对简单，只有两个大结构，硬盘硬盘，<strong>中间最显眼的那块就是它的盘，因为是硬的，所以大家叫他硬盘</strong>（冷笑话～）。</p><p><img src="https://cdn.sspai.com/2021/09/12/4bed6ede8b14b13c17c839be5e8f718b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>机械硬盘内部结构</p><p>另外一个大结构就是<strong>磁头组件</strong>，由磁头、传动手臂、传动轴三个部分组成。硬盘底下还有电机等等用来驱动整个磁头组件，通过磁头驱动电路精确控制电机带动传动轴传动手臂，使最尖端的磁头到达指定的位置。<strong>磁头组件是硬盘发生故障的主要位置，90% 的硬盘故障都是磁头组件的问题。</strong></p><p><img src="https://cdn.sspai.com/2021/09/12/18518005d69af071e4a845df83d477ab.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁头组件的结构</p><p>接下来就是最重要的<strong>盘片</strong>了，我们的数据都是存在它上面。物理上来讲，<strong>它就是一个铝合金或者玻璃盘子，上面涂一层磁性材料，然后加上保护润滑涂层等等其他东西一起加工一下</strong>，读写数据就是改变盘片上那些小磁颗粒的极性，不同物理性质材料直接影响盘片的数据密度，稳定性和鲁棒性。</p><p>另外盘片中间主轴还有一个马达让盘片高速旋转，通过前置控制电路控制速度等等。剩下的就是起落架，空气过滤片等等其他部件了。</p><p>整体来讲，<strong>机械硬盘的内部结构还算是蛮简单的</strong>，不过现在机械硬盘内部通常会叠多个盘片提升数据容量，对应地就会有很多个磁头。<strong>盘片的正反面都可以读写，所以正反面会各有一个磁头。</strong></p><p><img src="https://cdn.sspai.com/2021/09/12/7a12313ac334faf2506a70ba78c766ab.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>多个盘片与多个磁头</p><h3 id="工作原理（物理）"><a href="#工作原理（物理）" class="headerlink" title="工作原理（物理）"></a>工作原理（物理）</h3><p>看完上一章软盘部分的同学，其实基本上就能够很好的理解机械硬盘的工作原理了。硬盘不通电时，磁头是放到起落架的，通电之后，首先<strong>盘片会高速旋转</strong>，接着控制器控制磁头组件将磁头放在盘片上，<strong>盘片高速旋转的空气浮力会将磁头稍微悬浮于盘片上一点点（0.1</strong><del><strong>0.3μm，新技术可以做到 0.005</strong></del><strong>0.01μm，微米，1米的 100 万分之 1）</strong>，横截面看大概是这么一点点：</p><p><img src="https://cdn.sspai.com/2021/09/12/e7083aef1cdde4bc03e7475899c0d031.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>盘片和磁头横截面，和灰尘头发的对比</p><p>针尖大小的磁头上包含两个小磁头，<strong>一个是读磁头一个是写磁头</strong>。想要读写数据的时候，控制器会控制电机将磁头放到对应位置，等盘片旋转到对应数据点的时候：</p><p>想要写入数据就通过给电流给写磁头产生一个强大的磁场，改变底下盘片上经过的磁颗粒的极性，从而实现写入数据。</p><p>想要读取数据就直接检测底下磁颗粒经过让读磁头产生的电流，从而确定对应位置磁颗粒的极性，达到读取数据的目的。</p><p><img src="https://cdn.sspai.com/2021/09/12/08428c427a41872f2ed43bf2a9be69da.gif"></p><p>动画展示，来源：Youtube@TED-Ed</p><p><img src="https://cdn.sspai.com/2021/09/12/ce9da28439cbb492d6a08e915fea2d91.gif"></p><p>现实世界中，硬盘是这样子读写数据的（慢放）</p><p>整个读写过程原理就是我们常说的电磁现象，所以盘片又叫做磁盘。而且看到磁头和磁盘的距离和速度，大家应该能理解为什么机械硬盘这么怕灰尘之类的小颗粒了吧。</p><p><img src="https://cdn.sspai.com/2021/09/12/50b384707e2fda1422282508e56a1906.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>一旦有灰尘，磁头就能在盘片上「画画」，图片来源：Alchemist-hp (talk) <a href="http://www.pse-mendelejew.de/">www.pse-mendelejew.de</a></p><p>厂商和科学家们一直在努力提高机械硬盘容量的方向，就是尽量提高盘片上磁性材料的密度，以及在不影响读取写入的同时尽量减小读写磁头的大小。</p><p>而机械硬盘提高容量密度里面有一个很重要的技术，那就是 IBM 1991 年（没错，还是 IBM，实在太强了）发明的 <strong>MR 磁阻技术</strong>，利用磁阻效应，将<strong>磁头灵敏度大大提升，从而使盘片的储存密度直接提升几十倍</strong>，让现在 GB，TB 级硬盘的出现成为可能。</p><p>磁阻效应是个很简单的物理原理，就是某些金属或半导体的电阻值会随着外部磁场的变化变化，因为磁场会改变电子的轨迹，洛伦磁力就会在宏观上改变材料的电阻值。</p><p>IBM 把对应的材料做成了 MR 磁头，后来又进一步做成了 GMR 巨磁阻效应磁头，<strong>现在的机械硬盘，包括我们上面介绍工作原理时候的磁头都是使用磁阻效应材料的磁头。</strong></p><p>另外我们平时看到机械硬盘介绍的时候，可能还会看到 PMR、SMR 之类和 MR 有关的参数，这个是 MR 技术诞生后，使磁盘容量提升的另一个方法。因为 MR 技术之前磁头的灵敏度不够，所以盘片上的<strong>磁颗粒极性一般都是横向在盘片上的</strong>，称为水平磁记录 LMR，就像下面这样：</p><p><img src="https://cdn.sspai.com/2021/09/12/19a1803107fad4732ffabf955d45e7b6.gif"></p><p>LMR 水平磁记录</p><p>随着 MR 技术越来越成熟，灵敏度越来越高磁颗粒不仅能够做得越来越小，工程师们还能把<strong>磁颗粒竖起来放</strong>也能保证数据的正确读取写入，这样相同面积盘片就能塞进更多的磁颗粒，单盘片也能做到 1TB 的容量。</p><p><strong>这就是现在这些硬盘都在用的 PMR 垂直磁记录，所以我们通常叫 PMR 硬盘</strong>，知道了这项技术的原理，我们就能在下面很好的给大家解释清楚，为什么 SMR 叠瓦式硬盘会出现？为什么尽量不要买它。</p><p><img src="https://cdn.sspai.com/2021/09/12/089e40e318bcaaf79e65f254b71b851a.gif"></p><p>PMR 垂直磁记录</p><p>至于盘片在那么高转速情况下，读写磁头是怎么样实现快速精准改变底下磁颗粒的磁性等问题就不展开讲了，感兴趣的朋友可以找找相关文章，或者等我在这个系列最后一章拓展部分简单讲讲。</p><h3 id="工作原理（逻辑）"><a href="#工作原理（逻辑）" class="headerlink" title="工作原理（逻辑）"></a>工作原理（逻辑）</h3><p>知道了硬盘的物理工作原理，但我们还有很多问题没有解决，比如为什么硬盘要分区？为什么要有扇区和磁道，为什么分区表炸了硬盘就读取不了数据等等，这就涉及到硬盘的逻辑工作原理了。</p><p>为了提高数据的写入读取速度，最大化减少磁头走过的路径，提升工作效率，统一标准等，我们需要在逻辑上给硬盘分区，和软盘一样，机械硬盘首次使用时也需要格式化，这一步会给硬盘重新划分逻辑分区。</p><p>看过上一张软盘部分的朋友，应该比较好理解，<strong>机械硬盘的逻辑分区和软盘差不多</strong>：</p><p><img src="https://cdn.sspai.com/2021/09/12/7d648ca9fa3d6130de3e57396dcfa609.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>一般机械硬盘的逻辑分区</p><p>一个机械硬盘可以有好几个盘片，每个旁边有正反两个面，叫做<strong>磁盘面</strong>，每个面都像上面一样，分好<strong>磁道</strong>还有<strong>扇区</strong>。<strong>可以把它想象成有很多个跑道的操场，然后每个跑道再按照每 100 米分成一块一块去百米赛跑。</strong>，每一个盘片上面同一条磁道合起来组成的叫做<strong>柱面</strong>（图中所有白色的磁道合起来，就像一根竖起来的空心水泥管）。</p><blockquote><p>盘片在高速旋转而磁头固定位置的情况下，磁头在盘面上画出的轨迹是一个圆，我们就把它规定为磁道；而一定时间内磁头在盘片上走过的轨迹是一个圆弧，我们就把它规定为扇区。</p></blockquote><p>所以机械硬盘的逻辑分区从大到小是：<strong>磁盘面 -&gt; 柱面 -&gt; 磁道 -&gt; 扇区</strong>，扇区就是机械硬盘逻辑分区的最小单位，<strong>一般大小为 512B，也就是 0.5KB</strong>，也就是说即使你只想读写几十 B 的数据，磁头也会把对应扇区 512B 的数据都读写。</p><blockquote><p>每个扇区的容量（Byte，字节）* 一个磁道有多少个柱面 * 整个硬盘一共有多少个磁盘面 &#x3D; 机械硬盘的总容量。</p></blockquote><p>大家看到这里有没有发现扇区的划分有一个问题，磁盘面最外圈的周长比最内圈的周长要多几倍，<strong>如果每个磁道都划分同样的扇区数，那么最外圈磁道的扇区只放 512B 数据显然有点浪费</strong>。于是硬盘厂商开发出了 ZDR 等类似技术，把整个盘面的磁道由外到内分成几大块，根据每块的位置，越靠近外侧就分配越多的扇区，这样极大地提高了空间利用率。</p><p><img src="https://cdn.sspai.com/2021/09/12/cd3ce6ac9b725db96634f5a9a1615639.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><strong>ZDR 技术带来的另一个结果是，同样时间磁头在外侧能扫过更多扇区，带来更高的读写速度。所以我们给装 Windows 的时候，系统分区 C 盘一般都会放到靠近外面的磁道（当然现在不推荐把系统装在机械硬盘上了）。</strong></p><h3 id="快速格式化和低级格式化"><a href="#快速格式化和低级格式化" class="headerlink" title="快速格式化和低级格式化"></a>快速格式化和低级格式化</h3><p>平时我们格式化硬盘或者其它储存设备的时候，经常会看到有一个快速格式化的选项，同时还有低级格式化等其它的方式。</p><p><img src="https://cdn.sspai.com/2021/09/12/3e88b1004f0c3ba140fc0c7b2313691a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Windows 的格式化选项</p><p>这些格式化方式的区别是有没有对储存设备重新分区，比如快速格式化一般就只是清除掉储存设备上的分区表，这样系统认为所有扇区可以重新写入数据；普通格式化往往是填零操作，也就是把所有扇区数据都变成 0，还伴随着检测标注坏道等操作，所以速度会慢上不少；低级格式化现在很少见，却是最彻底的，它会将整个盘面都归空，然后重新划分磁道和扇区分区表等等，经常低级格式化的话对硬盘寿命有一点影响，这几种格式化的恢复数据难度会在后面的章节讲到。</p><ul><li><strong>磁盘面从 0 开始编号</strong>，因为每个盘面都会有一个磁头，所以这个也是磁头的编号。现在硬盘一般会有几片到十几二十片不等的盘片，也就意味着会有几十个磁盘面。</li><li><strong>磁道从磁盘面的最外侧到最内侧从 0 开始编号</strong>，大容量的机械硬盘，每个磁盘面都会有几千个磁道。</li><li><strong>柱面</strong>，看到上面机械硬盘物理结构的朋友应该清楚，所有磁头都是绑定在一起移动的，所以才会有柱面这个结构。机械硬盘读写数据都是按照柱面来进行的。</li><li><strong>扇区从 1 开始编号，每个扇区的数据是进行读取写入最小单位</strong>。比如一个磁道有 64 个扇区，编号就是 1 到 64。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/cf1e6d1d65664e7460660b32f075d926.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>磁盘的编码和定位</p><p>一些硬盘上有一个比较重要的磁道——<strong>最外圈的 0 磁道</strong>。这个磁道不会储存用户数据，我们开机常见的 MBR 引导，就是把引导数据（告诉电脑系统如何启动的数据）和 DPT 硬盘分区数据放到了 <strong>0 磁道 0 柱面 1 扇区</strong>（UEFI 引导则是把引导文件放在了 FAT 分区里），文件系统的 FAT 文件分配表有时候也是放到 0 柱面上。0 磁道损坏也是机械硬盘最常见的损坏原因。</p><p><img src="https://cdn.sspai.com/2021/09/12/e0b680ab0135e9aeb3da1e1817a220cb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>放到 0 磁道上面的数据</p><p>这样子给柱面、磁头、扇区编号，再按照以下的公式给每个扇区编号：</p><p>逻辑扇区号 &#x3D; (柱面号*总磁头数+磁头编号) * 每个磁道有多少个扇区 + 扇区编号 - 1</p><p>这样子就相当于每个扇区有自己独特的地址，跟我们给酒店房间编号一样，<strong>这个地址就是扇区的逻辑区块地址 LBA</strong>。有了编号，磁盘读写数据更方便。</p><p>至于机械硬盘在逻辑上的读取写入原理，我们会放到下面参数这一节再讲，这样大家理解比较容易。</p><p>机械硬盘能用相对便宜的价格获得大容量一直是它的优势，在各种技术的加持下，现在机械硬盘单盘片能够做到 2TB，单个机械硬盘的容量能够去到 24TB（希捷 Seagate，2021）。<strong>但受限于物理读写机制，一些硬盘的读写速度可以说不太尽如人意</strong>，一般不超过 300MB&#x2F;s，家用机械硬盘一般不会超过 150MB&#x2F;s，<strong>这个速度在现在看来是非常慢的</strong>，所以机械硬盘现在的使用用途一般都是存储大量不经常使用的数据，像是电影或者照片等，<strong>非常不建议把经常需要读写小文件的应用程序，游戏，操作系统安装到机械硬盘</strong>。</p><p><strong>相关文献</strong>：</p><p>[1]. 原始机械硬盘的详细结构可以参考这份<a href="https://patents.google.com/patent/US3503060">专利</a>。<br>[2]. 机械硬盘，详细的结构和高清的微距图片，可以查看 HDDScan 的文章<a href="https://hddscan.com/doc/HDD_from_inside.html">「 HDD from Inside Hard Drive Main Parts」</a>。<br>[3]. 部分动图来源于 Youtube@TED-Ed，一个很好的机械硬盘原理讲解视频，原视频<a href="https://www.youtube.com/watch?v=wteUW2sL7bc">「硬盘是如何工作的？- Kanawat Senanan」</a>。<br>[4]. 希捷对于自家新技术还有超大容量硬盘的<a href="https://blog.seagate.com/craftsman-ship/hamr-next-leap-forward-now/">介绍</a>。<br>[5]. 查看更加专业的机械硬盘结构，可以参考这份移动机械硬盘的<a href="https://patents.google.com/patent/US5041924">专利</a>。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>逻辑分区解释完，再往上一层就是我们熟知的文件和目录结构了。用来管理目录和文件的系统叫做文件系统，它规定了文件和目录数据如何储存到储存设备上，Windows 用的文件系统是 NTFS。</p><p>因为我们很少有只占用一个扇区以下的文件，所以文件系统会将<strong>磁盘面上相邻的若干个扇区合并为一个簇（又叫分配单元，Unix 类系统叫块，反正都是一个意思）</strong>。<strong>文件系统进行读写操作的基本单位就是簇。</strong></p><blockquote><p>每个系统规定的簇大小都不一样，<strong>簇越大读写速度就越好</strong>，但是空间浪费越严重，比如 64K 簇大小的文件系统，存放 1KB 的文件也要在磁盘上占用 64KB 的扇区 <strong>Windows NTFS 文件系统的簇大小是 4KB</strong>。</p></blockquote><p>以我们常见的 Windows 文件属性为例：</p><p><img src="https://cdn.sspai.com/2021/09/12/ae60cda758822762627a0bab6efcc555.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>相信很多人都很奇怪，为什么会有大小和占用空间两个不同的数据</p><p>可以看到大小和占用空间两个属性，后面跟着的容量是不同的。「大小」就是文件的实际大小，「占用空间」就是这个文件在磁盘上占用的簇大小 ，因为 10.2 KB &gt; 8KB，而 NTFS 文件系统的簇大小是 4KB，所以他必须要占三个簇，也就是 12KB。比较大的文件看着大小和占用空间可能一样，但仔细观察后面的字节数，也会发现相差了簇以内的字节。</p><p>文件系统会将每个文件在磁盘上占用哪些扇区汇总成一个文件分配表，这就是我们上面说的 FAT。同时文件系统也会把目录里面包含哪些文件和每个文件的属性都汇总成一个目录表，和文件分配表放到一块。</p><p><img src="https://cdn.sspai.com/2021/09/12/33e4046f9dfd2e6cc0a5730bd5756da2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>FAT 文件表和目录表的内容</p><h3 id="储存数据操作的层级"><a href="#储存数据操作的层级" class="headerlink" title="储存数据操作的层级"></a>储存数据操作的层级</h3><p>到这里我们会发现，一个简单的文件操作，从操作系统到文件系统，到逻辑分区，再到物理操作上分成了很多层：</p><ul><li>操作系统根据用户的操作控制文件系统读写相应的文件 -&gt;</li><li>文件系统根据文件表和目录表找到对应的文件在储存设备上的扇区 -&gt;</li><li>给机械硬盘提供扇区数据和操作命令 -&gt;</li><li>机械硬盘驱动磁头到对应位置读写数据并返回状态给文件系统 -&gt;</li><li>文件系统更新文件表和目录表然后通知操作系统 -&gt;</li><li>操作系统将结果核心的文件列表展示给用户</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/bdc7aaff41b02a8af394c3d078543fa5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>简单一个删除文件操作，背后的过程都很复杂</p><p>各层分离的机制既在保证最大性能的同时，也把兼容性拉满，不同的物理设备文件系统和操作系统都能够互相组合来运行。</p><blockquote><p>Linux 和 MacOS 等其它操作系统里面文件系统的机制稍有不同，感兴趣的同学可以查找相关书籍，或者等我在系列最后一章简单解释一下。</p></blockquote><h2 id="机械硬盘的参数解读"><a href="#机械硬盘的参数解读" class="headerlink" title="机械硬盘的参数解读"></a>机械硬盘的参数解读</h2><p>了解完关于机械硬盘物理结构逻辑结构和文件系统的相关知识，接下来我们就能进入机械硬盘相关参数的讲解了。在这个部分我会将参数和机械硬盘逻辑工作原理一起来讲解，不仅能让你了解机械硬盘具体的工作流程，也能让你更加形象地了解到这些参数对机械硬盘性能产生的影响。</p><p>首先先介绍一下一些跟原理无关的基本参数。</p><h3 id="尺寸与高度"><a href="#尺寸与高度" class="headerlink" title="尺寸与高度"></a>尺寸与高度</h3><p>对于普通消费者来讲，各种不同的硬盘，第一眼看上去最容易分辨的区别自然是<strong>三维尺寸</strong>了。为了能够方便在不同设备上统一使用，硬盘被分为了几个通用尺寸：</p><ul><li><strong>5.25 英寸</strong>：现代硬盘刚出来的时候比较通用的一个尺寸，在 2000 年前商用领域比较常见。之后硬盘普及到民用领域，因为这个尺寸有点大，所以基本没什么人用了。不过 5.25 英寸好像刚好能够塞进以前电脑常见的光驱架里。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/0fe6c353f64baeb60ce05837bd2e89c6.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>5.25 英寸机械硬盘</p><ul><li><strong>0.85 英寸</strong>：比 5.25 英寸消失得稍微晚一点，玩机经历比较长的朋友估计还会有印象。在固态颗粒没有出现的年代，移动设备也是有大容量需求的，0.85 英寸机械硬盘就是把当时硬盘技术运用到极致的产物，有一种微缩景观的精致美感。诺基亚 N91、iPod Shuffle 还有当时很多 MP3 播放器等等都使用这种尺寸的硬盘。</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/27db9ada0ea5b34108801615764e4d29.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>精致的 0.85 英寸机械硬盘</p><ul><li><strong>3.5 英寸</strong>：3.5 英寸应该是我们现在最常见的机械硬盘了，通常大家说的<strong>台式机硬盘</strong>就是它。*_长宽 147mm_101.6mm，常见高度 17.8~26.1mm（SFF-8301 标准）**，</li></ul><p><img src="https://cdn.sspai.com/2021/09/12/0ce03a50a79664c3686c9a9a168d7ac8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>最常见的 3.5 寸机械硬盘</p><p>通常来讲高度越高的机械硬盘里面盘片数量越多，一般的硬盘盒和硬盘架都能放进最高的 3.5 寸硬盘。</p><ul><li><strong>2.5 英寸</strong>：2.5 英寸机械硬盘也是现在比较广泛使用的一种机械硬盘尺寸，<strong>它主要是用在一些对空间要求比较高的设备上</strong>，就像我们的笔记本或者小主机里面用的就是 2.5 寸的硬盘。</li></ul><p>2.5 英寸机械硬盘长宽 95mm~101.85mm*69.85mm，常见高度有 7mm、9.5mm、15mm、17mm、25mm 等，高度主要还是受到盘片数量，影响容量大的一般会比较厚。</p><p>因为是给空间要求较高设备使用，这些设备通常也不会留太多的余量，<strong>2.5 英寸机械硬盘的商品详情通常会标明自己的高度</strong>，有一些笔记本甚至 9mm 厚的硬盘放进 7mm 的槽里都会顶住底面，所以<strong>给笔记本之类的小设备换硬盘，不仅要注意硬盘尺寸还要注意硬盘高度</strong>，免得发生放得进去却盖不上盖儿的尴尬情形。</p><p><img src="https://cdn.sspai.com/2021/09/12/b74ade0914cfa8697c2117e6870dce3b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同厚度的 2.5 英寸机械硬盘，图片来源：Tom’s Hardware</p><p><img src="https://cdn.sspai.com/2021/09/12/ce4b889b985b19b6712920e5a4704a7d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>商品详情里面的高度一定要注意</p><p>2.5 英寸硬盘因为空间还有技术等原因，比较不容易做到高转速，<strong>同容量下 2.5 英寸硬盘一般会比 3.5 英寸硬盘贵，不过优点是不需要额外的供电</strong>，适合做移动硬盘等低功率设备使用。空间供电足够的情况下，个人建议还是优先考虑 3.5 英寸硬盘。</p><p>另外还有一些比较少见的尺寸就不多介绍了，感兴趣的可以去相关文献那里看一下各种尺寸的表格。</p><h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p>容量这个就不用多说了吧，大家买什么储存设备，基本上第一眼看的就是这个参数。看你想要装多少东西，预算以内容量自然是越大越好的。</p><h4 id="实际容量比标称容量小？"><a href="#实际容量比标称容量小？" class="headerlink" title="实际容量比标称容量小？"></a>实际容量比标称容量小？</h4><p>虽然大家可能在各种地方都看过了，这里还是要放上那个老生常谈的话题：<strong>为什么我买的新硬盘总容量比标称的容量小</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/3f352ac68d58ca1088319364121731b6.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>其实厂家都会把解释印到包装盒上了</p><blockquote><p>Flash（内存）或硬盘设备的厂家一般以 1000 为进制计算容量，即 1KB＝1000 Bytes，1GB＝1000MB，操作系统是以1024 为进制计算容量，即 1KB＝1024 Bytes，1MB＝1024KB，1GB＝1024MB，格式化后的报告容量会少于标称容量。不同操作系统下，系统文件也会占用少量的空间。根据国家标准实际可用容量应大于等于标称容量的90％。</p></blockquote><p>根本原因大家伙细心的话应该能想出来，因为上面提到的<strong>文件系统它规定的簇大小一般都是 4、8、16KB……</strong>所以操作系统只能用 1024 来作为进制，加上储存设备都会预留一些区域用来放固件或者分区数据等等非用户数据，所以最后的容量一般都会比标称的容量小。</p><p><strong>而厂家以 1000 为进制来计算，其实是为了储存设备普及民用之后，方便大众消费者理解。</strong>，因为大家都知道 1 公斤等于 1 千克，1 公里等于 1 千米，为了对标公制单位，二进制的储存单位也就这样子定下来了 1000 进制（IEEE 标准，详细可以参考相关文献部分）。<strong>厂商也乐意这样子标注容量，毕竟可以显得容量大一点。</strong>，另外我们也能看到有些厂商会使用 GiB 这样子的单位来表示储存设备的容量，这其实就是1024 进制的单位，约等于储存设备的实际容量。</p><p>我们国家也有针对这个做出相关的标准，只要实际容量在标称容量的 90% 以上就是合规的，但我个人觉得厂商再良心一点其实可以把实际容量做足的，这样也算是一个可以用来宣传的优点。</p><h4 id="MB，Mb-等-Byte-和-Bit-的区别。"><a href="#MB，Mb-等-Byte-和-Bit-的区别。" class="headerlink" title="MB，Mb 等 Byte 和 Bit 的区别。"></a>MB，Mb 等 Byte 和 Bit 的区别。</h4><p>另一个大家经常弄混，也经常有人解释的问题就是 <strong>bit 比特和 Byte 字节的区别</strong>。</p><p>很多人经常傻傻分不清这两个单位的区别，比如我们常说 100M 宽带，很多人就认为每一秒钟就能下 100MB 的文件，但其实 100M 宽带的理论下载速度只有 12.5MB&#x2F;s；还有5G时代，各家运营商纷纷宣布自己的网络能够达到几百 Mbps 甚至 1G+Mbps，大家就把它当成真实下载速度了。<strong>加上 MBps 和 Mbps 还有 MB&#x2F;s 和 mb&#x2F;s 经常会被混用，搞的大家就更混乱了。</strong></p><p><img src="https://cdn.sspai.com/2021/09/12/058548153605996784bd8b3e6a08cf5e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>网络测试可以切换不同的速度单位</p><p>那么为什么要用两个单位呢？<strong>这是因为数据传输的最小单位是 bit，也就是二进制中的 0 或者 1，而文件储存的最低单位是 Byte，由 8 个 bit 组成</strong>，1Byte 的数据根据排列不同有 2 的 8 次方即 256 种排列方法，可以代表数字，大小写字母和常用字符。（<strong>这也是为啥 1Byte&#x3D;8bit</strong>，同理一个中文字占 2 byte，因为 2 的 16 次方等于 65536，16bit 才足够覆盖常见中文字符）</p><p><img src="https://cdn.sspai.com/2021/09/12/d8f81403a42975d3c25638696ebab009.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>IBM 最早的电脑上采用的 EBCDIC 编码表就是 8bit，很多人认为这也是 1Byte&#x3D;8bit 的重要原因</p><p>所以数据传输领域经常用 bit 做单位（传输的是 0&#x2F;1），下载和上传速度用 Byte 做单位（因为下载或上传 1Byte 以上的数据才有意义）。</p><p>介绍完原理无关的参数，接下来就要介绍和机械硬盘原理相关，并且能够切实影响机械硬盘性能的参数了。</p><h3 id="（平均）寻道时间"><a href="#（平均）寻道时间" class="headerlink" title="（平均）寻道时间"></a>（平均）寻道时间</h3><p>系统给硬盘发布读取写入指令时，硬盘需要把系统发来的文件逻辑逻辑指令转化为物理位置，也就是说<strong>要找到这个文件在硬盘上哪块地方</strong>，借助文件分配表就可以。接下来就是将磁头移到对应位置上进行读取写入了。</p><p><strong>首先电机会控制磁头移动到系统指定的磁道上，这个过程花费的时间就是机械硬盘的寻道时间</strong>。基本包括了三个参数，启动电机的时间、磁头臂的移动速度（常数）、现在位置到目标知道移动的距离。</p><p>寻道时间 &#x3D; 电机启动时间 + 移动距离&#x2F;移动速度</p><p><img src="https://cdn.sspai.com/2021/09/12/1915d0a85feb56d8b0115d36d5d81134.gif"></p><p>寻道过程，图片来源：dba-oracle</p><p><strong>可以看到寻道时间并不是固定的</strong>，如果移动到第 1 个目标磁道后，第 2 个目标磁道离得比较远的话，寻道时间自然会变长，反之则会变短。而且盘片容量越大，寻道时间越短（因为密度越大，每个磁道的宽度也就越短）。<strong>商品详情里机械硬盘的寻找时间一般是测试出来的平均值，所以又叫平均寻道时间。</strong></p><h3 id="转速-旋转时间（延迟）"><a href="#转速-旋转时间（延迟）" class="headerlink" title="转速&#x2F;旋转时间（延迟）"></a>转速&#x2F;旋转时间（延迟）</h3><p>磁头现在在目标磁道上，下一步就是<strong>等待盘片将磁道上对应的扇区转到磁头底下。</strong></p><p>这里<strong>盘片旋转的速度</strong>就是机械硬盘的转速参数，单位是 RPM，也就是<strong>每分钟转多少圈</strong>。大家常见的转速基本都是3600，5400 和 7200RPM，10000RPM 以上的比较少见。</p><p><strong>之所以会有这个数字，是因为美国交流电是 110V60Hz 的</strong>，所以硬盘里面的主轴电机是每秒 60 转，一分钟就是 3600RPM 了。 而 5400，7200 则是 3600 的 1.5 和 2 倍。</p><p>而<strong>将扇区旋转到磁头底下这段时间就是旋转时间</strong>，这段时间比较短所以也叫旋转延迟，最长的延迟也就是盘片转一圈而已。</p><p>按照这个原理，转速越高，机械硬盘的读写速度自然是越快的。但是也要考虑到数据密度，如果数据密度比较高，5400RPM 的硬盘最后读写速度也能够比 7200RPM 更快。</p><p><img src="https://cdn.sspai.com/2021/09/12/c92ef1c8792de9596b37511af9c57209.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同转速硬盘的速度跑分，左边西数 5400rpm，右边希捷 7200RPM</p><h3 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h3><p>IOPS 在处理设备或者其它电子设备上比较常见，但在机械硬盘这边还是比较少见的。不过偶尔也会有厂商在参数详情里面标出它，所以也简单介绍一下。</p><p>简单来说 IOPS 就是每秒能完成多少次 I&#x2F;O 操作，I&#x2F;O 指的是 input&#x2F;output，也就是说<strong>每秒能完成多少次读写请求（读和写混着来测试）</strong>。</p><p>其中读写请求又分为随机和循环两种，循环请求就是不停的读取写入同样一个数据，通常最后会转化为 MB&#x2F;s 显示。随机请求就是从随机不相邻扇区上读写数据，测出比较真实的速度。</p><p>通常机械硬盘的 IOPS 在 60-140IOPS 左右，这个参数还是比较能客观的反映出硬盘性能的。</p><h3 id="传输速度"><a href="#传输速度" class="headerlink" title="传输速度"></a>传输速度</h3><p>等盘片将扇区转到磁头下这一瞬间，就可以开始读取和写入这个扇区的数据了。之前原理部分也有提到<strong>磁盘的读取写入都是以柱面为单位进行</strong>，因为所有磁头都是固定在一块同步移动的（当然也有不同磁头单独移动的技术，这里就不展开讲了）。</p><p>最上面盘片上的第 1 个柱面上的磁头，开始对扇区进行读取写入，这个扇区完成后硬盘发送指令，第 2 个柱面上的磁头开始进行读取写入……一直这样到最后一个磁盘面上的同一位置扇区写完，磁头之间切换只是一条指令，所以占用时间忽略不计。如果这时候文件数据还没写入完，就开始移动到下一个扇区继续写入，直到写完这个文件；如果文件数据还没有读取完，就获取剩余文件数据的磁道扇区位置继续读取。</p><p><strong>寻道时间 + 旋转延迟 + 读取写入时间，最后再加上将数据放入运行内存的时间，就是硬盘的传输速度</strong>。我们可以发现<strong>完成一次读写请求的时间并不是固定的</strong>，受蛮多因素影响，比如盘片上，外边磁道和里面磁道的周长不一样，扇区数量可能也不一样，文件数据可能不会读取写入连续的扇区等等因素都会影响到最终的读写速度，机械硬盘商品详情上的读写速度通常都是最佳场景下测试出来的。</p><p>当然厂商们也会通过各种算法来对这个运行轨迹和文件数据排布等进行优化，以提高机械硬盘的读写速度。这个深究下去就非常深奥了，感兴趣的同学可以找相关的书籍来阅读。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>很多人都知道固态硬盘是有缓存的，但实际上<strong>机械硬盘也是有缓存的</strong>，只不过它的大小与作用和固态硬盘不太一样。</p><p>机械硬盘的缓存又叫做磁盘缓冲区，一般使用速度比较高的固态颗粒，相当于一个小的内存条。它主要的作用是用作一个临时的高速存储空间。不同于固态硬盘缓存越大越好，<strong>机械硬盘的缓存通常比较小</strong>，传统的机械硬盘缓存一般只有 8MB ~ 64MB，叠瓦式硬盘由于特性缓存会比较大，有 128MB~ 256MB（稍后会详细介绍）。</p><p><img src="https://cdn.sspai.com/2021/09/12/a8de2413803314e760a49b91cfc99d50.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>机械硬盘上的缓存颗粒</p><p>缓存在机械硬盘中最终实现的效果还是以提高读写速度为主，详细来讲是发挥以下几个作用：</p><p><strong>预读取</strong>：<strong>由于机械硬盘物理结构的原因，读取数据主要时间都花到了寻道和旋转延迟上</strong>，而大部分文件刚好数据都是放在相邻扇区上，当你请求一个文件时，机械硬盘会将这个扇区和周围扇区的数据全都读取（甚至同一个磁道上的所有数据，毕竟转一圈也不用多久），然后放到缓存里。最近我们请求相邻文件的情况还是蛮常见的，这样子<strong>如果这个文件读完之后，下一个文件在相邻扇区，那么这些硬盘就能够直接从缓存里面返回文件数据，而不用等待寻道和旋转延迟</strong>，命中率高的话能节省不少时间。</p><p><strong>平衡数据读写速度</strong>：很多时候硬盘接口和硬盘本身读写数据的速率是不一样的，<strong>硬盘上读写数据比把数据通过接口传到外部里要慢得多</strong>，平衡之后，接口就可以通过自己最大的速度将一次性将部分写入数据放到缓存，而不用等硬盘写好一个扇区之后再发送另一个扇区的数据，读取也是同理，这样能让接口和机械硬盘磁头都能最大化工作效率。</p><p><strong>减少写入等待时间</strong>：还是为了解决寻道时间和旋转延迟过长的问题，硬盘接收到写入数据的时候，可以<strong>将数据先放到缓存，然后直接向处理器发送写入完成的指令，这样子在计算机或者用户看来写入已经完成了，</strong>但实际上机械硬盘才开始慢慢的将缓存区里的数据写入盘片。</p><p>这样子不仅能够减少写入时间，也能够更好的给算法发挥，安排更高效的写入方式，从而提升写入速度和之后读取的速度。当然这样子做也有缺点，如果<strong>机械硬盘这个时候突然断电，那么缓存里面的数据清空，没有写入盘片的数据就没有了</strong>。</p><p><strong>这也是为啥以前我们拔 U 盘或者移动硬盘之前，要先卸载设备或者等一段时间。</strong>因为这个时候处理器已经收到了写入完成的命令，文件分配表有可能也写入好了，文件系统会认为这个文件数据是完整的，但实际上已经随着断电灰飞烟灭了。等下次我们再打开这些文件，就会发现文件不见了，或者文件还在但是损坏打不开了。现在的新系统或者手机都不用担心这个了，比如 Win10 就默认将移动设备策略设置为快速删除，这样直接拔 U 盘移动硬盘没问题了，想要更好的性能还可以在磁盘属性 -&gt; 策略里面开回来。</p><p><img src="https://cdn.sspai.com/2021/09/12/08aa77d378a78af31a028cf215fdaaab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>win10 上的快速删除设置</p><h3 id="缓存是越大越好吗"><a href="#缓存是越大越好吗" class="headerlink" title="缓存是越大越好吗"></a>缓存是越大越好吗</h3><p>很多人听到缓存这个词，然后看到上面的好处，自然会觉得越大越好，甚至买机械硬盘的时候，就挑那些大大缓存的买。在固态硬盘上缓存越大可能越好，在机械硬盘上却不一定。</p><p>更大的缓存能够让硬盘预读取更多数据，也能增大命中率，在某种程度上的确是越大越好。大到某种程度的时候就没什么用了，因为我们需要一个请求读写单个大于 64 MB 文件的情景还是比较少的（多个文件，如果每个文件少于 64MB 也不会太阻塞 CPU），平时大文件下载读写等系统也会有分块算法优化，加上高速的内存颗粒比较贵，上大缓存导致硬盘涨价不太划算。另外一个少见的风险就是缓存越大，掉电时候数据损失的风险就越大，加上会使硬盘逻辑结构变复杂等原因，<strong>机械硬盘缓存一般少于 64MB</strong>。</p><p>国外的 Youtuber 像是 Linus 他们也对这方面进行过测试，证明实际上无脑堆大缓存对性能提升并不大。</p><p><img src="https://cdn.sspai.com/2021/09/12/2e3b4c8c0e7d9e4eab342f286b9efcce.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Linus 的测试</p><p>而且在叠瓦盘上缓存是必须的，这也是为啥最近很多硬盘都上了256MB 缓存。简单来讲因为叠瓦盘的盘片太近了，写入数据磁头会破坏临近磁道的数据，所以要把数据读出来放到缓存，然后再一起写入（所以叠瓦盘比较慢，详细原理和工作过程会在下面讲到）。甚至还有 SSHD 这种利用固态硬盘作为机械硬盘缓存和利用运行内存来做缓存的硬盘存在，详细也会在下面硬盘类型中提到。</p><h3 id="硬盘健康相关参数"><a href="#硬盘健康相关参数" class="headerlink" title="硬盘健康相关参数"></a>硬盘健康相关参数</h3><p>另外如果我们购买二手硬盘或者日常使用的时候，还要注意一下硬盘健康相关的参数，比如坏道什么的。这个部分相关的原理和参数，由于篇幅原因就放在后面机械硬盘使用的章节来讲了。</p><p>现在你再看看机械硬盘上贴纸那些参数，基本上都能看明白了吧。</p><p><strong>相关文献</strong>：</p><p>[1]. 想知道硬盘都有啥尺寸可以参考这个<a href="https://en.m.wikipedia.org/wiki/List_of_disk_drive_form_factors">维基百科的表格</a>。<br>[2]. 规定接口硬盘尺寸等的 <a href="https://www.snia.org/technology-communities/sff/specifications">SFF 标准</a>。<br>[3]. 关于二进制单位 1000 进制和 1024 进制的由来，可以查看这篇<a href="https://physics.nist.gov/cuu/Units/binary.html">国际标准技术研究院的介绍</a>。<br>[4]. 更多高清硬盘的图片，可以查看 HDD Scan 的<a href="https://hddscan.com/doc/HDD_from_inside.html">拆解文章</a>。</p><h2 id="机械硬盘的接口和协议"><a href="#机械硬盘的接口和协议" class="headerlink" title="机械硬盘的接口和协议"></a>机械硬盘的接口和协议</h2><p>接口和协议也是储存设备另外一个比较重要的组成部分，<strong>不同的接口和协议能对储存设备的读写速度 IO 请求等产生较大的影响。接口和协议的兼容性也决定了储存设备能不能够在特定的设备上使用。</strong></p><p>在讲之前，我还是先给大家捋捋物理接口，协议，还有最终读写速度的关系。大家都知道计算机或者手机的设备里面会有很多个不同的部件，比如处理器、显卡、运行内存、储存硬盘、网卡等等，各部件和处理器，或者各部件互相都要不断传递数据。</p><p>而<strong>它们传输数据的物理通道就叫总线，用来走实际上的电信号</strong>。我们常听见的 SATA，PCIe 这种就是不同类型的总线通道，它们通常和北桥南桥直通。</p><p><strong>北桥可以理解为处理高速信号的芯片</strong>，可以说是直连 CPU，PCIe 一般就是连它；<strong>南桥可以理解为处理低速信号的芯片</strong>，比如 SATA 和 USB 都是连它，不过现在 Intel 和 AMD 都把它们整合进 CPU 里面了。</p><p><img src="https://cdn.sspai.com/2021/09/12/83b5290a518128ce25935118cba4a46f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>新的 CPU 芯片里面已经包含了北桥和南桥，图片来源：AnandTech</p><p>总线可以有很多条通道，具体取决于主板和处理器能够支持多少通道。<strong>每个通道能传输多少数据量就叫做带宽，每个通道的带宽乘以接口占用通道数，就是这个接口能够传输的速度理论上限</strong>，不过实际上速度要比理论上会低不少。</p><p><img src="https://cdn.sspai.com/2021/09/12/c1226988781056be087d8ace29370669.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>常见的总线速率，维基百科</p><p>比如我们用来插显卡的那个接口就是 PCIe 16X，下面通常会有的短短的接口是 PCIe 8X，<strong>有的主板会把它们做成同样长的，注意观察，里面有一半没有针角的就是 8X</strong>，主板上面也会有标注。</p><p><img src="https://cdn.sspai.com/2021/09/12/4f4b706d9809474e6b23d4a9eea14a0e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同的 PCIe 插槽，图片来源：Trenton Systems</p><p>按照上面的算法 PCIe3.0 16X 单通道的插槽速度能达到 16Gb&#x2F;s，而 8X 只有 8Gb&#x2F;s，<strong>所以把显卡等需要高带宽的设备插上去前，要先确定接口是多少通道的</strong>，不然插错了高端显卡性能减半就血亏。</p><p>另外还有一些主板是共享通道，也就是说主板上所有插槽合起来就这么多个通道，比如主板宣称 16 条共享通道却有 16X 和 8X 两个插槽，那么当第 2 个插槽插东西时，第 1 个插槽也会变成 8X，<strong>这就是所谓的抢速度，有时候明明你把一个固态硬盘直接插到主板上对应的插槽，速度还是上不去，可能就是因为其它设备在抢 PCIe 通道</strong>，所以还蛮需要注意主板参数说明的。</p><p><strong>物理接口就是提供两个设备之间的一种连接方式而已</strong>。比如主板和硬盘通过 SATA 接口来连接，那么实际的电信号则是从接口那里通过不同总线来传输到处理器的。<strong>而规定数据如何传输，如何沟通，每次传输多少数据，怎么打包等等我们就叫他协议。</strong></p><p>简单理解版本：总线就像管子，它只提供一个通道，多通道就是很多根管子，不管里面是水还是油还是其它什么都可以传输。不同的公司就能用这些管道来运送自家的商品，比如矿泉水公司就可以将矿泉水打包成小瓶，大瓶，一箱等等方式通过管子来运；食用油公司也可以将油打包成不同大小的瓶子，通过管道来运，这些公司就是接口，他们规定的打包方式外包装要用什么车或者飞机运，要运多快等等就是协议。</p><p>可以看到，<strong>其实物理接口并不能决定最终数据是怎么传输的，协议才能决定最终数据传输的方式</strong>，这也是为什么<strong>我们能够用转接线把一个接口转成另一个接口，还能够正常使用</strong>，因为转接口中间通常会有一个芯片，来将数据从一个协议的形式转换成另一个协议的形式。</p><p><img src="https://cdn.sspai.com/2021/09/12/04e06e4b68f4e5eb16c3828a27efa4e9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>五花八门的转接线</p><p>我们现在已经没有在使用的机械硬盘接口有 ATA，SAS，SCSI，光纤口（FC）等，我们现在在使用的机械硬盘接口基本上就 SATA 了，不过注意只有中间 L 型的这块才是 SATA 的数据接口。</p><p><img src="https://cdn.sspai.com/2021/09/12/2c97cc173a1383790472c19dc83b2704.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同的硬盘接口</p><p><img src="https://cdn.sspai.com/2021/09/12/e2ed02eaf5c4f5b680dd209160f962c9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SATA 数据接口</p><h3 id="不同协议接口对速度的影响"><a href="#不同协议接口对速度的影响" class="headerlink" title="不同协议接口对速度的影响"></a>不同协议接口对速度的影响</h3><p><strong>总线规定死了数据传输速度的物理上限</strong>，SATA 接口使用的是 SATA（AHCI） 协议走的也是 SATA 总线（是不是有点套娃），按照 SATA3.0 总线，传输上限就是 700MB&#x2F;s，还是能满足机械硬盘需求的，不过即使你把一个高速固态硬盘插到 SATA 接口上，撑死也能跑 700MB&#x2F;s 而已，这就是物理的上限。</p><p>而协议也决定了速度的上限，有两种方式，一个是就是同样的接口，但更新协议版本开放更高的速度上限。这和处理器的处理性能有关，也就是说物理接口和总线能够传输更高的速率，但是处理器处理不过来，就会通过协议来控制速度传输的速度。<strong>另一种情况是协议随接口更新</strong>，比如 USB3.0 接口推出之后用的是 USB3.0 协议，所以 USB3.0 接口和 USB2.0 接口是不一样的东西，只是为了保证兼容性，把它们做成一样的而已。<strong>通常新接口为了兼容都是会把旧接口作为它的子集</strong>，在旧接口的基础上加两个针脚或者改改电路等，这样子新接口的物理传输速度是提高的，所以需要新的协议充分地利用这个接口。</p><p>机械硬盘速度和寻道时间比较慢，所以对接口要求也不高。现在高速固态硬盘通常都是另外的走 PCIe 的接口，而不继续使用 SATA 也就是这个原因。</p><p><strong>数据通过不同的接口走不同的协议，最后通过不同总线到处理器的过程，实际的速度取决于这其中最慢的那部分</strong>。另外一些奇奇怪怪的接口，混插兼容等等的内容，我们会在下一章介绍完固态硬盘之后一起来讲。</p><h3 id="关于不同类型机械硬盘与叠瓦式硬盘"><a href="#关于不同类型机械硬盘与叠瓦式硬盘" class="headerlink" title="关于不同类型机械硬盘与叠瓦式硬盘"></a>关于不同类型机械硬盘与叠瓦式硬盘</h3><p>原本不同类型硬盘（不同颜色不同技术）和叠瓦盘的简单介绍是放在本章节中的，不过由于现在的内容和文章长度都比较足够，这个部分相关的原理和参数，出于篇幅考虑就放在后面机械硬盘选购的章节来讲了。</p><h2 id="实际性能"><a href="#实际性能" class="headerlink" title="实际性能"></a>实际性能</h2><p>参数再美丽，实际使用中也是要跟得上才行，所以我们也要了解一些跟机械硬盘实际性能有关的参数。</p><h3 id="如何测试机械硬盘实际性能"><a href="#如何测试机械硬盘实际性能" class="headerlink" title="如何测试机械硬盘实际性能"></a>如何测试机械硬盘实际性能</h3><p>在实际用文件测试之前，我们可以先用硬盘测试软件来给硬盘做个性能测试。储存设备测试领域基本上用两个大名鼎鼎并且很老牌的软件就足够了，它们分别是 <strong>AS SSD Benchmark</strong>和 <strong>CrystalDiskMark</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/a39631913d72cf012508327d4e0c7da2.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>两款软件的界面</p><p>基本上评测人员、UP 主、YouTuber 甚至商家在商品详情里用的性能测试软件都是他俩。</p><h3 id="性能参数详解"><a href="#性能参数详解" class="headerlink" title="性能参数详解"></a>性能参数详解</h3><p>我们用爱国者 2T 的移动机械硬盘为例，分别在两款软件上跑一下分：</p><p><img src="https://cdn.sspai.com/2021/09/12/dffef2996065398c61be2e27d41775b5.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者硬盘的跑分</p><p>跑完分之后我们来看一下这上面的参数都代表了啥。</p><ul><li>** Seq 指的是顺序（连续）读写<strong>：这个测试模拟的是读写单个体积比较大的文件，比如我们日常用的电影和压缩包等。就算是机械硬盘，单个写入和读取基本上都是在连续的扇区上，</strong>基本上这个参数代表的就是储存设备最佳情况下的读写速度了，商家往往也是把这项作为硬盘的参数放到商品详情里**。</li><li><strong>RND&#x2F;4K 指的是随机读写</strong>：这个测试模拟的是很多细碎的小文件，<strong>基本上就是我们日常使用中的绝大部分场景</strong>，比如安装运行应用和游戏，甚至系统本身的运行都是要频繁读写很多小文件。由于机械硬盘每个文件都要重新移动磁头去寻址，4K 性能一般很差，基本没眼看。<strong>这里再次建议不要把系统或者大的应用程序&#x2F;游戏装到机械硬盘上</strong>。</li><li><strong>Acc.Time 指的是平均访问时间</strong>：</li></ul><p>4K 后面跟着数字是指线程的数量，CrystalDiskMark 里面则是用 Q 和 T 来表示， Q32T1 代表 32 队列深度（也就是一次性发送多少个请求） 1 线程（同时发送多少个队列）。</p><p><strong>这部分模拟多线程的多文件读写</strong>，机械硬盘在这方面依然提升不是很大，因为磁头只有那么多，再怎么做线程，最后还是要这个磁头去读取，不过因为队列可以放到缓存提升一些速度。不像固态那样有主控，可以支持多线程多队列读取写入数据。</p><p><img src="https://cdn.sspai.com/2021/09/12/b422593fcda42ebc35c2f78a96d301e8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>至于剩下的选项主要就是测试容量的选择，这部分基本上是越大越准确，但是用的时间会比较长，保持默认 1GB 就可以了。另外 CrystalDiskMark SEQ1M 里面的 1M 指的是每一块大小 1MB，也就是说 1GB 的写入量会分成 1000 块，而两个软件的 4K 读写则是生成 512KB 大小的多个文件，然后以 4K 为单位随机挑选扇区写入数据，测出最真实的速度。</p><p><strong>随机读写部分是最能反映我们日常使用体验的</strong>，因为系统和软件运行本身就会经常读写文件，我们平时复制粘贴的文件常常也不是单个文件，这个时候就会发现机械硬盘速度远远满足不了我们的需求。<strong>很多人换成固态硬盘之后开机时间飞速提升，就是因为随机读写能力提升了。</strong></p><h3 id="剩余容量对机械硬盘性能的影响"><a href="#剩余容量对机械硬盘性能的影响" class="headerlink" title="剩余容量对机械硬盘性能的影响"></a>剩余容量对机械硬盘性能的影响</h3><p>现在机械硬盘容量大，大家可能不太会发现，但是之前硬盘容量不大，大家用着用着就会发现<strong>机械硬盘快满的时候速度也会下降</strong>。</p><p><img src="https://cdn.sspai.com/2021/09/12/0aff7a73ca263b53c0b30e1b0dd8d9c5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>普通用户应该是用不满 2T 以上硬盘的</p><p>首先一般机械硬盘的文件数据是从盘片外侧写到盘片内侧，内侧周长变小，然后同样时间划过的路径变短，读取的数据自然就少。因为这个原因，机械硬盘到差不多满的时候会慢一点点，但不是主要原因。</p><p>和固态硬盘因为缓存用完降速不同，<strong>机械硬盘容量不足时降速主要还是文件碎片的问题</strong>。机械硬盘上放得文件越多，产生的磁盘碎片就越多，也就是说更难找到一块儿连续的扇区去写入。这个时候如果想要写入文件，就必须将数据分散在不连续的散区，就导致无论是读还是写这些文件都会有更多的寻道时间，速度自然就慢了不少。</p><p>但比起固态硬盘，机械硬盘低剩余容量带来的速度影响其实不大。</p><p><strong>相关链接：</strong><br>[1]. AS SSD Benchmark <a href="https://www.techspot.com/downloads/6014-as-ssd-benchmark.html">下载地址</a>。<br>[2]. CrystalDiskMark <a href="https://crystalmark.info/en/download/#CrystalDiskMark">下载地址</a>。</p><h2 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h2><p>以前我们嫌机械键盘速度慢的时候，经常会在网上搜一些文章，它们通常会让你去做磁盘碎片优化，然后机械硬盘的速度就能提升。那么磁盘碎片是什么，它是怎么来的，为什么要优化它？</p><p>最常见的产生文件碎片的情景就是对<strong>文件修改</strong>。</p><p>举个例子，我们连续写入文件 A 和 B，A 文件占了 5 个扇区，B 文件跟在 A 后面。某一天我们对 A 文件产生修改，比如加了占用两个扇区的内容，这样添加内容在 A 和 B 中间是没有地方放的，只能放在 B 后面，于是 A 文件的数据就这样被分成了两块，我们就可以说 A 文件变成了两个碎片。如果是删了两个扇区的内容，A 和 B 中间就空了两个扇区，一般来讲新文件会无视这些空扇区在尾部连续写入，但如果空间不足的话，也只能填到这些扇区里面，导致把新的文件变成碎片（甚至更碎）。</p><p><img src="https://cdn.sspai.com/2021/09/12/b988e2334c5b3e7ec8292ad1e2c2d519.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>最后就会变成这个我们之前熟悉的界面</p><p>操作系统，应用程序甚至我们自己都会无时无刻对各种文件产生修改，于是<strong>磁盘碎片就会随着时间越来越多</strong>。这也导致了我们上面提到的文件越多，机械硬盘速度越慢，一个文件如果变成两个碎片，那么读取它就会多一次寻道时间，也就是多出几十毫秒，<strong>碎片越多速度下降越严重</strong>。</p><p>而磁盘碎片优化就是对整个磁盘进行一次全盘扫描，统计出所有文件以及它们占用的扇区，然后一个个移动搬运，使它们变成连续的扇区。</p><p><img src="https://cdn.sspai.com/2021/09/12/4e0b8cbf0f5ebfdb2761221dce2035c3.gif"></p><p>完成磁盘碎片优化之后，看着是不是清爽了很多</p><p>用过 Windows 磁盘优化工具的小伙伴都知道优化过程中文件越多越耗时（其实自带的工具很拉，用第三方会快很多），并且优化后仍然会产生新的文件碎片，所以还需要定时优化。而固态硬盘是没有磁盘碎片问题的（虽然会有其它类似问题），<strong>对固态硬盘进行磁盘碎片整理反而会损害它的寿命</strong>。</p><p>现代的计算机系统上，其实我们已经不用太管这些了，比如 Windows10 就能自动识别是固态硬盘还是机械硬盘，来打开关闭磁盘碎片优化，也能够空闲时自动优化，不需要我们再管它。</p><p>最后给大家一个好玩的软件：<a href="https://www.disktrix.com/ultimatedefrag6.html">UltimateDefrag6</a>，文章逻辑分区的截图都是用它来截的，虽然本质是一个磁盘碎片整理工具，但是它可以清楚地用盘片形状来展示你的硬盘上所有扇区的使用情况，还可以用颜色划分不同类型，下回来看看自己的硬盘使用情况也不错。</p><p><img src="https://cdn.sspai.com/2021/09/12/3874f02b52bf7581e8e2cdd43a571eaf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>UltimateDefrag6 截图</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里关于机械硬盘原理的部分就讲完了。说实话，即使把原本的部分内容移到后面几章，又精简了一下，这篇文章还是有点超长了。主要是基础部分比较多，了解清楚之后比较容易了解固态硬盘等其它储存设备的原理，也能帮助大家更好地选购和使用。</p><p>其实还有很多可以介绍的，比如常见不同类型的硬盘区别，要空气盘还是氦气盘，要垂直还是叠瓦，还有混合硬盘等其它新的硬盘类型……因为篇幅的原因我就放到后面的选购章节了，刚好让大家购买之前好好了解了解。</p><p>机械硬盘毕竟已经出现很多年，性能速度都不及下一章我要开始介绍数码时代新王者——固态硬盘。下一章我将带你了解固态硬盘的结构原理，各种参数如何解读，又是如何查看实际性能的。</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
      <category>数据存储历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机械硬盘的原理与参数详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极限定理</title>
    <link href="/Blogs/2025/08/28/%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ol><li><p>​<strong>​大数定律​</strong>​</p><ul><li>​<strong>​弱大数律​</strong>​：limn→∞​P(​nSn​​−μ​&lt;ε)&#x3D;1</li><li>​<strong>​伯努利大数律​</strong>​：频率 nSn​​→p（概率）</li></ul></li><li><p>​<strong>​中心极限定理​</strong>​</p><ul><li><p>若 Xi​ i.i.d，E[Xi​]&#x3D;μ，Var(Xi​)&#x3D;σ2，则：</p><p>  σn​Sn​−nμ​d​N(0,1)</p></li><li><p>​<strong>​应用​</strong>​：二项分布近似正态（n&gt;30，np&gt;5）</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>概率与统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>极限定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派使用Aria2搭建BT远程下载机</title>
    <link href="/Blogs/2025/08/28/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8Aria2%E6%90%AD%E5%BB%BABT%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%9C%BA/"/>
    <url>/Blogs/2025/08/28/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8Aria2%E6%90%AD%E5%BB%BABT%E8%BF%9C%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派使用Aria2搭建BT远程下载机"><a href="#树莓派使用Aria2搭建BT远程下载机" class="headerlink" title="树莓派使用Aria2搭建BT远程下载机"></a>树莓派使用Aria2搭建BT远程下载机</h1><p><a href="https://www.lxx1.com/4469">2020年3月19日 </a><a href="https://www.lxx1.com/author/admin">科技爱好者</a><a href="https://www.lxx1.com/topics/hard/raspberry-pi">树莓派</a>、<a href="https://www.lxx1.com/topics/hard">硬件产品</a>  &#x2F;  热度：3,426℃</p><p>开着电脑下电影速度比较慢，而且还很费电，这时可以使用树莓派，利用Aria2这个工具，搭建一个远程离线下载机，想看的电影，推送到树莓派下载后，使用SMB就可以在电视上观看了。要下载大文件，同样推送到树莓派下载，完成后再拉到电脑上，非常方便，以下是具体的搭建过程。</p><h2 id="一、安装Aria2"><a href="#一、安装Aria2" class="headerlink" title="一、安装Aria2"></a>一、安装Aria2</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install aria2<br></code></pre></td></tr></table></figure><h2 id="二、Aria2配置"><a href="#二、Aria2配置" class="headerlink" title="二、Aria2配置"></a>二、Aria2配置</h2><h3 id="2-1创建配置文件"><a href="#2-1创建配置文件" class="headerlink" title="2.1创建配置文件"></a>2.1创建配置文件</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir -p /home/pi/.config/aria2/<br>touch /home/pi/.config/aria2/aria<span class="hljs-number">2.</span>session<br>vim /home/pi/.config/aria2/aria<span class="hljs-number">2.</span>config<br></code></pre></td></tr></table></figure><h3 id="2-2添加如下配置信息"><a href="#2-2添加如下配置信息" class="headerlink" title="2.2添加如下配置信息"></a>2.2添加如下配置信息</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># set your own path</span><br><span class="hljs-attr">dir</span>=/home/pi/download<br><span class="hljs-attr">disk-cache</span>=<span class="hljs-number">32</span>M<br><span class="hljs-attr">file-allocation</span>=trunc<br><span class="hljs-attr">continue</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-attr">max-concurrent-downloads</span>=<span class="hljs-number">10</span><br><br><span class="hljs-attr">max-connection-per-server</span>=<span class="hljs-number">16</span><br><span class="hljs-attr">min-split-size</span>=<span class="hljs-number">10</span>M<br><span class="hljs-attr">split</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">max-overall-download-limit</span>=<span class="hljs-number">0</span><br><span class="hljs-comment">#max-download-limit=0</span><br><span class="hljs-comment">#max-overall-upload-limit=0</span><br><span class="hljs-comment">#max-upload-limit=0</span><br><span class="hljs-attr">disable-ipv6</span>=<span class="hljs-literal">false</span><br><br><span class="hljs-attr">save-session</span>=/home/pi/.config/aria2/aria2.session<br><span class="hljs-attr">input-file</span>=/home/pi/.config/aria2/aria2.session<br><span class="hljs-attr">save-session-interval</span>=<span class="hljs-number">60</span><br><br><br><span class="hljs-attr">enable-rpc</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">rpc-allow-origin-all</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">rpc-listen-all</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">rpc-secret</span>=secret<br><span class="hljs-comment">#event-poll=select</span><br><span class="hljs-attr">rpc-listen-port</span>=<span class="hljs-number">6800</span><br><br><br><span class="hljs-comment"># for PT user please set to false</span><br><span class="hljs-attr">enable-dht</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">enable-dht6</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">enable-peer-exchange</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-comment"># for increasing BT speed</span><br><span class="hljs-attr">listen-port</span>=<span class="hljs-number">51413</span><br><span class="hljs-comment">#follow-torrent=true</span><br><span class="hljs-comment">#bt-max-peers=55</span><br><span class="hljs-comment">#dht-listen-port=6881-6999</span><br><span class="hljs-comment">#bt-enable-lpd=false</span><br><span class="hljs-comment">#bt-request-peer-speed-limit=50K</span><br><span class="hljs-attr">peer-id-prefix</span>=-TR2770-<br><span class="hljs-attr">user-agent</span>=Transmission/<span class="hljs-number">2.77</span><br><span class="hljs-attr">seed-ratio</span>=<span class="hljs-number">0</span><br><span class="hljs-comment">#force-save=false</span><br><span class="hljs-comment">#bt-hash-check-seed=true</span><br><span class="hljs-attr">bt-seed-unverified</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">bt-save-metadata</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">bt-tracker</span>=http://<span class="hljs-number">93.158</span>.<span class="hljs-number">213.92</span>:<span class="hljs-number">1337</span>/announce,udp://<span class="hljs-number">151.80</span>.<span class="hljs-number">120.114</span>:<span class="hljs-number">2710</span>/announce,udp://<span class="hljs-number">62.210</span>.<span class="hljs-number">97.59</span>:<span class="hljs-number">1337</span>/announce,udp://<span class="hljs-number">188.241</span>.<span class="hljs-number">58.209</span>:<span class="hljs-number">6969</span>/announce,udp://<span class="hljs-number">80.209</span>.<span class="hljs-number">252.132</span>:<span class="hljs-number">1337</span>/announce,udp://<span class="hljs-number">208.83</span>.<span class="hljs-number">20.20</span>:<span class="hljs-number">6969</span>/announce,udp://<span class="hljs-number">185.181</span>.<span class="hljs-number">60.67</span>:<span class="hljs-number">80</span>/announce,udp://<span class="hljs-number">194.182</span>.<span class="hljs-number">165.153</span>:<span class="hljs-number">6969</span>/announce,udp://<span class="hljs-number">37.235</span>.<span class="hljs-number">174.46</span>:<span class="hljs-number">2710</span>/announce,udp://<span class="hljs-number">5.206</span>.<span class="hljs-number">3.65</span>:<span class="hljs-number">6969</span>/announce,udp://<span class="hljs-number">89.234</span>.<span class="hljs-number">156.205</span>:<span class="hljs-number">451</span>/announce,udp://<span class="hljs-number">92.223</span>.<span class="hljs-number">105.178</span>:<span class="hljs-number">6969</span>/announce,udp://<span class="hljs-number">51.15</span>.<span class="hljs-number">40.114</span>:<span class="hljs-number">80</span>/announce,udp://<span class="hljs-number">207.241</span>.<span class="hljs-number">226.111</span>:<span class="hljs-number">6969</span>/announce,udp://<span class="hljs-number">176.113</span>.<span class="hljs-number">71.60</span>:<span class="hljs-number">6961</span>/announce,udp://<span class="hljs-number">207.241</span>.<span class="hljs-number">231.226</span>:<span class="hljs-number">6969</span>/announce<br></code></pre></td></tr></table></figure><p>然后启动aria2：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ sudo aria2c <span class="hljs-comment">--conf-path=/home/pi/.config/aria2/aria2.config</span><br>Exception caught<br>Exception: [download_helper.cc:<span class="hljs-number">563</span>] errorCode=<span class="hljs-number">1</span> Failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">open</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> /home/<span class="hljs-literal">pi</span>/.config/aria2/aria2.session, cause: File <span class="hljs-keyword">not</span> found <span class="hljs-keyword">or</span> <span class="hljs-keyword">it</span> is <span class="hljs-keyword">a</span> <span class="hljs-built_in">directory</span><br></code></pre></td></tr></table></figure><p>结果出现错误，这是因为找不到aria2.session文件导致的，应该是无法识别“～”目录造成的，所以解决办法也很简单，将配置文件中的<strong>“～”修改为“&#x2F;home&#x2F;pi”</strong>即可。</p><p>修改后再次启动aria2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">$ sudo aria2c <span class="hljs-operator">-</span>-conf-path<span class="hljs-operator">=</span><span class="hljs-symbol">/home/pi/.config/aria2/aria2.config</span><br><br><span class="hljs-number">03</span><span class="hljs-symbol">/19</span> <span class="hljs-number">13</span>:<span class="hljs-number">35</span>:<span class="hljs-number">47</span> [NOTICE] IPv4 <span class="hljs-params">RPC:</span> listening on TCP port <span class="hljs-number">6800</span><br><br><span class="hljs-number">03</span><span class="hljs-symbol">/19</span> <span class="hljs-number">13</span>:<span class="hljs-number">35</span>:<span class="hljs-number">47</span> [NOTICE] IPv6 <span class="hljs-params">RPC:</span> listening on TCP port <span class="hljs-number">6800</span><br></code></pre></td></tr></table></figure><p>可以看到aria2已经成功启动了！</p><h2 id="三、配置aria2开机启动"><a href="#三、配置aria2开机启动" class="headerlink" title="三、配置aria2开机启动"></a>三、配置aria2开机启动</h2><p>创建systemctl service文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>aria2.service<br></code></pre></td></tr></table></figure><p>User,conf-path下换成自己的username</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Aria2 Service<br><span class="hljs-attr">After</span>=network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">User</span>=pi    <br><span class="hljs-attr">ExecStart</span>=/usr/bin/aria2c --conf-path=/home/pi/.config/aria2/aria2.config<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=default.target<br></code></pre></td></tr></table></figure><p>重载服务并设置开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> aria2<br><span class="hljs-built_in">sudo</span> systemctl start aria2<br><span class="hljs-built_in">sudo</span> systemctl status aria2<br></code></pre></td></tr></table></figure><p>看到如下文字证明启动成功(记住TCP port，AiraNg配置以及公网端口映射需要)</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nix">sudo kill <span class="hljs-operator">-</span><span class="hljs-number">9</span> $(pidof aria2c)<br>$ sudo systemctl status aria2<br>● aria2.service <span class="hljs-operator">-</span> Aria2 Service<br>   <span class="hljs-params">Loaded:</span> loaded (<span class="hljs-symbol">/lib/systemd/system/aria2.service</span>; enabled; vendor <span class="hljs-params">preset:</span> enabled)<br>   <span class="hljs-params">Active:</span> active (running) since Thu <span class="hljs-number">202</span>0-<span class="hljs-number">0</span>3-<span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">39</span> CST; <span class="hljs-number">5</span>s ago<br> Main <span class="hljs-params">PID:</span> <span class="hljs-number">6798</span> (aria2c)<br>    <span class="hljs-params">Tasks:</span> <span class="hljs-number">1</span> (<span class="hljs-params">limit:</span> <span class="hljs-number">2200</span>)<br>   <span class="hljs-params">Memory:</span> <span class="hljs-number">3.4</span>M<br>   <span class="hljs-params">CGroup:</span> <span class="hljs-symbol">/system.slice/aria2.service</span><br>           └─<span class="hljs-number">6798</span> <span class="hljs-symbol">/usr/bin/aria2c</span> <span class="hljs-operator">-</span>-conf-path<span class="hljs-operator">=</span><span class="hljs-symbol">/home/pi/.config/aria2/aria2.config</span><br><br>Mar <span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">39</span> raspberrypi systemd[<span class="hljs-number">1</span>]: Started Aria2 Service.<br>Mar <span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">39</span> raspberrypi aria2c[<span class="hljs-number">6798</span>]: <span class="hljs-number">03</span><span class="hljs-symbol">/19</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">39</span> [NOTICE] IPv4 <span class="hljs-params">RPC:</span> listening on TCP port <span class="hljs-number">6800</span><br>Mar <span class="hljs-number">19</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">39</span> raspberrypi aria2c[<span class="hljs-number">6798</span>]: <span class="hljs-number">03</span><span class="hljs-symbol">/19</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">39</span> [NOTICE] IPv6 <span class="hljs-params">RPC:</span> listening on TCP port <span class="hljs-number">6800</span><br></code></pre></td></tr></table></figure><h2 id="四、安装AriaNg以在网页上进行下载管理"><a href="#四、安装AriaNg以在网页上进行下载管理" class="headerlink" title="四、安装AriaNg以在网页上进行下载管理"></a>四、安装AriaNg以在网页上进行下载管理</h2><p>AriaNg 是一个让 aria2 更容易使用的现代 Web 前端. AriaNg 使用纯 html &amp; javascript 开发, 所以其不需要任何编译器或运行环境. 只要将 AriaNg 放在 Web 服务器里并在浏览器中打开即可使用. AriaNg 使用响应式布局, 支持各种计算机或移动设备.</p><p>安装AriaNg的前提是树莓派上已经配置好了web环境，如果没有，按照<a href="http://www.lxx1.com/3696">树莓派安装 lnmp 套件搭建个人博客网站服务器</a> 的教程，在树莓派上安装nginx软件（⚠️注意：只需要安装nginx即可）。</p><h4 id="安装AriaNg与php7-3"><a href="#安装AriaNg与php7-3" class="headerlink" title="安装AriaNg与php7.3"></a>安装AriaNg与php7.3</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install nginx-light<br>sudo apt-<span class="hljs-built_in">get</span> install php7.3-fpm<br></code></pre></td></tr></table></figure><p>Nginx的配置文件默认位置为：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf，而配置PHP只需修改 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default 文件就可以。</p><p>修改 nginx 配置：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo nano <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/sites-available/</span><span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure><p>修改的地方很少。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># Default server configuration</span><br><span class="hljs-comment">#</span><br><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;<br>        <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span> default_server;<br><br>        <span class="hljs-attribute">root</span> /var/www/html;<br><br>        <span class="hljs-comment"># Add index.php to the list if you are using PHP</span><br>        <span class="hljs-attribute">index</span> index.html index.htm index.nginx-debian.html index.php;<br><br>        <span class="hljs-attribute">server_name</span> _;<br><br>        <span class="hljs-section">location</span> / &#123;<br>                <span class="hljs-comment"># First attempt to serve request as file, then</span><br>                <span class="hljs-comment"># as directory, then fall back to displaying a 404.</span><br>                <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =<span class="hljs-number">404</span>;<br>        &#125;<br><br>        <span class="hljs-comment"># pass PHP scripts to FastCGI server</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-section">location</span> <span class="hljs-regexp">~ \.php$</span> &#123;<br>        <span class="hljs-comment">#       include snippets/fastcgi-php.conf;</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-comment">#       # With php-fpm (or other unix sockets):</span><br>                <span class="hljs-attribute">fastcgi_pass</span> unix:/run/php/php7.3-fpm.sock;<br>        <span class="hljs-comment">#       # With php-cgi (or other tcp sockets):</span><br>        <span class="hljs-comment">#       fastcgi_pass 127.0.0.1:9000;</span><br>        <span class="hljs-comment"># 设置脚本文件请求的路径</span><br>                <span class="hljs-attribute">fastcgi_param</span> SCRIPT_FILENAME <span class="hljs-variable">$document_root</span><span class="hljs-variable">$fastcgi_script_name</span>;<br>        <span class="hljs-comment"># 引入fastcgi的配置文件 </span><br>                <span class="hljs-attribute">include</span> fastcgi_params;<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改之后重启nginx,即可配置好nginx和php:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> nginx -s reload<br></code></pre></td></tr></table></figure><p>这时可以查看下是否配置成功，在网站根目录下新建一个index.php的文件，输入以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>在<a href="https://github.com/mayswind/AriaNg/releases">这里</a>选择最新版本的AriaNg.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /tmp<br><span class="hljs-attribute">sudo</span> wget https://github.com/mayswind/AriaNg/releases/download/<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span>/AriaNg-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.zip<br><span class="hljs-attribute">sudo</span> unzip AriaNg-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.zip -d /var/www/html/aria<br></code></pre></td></tr></table></figure><p>在浏览器中访问<code>http://your-ip/aira</code>即可打开AriaNg了</p><p><img src="http://www.lxx1.com/wp-content/uploads/2020/03/%E6%88%AA%E5%B1%8F2020-03-19%E4%B8%8B%E5%8D%887.24.23.png" alt="img"></p><p>这时AriaNg显示未连接，在“系统设置-（PRC192.168.0.108）-Aria2 PRC 密钥 ”中，输入“<strong>secret</strong>” 即可连接！</p><p>之后，就可以愉快的用树莓派下载电影或者文件了～</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派使用Aria2搭建BT远程下载机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率与数理统计篇</title>
    <link href="/Blogs/2025/08/28/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AF%87/"/>
    <url>/Blogs/2025/08/28/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="随机性与概率论"><a href="#随机性与概率论" class="headerlink" title="随机性与概率论"></a>随机性与概率论</h1><h2 id="古典概率"><a href="#古典概率" class="headerlink" title="古典概率"></a>古典概率</h2><p>基本随机事件P（A）&#x3D;A所包含的事件的数量&#x2F;总数量</p><h2 id="伯努利实验"><a href="#伯努利实验" class="headerlink" title="伯努利实验"></a>伯努利实验</h2><p>从最简单，可重复的实验入手，因为可重复，才有规律，因为简单，规律才好找</p><p>两点分布也被称为伯努利分布</p><h2 id="均值与方差"><a href="#均值与方差" class="headerlink" title="均值与方差"></a>均值与方差</h2><p>均值（期望）：同样条件下下多次重复某随机实验得到结果的平均值</p><p>方差：偏离平均值的程度</p><h1 id="分布模型"><a href="#分布模型" class="headerlink" title="分布模型"></a>分布模型</h1><h2 id="柏松分布"><a href="#柏松分布" class="headerlink" title="柏松分布"></a>柏松分布</h2><p>准备资源时，需要冗余量</p><p>柏松分布的概率函数为：</p><p><img src="https://bkimg.cdn.bcebos.com/formula/fb8ba6b970e4eb1892b70adbc0b8ef68.svg" alt="img"></p><p>泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数，揭示了诸多小概率事件发生时的统计规律</p><h2 id="高斯（正态）分布"><a href="#高斯（正态）分布" class="headerlink" title="高斯（正态）分布"></a>高斯（正态）分布</h2><p>若随机变量x 服从一个，位置参数为μ，尺度参数为δ的概率分布，且其概率密度函数为</p><p><img src="https://bkimg.cdn.bcebos.com/formula/d8fc1a3696534a47f23d6bcb60c1212c.svg" alt="img"></p><p>则这个随机变量就称为<strong>正态随机变量</strong></p><p>可以通过标准差（多宽）与置信度（多高）来分析概率</p><h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>P(A|B)&#x3D;P(A,B)&#x2F;P(B)</p><h2 id="概率，联合概率与条件概率的差异"><a href="#概率，联合概率与条件概率的差异" class="headerlink" title="概率，联合概率与条件概率的差异"></a>概率，联合概率与条件概率的差异</h2><p>概率与条件概率的误区</p><ul><li>有意无意漏掉部分选项</li><li>穷举后以为涵盖了所有情况</li><li>不自觉选择对自己有利的情况判断</li></ul><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>P(X|Y)&#x3D;P(Y|X)P(X)&#x2F;P(Y)</p><p>在机械翻译内作用较大</p><h1 id="统计学与方法"><a href="#统计学与方法" class="headerlink" title="统计学与方法"></a>统计学与方法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>收集，分析，解释，陈述数据的科学</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>从大量数据中寻找规律性，不同因素的相关性及可能存在的因果关系</p><h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>牵强寻找不是规律的规律（其实只是统计量不足的巧合）</p><p>忽略了统计主观行为对统计结果的影响（霍桑效应：被观察者知道自己成为观察对象而改变行为倾向的反应）</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>设立研究目标</p><p>设计实验，选取数据</p><p>根据实验方案统计，分析</p><p>使用研究结果</p><h2 id="古德-图灵折扣估计（防范黑天鹅）"><a href="#古德-图灵折扣估计（防范黑天鹅）" class="headerlink" title="古德-图灵折扣估计（防范黑天鹅）"></a>古德-图灵折扣估计（防范黑天鹅）</h2><p>解决零概率事件</p><p>利用齐普夫定律，从高频拿出一点概率总量分配到低频的随机事件上，再从低频的随机事件拿出一些概率总量分配给统计时没见到的随机事件</p><h3 id="齐普夫定律"><a href="#齐普夫定律" class="headerlink" title="齐普夫定律"></a>齐普夫定律</h3><p>对各种语言中的词频与按照词频的排序，排序*词频&#x3D;常数</p><h3 id="80-20定律"><a href="#80-20定律" class="headerlink" title="80:20定律"></a>80:20定律</h3><p>80%的总量常常由20%的高频率元素构成</p><h2 id="删除插值法"><a href="#删除插值法" class="headerlink" title="删除插值法"></a>删除插值法</h2><p>统计数据不够时，大量小概率事件的概率无法准确估计</p><p>所以在估算条件概率时，用一般的概率作为补充</p><h1 id="更大"><a href="#更大" class="headerlink" title="更大"></a>更大</h1><p>概率是一种世界观，要明白很多时候没有简单的黑与白，只有灰度</p><p>统计是一种方法论，为了验证前提的正确性，或是在看似杂乱无章的数据中找到规律</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>数学通识讲义</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率与数理统计篇</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率基础</title>
    <link href="/Blogs/2025/08/28/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/"/>
    <url>/Blogs/2025/08/28/%E6%A6%82%E7%8E%87%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="概率基础​​"><a href="#概率基础​​" class="headerlink" title="概率基础​​"></a><strong>概率基础​</strong>​</h3><ol><li><p>​<strong>​事件关系​</strong>​</p><ul><li><p>​<strong>​运算律​</strong>​：</p><table><thead><tr><th>公式类型</th><th>表达式</th><th>条件</th></tr></thead><tbody><tr><td>加法公式</td><td>P(A∪B)&#x3D;P(A)+P(B)−P(AB)</td><td>一般事件</td></tr><tr><td>互斥事件加法</td><td>P(A∪B)&#x3D;P(A)+P(B)</td><td>AB&#x3D;∅</td></tr><tr><td>德摩根定律</td><td>P(A∪B)&#x3D;P(Aˉ∩Bˉ)</td><td>任意事件</td></tr></tbody></table></li><li><p>​<strong>​独立性​</strong>​：</p><ul><li>A,B独立 ⇔P(AB)&#x3D;P(A)P(B)</li><li>​<strong>​性质​</strong>​：若A,B独立，则A与Bˉ、Aˉ与B、Aˉ与Bˉ均独立</li></ul></li></ul></li><li><p>​<strong>​条件概率​</strong>​</p><ul><li>P(A∣B)&#x3D;P(B)P(AB)​</li><li>​<strong>​乘法公式​</strong>​：P(AB)&#x3D;P(A)P(B∣A)&#x3D;P(B)P(A∣B)</li><li>​<strong>​全概率公式​</strong>​：P(A)&#x3D;∑i​P(Bi​)P(A∣Bi​) （Bi​为完备事件组）</li><li>​<strong>​贝叶斯公式​</strong>​：P (Bk​∣A)&#x3D;∑i​P (Bi​) P (A∣Bi​) P (Bk​) P (A∣Bk​)​</li></ul></li></ol><h2 id="事件关系"><a href="#事件关系" class="headerlink" title="事件关系"></a>事件关系</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li><p>样本空间</p><ul><li>一个实验所有可能的集合</li></ul></li><li><p>特点</p><ul><li><p>必须包含所有的可能结果</p></li><li><p>mutually exclusive 相互排斥</p></li></ul></li><li><p>空集Empty set</p><ul><li>不包含任何元素</li></ul></li><li><p>Complement补集</p><ul><li>定义</li></ul></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>Event</p><ul><li>样本空间内良好定义的自集</li></ul></li><li><p>互不相容事件</p><ul><li>A,B不同时发生，AB&#x3D;空集</li></ul></li><li><p>完备事件组</p><ul><li>A,A2,…An两两不相容，且构成全集</li></ul></li><li><p>对立事件</p><ul><li>A,B不相容</li></ul></li></ul><h3 id="事件的计算（一般情况）"><a href="#事件的计算（一般情况）" class="headerlink" title="*事件的计算（一般情况）"></a>*事件的计算（一般情况）</h3><ul><li><p>减法：</p><ul><li>A-B&#x3D;A-AB</li></ul></li><li><p>*加法其实就是并集：</p><ul><li><p>一般情况</p><ul><li><p>A+B&#x3D;A+B-AB（交集）</p></li><li><p>多个并</p></li></ul></li><li><p>不相容</p><ul><li>A+B&#x3D;A+B</li></ul></li></ul></li><li><p>De Morgan，对所有事件</p></li><li><p>运算律</p><ul><li><p>基本运算</p><ul><li><p>对所有并事件</p></li><li><p>对A交B存在的所有事件</p></li></ul></li><li><p>交换Commutative law</p></li><li><p>结合Associative laws</p></li><li><p>*分配Distributive laws</p></li><li><p>*对偶De Morgan’s laws</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>概率与统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟电路</title>
    <link href="/Blogs/2025/08/28/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/"/>
    <url>/Blogs/2025/08/28/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>处理连续的光、声音、速度、温度等自然模拟信号的IC称之为模拟IC。模拟IC处理的信号都具有连续性，可以转换为正弦波研究，而数字IC处理的是非连续信号，都是脉冲方波。</p><p>模拟电路设计是微电子领域一个集基础理论知识和创造性于一身的绝学。</p><p>如今的模电设计已经处较成熟的层面，完备的仿真计算工具将设计者从繁琐的数据运算中解放出来。足够的理论基础和创造性，配以对信号处理的理解和公式推算的驾驭能力，一个个完美的设计方案就会应运而生。</p><p>要成为模拟电路的设计者，我们必须掌握其基本的以下四个组成部分：</p><p>(1)晶体管元件的设计</p><p>晶体管元件指半导体工程学方面的知识，任何设计的芯片都将终回归于它，一般都是从薛定谔波动方程式开始引出的，虽然与实际具体设计电路直接联系不大，但作为一个成熟的模拟设计工程师，理论基础是必不可少的。</p><p>[[1晶体管元件设计]]</p><p>(2)晶体管电路的设计</p><p>要从事模拟电路设计，必须扎实掌握晶体管电路的基本知识，推荐一边学习一边实验、仿真，PSPICE之类的都可以，能理解一个就行，同时要注意多想多动手。<br>做得多了，自然就能掌握晶体管的设计知识了，从这里就需要储备动手的经验，晶体管、FET是构成整个电路的基础，这里理解了，其他更多IC的原理图也就一目了然了。</p><p>[[2放大器设计]]</p><p>(3)功能模块的设计</p><p>功能模块主要以各种各样的运放为基础，包括AD、DA、PLL、稳压源等等，它们都主要是由晶体管构成的，功能模块设计工程中都会将元器件适当的理想化。</p><p>这部分的学习是十分重要的，一般都是从这里开始学习模拟电路，这部分相对来说比较易懂，也是模拟电路学习的切入点。</p><p>[[3模拟集成电路设计]]</p><p>(4)系统设计</p><p>这部分就需要相当的高度，需要考虑方方面面。<br>其实，说实在的，真正做过一两块片子就差不多能理解大半部分。关键是试验、动手。</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>模拟电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率与统计</title>
    <link href="/Blogs/2025/08/28/%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-编程中的概率date-2020-04-25-15-35-12tags-数学categories-技术mathjax-true"><a href="#title-编程中的概率date-2020-04-25-15-35-12tags-数学categories-技术mathjax-true" class="headerlink" title="title: 编程中的概率date: 2020-04-25 15:35:12tags:- 数学categories: 技术mathjax: true"></a>title: 编程中的概率<br>date: 2020-04-25 15:35:12<br>tags:<br>- 数学<br>categories: 技术<br>mathjax: true</h2><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p>表示不确定性声明的数学框架，提供量化不确定性的方法，也提出不确定声明的公理。</p><span id="more"></span><p>[[01概率基础]]</p><p>[[02随机变量与分布]]</p><p>[[03极限定理]]</p><p>[[04统计推断]]</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>P(x)&#x3D;0.5<br>频率派概率(Frequentist probablity)<br>抛硬币正面向上概率0.t<br><strong>可重复</strong>事件的频率<br>贝叶斯派概率(Bayesian probablity)<br>病人患病的概率<br><strong>不可重复</strong>事件的概率<br><strong>随机变量</strong>(random variable)是可以随机取不同值的变量<br>样本空间(概率对应面积)<br><img src="https://i.loli.net/2020/04/24/7MOBCdjAWilqXbh.jpg" alt="Alt"></p><h3 id="离散型概率分布"><a href="#离散型概率分布" class="headerlink" title="离散型概率分布"></a>离散型概率分布</h3><p>(Probablity mass function, PMF)将随机变量取得的每个状态映射到随机变量取得该状态的概率。</p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li><p>P的定义域必须是X所有状态的集合。</p></li><li><p>对于x，0&lt;&#x3D;p&lt;&#x3D;1,不可能事件为0，必然发生的事件为1</p></li><li><p>归一化条件</p><p>$$\sum P(x)&#x3D;1$$</p></li></ul><h3 id="离散型均匀分布"><a href="#离散型均匀分布" class="headerlink" title="离散型均匀分布"></a>离散型均匀分布</h3><p>给定一个离散型变量x，有k种可能的状态(x1,x2,x3…)每种状态的可能性是相同的，即均匀分布(Uniform distribution),则其概率分布为：</p><p>$$P{(x&#x3D;x_{i})}&#x3D;\cfrac{1}{k}$$</p><p>$$\sum P(x&#x3D;x_{i})&#x3D;\sum P(\cfrac{1}{k})&#x3D;\cfrac{k}{k}$$</p><h3 id="连续型概率分布"><a href="#连续型概率分布" class="headerlink" title="连续型概率分布"></a>连续型概率分布</h3><p>如果一个数为概率密度函数(Probabilty Density Function, PDF),则必须满足以下条件：</p><ul><li>P的定义域必须是X所有状态的集合</li><li>对于x，p(x)&gt;&#x3D;0(不要求小于等于1)</li><li>$$\int P(x)dx&#x3D;1$$</li><li>P(x)没有直接给出特定状态的概率，而是：落在面积为Sx的无限小区域内的概率为p(x)Sx<br><img src="https://i.loli.net/2020/04/24/aHCpzIAmsV2DfO7.jpg" alt="Alt"><br>只要<strong>所有面积加起来等于一</strong>就可以<br><img src="https://i.loli.net/2020/04/24/bEASKtlVgad8Dw5.jpg" alt="Alt"></li></ul><h3 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h3><p>P(联合)&#x3D;P(事件一)*P(事件二)</p><h3 id="边缘概率"><a href="#边缘概率" class="headerlink" title="边缘概率"></a>边缘概率</h3><p>P(边缘)&#x3D;P(部分)+P(部分)</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>P(y&#x3D;yi|x&#x3D;xi)&#x3D;P(y&#x3D;yi,x&#x3D;xi(联合))&#x2F;P(x&#x3D;xi(其他情况))</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="https://i.loli.net/2020/04/24/d2xvcHhbi4twDoX.jpg" alt="Alt"><br><img src="https://i.loli.net/2020/04/24/lTIVMay8EU53hOX.jpg" alt="Alt"></p><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>P(x,y,z)&#x3D;P(x|y,z)P(y,z)&#x3D;P(x|y,z)P(y|z)P(z)<br>若随机变量X，Y互相独立，则：<br>1.条件概率与条件<strong>无关</strong><br>P(x|y)&#x3D;P(x|yprime(这里是y的反面))<br>2.添加&#x2F;去除条件<strong>无影响</strong><br>P(x)&#x3D;P(x|y)<br>3.联合概率<strong>等于</strong>边缘概率乘积<br>P(x,y)&#x3D;P(x)P(Y)<br>独立：没有关系，不能提出线索</p><ul><li>独立不是均匀，互斥</li><li>但是互斥一定不独立</li></ul><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><h4 id="图形化认识"><a href="#图形化认识" class="headerlink" title="图形化认识"></a>图形化认识</h4><p>概率&#x3D;面积<br>期望&#x3D;体积</p><p>$$E[x]&#x3D;\sum kP(x&#x3D;k)$$(离散)</p><p>$$E[x]&#x3D;\int f(x)p(x)dx$$(连续)</p><p><strong>Ex.</strong><br>投一枚均匀骰子，期望？<br>$$E[x]&#x3D;\cfrac{1}{6}*1+\cfrac{1}{6}*2+\cfrac{1}{6}*3+\cfrac{1}{6}*4+\cfrac{1}{6}*5+\cfrac{1}{6}*6&#x3D;3.5$$</p><h4 id="期望值的数学性质"><a href="#期望值的数学性质" class="headerlink" title="期望值的数学性质"></a>期望值的数学性质</h4><p><img src="https://i.loli.net/2020/04/24/XEsioTpeVzuS9kn.jpg" alt="Alt"><br>E[x+c]&#x3D;E[x]+c<br>E[cx]&#x3D;cE[x]<br>E[x+y]&#x3D;E[x]+E[y]<br>下条当且仅当<strong>xy相互独立</strong>时成立<br>E[xy]&#x3D;E[x]E [y]</p><h4 id="期望与均值"><a href="#期望与均值" class="headerlink" title="期望与均值"></a>期望与均值</h4><p>期望E[x]为固定值，平均值是变化值<br>重复次数越多，平均值愈接近期望值</p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>衡量随机变量的离散情况<br>也是一种期望，是随机变量偏离度的期望<br>V[x]&#x3D;E[(x-u(平均值))^(2)]<br>V[x+c]&#x3D;v[x]<br>V[cx]&#x3D;c^(2)V[x]<br><strong>方差非线性</strong><br>仅当<strong>x，y相互独立</strong>时<br>V[x+y]&#x3D;v[x]+v[y]</p><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>给出了两个变量线性相关性的强度<br>Cov[x,y]&#x3D;E[(x-u)(y-v)]<br>对比方差<br>$$V[x]&#x3D;E[(x-u)^2]$$<br>协方差是方差定义的补充</p><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>(x-u)与(x-v)符号相同：协方差为正<br>代表一方大于期望值，另一方<strong>也</strong>大于期望值的概率高<br>(x-u)与(x-v)符号相反：协方差为负</p><h4 id="数学性质"><a href="#数学性质" class="headerlink" title="数学性质"></a>数学性质</h4><p>Cov[x,x]&#x3D;(方差)V[x]<br>Cov[x,y]&#x3D;Cov[y,x]<br>Cov[x+a,y+b]&#x3D;Cov[x,y]<br>Cov[ax,by]&#x3D;abCov[x,y]<br>Cov[ax,by]&#x3D;E[(ax-au)(by-bv)]&#x3D;abE[(a-u)(b-v)]</p><h4 id="独立变量的协方差"><a href="#独立变量的协方差" class="headerlink" title="独立变量的协方差"></a>独立变量的协方差</h4><p>若x，y相互独立，则协方差为0<br>cov[x,y]&#x3D;E[(x-u)(y-u)]&#x3D;E[x-u][y-u]&#x3D;0<br>变量独立则线性无关，&#x3D;协方差为0</p><h4 id="Ex"><a href="#Ex" class="headerlink" title="Ex."></a>Ex.</h4><p><img src="https://i.loli.net/2020/04/25/9y6zlFtRSxpOku5.jpg" alt="Alt"></p><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><p>方差是随机变量的平方，不能直接比较<br><img src="https://i.loli.net/2020/04/25/dn8r39Z51pwWQIs.jpg" alt="Alt"></p><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p><img src="https://i.loli.net/2020/04/25/G2QuNhSAHjxCF9n.jpg" alt="Alt"></p><h2 id="常用概率分布"><a href="#常用概率分布" class="headerlink" title="常用概率分布"></a>常用概率分布</h2><h3 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h3><p>(Bernouli distribution)是单个二值随机变量的分布，由p属于[0,1]控制，p即是随机变量&#x3D;1的概率<br>P(x&#x3D;1)&#x3D;p<br>P(x&#x3D;0)&#x3D;1-p&#x3D;q<br>E[x]&#x3D;1p+0(1-p)&#x3D;p<br>V[x]&#x3D;E[x^(2)]-E[x]^(2)&#x3D;p-p^(2)&#x3D;p(1-p)&#x3D;pq</p><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>(Binomial distribution):硬币正面向上的概率为P时，抛硬币n次后正面向上的概率。<br>二项分布是伯努利分布的叠加x&#x3D;z1+z2+…+zn,计作Bn(n,p)<br><img src="https://i.loli.net/2020/04/25/PV7oGMZH4AIvQhk.jpg" alt="Alt"></p><h3 id="正态分布（高斯分布）"><a href="#正态分布（高斯分布）" class="headerlink" title="正态分布（高斯分布）"></a>正态分布（高斯分布）</h3><p>标准正态分布<br>期望为0，方差为1<br><img src="https://i.loli.net/2020/04/25/DqYm4WgyJZz1tAM.jpg" alt="Alt"></p><h2 id="贝叶斯定律"><a href="#贝叶斯定律" class="headerlink" title="贝叶斯定律"></a>贝叶斯定律</h2><p><img src="https://i.loli.net/2020/04/25/ZXEqlR39T2ujAC5.jpg" alt="Alt"><br>Ex.<br><img src="https://i.loli.net/2020/04/25/NhJLM3B6Tf9bktl.jpg" alt="Alt"><br><img src="https://i.loli.net/2020/04/25/Ag8aWQ4KmjZ6zpD.jpg" alt="Alt"></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>概率与统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率与统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟集成电路设计</title>
    <link href="/Blogs/2025/08/28/%E6%A8%A1%E6%8B%9F%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E6%A8%A1%E6%8B%9F%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="集成电路设计​​"><a href="#集成电路设计​​" class="headerlink" title="集成电路设计​​"></a><strong>集成电路设计​</strong>​</h3><h4 id="​​1-电流源​​"><a href="#​​1-电流源​​" class="headerlink" title="​​1. 电流源​​"></a>​<strong>​1. 电流源​</strong>​</h4><ul><li>​<strong>​基本镜像​</strong>​：Iout​&#x3D;Iref​(W&#x2F;L)1​(W&#x2F;L)2​​</li><li>​<strong>​威尔逊镜像​</strong>​：提高输出阻抗</li></ul><h4 id="​​2-运算放大器​​"><a href="#​​2-运算放大器​​" class="headerlink" title="​​2. 运算放大器​​"></a>​<strong>​2. 运算放大器​</strong>​</h4><ul><li>​<strong>​两级结构​</strong>​：<ol><li>差分输入级（高增益）</li><li>共源输出级（低输出阻抗）</li></ol></li><li>​<strong>​GBW积​</strong>​：GBW&#x3D;Av0​⋅fH​</li></ul><p>分析方法 [[电路分析与设计]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>模拟电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟集成电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫原理</title>
    <link href="/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/"/>
    <url>/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-基本原理"><a href="#HTTP-基本原理" class="headerlink" title="HTTP 基本原理"></a>HTTP 基本原理</h1><p>在正式学习网络爬虫之前，我们需要详细了解 HTTP 的基本原理，了解在浏览器中敲入 URL 到获取网页内容之间发生了什么。了解这些内容，有助于我们进一步了解爬虫的基本原理。</p><h1 id="1-1-HTTP-基本原理"><a href="#1-1-HTTP-基本原理" class="headerlink" title="1.1 HTTP 基本原理"></a><a href="https://cuiqingcai.com/202212.html#1-1-HTTP-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" title="1.1 HTTP 基本原理"></a>1.1 HTTP 基本原理</h1><p>在本节中，我们会详细了解 HTTP 的基本原理，了解在浏览器中敲入 URL 到获取网页内容之间发生了什么。了解这些内容，有助于我们进一步了解爬虫的基本原理。</p><h2 id="1-URI-和-URL"><a href="#1-URI-和-URL" class="headerlink" title="1. URI 和 URL"></a><a href="https://cuiqingcai.com/202212.html#1-URI-%E5%92%8C-URL" title="1. URI 和 URL"></a>1. URI 和 URL</h2><p>这里我们先了解一下 URI 和 URL。URI 的全称为 Uniform Resource Identifier，即统一资源标志符；而 URL 的全称为 Universal Resource Locator，即统一资源定位符。举例来说，<a href="https://github.com/favicon.ico">https://github.com/favicon.ico</a> 是一个 URL，也是一个 URI。即有这样一个图标资源，我们用 URL&#x2F;URI 来唯一指定了它的访问方式，这其中包括了访问协议 https、访问路径（即根目录）和资源名称 favicon.ico。通过这样一个链接，我们便可以从互联网上找到这个资源，这就是 URL&#x2F;URI。</p><p>URL 是 URI 的子集，也就是说每个 URL 都是 URI，但不是每个 URI 都是 URL。那么，怎样的 URI 不是 URL 呢？URI 还包括一个子类，叫作 URN，它的全称为 Universal Resource Name，即统一资源名称。URN 只命名资源而不指定如何定位资源，比如 urn:isbn:0451450523 指定了一本书的 ISBN，可以唯一标识这本书，但是没有指定到哪里定位这本书，这就是 URN。URL、URN 和 URI 的关系可以用图 1-1 表示。</p><p><img src="https://cdn.cuiqingcai.com/l7600.jpg" alt="URL、URN 和 URI 关系图"></p><p>但是在目前的互联网，URN 使用得非常少，几乎所有的 URI 都是 URL，所以对于一般的网页链接，我们既可以称之为 URL，也可以称之为 URI，我个人习惯称之为 URL。</p><p>但 URL 也不是随便写的，它也是需要遵循一定的格式规范的，基本的组成格式如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>scheme:&#x2F;&#x2F;[username:password@]hostname[:port][&#x2F;path][;parameters][?query][#fragment]</td></tr></tbody></table><p>其中这里中括号包括的内容代表非必要部分，比如 <a href="https://www.baidu.com/">https://www.baidu.com</a> 这个 URL，这里就只包含了 scheme 和 host 两部分，其他的 port、path、parameters、query、fragment 都没有。</p><p>这里我们分别介绍下几部分代表的含义和作用：</p><ul><li>scheme：协议。比如常用的协议有 http、https、ftp 等等，另外 scheme 也被常称作 protocol，都代表协议的意思。</li><li>username、password：用户名和密码。在某些情况下 URL 需要提供用户名和密码才能访问，这时候可以把用户名密码放在 host 前面。比如 <a href="https://ssr3.scrape.center/">https://ssr3.scrape.center</a> 这个 URL 需要用户名密码才能访问，那么可以直接写为 <a href="https://admin:admin@ssr3.scrape.center/">https://admin:admin@ssr3.scrape.center</a> 则可以直接访问。</li><li>hostname：主机地址。可以是域名或 IP 地址，比如 <a href="https://www.baidu.com/">https://www.baidu.com</a> 这个 URL 中的 hostname 就是 <a href="http://www.baidu.com,这就是百度的二级域名.比如/">www.baidu.com，这就是百度的二级域名。比如</a> <a href="https://8.8.8.8/">https://8.8.8.8</a> 这个 URL 中 hostname 就是 8.8.8.8，它是一个 IP 地址。</li><li>port：端口。这是服务器设定的服务端口，比如 <a href="https://8.8.8.8:12345/">https://8.8.8.8:12345</a> 这个 URL 中的端口就是 12345。但是有些 URL 中没有端口信息，这是使用了默认的端口，http 协议的默认端口是 80，https 协议的默认端口是 443。所以 <a href="https://www.baidu.com/">https://www.baidu.com</a> 其实相当于 <a href="https://www.baidu.com:443，而">https://www.baidu.com:443，而</a> <a href="http://www.baidu.com/">http://www.baidu.com</a> 其实相当于 <a href="http://www.baidu.com:80。">http://www.baidu.com:80。</a></li><li>path：路径。指的是网络资源在服务器中的指定地址，比如 <a href="https://github.com/favicon.ico">https://github.com/favicon.ico</a> 这里 path 就是 favicon.ico，指的就是访问 GitHub 上的根目录下的 favicon.ico 这个资源。</li><li>parameters：参数。用来制定访问某个资源的时候的附加信息，比如 <a href="https://8.8.8.8:12345/hello;user">https://8.8.8.8:12345/hello;user</a> 这里的 user 就是 parameters。但是 parameters 现在用得很少，所以目前很多人会把该参数后面的 query 部分称为参数，甚至把 parameters 和 query 混用。严格意义上来说，parameters 是分号；后面的内容。</li><li>query：查询。用来查询某类资源，如果有多个查询，则用 &amp; 隔开。query 其实非常常见，比如 <a href="https://www.baidu.com/s?wd=nba&amp;ie=utf-8%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84">https://www.baidu.com/s?wd=nba&ie=utf-8，这里的</a> query 部分就是 wd&#x3D;nba&amp;ie&#x3D;utf-8，这里指定了 wd 是 nba，ie 是 utf-8。由于 query 比刚才所说的 parameters 使用频率高太多，所以平时我们见到的参数、GET 请求参数、parameters、params 等称呼多数情况指代的也是 query。严格意义上来说，其实应该用 query 来表示。</li><li>fragment：片段。它是对资源描述的部分补充，可以理解为资源内部的书签。目前它有两个主要应用，一个是用作单页面路由，比如 现代前端框架 Vue、React 都可以借助它来做路由管理；另外一个应用是用作 HTML 锚点，用它可以控制一个页面打开时自动下滑滚动到某个特定的位置。</li></ul><p>以上我们就简单了解了 URL 的基本概念和构成，后文我们会结合多个实战案例练习来帮助加深其理解。</p><h2 id="2-HTTP-和-HTTPS"><a href="#2-HTTP-和-HTTPS" class="headerlink" title="2. HTTP 和 HTTPS"></a><a href="https://cuiqingcai.com/202212.html#2-HTTP-%E5%92%8C-HTTPS" title="2. HTTP 和 HTTPS"></a>2. HTTP 和 HTTPS</h2><p>刚才我们了解了 URL 的基本构成，其支持的协议有很多，比如 http、https、ftp、sftp、smb 等等。</p><p>在爬虫中，我们抓取的页面通常基于 http 或 https 协议，这里首先我们先来了解一下这两个协议的含义。</p><p>HTTP 的全称是 Hyper Text Transfer Protocol，中文名叫作超文本传输协议。HTTP 协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP 由万维网协会（World Wide Web Consortium）和 Internet 工作小组 IETF（Internet Engineering Task Force）共同合作制定的规范，目前广泛使用的是 HTTP 1.1 版本，当然 HTTP 2.0 现在不少网站也增加了支持。</p><p>其发展历史见下表：</p><table><thead><tr><th>版本</th><th>产生时间</th><th>主要特点</th><th>发展现状</th></tr></thead><tbody><tr><td>HTTP&#x2F;0.9</td><td>1991 年</td><td>不涉及数据包传输，规定客户端和服务器之间通信格式，只能 GET 请求</td><td>没有作为正式的标准</td></tr><tr><td>HTTP&#x2F;1.0</td><td>1996 年</td><td>传输内容格式不限制，增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 命令</td><td>正式作为标准</td></tr><tr><td>HTTP&#x2F;1.1</td><td>1997 年</td><td>持久连接 (长连接)、节约带宽、HOST 域、管道机制、分块传输编码</td><td>正式作为标准并广泛使用</td></tr><tr><td>HTTP&#x2F;2.0</td><td>2015 年</td><td>多路复用、服务器推送、头信息压缩、二进制协议等</td><td>逐渐覆盖市场</td></tr></tbody></table><p>HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即在 HTTP 下加入 SSL 层，简称为 HTTPS。</p><p>HTTPS 的安全基础是 SSL，因此通过它传输的内容都是经过 SSL 加密的，它的主要作用分为以下两种。</p><ul><li>建立一个信息安全通道，保证数据传输的安全性。</li><li>确认网站的真实性。凡是使用了 https 的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过 CA 机构颁发的安全签章来查询。</li></ul><p>现在越来越多的网站和 App 都已经向 HTTPS 方向发展，举例如下。</p><ul><li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。</li><li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。</li><li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li></ul><p>因此，HTTPS 已经是大势所趋。</p><blockquote><p>注：HTTP 和 HTTPS 协议都属于计算机网络中的应用层协议，其下层是基于 TCP 协议实现的，TCP 协议属于计算机网络中的传输层协议，包括建立连接时的三次握手和断开时的四次挥手等过程。但本书主要讲的是网络爬虫相关，主要爬取的是 HTTP&#x2F;HTTPS 协议相关的内容，所以这里就不再展开深入讲解 TCP、IP 等相关知识了，感兴趣的读者可以搜索相关资料了解下，如《计算机网络》、《图解 HTTP》等书籍。</p></blockquote><h2 id="3-HTTP-请求过程"><a href="#3-HTTP-请求过程" class="headerlink" title="3. HTTP 请求过程"></a><a href="https://cuiqingcai.com/202212.html#3-HTTP-%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B" title="3. HTTP 请求过程"></a>3. HTTP 请求过程</h2><p>我们在浏览器中输入一个 URL，回车之后便会在浏览器中观察到页面内容。</p><p>实际上，这个过程是浏览器向网站所在的服务器发送了一个请求，网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</p><p>由于响应里包含页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，流程如图 1-3 所示。</p><p><img src="https://cdn.cuiqingcai.com/aod7o.jpg" alt="模型图"></p><p>此处客户端即代表我们自己的 PC 或手机浏览器，服务器即要访问的网站所在的服务器。</p><p>为了更直观地说明这个过程，这里用 Chrome 浏览器开发者模式下的 Network 监听组件来做下演示，它可以显示访问当前请求网页时发生的所有网络请求和响应。</p><p>打开 Chrome 浏览器，访问百度 <a href="http://www.baidu.com/">http://www.baidu.com/</a>，这时候鼠标右键并选择 “检查” 菜单（或直接按快捷键 F12），即可打开浏览器的开发者工具，如下图所示：</p><p><img src="https://cdn.cuiqingcai.com/rc3jq.png" alt="打开浏览器的开发者工具"></p><p>我们切换到 Network 面板，然后重新刷新网页，这时候就可以看到在 Network 面板下方出现了很多个条目，其中一个条目就代表一次发送请求和接收响应的过程，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/lwt4l.png" alt="请求和接收响应的过程"></p><p>我们先观察第一个网络请求，即 <a href="http://www.baidu.com,其中各列的含义如下./">www.baidu.com，其中各列的含义如下。</a></p><ul><li>第一列 Name：请求的名称，一般会将 URL 的最后一部分内容当作名称。</li><li>第二列 Status：响应的状态码，这里显示为 200，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。</li><li>第三列 Protocol：请求的协议类型，这里 http&#x2F;1.1 代表是 HTTP 1.1 版本，h2 代表 HTTP 2.0 版本。</li><li>第四列 Type：请求的文档类型。这里为 document，代表我们这次请求的是一个 HTML 文档，内容就是一些 HTML 代码。</li><li>第五列 Initiator：请求源。用来标记请求是由哪个对象或进程发起的。</li><li>第六列 Size：从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示 from cache。</li><li>第七列 Time：发起请求到获取响应所用的总时间。</li><li>第八列 Waterfall：网络请求的可视化瀑布流。</li></ul><p>我们点击这个条目，即可看到其更详细的信息，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/0utz7.png" alt="更详细的信息"></p><p>首先是 General 部分，其中 Request URL 为请求的 URL，Request Method 为请求的方法，Status Code 为响应状态码，Remote Address 为远程服务器的地址和端口，Referrer Policy 为 Referrer 判别策略。</p><p>再继续往下可以看到，有 Response Headers 和 Request Headers，它们分别代表响应头和请求头。请求头里带有许多请求信息，例如浏览器标识、Cookie、Host 等信息，这是请求的一部分，服务器会根据请求头内的信息判断请求是否合法，进而作出对应的响应。图 1-5 中看到的 Response Headers 就是响应的一部分，其中包含了服务器的类型、文档类型、日期等信息，浏览器接收到响应后，会解析响应内容，进而呈现网页内容。</p><p>下面我们分别来介绍一下请求和响应都包含哪些内容。</p><h2 id="4-请求（Request）"><a href="#4-请求（Request）" class="headerlink" title="4. 请求（Request）"></a><a href="https://cuiqingcai.com/202212.html#4-%E8%AF%B7%E6%B1%82%EF%BC%88Request%EF%BC%89" title="4. 请求（Request）"></a>4. 请求（Request）</h2><p>请求，英文为 Request，由客户端向服务器发出，可以分为 4 部分内容：请求方法（Request Method）、请求的网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。</p><p>下面我们分别予以介绍。</p><h3 id="请求方法（Request-Method）"><a href="#请求方法（Request-Method）" class="headerlink" title="请求方法（Request Method）"></a><a href="https://cuiqingcai.com/202212.html#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%88Request-Method%EF%BC%89" title="请求方法（Request Method）"></a>请求方法（Request Method）</h3><p>请求方法，英文为 Request Method，用于标识请求客户端请求服务端的方式，常见的请求方法有两种：GET 和 POST。</p><p>在浏览器中直接输入 URL 并回车，这便发起了一个 GET 请求，请求的参数会直接包含到 URL 里。例如，在百度中搜索 Python，这就是一个 GET 请求，链接为 <a href="https://www.baidu.com/s?wd=Python">https://www.baidu.com/s?wd=Python</a>，其中 URL 中包含了请求的 query 信息，这里的参数 wd 表示要搜寻的关键字。POST 请求大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击 “登录” 按钮，这通常会发起一个 POST 请求，其数据通常以表单的形式传输，而不会体现在 URL 中。</p><p>GET 和 POST 请求方法有如下区别：</p><ul><li>GET 请求中的参数包含在 URL 里面，数据可以在 URL 中看到；而 POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li><li>GET 请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。</li></ul><p>一般来说，登录时，需要提交用户名和密码，其中包含了敏感信息，使用 GET 方式请求的话，密码就会暴露在 URL 里面，造成密码泄露，所以这里最好以 POST 方式发送。上传文件时，由于文件内容比较大，也会选用 POST 方式。</p><p>我们平常遇到的绝大部分请求都是 GET 或 POST 请求。另外，还有一些请求方法，如 GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE 等，我们简单将其总结为下表。</p><table><thead><tr><th>方　　法</th><th>描　　述</th></tr></thead><tbody><tr><td>GET</td><td>请求页面，并返回页面内容</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>本表参考：<a href="http://www.runoob.com/http/http-methods.html">http://www.runoob.com/http/http-methods.html</a>。</p><h3 id="请求的网址（Request-URL）"><a href="#请求的网址（Request-URL）" class="headerlink" title="请求的网址（Request URL）"></a><a href="https://cuiqingcai.com/202212.html#%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BD%91%E5%9D%80%EF%BC%88Request-URL%EF%BC%89" title="请求的网址（Request URL）"></a>请求的网址（Request URL）</h3><p>请求的网址，英文为 Reqeust URL，它可以唯一确定我们想请求的资源。关于 URL 的构成和各个部分的功能我们在前文已经提及到了，这里就不再赘述。</p><h3 id="请求头（Request-Headers）"><a href="#请求头（Request-Headers）" class="headerlink" title="请求头（Request Headers）"></a><a href="https://cuiqingcai.com/202212.html#%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%88Request-Headers%EF%BC%89" title="请求头（Request Headers）"></a>请求头（Request Headers）</h3><p>请求头，英文为 Request Headers，用来说明服务器要使用的附加信息，比较重要的信息有 Cookie、Referer、User-Agent 等。</p><p>下面简要说明一些常用的头信息：</p><ul><li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码。</li><li>Host：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL 的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。</li><li>Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是 Cookie 的功劳。Cookie 里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上 Cookie 并将其发送给服务器，服务器通过 Cookie 识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li><li>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做来源统计、防盗链处理等。</li><li>User-Agent：简称 UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别为爬虫。</li><li>Content-Type：也叫互联网媒体类型（Internet Media Type）或者 MIME 类型，在 HTTP 协议消息头中，它用来表示具体请求中的媒体类型信息。例如，text&#x2F;html 代表 HTML 格式，image&#x2F;gif 代表 GIF 图片，application&#x2F;json 代表 JSON 类型，更多对应关系可以查看此对照表：<a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a>。</li></ul><p>因此，请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h3 id="请求体（Request-Body）"><a href="#请求体（Request-Body）" class="headerlink" title="请求体（Request Body）"></a><a href="https://cuiqingcai.com/202212.html#%E8%AF%B7%E6%B1%82%E4%BD%93%EF%BC%88Request-Body%EF%BC%89" title="请求体（Request Body）"></a>请求体（Request Body）</h3><p>请求体，即 Request Body 一般承载的内容是 POST 请求中的表单数据，而对于 GET 请求，请求体则为空。</p><p>例如，这里我登录 GitHub 时捕获到的请求和响应如图 1-6 所示。</p><p><img src="https://cdn.cuiqingcai.com/4tinn.jpg" alt="请求和响应"></p><p>登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，此时需要注意 Request Headers 中指定 Content-Type 为 application&#x2F;x-www-form-urlencoded。只有设置 Content-Type 为 application&#x2F;x-www-form-urlencoded，才会以表单数据的形式提交。另外，我们也可以将 Content-Type 设置为 application&#x2F;json 来提交 JSON 数据，或者设置为 multipart&#x2F;form-data 来上传文件。</p><p>如下表是 Content-Type 和 POST 提交数据方式的关系</p><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart&#x2F;form-data</td><td>表单文件上传</td></tr><tr><td>application&#x2F;json</td><td>序列化 JSON 数据</td></tr><tr><td>text&#x2F;xml</td><td>XML 数据</td></tr></tbody></table><p>在爬虫中，如果要构造 POST 请求，需要使用正确的 Content-Type，并了解各种请求库的各个参数设置时使用的是哪种 Content-Type，不然可能会导致 POST 提交后无法正常响应。</p><h2 id="5-响应（Response）"><a href="#5-响应（Response）" class="headerlink" title="5. 响应（Response）"></a><a href="https://cuiqingcai.com/202212.html#5-%E5%93%8D%E5%BA%94%EF%BC%88Response%EF%BC%89" title="5. 响应（Response）"></a>5. 响应（Response）</h2><p>响应，即 Response，由服务器返回给客户端，可以分为三部分：响应状态码（Response Status Code）、响应头（Response Headers）和响应体（Response Body）。</p><h3 id="响应状态码（Response-Status-Code）"><a href="#响应状态码（Response-Status-Code）" class="headerlink" title="响应状态码（Response Status Code）"></a><a href="https://cuiqingcai.com/202212.html#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%88Response-Status-Code%EF%BC%89" title="响应状态码（Response Status Code）"></a>响应状态码（Response Status Code）</h3><p>响应状态码，即 Response Status Code，表示服务器的响应状态，如 200 代表服务器正常响应，404 代表页面未找到，500 代表服务器内部发生错误。在爬虫中，我们可以根据状态码来判断服务器响应状态，如状态码为 200，则证明成功返回数据，再进行进一步的处理，否则直接忽略。下表列出了常见的错误代码及错误原因。</p><p>常见的错误代码及错误原因</p><table><thead><tr><th>状态码</th><th>说　　明</th><th>详　　情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，内容被重置</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td>302</td><td>临时移动</td><td>请求的网页暂时跳转到其他页面，即暂时重定向</td></tr><tr><td>303</td><td>查看其他位置</td><td>如果原来的请求是 POST，重定向目标文档应该通过 GET 提取</td></tr><tr><td>304</td><td>未修改</td><td>此次请求返回的网页未修改，继续使用上次的资源</td></tr><tr><td>305</td><td>使用代理</td><td>请求者应该使用代理访问该网页</td></tr><tr><td>307</td><td>临时重定向</td><td>请求的资源临时从其他位置响应</td></tr><tr><td>400</td><td>错误请求</td><td>服务器无法解析该请求</td></tr><tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过</td></tr><tr><td>403</td><td>禁止访问</td><td>服务器拒绝此请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页</td></tr><tr><td>405</td><td>方法禁用</td><td>服务器禁用了请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容响应请求的网页</td></tr><tr><td>407</td><td>需要代理授权</td><td>请求者需要使用代理授权</td></tr><tr><td>408</td><td>请求超时</td><td>服务器请求超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突</td></tr><tr><td>410</td><td>已删除</td><td>请求的资源已永久删除</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求 URI 过长</td><td>请求网址过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持类型</td><td>请求格式不被请求页面支持</td></tr><tr><td>416</td><td>请求范围不符</td><td>页面无法提供请求的范围</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足期望请求标头字段的要求</td></tr><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>未实现</td><td>服务器不具备完成请求的功能</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求</td></tr><tr><td>505</td><td>HTTP 版本不支持</td><td>服务器不支持请求中所用的 HTTP 协议版本</td></tr></tbody></table><h3 id="响应头（Response-Headers）"><a href="#响应头（Response-Headers）" class="headerlink" title="响应头（Response Headers）"></a><a href="https://cuiqingcai.com/202212.html#%E5%93%8D%E5%BA%94%E5%A4%B4%EF%BC%88Response-Headers%EF%BC%89" title="响应头（Response Headers）"></a>响应头（Response Headers）</h3><p>响应头，即 Response Headers，包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。下面简要说明一些常用的头信息。</p><ul><li>Date：标识响应产生的时间。</li><li>Last-Modified：指定资源的最后修改时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号等。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如 text&#x2F;html 代表返回 HTML 文档，application&#x2F;x-javascript 则代表返回 JavaScript 文件，image&#x2F;jpeg 则代表返回图片。</li><li>Set-Cookie：设置 Cookie。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookie 中，下次请求携带 Cookie 请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h3 id="响应体（Response-Body）"><a href="#响应体（Response-Body）" class="headerlink" title="响应体（Response Body）"></a><a href="https://cuiqingcai.com/202212.html#%E5%93%8D%E5%BA%94%E4%BD%93%EF%BC%88Response-Body%EF%BC%89" title="响应体（Response Body）"></a>响应体（Response Body）</h3><p>响应体，即 Response Body，这可以说是最关键的部分了，响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的 HTML 代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体，如图 1-7 所示。</p><p><img src="https://cdn.cuiqingcai.com/6sq5o.jpg" alt="响应体"></p><p>在浏览器开发者工具中点击 Preview，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。</p><p>在做爬虫时，我们主要通过响应体得到网页的源代码、JSON 数据等，然后从中做相应内容的提取。</p><p>本节中，我们了解了 HTTP 的基本原理，大概了解了访问网页时背后的请求和响应过程。本节涉及的知识点需要好好掌握，后面分析网页请求时会经常用到。</p><h2 id="6-HTTP-2-0"><a href="#6-HTTP-2-0" class="headerlink" title="6. HTTP&#x2F;2.0"></a><a href="https://cuiqingcai.com/202212.html#6-HTTP-2-0" title="6. HTTP/2.0"></a>6. HTTP&#x2F;2.0</h2><p>前面我们也提到了 HTTP 协议从 2015 年起发布了 2.0 版本，相比 HTTP&#x2F;1.1 来说，HTTP&#x2F;2.0 变得更快、更简单、更稳定，HTTP&#x2F;2.0 在传输层做了很多优化，HTTP&#x2F;2.0 的主要目标是通过支持完整的请求与响应复用来减少延迟，并通过有效压缩 HTTP 请求头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持，这些优化一笔勾销了 HTTP&#x2F;1.1 为做传输优化想出的一系列 “歪招”。</p><p>有读者这时候可能会问，为什么不叫 HTTP&#x2F;1.2 而叫 HTTP&#x2F;2.0 呢？因为 HTTP&#x2F;2.0 在内部实现上新的二进制分帧层，这是没法与之前的 HTTP&#x2F;1.x 的服务器和客户端实现向后兼容的，所以直接修改了主版本号为 2.0。</p><p>下面我们就来了解下 HTTP&#x2F;2.0 相比 HTTP&#x2F;1.1 来说做了哪些优化吧。</p><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a><a href="https://cuiqingcai.com/202212.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82" title="二进制分帧层"></a>二进制分帧层</h3><p>HTTP&#x2F;2.0 所有性能增强的核心就在于这个新的二进制分帧层。在 HTTP&#x2F;1.x 中，不管是请求（Request）还是响应（Response），它们都是用文本格式传输的，其头部（Headers）、实体（Body）之间也是用文本换行符分隔开的。HTTP&#x2F;2.0 对其做了优化，将文本格式修改为了二进制格式，使得解析起来更加高效。同时将请求和响应数据分割为更小的帧，并采用二进制编码。</p><p>所以这里就引入了几个新的概念：</p><ul><li>帧：只存在于 HTTP&#x2F;2.0 中的概念，是数据通信的最小单位，比如一个请求被分为了请求头帧（Request Headers frame）和请求体 &#x2F; 数据帧（Request Data frame）。</li><li>数据流：一个虚拟通道，可以承载双向的消息，每个流都有一个唯一的整数 ID 来标识。</li><li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li></ul><p>在 HTTP&#x2F;2.0 中，同域名下的所有通信都可以在单个连接上完成，该连接可以承载任意数量的双向数据流，数据流是用于承载双向消息的，每条消息都是一条逻辑 HTTP 消息（例如请求或响应），它可以包含一个或多个帧。</p><p>简而言之，HTTP&#x2F;2.0 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息，所有这些都在一个 TCP 连接内复用，这是 HTTP&#x2F;2.0 协议所有其他功能和性能优化的基础。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><a href="https://cuiqingcai.com/202212.html#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8" title="多路复用"></a>多路复用</h3><p>在 HTTP&#x2F;1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接，而且浏览器位了控制资源，还会对单个域名有 6-8 个 TCP 连接请求的限制。但在 HTTP&#x2F;2.0 中，由于又了二进制分帧技术的加持，HTTP&#x2F;2.0 不用再以来 TCP 连接去实现多路并行了，客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来，让我们可以:</p><ul><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>使用一个连接并行发送多个请求和响应。</li><li>不必再为绕过 HTTP&#x2F;1.x 限制而做很多工作。</li><li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li></ul><p>这样以来，整个数据传输使性能就有了极大提升：</p><ul><li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应，消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>并行交错地发送多个请求和详情，而且之间互不影响。</li><li>在 HTTP&#x2F;2.0 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><a href="https://cuiqingcai.com/202212.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" title="流量控制"></a>流量控制</h3><p>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。可以理解为，接收方已经太繁忙了，来不及处理收到的消息了，但是发送方还在一直大量发送消息，这样就会出现一些问题。</p><p>比如说，客户端可能请求了一个具有较高优先级的大型视频流，但是用户已经暂停视频，客户端现在希望暂停或限制从服务器的传输，以免提取和缓冲不必要的数据。 再比如，一个代理服务器可能具有较快的下游连接和较慢的上游连接，并且也希望调节下游连接传输数据的速度以匹配上游连接的速度来控制其资源利用率等等。</p><p>由于 HTTP 是基于 TCP 实现的，虽然 TCP 原生有流量控制机制，但是由于 HTTP&#x2F;2.0 数据流在一个 TCP 连接内复用，TCP 流控制既不够精细，也无法提供必要的应用级 API 来调节各个数据流的传输。</p><p>为了解决这一问题，HTTP&#x2F;2.0 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制:</p><ul><li>流控制具有方向性。 每个接收方都可以根据自身需要选择为每个数据流和整个连接设置任意的窗口大小。</li><li>流控制基于信用。 每个接收方都可以公布其初始连接和数据流流控制窗口（以字节为单位），每当发送方发出 <code>DATA</code> 帧时都会减小，在接收方发出 <code>WINDOW_UPDATE</code> 帧时增大。</li><li>流控制无法停用。 建立 HTTP&#x2F;2.0 连接后，客户端将与服务器交换 <code>SETTINGS</code> 帧，这会在两个方向上设置流控制窗口。 流控制窗口的默认值设为 65535 字节，但是接收方可以设置一个较大的最大窗口大小（<code>2^31-1</code> 字节），并在接收到任意数据时通过发送 <code>WINDOW_UPDATE</code> 帧来维持这一大小。</li><li>流控制为逐跃点控制，而非端到端控制。 即，可信中介可以使用它来控制资源使用，以及基于自身条件和启发式算法实现资源分配机制。</li></ul><p>由此可见，HTTP&#x2F;2.0 提供了简单的构建块实现了自定义策略来调节资源使用和分配，以及实现新传输能力，同时提升了网页应用的实际性能和感知性能。</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a><a href="https://cuiqingcai.com/202212.html#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81" title="服务端推送"></a>服务端推送</h3><p>HTTP&#x2F;2.0 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</p><p>如果某些资源客户端是一定会请求的，这时就可以采取服务端推送的技术，在客户端发起一次请求后，额外提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。例如，服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p><p><img src="https://cdn.cuiqingcai.com/y0vea.png" alt="服务端推送"></p><p>服务端可以主动推送，当然客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。</p><p>另外主动推送也遵守同源策略，即服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行，这样也能保证一定的安全性。</p><h3 id="HTTP-2-0-发展现状"><a href="#HTTP-2-0-发展现状" class="headerlink" title="HTTP&#x2F;2.0 发展现状"></a><a href="https://cuiqingcai.com/202212.html#HTTP-2-0-%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6" title="HTTP/2.0 发展现状"></a>HTTP&#x2F;2.0 发展现状</h3><p>HTTP&#x2F;2.0 的普及是一件任重而道远的事情，一些主流的网站现在已经支持了 HTTP&#x2F;2.0，主流浏览器现在都已经实现了 HTTP&#x2F;2.0 的支持，但总的来看，目前大部分网站依然还是以 HTTP&#x2F;1.1 为主。</p><p>另外一些编程语言的库还没有完全支持 HTTP&#x2F;2.0，比如对于 Python 来说，hyper、httpx 等库已经支持了 HTTP&#x2F;2.0，但广泛使用的 requests 库依然还是只支持 HTTP&#x2F;1.1。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><a href="https://cuiqingcai.com/202212.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>本节介绍了关于 HTTP 的一些基础知识，内容不少，需要好好掌握，这些知识对于后面我们编写和理解网络爬虫具有非常大的帮助。</p><p>由于本节的内容多数为概念介绍，内容参考了很多书籍、文档、博客，来源如下：</p><ul><li>书籍 - 《HTTP 权威指南》- 作者 David Gourley &#x2F; Brian Totty</li><li>文档 - HTTP - 维基百科：<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></li><li>文档 - HTTP - 百度百科：<a href="https://baike.baidu.com/item/HTTP/243074">https://baike.baidu.com/item/HTTP/243074</a></li><li>文档 - HTTP - MDN Web Docs：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">https://developer.mozilla.org/en-US/docs/Web/HTTP</a></li><li>文档 - HTTP&#x2F;2 简介 - Google 开发文档：<a href="https://developers.google.com/web/fundamentals/performance/http2">https://developers.google.com/web/fundamentals/performance/http2</a></li><li>博客 - 一文读懂 HTTP&#x2F;2 及 HTTP&#x2F;3 特性：<a href="https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/">https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/</a></li><li>博客 - 一文读懂 HTTP&#x2F;2 特性：<a href="https://zhuanlan.zhihu.com/p/26559480">https://zhuanlan.zhihu.com/p/26559480</a></li></ul><h1 id="web网页基础"><a href="#web网页基础" class="headerlink" title="web网页基础"></a>web网页基础</h1><p>用浏览器访问网站时，页面各不相同，你有没有想过它为何会呈现这个样子呢？本节中，我们就来了解一下网页的组成、结构和节点等内容。</p><h2 id="1-网页的组成"><a href="#1-网页的组成" class="headerlink" title="1. 网页的组成"></a><a href="https://cuiqingcai.com/202213.html#1-%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%84%E6%88%90" title="1. 网页的组成"></a>1. 网页的组成</h2><p>网页可以分为三大部分 —— HTML、CSS 和 JavaScript。如果把网页比作一个人的话，HTML 相当于骨架，JavaScript 相当于肌肉，CSS 相当于皮肤，三者结合起来才能形成一个完善的网页。下面我们分别来介绍一下这三部分的功能。</p><h3 id="（1）HTML"><a href="#（1）HTML" class="headerlink" title="（1）HTML"></a><a href="https://cuiqingcai.com/202213.html#%EF%BC%881%EF%BC%89HTML" title="（1）HTML"></a>（1）HTML</h3><p>HTML，其英文叫做 HyperText Markup Language，中文翻译叫做超文本标记语言，但我们通常不会用中文翻译来称呼它，一般就叫 HTML。</p><p>HTML 是用来描述网页的一种语言，网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是 HTML。不同类型的元素通过不同类型的标签来表示，如图片用 <code>img</code>标签表示，视频用 <code>video</code> 标签表示，段落用 <code>p</code> 标签表示，它们之间的布局又常通过布局标签 <code>div</code> 嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。</p><p>那 HTML 长什么样子呢？我们可以随意打开一个网站，比如淘宝 <a href="https://www.taobao.com,然后右键菜单点击“检查元素”或者按/">https://www.taobao.com，然后右键菜单点击 “检查元素” 或者按</a> F12 快捷键，即可打开浏览器开发者工具，切换到 Elements 面板，这时候就可以看到这里呈现的就是淘宝网对应的 HTML，它包含了一系列标签，浏览器解析这些标签后，便会在网页中渲染成一个个的节点，这便形成了我们平常看到的网页。比如这里可以看到一个输入框就对应一个 input 标签，可以用于输入文字。</p><p><img src="https://cdn.cuiqingcai.com/jq4ak.png"></p><p>不同的标签对应着不同的功能，这些标签定义的节点相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p><h3 id="（2）CSS"><a href="#（2）CSS" class="headerlink" title="（2）CSS"></a><a href="https://cuiqingcai.com/202213.html#%EF%BC%882%EF%BC%89CSS" title="（2）CSS"></a>（2）CSS</h3><p>HTML 定义了网页的结构，但是只有 HTML 页面的布局并不美观，可能只是简单的节点元素的排列。为了让网页看起来更好看一些，这里借助了 CSS。</p><p>CSS，全称叫作 Cascading Style Sheets，即层叠样式表。“层叠” 是指当在 HTML 中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式” 指网页中文字大小、颜色、元素间距、排列等格式。CSS 是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。</p><p>在上图中，Styles 面板呈现的就是一系列 CSS 样式，比如摘抄一段 CSS，内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>#head_wrapper.s-ps-islite .s-p-top {  <br>  position: absolute;  <br>  bottom: 40px;  <br>  width: 100%;  <br>  height: 181px;  <br>}</td></tr></tbody></table><p>这就是一个 CSS 样式。大括号前面是一个 CSS 选择器。此选择器的意思是首先选中 <code>id</code> 为 <code>head_wrapper</code> 且 <code>class</code> 为 <code>s-ps-islite</code> 的节点，然后再选中其内部的 <code>class</code> 为 <code>s-p-top</code> 的节点。大括号内部写的就是一条条样式规则，例如 <code>position</code> 指定了这个节点的布局方式为绝对布局，<code>bottom</code> 指定节点的下边距为 40 像素，<code>width</code> 指定了宽度为 100%，表示占满父节点，height 则指定了节点的高度。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上 CSS 选择器，这就代表这个样式对 CSS 选择器选中的节点生效，节点就会根据此样式来展示了。</p><p>在网页中，一般会统一定义整个网页的样式规则，并写入 CSS 文件中（其后缀为 css）。在 HTML 中，只需要用 <code>link</code> 标签即可引入写好的 CSS 文件，这样整个页面就会变得美观、优雅。</p><h3 id="（3）JavaScript"><a href="#（3）JavaScript" class="headerlink" title="（3）JavaScript"></a><a href="https://cuiqingcai.com/202213.html#%EF%BC%883%EF%BC%89JavaScript" title="（3）JavaScript"></a>（3）JavaScript</h3><p>JavaScript，简称 JS，是一种脚本语言。HTML 和 CSS 配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是 JavaScript 的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。</p><p>JavaScript 通常也是以单独的文件形式加载的，后缀为 js，在 HTML 中通过 <code>script</code> 标签即可引入，例如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><script src="jquery-2.1.0.js"></script></td></tr></tbody></table><p>综上所述，HTML 定义了网页的内容和结构，CSS 描述了网页的样式，JavaScript 定义了网页的行为。</p><h2 id="2-网页的结构"><a href="#2-网页的结构" class="headerlink" title="2. 网页的结构"></a><a href="https://cuiqingcai.com/202213.html#2-%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%93%E6%9E%84" title="2. 网页的结构"></a>2. 网页的结构</h2><p>我们首先用例子来感受一下 HTML 的基本结构。新建一个文本文件，名称叫做 test.html，内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><html>  <br>  <head>  <br>    <meta charset="UTF-8" />  <br>    <title>This is a Demo</title>  <br>  </head>  <br>  <body>  <br>    <div id="container">  <br>      <div class="wrapper">  <br>        <h2 class="title">Hello World</h2>  <br>        <p class="text">Hello, this is a paragraph.</p>  <br>      </div>  <br>    </div>  <br>  </body>  <br></html></td></tr></tbody></table><p>这就是一个最简单的 HTML 实例。开头用 <code>DOCTYPE</code> 定义了文档类型，其次最外层是 <code>html</code> 标签，最后还有对应的结束标签来表示闭合，其内部是 <code>head</code> 标签和 <code>body</code> 标签，分别代表网页头和网页体，它们也需要结束标签。<code>head</code> 标签内定义了一些页面的配置和引用，如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><meta charset="UTF-8" /></td></tr></tbody></table><p>它指定了网页的编码为 UTF-8。</p><p><code>title</code> 标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。<code>body</code> 标签内则是在网页正文中显示的内容。<code>div</code> 标签定义了网页中的区块，它的 <code>id</code> 是 <code>container</code>，这是一个非常常用的属性，且 <code>id</code> 的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个 <code>div</code> 标签，它的 <code>class</code> 为 <code>wrapper</code>，这也是一个非常常用的属性，经常与 CSS 配合使用来设定样式。然后此区块内部又有一个 <code>h2</code> 标签，这代表一个二级标题。另外，还有一个 <code>p</code> 标签，这代表一个段落。在这两者中直接写入相应的内容即可在网页中呈现出来，它们也有各自的 <code>class</code> 属性。</p><p>将代码保存后，双击该文件在浏览器中打开，可以看到如图所示的内容。</p><p><img src="https://cdn.cuiqingcai.com/wi3k2.png" alt="运行结果"></p><p>可以看到，选项卡上显示了 This is a Demo 字样，这是我们在 <code>head</code> 中的 <code>title</code> 里定义的文字。而网页正文是 <code>body</code> 标签内部定义的各个元素生成的，可以看到这里显示了二级标题和段落。</p><p>这个实例便是网页的一般结构。一个网页的标准形式是 <code>html</code> 标签内嵌套 <code>head</code> 和 <code>body</code> 标签，<code>head</code> 内定义网页的配置和引用，<code>body</code> 内定义网页的正文。</p><h2 id="3-节点树及节点间的关系"><a href="#3-节点树及节点间的关系" class="headerlink" title="3 节点树及节点间的关系"></a><a href="https://cuiqingcai.com/202213.html#3-%E8%8A%82%E7%82%B9%E6%A0%91%E5%8F%8A%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB" title="3 节点树及节点间的关系"></a>3 节点树及节点间的关系</h2><p>在 HTML 中，所有标签定义的内容都是节点，它们构成了一个 HTML 节点树，也称之为 HTML DOM 树。</p><p>我们先看下什么是 DOM。DOM 是 W3C（万维网联盟）的标准，其英文全称 Document Object Model，即文档对象模型。它定义了访问 HTML 和 XML 文档的标准。根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点。</p><ul><li>整个网站文档是一个文档节点。</li><li>每个 html 标签对应一个根元素节点，即上例中的 html 标签，这属于一个跟元素节点。</li><li>节点内的文本是文本节点，比如 a 节点代表一个超链接，它内部的文本也被认为是一个文本节点。</li><li>每个节点的属性是属性节点，比如 a 节点有一个 href 属性，它就是一个属性节点。</li><li>注释是注释节点，在 HTML 中有特殊的语法会被解析为注释，但其也会对应一个节点。</li></ul><p>所以，HTML DOM 将 HTML 文档视作树结构，这种结构被称为节点树，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/5fe0q.jpg" alt="节点树"></p><p>通过 HTML DOM，树中的所有节点均可通过 JavaScript 访问，所有 HTML 节点元素均可被修改，也可以被创建或删除。</p><p>节点树中的节点彼此拥有层级关系。我们常用父（parent）、子（child）和兄弟（sibling）等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。</p><p>在节点树中，顶端节点称为根（root）。除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。图展示了节点树以及节点之间的关系。</p><p><img src="https://cdn.cuiqingcai.com/muz4m.jpg" alt="节点树及节点间的关系"></p><h2 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4. 选择器"></a><a href="https://cuiqingcai.com/202213.html#4-%E9%80%89%E6%8B%A9%E5%99%A8" title="4. 选择器"></a>4. 选择器</h2><p>我们知道网页由一个个节点组成，CSS 选择器会根据不同的节点设置不同的样式规则，那么怎样来定位节点呢？</p><p>在 CSS 中，我们使用 CSS 选择器来定位节点。例如，上例中 <code>div</code> 节点的 <code>id</code> 为 <code>container</code>，那么就可以表示为 <code>#container</code>，其中 <code>#</code> 开头代表选择 <code>id</code>，其后紧跟 <code>id</code>的名称。另外，如果我们想选择 <code>class</code> 为 <code>wrapper</code> 的节点，便可以使用<code>.wrapper</code>，这里以点（.）开头代表选择 <code>class</code>，其后紧跟 <code>class</code> 的名称。另外，还有一种选择方式，那就是根据标签名筛选，例如想选择二级标题，直接用 <code>h2</code> 即可。这是最常用的 3 种表示，分别是根据 <code>id</code>、<code>class</code>、标签名筛选，请牢记它们的写法。</p><p>另外，CSS 选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表嵌套关系，如 <code>#container .wrapper p</code> 则代表先选择 <code>id</code> 为 <code>container</code> 的节点，然后选中其内部的 <code>class</code> 为 <code>wrapper</code> 的节点，然后再进一步选中其内部的 <code>p</code> 节点。另外，如果不加空格，则代表并列关系，如 <code>div#container .wrapper p.text</code> 代表先选择 <code>id</code> 为 <code>container</code> 的 <code>div</code> 节点，然后选中其内部的 <code>class</code> 为 <code>wrapper</code> 的节点，再进一步选中其内部的 <code>class</code> 为 <code>text</code> 的 <code>p</code> 节点。这就是 CSS 选择器，其筛选功能还是非常强大的。</p><p>我们可以在浏览器中测试 CSS 选择器的效果，依然还是打开浏览器的开发者工具，然后按快捷键 Ctrl + F（如果你用的是 Mac，则是 Command + F），这时候在左下角便会出现一个搜索框，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/x3taf.png"></p><p>这时候我们输入 <code>.title</code> 就是选中了 class 为 title 的节点，这时候该节点就会被选中并在网页中高亮显示，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/ww6nn.png"></p><p>输入 <code>div#container .wrapper p.text</code> 就逐层选中了 id 为 container 中 class 为 wrapper 节点中的 p 节点，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/3g8jg.png"></p><p>另外，CSS 选择器还有一些其他语法规则，具体如下表所示。</p><p>CSS 选择器的其他语法规则</p><table><thead><tr><th>选　择　器</th><th>例　　子</th><th>例子描述</th></tr></thead><tbody><tr><td><code>.class</code></td><td><code>.intro</code></td><td>选择 <code>class=&quot;intro&quot;</code> 的所有节点</td></tr><tr><td><code>#id</code></td><td><code>#firstname</code></td><td>选择 <code>id=&quot;firstname&quot;</code> 的所有节点</td></tr><tr><td><code>*</code></td><td><code>*</code></td><td>选择所有节点</td></tr><tr><td><code>element</code></td><td><code>p</code></td><td>选择所有 <code>p</code> 节点</td></tr><tr><td><code>element,element</code></td><td><code>div,p</code></td><td>选择所有 <code>div</code> 节点和所有 <code>p</code> 节点</td></tr><tr><td><code>element element</code></td><td><code>div p</code></td><td>选择 <code>div</code> 节点内部的所有 <code>p</code> 节点</td></tr><tr><td><code>element&gt;element</code></td><td><code>div&gt;p</code></td><td>选择父节点为 <code>div</code> 节点的所有 <code>p</code> 节点</td></tr><tr><td><code>element+element</code></td><td><code>div+p</code></td><td>选择紧接在 <code>div</code> 节点之后的所有 <code>p</code> 节点</td></tr><tr><td><code>[attribute]</code></td><td><code>[target]</code></td><td>选择带有 <code>target</code> 属性的所有节点</td></tr><tr><td><code>[attribute=value]</code></td><td><code>[target=blank]</code></td><td>选择 <code>target=&quot;blank&quot;</code> 的所有节点</td></tr><tr><td><code>[attribute~=value]</code></td><td><code>[title~=flower]</code></td><td>选择 <code>title</code> 属性包含单词 <code>flower</code> 的所有节点</td></tr><tr><td><code>:link</code></td><td><code>a:link</code></td><td>选择所有未被访问的链接</td></tr><tr><td><code>:visited</code></td><td><code>a:visited</code></td><td>选择所有已被访问的链接</td></tr><tr><td><code>:active</code></td><td><code>a:active</code></td><td>选择活动链接</td></tr><tr><td><code>:hover</code></td><td><code>a:hover</code></td><td>选择鼠标指针位于其上的链接</td></tr><tr><td><code>:focus</code></td><td><code>input:focus</code></td><td>选择获得焦点的 <code>input</code> 节点</td></tr><tr><td><code>:first-letter</code></td><td><code>p:first-letter</code></td><td>选择每个 <code>p</code> 节点的首字母</td></tr><tr><td><code>:first-line</code></td><td><code>p:first-line</code></td><td>选择每个 <code>p</code> 节点的首行</td></tr><tr><td><code>:first-child</code></td><td><code>p:first-child</code></td><td>选择属于父节点的第一个子节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:before</code></td><td><code>p:before</code></td><td>在每个 <code>p</code> 节点的内容之前插入内容</td></tr><tr><td><code>:after</code></td><td><code>p:after</code></td><td>在每个 <code>p</code> 节点的内容之后插入内容</td></tr><tr><td><code>:lang(language)</code></td><td><code>p:lang</code></td><td>选择带有以 <code>it</code> 开头的 <code>lang</code> 属性值的所有 <code>p</code> 节点</td></tr><tr><td><code>element1~element2</code></td><td><code>p~ul</code></td><td>选择前面有 <code>p</code> 节点的所有 <code>ul</code> 节点</td></tr><tr><td><code>[attribute^=value]</code></td><td><code>a[src^=&quot;https&quot;]</code></td><td>选择其 <code>src</code> 属性值以 <code>https</code> 开头的所有 <code>a</code> 节点</td></tr><tr><td><code>[attribute$=value]</code></td><td><code>a[src$=&quot;.pdf&quot;]</code></td><td>选择其 <code>src</code> 属性以 .pdf 结尾的所有 <code>a</code> 节点</td></tr><tr><td><code>[attribute*=value]</code></td><td><code>a[src*=&quot;abc&quot;]</code></td><td>选择其 <code>src</code> 属性中包含 <code>abc</code> 子串的所有 <code>a</code> 节点</td></tr><tr><td><code>:first-of-type</code></td><td><code>p:first-of-type</code></td><td>选择属于其父节点的首个 <code>p</code> 节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:last-of-type</code></td><td><code>p:last-of-type</code></td><td>选择属于其父节点的最后一个 <code>p</code> 节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:only-of-type</code></td><td><code>p:only-of-type</code></td><td>选择属于其父节点唯一的 <code>p</code> 节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:only-child</code></td><td><code>p:only-child</code></td><td>选择属于其父节点的唯一子节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:nth-child(n)</code></td><td><code>p:nth-child</code></td><td>选择属于其父节点的第二个子节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:nth-last-child(n)</code></td><td><code>p:nth-last-child</code></td><td>同上，从最后一个子节点开始计数</td></tr><tr><td><code>:nth-of-type(n)</code></td><td><code>p:nth-of-type</code></td><td>选择属于其父节点第二个 <code>p</code> 节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:nth-last-of-type(n)</code></td><td><code>p:nth-last-of-type</code></td><td>同上，但是从最后一个子节点开始计数</td></tr><tr><td><code>:last-child</code></td><td><code>p:last-child</code></td><td>选择属于其父节点最后一个子节点的所有 <code>p</code> 节点</td></tr><tr><td><code>:root</code></td><td><code>:root</code></td><td>选择文档的根节点</td></tr><tr><td><code>:empty</code></td><td><code>p:empty</code></td><td>选择没有子节点的所有 <code>p</code> 节点（包括文本节点）</td></tr><tr><td><code>:target</code></td><td><code>#news:target</code></td><td>选择当前活动的 <code>#news</code> 节点</td></tr><tr><td><code>:enabled</code></td><td><code>input:enabled</code></td><td>选择每个启用的 <code>input</code> 节点</td></tr><tr><td><code>:disabled</code></td><td><code>input:disabled</code></td><td>选择每个禁用的 <code>input</code> 节点</td></tr><tr><td><code>:checked</code></td><td><code>input:checked</code></td><td>选择每个被选中的 <code>input</code> 节点</td></tr><tr><td><code>:not(selector)</code></td><td><code>:not</code></td><td>选择非 <code>p</code> 节点的所有节点</td></tr><tr><td><code>::selection</code></td><td><code>::selection</code></td><td>选择被用户选取的节点部分</td></tr></tbody></table><p>另外，还有一种比较常用的选择器 XPath，这种选择方式后面会详细介绍。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><a href="https://cuiqingcai.com/202213.html#5-%E6%80%BB%E7%BB%93" title="5. 总结"></a>5. 总结</h2><p>本节介绍了网页的结构和节点间的关系，了解了这些内容，我们才有更加清晰的思路去解析和提取网页内容。</p><p>本节参考来源：</p><ul><li>文档 - HTML - MDN Web Docs：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">https://developer.mozilla.org/en-US/docs/Web/HTML</a></li><li>文档 - JavaScript - MDN Web Docs：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a></li><li>文档 - HTML DOM 节点 - W3School：<a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp">http://www.w3school.com.cn/htmldom/dom_nodes.asp</a></li><li>文档 - HTML - 维基百科：<a href="https://en.wikipedia.org/wiki/HTML">https://en.wikipedia.org/wiki/HTML</a></li><li>文档 - CSS Selector - W3School：<a href="https://www.w3schools.com/cssref/css_selectors.asp">https://www.w3schools.com/cssref/css_selectors.asp</a></li></ul><h1 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h1><p>在浏览网站的过程中，我们经常会遇到需要登录的情况，有些页面只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。还有一些网站，在打开浏览器时就自动登录了，而且很长时间都不会失效，这种情况又是为什么？其实这里面涉及 Session 和 Cookie 的相关知识，本节就来揭开它们的神秘面纱。</p><h2 id="1-静态网页和动态网页"><a href="#1-静态网页和动态网页" class="headerlink" title="1. 静态网页和动态网页"></a><a href="https://cuiqingcai.com/202214.html#1-%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5" title="1. 静态网页和动态网页"></a>1. 静态网页和动态网页</h2><p>在开始之前，我们需要先了解一下静态网页和动态网页的概念。这里还是前面的示例代码，内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><html>  <br>  <head>  <br>    <meta charset="UTF-8" />  <br>    <title>This is a Demo</title>  <br>  </head>  <br>  <body>  <br>    <div id="container">  <br>      <div class="wrapper">  <br>        <h2 class="title">Hello World</h2>  <br>        <p class="text">Hello, this is a paragraph.</p>  <br>      </div>  <br>    </div>  <br>  </body>  <br></html></td></tr></tbody></table><p>这是最基本的 HTML 代码，我们将其保存为一个 test.html 文件，然后把它放在某台具有固定公网 IP 的主机上，主机上装上 Apache 或 Nginx 等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服务器看到这个页面，这就搭建了一个最简单的网站。</p><p>这种网页的内容是 HTML 代码编写的，文字、图片等内容均通过写好的 HTML 代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL 灵活多变地显示内容等。例如，我们想要给这个网页的 URL 传入一个 <code>name</code> 参数，让其在网页中显示出来，是无法做到的。</p><p>因此，动态网页应运而生，它可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python 等语言编写的，其功能比静态网页强大、丰富太多了。此外，动态网站还可以实现用户登录和注册的功能。</p><p>再回到开头提到的问题，很多页面是需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东西，有了它，我们才能保持登录状态，访问登录之后才能看到的页面。</p><p>那么，这种神秘的凭证到底是什么呢？其实它就是 Session 和 Cookie 共同产生的结果，下面我们来一探究竟。</p><h2 id="2-无状态-HTTP"><a href="#2-无状态-HTTP" class="headerlink" title="2. 无状态 HTTP"></a><a href="https://cuiqingcai.com/202214.html#2-%E6%97%A0%E7%8A%B6%E6%80%81-HTTP" title="2. 无状态 HTTP"></a>2. 无状态 HTTP</h2><p>在了解 Session 和 Cookie 之前，我们还需要了解 HTTP 的一个特点，叫作无状态。</p><p>HTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。这意味着如果后续需要处理前面的信息，则必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。</p><p>这时两个用于保持 HTTP 连接状态的技术就出现了，它们分别是 Session 和 Cookie。Session 在服务端，也就是网站的服务器，用来保存用户的 Session 信息；Cookie 在客户端，也可以理解为浏览器端，有了 Cookie，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookie 并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</p><p>我们可以理解为 Cookie 里面保存了登录的凭证，有了它，只需要在下次请求携带 Cookie 发送请求而不必重新输入用户名、密码等信息重新登录了。</p><p>因此，在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的 Cookie 放在请求头里面直接请求，而不必重新模拟登录。</p><p>好了，了解 Session 和 Cookie 的概念之后，我们在来详细剖析它们的原理。</p><h2 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a><a href="https://cuiqingcai.com/202214.html#3-Session" title="3. Session"></a>3. Session</h2><p>Session，中文称为会话，其本来的含义是指有始有终的一系列动作 &#x2F; 消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 Session。</p><p>而在 Web 中，Session 对象用来存储特定用户 Session 所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户 Session 中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有 Session，则 Web 服务器将自动创建一个 Session 对象。当 Session 过期或被放弃后，服务器将终止该 Session。</p><h2 id="4-Cookie"><a href="#4-Cookie" class="headerlink" title="4. Cookie"></a><a href="https://cuiqingcai.com/202214.html#4-Cookie" title="4. Cookie"></a>4. Cookie</h2><p>Cookie，也常用其复数形式 Cookies，Cookie 指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据。</p><h4 id="Session-维持"><a href="#Session-维持" class="headerlink" title="Session 维持"></a><a href="https://cuiqingcai.com/202214.html#Session-%E7%BB%B4%E6%8C%81" title="Session 维持"></a>Session 维持</h4><p>那么，我们怎样利用 Cookies 保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有 Set-Cookie 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。当浏览器下一次再请求该网站时，浏览器会把此 Cookies 放到请求头一起提交给服务器，Cookies 携带了 Session ID 信息，服务器检查该 Cookies 即可找到对应的 Session 是什么，然后再判断 Session 来辨认用户状态。</p><p>在成功登录某个网站时，服务器会告诉客户端设置哪些 Cookies 信息。在后续访问页面时，客户端会把 Cookies 发送给服务器，服务器再找到对应的 Session 加以判断。如果 Session 中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p><p>反之，如果传给服务器的 Cookies 是无效的，或者 Session 已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。</p><p>所以，Cookies 和 Session 需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录 Session 控制。</p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a><a href="https://cuiqingcai.com/202214.html#%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84" title="属性结构"></a>属性结构</h4><p>接下来，我们来看看 Cookies 都有哪些内容。这里以知乎为例，在浏览器开发者工具中打开 Application 选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies，将其点开，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/5yb6e.jpg"></p><p>Cookies 列表</p><p>可以看到，这里有很多条目，其中每个条目可以称为 Cookie。它有如下几个属性。</p><ul><li>Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改。</li><li>Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。</li><li>Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com 结尾的域名都可以访问该 Cookie。</li><li>Path，即该 Cookie 的使用路径。如果设置为 &#x2F;path&#x2F;，则只有路径为 &#x2F;path&#x2F; 的页面可以访问该 Cookie。如果设置为 &#x2F;，则本域名下的所有页面都可以访问该 Cookie。</li><li>Max-Age，即该 Cookie 失效的时间，单位为秒，常和 Expires 一起使用，通过它可以计算出其有效时间。Max-Age 如果为正数，则该 Cookie 在 Max-Age 秒之后失效。如果为负数，则关闭浏览器时 Cookie 即失效，浏览器也不会以任何形式保存该 Cookie。</li><li>Size 字段，即此 Cookie 的大小。</li><li>HTTP 字段，即 Cookie 的 <code>httponly</code> 属性。若此属性为 <code>true</code>，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 <code>document.cookie</code> 来访问此 Cookie。</li><li>Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议有 HTTPS 和 SSL 等，在网络上传输数据之前先将数据加密。其默认值为 <code>false</code>。</li></ul><h4 id="会话-Cookie-和持久-Cookie"><a href="#会话-Cookie-和持久-Cookie" class="headerlink" title="会话 Cookie 和持久 Cookie"></a><a href="https://cuiqingcai.com/202214.html#%E4%BC%9A%E8%AF%9D-Cookie-%E5%92%8C%E6%8C%81%E4%B9%85-Cookie" title="会话 Cookie 和持久 Cookie"></a>会话 Cookie 和持久 Cookie</h4><p>从表面意思来说，会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效；持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。</p><p>其实严格来说，没有会话 Cookie 和持久 Cookie 之分，只是由 Cookie 的 Max-Age 或 Expires 字段决定了过期的时间。</p><p>因此，一些持久化登录的网站其实就是把 Cookie 的有效时间和 Session 有效期设置得比较长，下次我们再访问页面时仍然携带之前的 Cookie，就可以直接保持登录状态。</p><h2 id="5-常见误区"><a href="#5-常见误区" class="headerlink" title="5. 常见误区"></a><a href="https://cuiqingcai.com/202214.html#5-%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA" title="5. 常见误区"></a>5. 常见误区</h2><p>在谈论 Session 机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，Session 就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对 Session 来说，也一样，除非程序通知服务器删除一个 Session，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除 Session。</p><p>但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时，也就无法找到原来的 Session 了。如果服务器设置的 Cookies 保存到硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookies 发送给服务器，则再次打开浏览器，仍然能够找到原来的 Session ID，依旧还是可以保持登录状态的。</p><p>而且恰恰是由于关闭浏览器不会导致 Session 被删除，这就需要服务器为 Session 设置一个失效时间，当距离客户端上一次使用 Session 的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把 Session 删除以节省存储空间。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><a href="https://cuiqingcai.com/202214.html#6-%E6%80%BB%E7%BB%93" title="6. 总结"></a>6. 总结</h2><p>本节介绍了 Session 和 Cookie 的基本概念，这对后文进行网络爬虫的开发有很大的帮助，需要好好掌握。</p><p>由于涉及一些专业名词知识，本节部分内容的参考来源如下：</p><ul><li>文档 - Session - 百度百科：<a href="https://baike.baidu.com/item/session/479100">https://baike.baidu.com/item/session/479100</a></li><li>文档 - Cookie - 百度百科：<a href="https://baike.baidu.com/item/cookie/1119">https://baike.baidu.com/item/cookie/1119</a></li><li>文档 - HTTP Cookie 维基百科：<a href="https://en.wikipedia.org/wiki/HTTP_cookie">https://en.wikipedia.org/wiki/HTTP_cookie</a></li><li>博客 - Session 和几种状态保持方案理解：<a href="http://www.mamicode.com/info-detail-46545.html">http://www.mamicode.com/info-detail-46545.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫简介</title>
    <link href="/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B/"/>
    <url>/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h1><p>简而言之，爬虫可以帮助我们快速把网站上的信息快速提取并保存下来。</p><p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，就能把网页上的信息提取出来。我们可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p><h2 id="1-爬虫有什么用？"><a href="#1-爬虫有什么用？" class="headerlink" title="1. 爬虫有什么用？"></a><a href="https://cuiqingcai.com/202211.html#1-%E7%88%AC%E8%99%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F" title="1. 爬虫有什么用？"></a>1. 爬虫有什么用？</h2><p>通过上面的话，你可能已经初步知道了爬虫是做了什么事情，但一般要学一个东西，我们得知道学来干什么用吧？</p><p>其实，爬虫的用处可大了去了。</p><ul><li>比如，我们想要研究最近各大网站头条都有什么热点，那我们就可以用爬虫把这些网站的热门新闻用爬虫爬下来，这样我们就可以分析其中的标题、内容等知道热点关键词了。</li><li>比如，我们想要对一些天气、金融、体育、公司等各种信息进行整理和分析，但这些内容都分布在各种不同的网站上，那我们就可以用爬虫把这些网站上的数据爬取下来，整理成我们想要的数据保存下来，就可以对其进行分析了。</li><li>比如，我们在网上看到了很多美图，比如风景、美食、美女，或者一些资料、文章，想保存到电脑上，但一次次右键保存、复制粘贴显然非常费时费力，那我们就可以利用爬虫将这些图片或资源快速爬取下来，极大地节省时间和精力。</li></ul><p>另外还有很多其他的，比如黄牛抢票、自助抢课、网站排名等等各种技术也都和爬虫分不开，爬虫的用处可谓是非常大，可以说人人都应该会点爬虫。</p><p>另外学爬虫还可以帮助我们顺便学好 Python。学爬虫，个人首推的就是 Python 语言，如果你对 Python 还不太熟，没关系，爬虫就非常适合作为入门 Python 的方向来学习，一边学爬虫，一边学 Python，最后一举两得。</p><p>不仅如此，爬虫技术和其他领域的几乎都有交集，比如前后端 Web 开发、数据库、数据分析、人工智能、运维、安全等等领域都和爬虫有所沾边，所以学好了爬虫，就相当于为其他的领域也铺好了一个台阶，以后想进军其他领域都可以更轻松地衔接。Python 爬虫可谓是学习计算机的一个很好的入门方向之一。</p><h2 id="2-爬虫的流程"><a href="#2-爬虫的流程" class="headerlink" title="2. 爬虫的流程"></a><a href="https://cuiqingcai.com/202211.html#2-%E7%88%AC%E8%99%AB%E7%9A%84%E6%B5%81%E7%A8%8B" title="2. 爬虫的流程"></a>2. 爬虫的流程</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，下面概要介绍一下。</p><h3 id="1-获取网页"><a href="#1-获取网页" class="headerlink" title="(1) 获取网页"></a><a href="https://cuiqingcai.com/202211.html#1-%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5" title="(1) 获取网页"></a>(1) 获取网页</h3><p>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</p><p>我们用浏览器浏览网页时，其实浏览器就帮我们模拟了这个过程，浏览器向服务器发送了一个个请求，返回的响应体便是网页源代码，然后浏览器将其解析并呈现出来。所以，我们要做的爬虫其实就和浏览器类似，将网页源代码获取下来之后将内容解析出来就好了，只不过我们用的不是浏览器，而是 Python。</p><p>刚才说，最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样用 Python 实现呢？</p><p>Python 提供了许多库来帮助我们实现这个操作，如 urllib、requests 等。我们可以用这些库来实现 HTTP 请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的 <code>body</code> 部分即可，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。</p><h3 id="2-提取信息"><a href="#2-提取信息" class="headerlink" title="(2) 提取信息"></a><a href="https://cuiqingcai.com/202211.html#2-%E6%8F%90%E5%8F%96%E4%BF%A1%E6%81%AF" title="(2) 提取信息"></a>(2) 提取信息</h3><p>获取网页的源代码后，接下来就是分析网页的源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p><p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS 选择器或 XPath 来提取网页信息的库，如 Beautiful Soup、pyquery、lxml 等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。</p><p>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理、清晰，以便我们后续处理和分析数据。</p><h3 id="3-保存数据"><a href="#3-保存数据" class="headerlink" title="(3) 保存数据"></a><a href="https://cuiqingcai.com/202211.html#3-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE" title="(3) 保存数据"></a>(3) 保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为 TXT 文本或 JSON 文本，也可以保存到数据库，如 MySQL 和 MongoDB 等，还可保存至远程服务器，如借助 SFTP 进行操作等。</p><h3 id="4-自动化程序"><a href="#4-自动化程序" class="headerlink" title="(4) 自动化程序"></a><a href="https://cuiqingcai.com/202211.html#4-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A8%8B%E5%BA%8F" title="(4) 自动化程序"></a>(4) 自动化程序</h3><p>说到自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p><h2 id="3-能爬怎样的数据？"><a href="#3-能爬怎样的数据？" class="headerlink" title="3. 能爬怎样的数据？"></a><a href="https://cuiqingcai.com/202211.html#3-%E8%83%BD%E7%88%AC%E6%80%8E%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F" title="3. 能爬怎样的数据？"></a>3. 能爬怎样的数据？</h2><p>在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着 HTML 代码，而最常抓取的便是 HTML 源代码。</p><p>另外，可能有些网页返回的不是 HTML 代码，而是一个 JSON 字符串（其中 API 接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。</p><p>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</p><p>另外，还可以看到各种扩展名的文件，如 CSS、JavaScript 和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</p><p>上述内容其实都对应各自的 URL，是基于 HTTP 或 HTTPS 协议的，只要是这种数据，爬虫都可以抓取。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征向量</title>
    <link href="/Blogs/2025/08/28/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
    <url>/Blogs/2025/08/28/%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="特征值与特征向量​​-🌟"><a href="#特征值与特征向量​​-🌟" class="headerlink" title="特征值与特征向量​​ 🌟"></a><strong>特征值与特征向量​</strong>​ 🌟</h3><ol><li><p>​<strong>​基础概念​</strong>​</p><ul><li>​<strong>​定义​</strong>​：Ax&#x3D;λx（x&#x3D;0）</li><li>​<strong>​求法​</strong>​：解特征方程 det(A−λI)&#x3D;0 → 特征值 → 代入求特征向量</li><li>​<strong>​性质​</strong>​：<ul><li>不同特征值的特征向量​<strong>​线性无关​</strong>​</li><li>A可逆 ⇔ 所有 λ&#x3D;0</li></ul></li></ul></li><li><p>​<strong>​对角化​</strong>​</p><ul><li>​<strong>​条件​</strong>​：A 有 n 个线性无关特征向量（或 n 个互异特征值）</li><li>​<strong>​步骤​</strong>​：P−1AP&#x3D;D（D为特征值对角阵，P为特征向量矩阵）</li><li>​<strong>​应用​</strong>​：快速计算 Ak&#x3D;PDkP−1</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>特征向量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电容和电感</title>
    <link href="/Blogs/2025/08/28/%E7%94%B5%E5%AE%B9%E5%92%8C%E7%94%B5%E6%84%9F/"/>
    <url>/Blogs/2025/08/28/%E7%94%B5%E5%AE%B9%E5%92%8C%E7%94%B5%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>[[01微分]] 和 [[02积分]]</p><h4 id="电容（Capacitor）​​"><a href="#电容（Capacitor）​​" class="headerlink" title="电容（Capacitor）​​"></a><strong>电容（Capacitor）​</strong>​</h4><table><thead><tr><th>​<strong>​特性​</strong>​</th><th>表达式&#x2F;说明</th><th>关键点</th></tr></thead><tbody><tr><td>​<strong>​V-I关系​</strong>​</td><td>iC​(t)&#x3D;CdtdvC​(t)​</td><td>电流正比于电压变化率</td></tr><tr><td>​<strong>​积分形式​</strong>​</td><td>vC​(t)&#x3D;C1​∫iC​(t)dt+vC​(0)</td><td>电压记忆效应</td></tr><tr><td>​<strong>​能量存储​</strong>​</td><td>WC​&#x3D;21​CvC2​</td><td>能量与电压平方成正比</td></tr><tr><td>​<strong>​正弦响应​</strong>​</td><td>电流相位超前电压90°</td><td>iC​&#x3D;ωCVm​cos(ωt+ϕ+90°)</td></tr><tr><td>​<strong>​串并联​</strong>​</td><td>串联：Ceq​1​&#x3D;∑Ci​1​  <br>并联：Ceq​&#x3D;∑Ci​</td><td>并联增大容量，串联减小</td></tr></tbody></table><h4 id="​​电感（Inductor）​​"><a href="#​​电感（Inductor）​​" class="headerlink" title="​​电感（Inductor）​​"></a>​<strong>​电感（Inductor）​</strong>​</h4><table><thead><tr><th>​<strong>​特性​</strong>​</th><th>表达式&#x2F;说明</th><th>关键点</th></tr></thead><tbody><tr><td>​<strong>​V-I关系​</strong>​</td><td>vL​(t)&#x3D;LdtdiL​(t)​</td><td>电压正比于电流变化率</td></tr><tr><td>​<strong>​积分形式​</strong>​</td><td>iL​(t)&#x3D;L1​∫vL​(t)dt+iL​(0)</td><td>电流记忆效应</td></tr><tr><td>​<strong>​能量存储​</strong>​</td><td>WL​&#x3D;21​LiL2​</td><td>能量与电流平方成正比</td></tr><tr><td>​<strong>​正弦响应​</strong>​</td><td>电压相位超前电流90°</td><td>vL​&#x3D;ωLIm​cos(ωt+ϕ+90°)</td></tr><tr><td>​<strong>​串并联​</strong>​</td><td>串联：Leq​&#x3D;∑Li​  <br>并联：Leq​1​&#x3D;∑Li​1​</td><td>串联增大感量，并联减小</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电容和电感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 U 盘内存卡移动硬盘和手机储存芯片构造</title>
    <link href="/Blogs/2025/08/28/%E7%90%86%E8%A7%A3%20U%20%E7%9B%98%E5%86%85%E5%AD%98%E5%8D%A1%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%92%8C%E6%89%8B%E6%9C%BA%E5%82%A8%E5%AD%98%E8%8A%AF%E7%89%87%E6%9E%84%E9%80%A0/"/>
    <url>/Blogs/2025/08/28/%E7%90%86%E8%A7%A3%20U%20%E7%9B%98%E5%86%85%E5%AD%98%E5%8D%A1%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%92%8C%E6%89%8B%E6%9C%BA%E5%82%A8%E5%AD%98%E8%8A%AF%E7%89%87%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数字存储完全指南-06：理解-U-盘、内存卡、移动硬盘和手机储存芯片构造"><a href="#数字存储完全指南-06：理解-U-盘、内存卡、移动硬盘和手机储存芯片构造" class="headerlink" title="数字存储完全指南 06：理解 U 盘、内存卡、移动硬盘和手机储存芯片构造"></a>数字存储完全指南 06：理解 U 盘、内存卡、移动硬盘和手机储存芯片构造</h1><p>上一章我们了解到了另一种特殊的储存介质，运行内存的方方面面，本章我们就继续来介绍除了机械硬盘和固态硬盘外，我们常用的一些储存设备，包括 U 盘、内存卡、移动硬盘和手机储存芯片。它们都是使用 NAND 颗粒来储存数据，并且有着相同的工作结构，不过形态和实际性能却截然不同。</p><h2 id="U-盘的结构原理和常见参数"><a href="#U-盘的结构原理和常见参数" class="headerlink" title="U 盘的结构原理和常见参数"></a>U 盘的结构原理和常见参数</h2><p>说完运行内存，接下来再说一个大家更加熟悉的东西 —— U 盘（很多人也叫它优盘）。从学生时代开始，这玩意儿估计是大部分人必备的一个东西，带着我们重要的文档（或许还有病毒~），流连在各个电脑的 USB 接口之间。比如底下这个超经典的金士顿 U 盘，应该都曾经拥有或者见过别人用这个吧：</p><p><img src="https://cdn.sspai.com/2021/10/19/9d592b8a008b06b2da277a3d86298489.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>经典的红色透明金士顿 Kingston U 盘，型号是 DT101G2</p><p>如果你年纪比较小，那经典的 U 盘应该换成这个：</p><p><img src="https://cdn.sspai.com/2021/10/19/1821fd565d2f0666d51a5a6dc016d6dc.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>新经典金属外壳金士顿 Kingston U 盘，型号是 DTSE9&#x2F;DTSE9G2</p><p>也许现在大部分人用的还是好几年前的 U 盘，但其实除了我们印象中的那些经典 U 盘，现在的 U 盘已经发展得更加成熟，稳定性和速度都有了很大提升，还出现了新的品类。接下来我就给大家详细介绍一下 U 盘的结构原理和一些我们需要了解的参数。</p><p><img src="https://cdn.sspai.com/2021/10/19/26331e489556f57067e9ce9ddb932058.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 的超高速固态 U 盘，金属外壳质感不错</p><h3 id="U-盘的结构和原理"><a href="#U-盘的结构和原理" class="headerlink" title="U 盘的结构和原理"></a>U 盘的结构和原理</h3><p>和现在金属一体外壳的 U 盘越来越多不同，以前的 U 盘大多数是塑料外壳。还要了解 U 盘的结构和原理非常简单，我们只需要拆一个 U 盘就行了。</p><p>原本我费了九牛二虎之力把自己的金士顿 U 盘拆了，然后仔细瞅了半天感觉不像正品，又在网上找了下图片才发现不一样，也懒得去弄清楚是不同版本还是盗版了，<strong>反正金士顿不管是 U 盘还是固态盗版比正版卖得还多，估计连商家自己都分不清楚</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/821b1cbd0382da6060dc80374dca560a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>我自己拆的金士顿 Kingston DT101G2，G1 是 4GB 的</p><p><img src="https://cdn.sspai.com/2021/10/19/58f74cd767c5ae3b4ddc3abcacfabf24.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>网上找到拆解图片，来源是国产大狮子</p><p>我们就以网上找到的图片作为标准，大家看后面的那个颗粒是不是很熟悉？没错，<strong>它就是在固态上使用的 NAND 颗粒</strong>，具体到这个 U 盘使用的还是东芝（还不是铠侠）的单通道 64 层 TLC 颗粒（黑片）。</p><p>另外一面一坨大大的黑色圆圈，和我差姐自己的上面一个小芯片，就是 <strong>U 盘的主控</strong>。网上拆解那一大坨黑黑的就是安国的主控（有个很不好听的外号叫做牛屎主控哈哈）。</p><p>看到这里大家应该懂了吧，又有主控又是 NAND 颗粒，就差个缓存了，其实 <strong>U 盘的结构和工作方式就和固态硬盘差不多</strong>。 U 盘的全称就是 USB 闪存盘，就差不多是「使用 USB 接口的固态硬盘的」的意思。</p><p>由于它俩实在挺像的，基本上节省了给大家普及原理和工作方式的时间，<strong>把它俩当成同类型产品的乞丐版和高配版就可以</strong>。那么既然它俩的结构和工作原理都差不多，那<strong>为什么 U 盘和固态硬盘在速度，容量和寿命方面差这么多呢</strong>？</p><h3 id="U-盘和固态硬盘的容量对比"><a href="#U-盘和固态硬盘的容量对比" class="headerlink" title="U 盘和固态硬盘的容量对比"></a>U 盘和固态硬盘的容量对比</h3><p>在好几年之前，同样价格的 U 盘容量是比固态硬盘少上不少，大容量的 U 盘特别贵。所以在那个笔记本都上 256G 固态的年代大家都喜欢买 8G，16G 的 U 盘。</p><p>这是因为<strong>固态硬盘空间比较大，可以用生产难度比较小的多个颗粒组成大容量</strong>，比如那个时候 256G 的 U 盘通常会有4~8 个闪存颗粒。而 <strong>U 盘往往只能放一个闪存颗粒</strong>，在没有新技术出来之前（比如 MLC 固态硬盘时代使用 TLC 降低成本），高密度的闪存颗粒通常贵到飞起。</p><p>而随着 TLC 设置甚至 QLC 的出现，加上闪存颗粒生产成本的降低，就连固态硬盘都开始使用单颗粒了（比如前几章出现的西部数据 SN550 就是只有一个闪存颗粒），所以现在同样价格的固态硬盘和 U 盘容量基本都差不多。也出现了 512GB 甚至 1TB 的小 U 盘（Nvme 固态硬盘套壳那种不算），但不对比价格的话比起现在甚至 8TB 的固态硬盘来讲容量还是比较小。</p><p><img src="https://cdn.sspai.com/2021/10/19/f557601d5c97380cc17cea37619cf133.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>现在同样容量的固态硬盘和 U 盘价格对比 - 爱国者 Aigo 256G 固态硬盘价格</p><p><img src="https://cdn.sspai.com/2021/10/19/974db143dab5e6d50bb8df939cf24552.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>现在同样容量的固态硬盘和 U 盘价格对比 - 爱国者 Aigo 256G 固态 U 盘价格</p><p><img src="https://cdn.sspai.com/2021/10/19/57042a2e3c85f6c9b244f579b89d86df.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>多达 8TB 容量的 SATA 和 Nvme 固态硬盘，图片来源：AnandTech</p><h3 id="为什么（以前的）-U-盘和固态硬盘的速度相差那么多？"><a href="#为什么（以前的）-U-盘和固态硬盘的速度相差那么多？" class="headerlink" title="为什么（以前的） U 盘和固态硬盘的速度相差那么多？"></a>为什么（以前的） U 盘和固态硬盘的速度相差那么多？</h3><p>另一个大家最突出体验到的点就是 U 盘和步态硬盘的速度差异。比如复制和读取文件，即使在机械硬盘的时代，大家也能感觉到 <strong>U 盘还不如机械硬盘来的快呢</strong>，更别说现在固态硬盘的时代了。这个差异简单来解释就是<strong>主控性能和通道数的锅</strong>。由于供电和散热比较好，固态硬盘一般拥有性能比较好的主控，而且固态硬盘使用 SATA 和 M.2&#x2F;PCIE 等接口带宽更高。</p><p><img src="https://cdn.sspai.com/2021/10/19/d2fdbdd370f204508485f9d190f166bf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>十几 MB 的写入速度是以前的 U 盘常态</p><p><strong>更好的主控性能让固态硬盘主控可以运行更复杂的数据压缩和分配算法，主要是支持更多的闪存通道</strong>。上一章我们学到主控是通过闪存通道和闪存颗粒交互数据的，性能越强的主控就能支持<strong>同时</strong>更多的闪存通道交互数据。</p><p>比如一个固态硬盘上有 8 个固态颗粒，然后固态硬盘的主控支持 8 通道，就可以利用自己的处理能力把数据分成八份分别平均<strong>同时</strong>读取或者写入 8 个颗粒，假设一个通道的速度是 1GB&#x2F;s（目前旗舰固态主控就是这么个速度）那么八个通道就是 8GB&#x2F;s。</p><p>而 U 盘主控一般都是单通道，偶尔会有 U 盘用两个闪存颗粒组成双通道。受制于功率和工艺散热等影响，主控性能一般很渣，一个通道处理数据的速度通常只有 100MB&#x2F;s</p><p>我们上面讲的<strong>这些速度还只是顺序读取的最佳情境</strong>，换上写入甚至对主控性能和算法要求更高的随机写入那差距就更大了，U 盘速度跌到个位数也是正常的（虽然我们经常调侃垃圾固态是大号 U 盘，但是再差的固态，即使用的最烂的固态主控性能也是好过 U 盘的）。</p><p><img src="https://cdn.sspai.com/2021/10/19/7fe04b182d46068b58aec79f62edb036.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>复制一些细碎的小文件，速度简直没眼看</p><p><img src="https://cdn.sspai.com/2021/10/19/1adfab82e000be86fdc86a178c67d0c0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><img src="https://cdn.sspai.com/2021/10/19/dbb549dc7a57607a39194f9cd23bca15.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>旧 U 盘和普通 SATA 固态的测试软件跑分对比</p><p>另一个重要的区别是<strong>固态硬盘支持读写同时进行，而 U 盘同一时刻只能读或者写</strong>。上上一章原理我们知道 NAND 闪存颗粒读写的电压都是不一样的，TLC 这种还要分出好几个阈值电压，U 盘主控没办法做到这样精细的电压调控，<strong>所以同一时刻在同一内存通道内只能读或者写</strong>，而固态主控可以轻松做到精准的电压调节，<strong>同一内存通道内可以支持同时读和写</strong>，这样速度又产生了成倍的差距。</p><p>另外由于之前 USB2.0 接口的速度上限不高，即使到了 USB3.1 和现代储存接口 M.2 等速度上限差距还是比较大，所以 <strong>U 盘一般没有缓存（好消息是没有缓外掉速，坏消息是不掉速也没啥速度）</strong>，再加上性能限制纠错算法和垃圾回收算法 TRIM 的缺失，特别是现在都用上 TLC 甚至 QLC 颗粒，这几样东西的缺失还是对速度影响很大的。</p><p>最后在<strong>实际使用过程中体积比较小的 U 盘也容易积热，复制文件时间稍微一长， U 盘主控和颗粒的性能都会急剧降低</strong>。举个经典的例子，大家伙儿小时候如果有拿着 U 盘去网吧复制游戏的经历就懂了，开始还有十几 MB 的写入速度，那想着有半个小时应该能复制完了吧，结果电脑店买的 U 盘坚持不到 10 分钟就萎了，我试过最慢的甚至只有 1~2KB 每秒写入，等得那个急呀，真是痛苦的回忆。</p><blockquote><p>很多人都会发现 U 盘用得越久，装的东西越多就越慢，根本原因就是 U 盘纠错算法质量差和垃圾回收算法 TRIM 的缺失。这个时候只需要手动格式化一下 U 盘，把数据全部清空，就能恢复原本的速度了。</p></blockquote><h3 id="U-盘和固态硬盘的寿命为什么相差那么多？"><a href="#U-盘和固态硬盘的寿命为什么相差那么多？" class="headerlink" title="U 盘和固态硬盘的寿命为什么相差那么多？"></a>U 盘和固态硬盘的寿命为什么相差那么多？</h3><p>说完速度就要说说寿命了，很多人其实对 U 盘的寿命没有什么感觉，因为很少有人把 U 盘当做主力储存设备来用，都是用来临时存个文件什么的。</p><p>但 U 盘这个东西很神奇，大部分人的 U 盘都能用很久，有时候它却莫名其妙的就会自己挂了。从结构原理大家就可以看出来，这玩意儿是不够那些正儿八经的硬盘靠谱的，所以<strong>千万千万不要把重要文件只放在 U 盘上</strong>。可能大家想不到，我经常会收到一些相关的求助，比如有很多老师真的就只把课件和自己做的备课笔记什么的全都只放在 U 盘上，很多学生上班族也把自己制作的 PPT 什么的都放在 U 盘上，甚至我还看见过小说作者只在网吧码字，把自己辛辛苦苦写的小说和大纲都放在 U 盘上，然后没有的。</p><p>U 盘挂掉之后再怎么四处求助，这些数据一般不付出很大代价是恢复不回来的了（虽然 U 盘没有 TRIM 和垃圾回收算法还有机会恢复数据），虽然后面安全部分我会详细给大家介绍，如何保证数据安全，但是在这里还是要提前提醒一下大家，<strong>即使做不到 123 原则，重要数据也一定要放在两个以上的地方</strong>。</p><p>说回 U 盘和固态硬盘寿命差距的根本原因，<strong>还是在于主控性能和闪存颗粒质量数量</strong>。</p><p>首先是闪存颗粒的质量，U 盘上的闪存颗粒一般速度不高性能要求也不高（毕竟主控性能摆在那里），<strong>基本上用的就是最烂的颗粒</strong>。即使是大牌子，不会用一些乱七八糟的东西，用的基本也是 TLC&#x2F;QLC 等等当前性能最差容量最高的技术，原厂白片等就更加不要想了，大牌子用黑片（简单解释就是晶圆厂不合格的颗粒，屏蔽一部分坏掉的继续用）也是偶尔会出现的（比如上面的金士顿 U 盘用量产工具识别到就是用的东芝黑片）。</p><p>更别说小牌子，或者我们在学校门口，电脑店火车站等等地方买到的杂牌 U 盘了。用降级片（就是有瑕疵的合格颗粒）是良心，用黑片是常态，用回收回来的二手黑片也一大把，<strong>就这种质量的 U 盘用着用着突然暴毙也就很正常了</strong>。</p><p>上一章我们学到了固态硬盘主控的作用，里面有一大半都是用来提升颗粒寿命的，而<strong>这些方法很多都是要多个闪存颗粒才能实现</strong>。比如磨损均衡就是把数据平均摊到不同的颗粒上，减少每个颗粒的 P&#x2F;E 次数，写入的时候平摊到每个颗粒，也能减少写放大效应。</p><p>但 U 盘它没有啊，一般 U 盘只有一个闪存颗粒，高端的也是只有两个，磨损均衡都不知道去哪均衡，加上天天逮着一个闪存颗粒薅，写放大效应那是超级加倍。再加上用的 TLC&#x2F;QLC 等等这类寿命本来就短的颗粒，主控还没有性能去运行相关的纠错垃圾回收算法，那真是所有 debuff（负优化）都集齐了。</p><p><strong>这就是 U 盘标称寿命很长，但用起来随时暴毙体质的由来</strong>。如果你对 U 盘的速度掉速和寿命都没有什么概念的话，可以试试淘宝买一个便宜的 U 盘，然后下载迅雷并把下载文件夹设置为 U 盘，随便下两部电影你就懂了。</p><h3 id="为什么山寨-U-盘很多，山寨固态硬盘比较少"><a href="#为什么山寨-U-盘很多，山寨固态硬盘比较少" class="headerlink" title="为什么山寨 U 盘很多，山寨固态硬盘比较少"></a>为什么山寨 U 盘很多，山寨固态硬盘比较少</h3><p>很多朋友还会发现，市场上超级多山寨 U 盘，很多都是直接明目张胆用大牌子的商标。经典受害者就是金士顿 Kingston（谁让他卖的最好呢），假货多到销量是真货的三倍，泛滥到金士顿最后都不管了。不像固态硬盘，虽然也有山寨的，但起码人家还会起一个比较容易混淆的名字不是直接盗版大牌子。</p><p>因为 U 盘对技术要求比较低，如果你去闲鱼逛逛，你就会发现有一大堆自制 U 盘的卖家，便宜的贵的用什么技术的都有（没有贬低的意思，我自己也买了几个用手机 UFS 芯片改造的 U 盘，性价比很高，前提是会挑）。</p><p><img src="https://cdn.sspai.com/2021/10/19/86b9473eb957316e642155dcfc8937eb.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闲鱼上的自制 U 盘，一般都会标注出速度</p><p>对于奸商来讲同样如此，制作假 U 盘实在太简单了，一大堆伪劣假冒的主控芯片可以选，一大堆来路不明的闪存颗粒可以买，焊接起来刷个固件就是一个 U 盘了，比起市面上低性能的 U 盘，用起来还差不多。</p><p>而固态硬盘就没有那么好制作了，起码要有一点研发能力和渠道。比如大批量的主控芯片需要比较正规的厂家才能采购，起码得有正常的品牌名。同时闪存颗粒数量一多，主控性能一上去，还要加上缓存芯片，SATA&#x2F;M.2&#x2F;Nvme 控制器什么的比起 USB 来讲也复杂很多，对电路板的设计还有多通道什么的要求就多起来了，一般人还真搞不定。像是直接把 U 盘套个固态壳子卖的买家通常也能直接发现（毕竟性能实在差太多了）。</p><p><img src="https://cdn.sspai.com/2021/10/19/bd5922365b6c21b9b8dbaea182e1a9ff.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闲鱼上的山寨和自制固态硬盘非常少，很多都不敢放出读写速度，这些其实就是自制 U 盘套了个固态的壳</p><h3 id="新时代的-U-盘：固态-U-盘"><a href="#新时代的-U-盘：固态-U-盘" class="headerlink" title="新时代的 U 盘：固态 U 盘"></a>新时代的 U 盘：固态 U 盘</h3><p>现在我们去电商平台搜索，会发现现在贵一点的 U 盘通常都会打上高速 U 盘的口号，质保期限也跟固态硬盘那样敢喊 5 年质保了。</p><p><img src="https://cdn.sspai.com/2021/10/19/214b307bfc37e1cebe6c688a889d99ab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 高速固态 U 盘</p><p>这些其实就是现在比较流行的固态 U 盘。听起来好像很高端，像是固态硬盘一样，<strong>其实就是把 U 盘的主控换成了固态的主控</strong>。</p><p>一方面是现在 USB3.0，3.1 和 Type-C，雷电接口开始普及，速率大大提升；另一方面是固态主控的制造技术制程和成本下降，固态主控的功率和发热量都能塞进 U 盘里。虽然还达不到真正固态硬盘主控的程度，高端一些的产品也能达到 400-500MB&#x2F;s 的顺序读取速度了，这个速度都已经快达到 USB3.0 的速率上限，可以制作 Win10 to Go 移动系统盘并且流畅使用了。</p><p><img src="https://cdn.sspai.com/2021/10/19/7ebae48ad2c91dbb84ed6250d779792f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>闪迪 SanDisk 的超高端固态 U 盘 CZ880</p><p>优点比较直观，但是固态 U 盘也不是没有缺点。<strong>首先就是同容量下会比普通 U 盘甚至固态硬盘都贵</strong>，毕竟固态主控和 U 盘主控不是一个价，做到 U 盘里的固态主控和普通固态主控也不是一个价。加上高速的优点和卖点溢价，这类 U 盘通常不便宜，没有特别便携要求的朋友直接上移动固态硬盘会更加有性价比；另一个缺点是<strong>固态主控发热会比较严重，如果没有很好的散热持续工作性能下降很明显</strong>，这也是为什么大部分固态 U 盘都是金属外壳，比如我自己用的自制 U 盘和爱国者的固态 U 盘，复制电影什么的手摸上去都会温温的，如果上个 Win to Go 什么的那温度会更高。当然散热比较好是不会有掉速的，只不过金手外壳重量和价格又要上去了。</p><h2 id="内存卡的结构原理和常见参数"><a href="#内存卡的结构原理和常见参数" class="headerlink" title="内存卡的结构原理和常见参数"></a>内存卡的结构原理和常见参数</h2><p>说到我们广泛实用并且非常熟悉的小型储存设备，除了 U 盘以外自然就是内存卡了。内存卡诞生之后，凭借着自己微小的体积和方便的安装方式迅速普及，即使到现在还是绝大部分设备扩展储存空间的首选。</p><p><img src="https://cdn.sspai.com/2021/10/19/a1f81e21cbca8678744f58581043c962.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>我手上各种牌子和容量内存卡都有，这里放一部分</p><p>内存卡曾经有很多个类型，比如索尼的 MMC，记忆棒，M2 卡，MiniSD 卡等等。<strong>现在我们主要使用的内存卡就只有两种类型：SD（Secure Digital，虽然一点也不安全） 卡 和 Micro SD（也就是之前的 TF） 卡</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/0c64d9867f65a4151307782393040695.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 256GB Micro SD 卡</p><p><img src="https://cdn.sspai.com/2021/10/19/04aee40a942f68bc595fa5876b5521f6.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Micro SD 卡和 SD 卡</p><p><img src="https://cdn.sspai.com/2021/10/19/64fc11a26736f0e14b2cbf84d36af59a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>1TB 容量的闪迪 Sandisk 内存卡</p><p>有些 Micro SD 卡在包装盒上还会附赠一个卡套，用来转成大的 SD 卡。现在的的 SD 卡一般都是摄影设备，比如数码相机和摄像机用的比较多，而小型设备都用 Micro SD 卡。而内存卡的进化也是非常迅速，我之前手上还有一个不到 1MB 内存卡（弄丢了蛮可惜的），而现在 1TB 的内存卡也已经可以在网上买到，<strong>重点是它俩的大小一模一样</strong>。</p><h3 id="内存卡的结构原理"><a href="#内存卡的结构原理" class="headerlink" title="内存卡的结构原理"></a>内存卡的结构原理</h3><p>不像 U 盘，内存卡我们可就没办法自己拆了，只能给大家找找拆解的图片：</p><p><img src="https://cdn.sspai.com/2021/10/19/fca5d5d7e0d5fd5f0cbcc8a38e566272.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SD 卡的内部结构，图片来源：Gough’s Tech Zone</p><p><img src="https://cdn.sspai.com/2021/10/19/5ccab12dd7e992850713ab674f0c0802.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Micro SD 卡结构，图片来源：Storage Review</p><p>Micro SD 卡还不太清楚，SD 卡拆开后里面的结构就比较明了了，<strong>是不是看起来和 U 盘非常像</strong>？没错，<strong>内存卡其实也和 U 盘甚至固态硬盘一样，都是 NAND 闪存颗粒加主控的工作模式</strong>，甚至用料都很类似，比如图上那个金士顿的内存卡就是熟悉的 TLC 颗粒加上群联的主控。</p><p>更小的 Micro SD 卡其实也是类似，不过由于体积实在太小了，主控都是特别定制的内存卡主控，底下放置的闪存颗粒同样密度也变得特别大。</p><p>既然工作方式和组成结构都类似，那么<strong>上面介绍到的 U 盘与固态硬盘的容量速度寿命等对比也可以套用到内存卡与 U 盘或者内存卡与固态硬盘的对比上</strong>，就不用重复介绍了。甚至这个体积<strong>内存卡的主控比 U 盘主控性能差得更多</strong>，基本上就真的只有单通道和基本的数据控制功能了，多的那是一点没有。</p><p>过小的体积导致主控算力严重不足，和 U 盘相同的原因让内存卡的容量，速度， 寿命比起 U 盘再下一个台阶。也导致使用时候更加容易发热，让原本就不剩多少的性能再次下降。</p><p><img src="https://cdn.sspai.com/2021/10/19/ce329a92165a763356550ba80c824937.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 256G 内存卡的速度</p><h3 id="内存卡读卡器"><a href="#内存卡读卡器" class="headerlink" title="内存卡读卡器"></a>内存卡读卡器</h3><p>很多时候我们不仅要将内存卡插到各种设备内部使用，也要把内存卡通过 USB 等方式插到设备外部传输数据（比如最常见的通过 USB 插到电脑上）。如果设备没有内存卡插槽，就需要借助读卡器来将内存卡变为一个类似 U 盘的东西。</p><p>甚至我们上面提到的卡套，也就是把 Micro SD 卡转成 SD 卡的东西，严格来讲也算是一种读卡器。读卡器的结构相对简单，里面主要就<strong>一个卡槽和一个主控，负责将内存卡的 SPI&#x2F;SD 协议转化为 USB 协议</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/895540bc0760b4dc8de7062a1cb03a71.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>经典的地摊小衣服读卡器和卡套</p><p>很多人对读卡器没有什么概念，觉得能用就行，但其实<strong>读卡器也分不同的 USB 等级支持，甚至使用不同读卡器对内存卡的速度和寿命有比较大的影响</strong>。</p><p>像是以前我们常见那种都是 USB2.0 的读卡器，速度即使全速也就 60MB&#x2F;s，更别说这种级别读卡器主控一般特别差，内存卡插上去通常只能跑十几 MB&#x2F;s。</p><p>所以我们必须要按照下面操作讲解去看内存卡的速度等级，然后购买对应的读卡器或者直接上最高级的读卡器（反正也不贵），现在购买读卡器就直接上支持 UHS-Ⅱ 的读卡器，主控性能更好，同时插大卡和小卡也能跑满速度，而且免得以后升级那种卡还要换读卡器。</p><p><img src="https://cdn.sspai.com/2021/10/19/3056725b3323401bd7c933e020743f1a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>川宇 UHS-Ⅱ 读卡器</p><p>主控性能差的读卡器不仅让上面的内存卡速度变慢，传输数据时不稳定的电压和不靠谱的算法还会影响内存卡的寿命。实际上影响比我们想象中还大，<strong>很多人的内存卡就是因为用了质量差的读卡器而提前「寿终正寝」</strong>。</p><h3 id="内存卡的常见参数讲解"><a href="#内存卡的常见参数讲解" class="headerlink" title="内存卡的常见参数讲解"></a>内存卡的常见参数讲解</h3><p>其实别看内存卡小，它的各种规范参数反而比 U 盘更加详细，甚至大部分都印在了内存卡面上。</p><p><img src="https://cdn.sspai.com/2021/10/19/98d7cf86a24f209a0e0c143f3834bc5a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>内存卡表面的各种图标就是它代表的参数</p><p>像是型号容量这些就不说了，大家都能看出来，剩下这些符号也把内存卡的基本性能都标注出来了。</p><p>而且内存卡的参数标准标的比较实在，不像是 U 盘和硬盘等其他设备厂家通常都用顺序读取速度来标注，而且还有应用表现等级（Application Performance Class）这种针对移动设备应用运行的标准，把发热掉速都考虑进去的标准，直接标注随机和连续性平稳写入最低速度。</p><p>先说一个跟容量相关的 SD 容量标准，也就是<strong>内存卡上面最大个的那个图标标明了内存卡的类型</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/f1d7cff5ffdd4082e72344242568e48b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SD 卡容量标准与总线对应的速度和 SD 协议版本，图片数据来源：SD 联盟 SDcard.org</p><p>其中 2GB 的 SD 标准我们现在基本已经见不着了，2-32GB 的 SDHC 也越来越少，<strong>目前市面上绝大部分都是 UHS（Ultra High Speed）SDXC 卡</strong>。更新的标准不仅是更大的容量和速度上限，更新 SD 协议版本也能让主控性能更加优化，把稳定性和寿命也提上来。<strong>支持 UHS-Ⅲ 的内存卡速度甚至已经逼近了 SATA3 固态硬盘的最高速度。</strong></p><p><img src="https://cdn.sspai.com/2021/10/19/cc78b338ca2019ee95659f4e3d739499.gif"></p><p>UHS 不同等级的内存卡针脚是不一样的，可以向下兼容</p><p>有些品牌还会有超频 UHS 内存卡这种神奇的东西，就是将内存卡里面的主控性能超频，以达到比标准更高的读写速度，但是发热和价格也会更加感人，除非你经常需要传输大量素材，不然没有必要上这种卡。</p><p><img src="https://cdn.sspai.com/2021/10/19/73818bfd116d94332efc99a723c323e4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>金士顿 Kingston 的超频 UHS 内存卡</p><p>另外内存卡上比较常见的还有 <strong>Speed Class，UHS Speed Class，和 Video Speed Class 三个速度标准</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/40a322f6a28b2940f133a22184f76fc5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><img src="https://cdn.sspai.com/2021/10/19/291532453ea2c235126804665551666d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>这三个速度等级对应的速度和视频录制分辨率上限，图片来源：金士顿 Kingston Technology</p><p>通常来讲 <strong>C10（甚至可以说 U1） 是现在最低标准的内存卡，低于这个等级的都是当电子垃圾处理</strong>。Video Speed Class 比较好看， <strong>V 后面跟着的数字是多少最低顺序写入速度就是多少</strong>。</p><p>而最后还有一个 Ax 的图标代表的就是我们上面提到的应用表现等级（Application Performance Class）。</p><p><img src="https://cdn.sspai.com/2021/10/20/258b872536bc5d831cedfcee31d0ede0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>应用表现等级和对应的最低速度与 IOPS，图片来源：SD 联盟 SDcard.org</p><p>有些内存卡不会标这个，但是有标这个的话是非常良心的，因为<strong>这个标准不仅规定了最低速度，而且还是随机地写入读取速度</strong>，还有一个把发热掉速等等原因都考虑进去的，连续性平稳写入最低速度，除了速度以外还考虑到了 IOPS，也就是我们第二章介绍到的每秒处理读写命令次数，<strong>最贴合用户实际的使用场景，A1&#x2F;A2 都表示即使移动设备安装应用到这张内存卡上也能保持使用流畅</strong>。</p><p>另外只有达到这个标准一些特殊的功能用起来才不会掉链子，比如安卓 Android 设备上把应用装到内存卡的功能，就需要内存卡的质量和性能都很不错，不然像是应用这种频繁交互的东西用起来就卡出翔。</p><p><img src="https://cdn.sspai.com/2021/10/20/f45df15b9fd8e83dc5fad23969cdfcae.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>空间不足的时候，可以把微信的存储空间改为内存卡</p><p>怎么样，这样看是不是内存卡标注的参数非常良心也通俗易懂，以后我们购买的时候只要直接看卡面就能清楚地知道这个内存卡的大概性能了。</p><h3 id="UFS-内存卡"><a href="#UFS-内存卡" class="headerlink" title="UFS 内存卡"></a>UFS 内存卡</h3><p>三星还捣鼓过一个比目前内存卡性能高很多的用手机上常见的 UFS 协议的内存卡，不仅针脚完全不同，连样子都不一样，插不进普通的内存卡插槽。不过性能完全秒杀现在最高的 UHS-Ⅲ，达到 SATA 固态的水平。</p><p><img src="https://cdn.sspai.com/2021/10/20/b4670002660f8c1039308718c9ccc36a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>三星 UFS 内存卡，图片来源：三星 Samung Semiconductor</p><p>可惜这玩意儿三星推不起来，干打雷不下雨，最后连三星自家的设备也不支持了。</p><h4 id="防写入开关"><a href="#防写入开关" class="headerlink" title="防写入开关"></a>防写入开关</h4><p>最后再简单讲讲一个 SD 卡上有，而 MicroSD 没有的开关，就是可以往上推的写保护开关。这玩意儿跟之前我们介绍的软盘上的写保护开关类似，也是向上推就禁止写入。不过它就是一个提供给设备识别的塑料块，写保护功能需要设备支持，随着现在有写保护开关的内存卡越来越少，很多设备直接就不认这个开关了，就算把写保护开关打开的内存卡插进去，也照样能写入数据。</p><p><img src="https://cdn.sspai.com/2021/10/20/b2f98d31f2b0b7d55f41886dc74ddd0b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>SD 卡上的写入保护开关，图片来源：<br>AOMEI Partition Assistant</p><h3 id="内存卡与移动设备"><a href="#内存卡与移动设备" class="headerlink" title="内存卡与移动设备"></a>内存卡与移动设备</h3><p>随着智能手机崛起，MP3，MP4 之类的东西成为时代的眼泪，甚至智能手机和平板大部分都不支持内存卡拓展，现在我们使用内存卡的场景大概也就是数码相机、摄像机、HiFi 音乐播放器、 Nintendo Switch 游戏机之类的了。</p><p>普通的数码相机和摄像机就直接参考 Video Speed Class 后面的视频格式，按照现在的标准<strong>只要达到 8K 视频的最低标准（也就是 V30）以上，就可以完全无压力拍摄 4K 视频或者全画幅照片连拍</strong>。</p><p>而如果你的手机还支持内存卡扩展的话，就像上面提到那样建议购买 A2 等级的内存卡，这样无论是拍照录像还是把应用数据直接放在内存卡上，都没有太大的压力。很多人担心内存卡会不会降低手机速度，这也是很多手机厂商不支持内存卡的原因，但根据我使用多年并且目前还在使用，支持内存卡并且是对性能下降比较敏感的旗舰智能手机的经验来看，即使把通话录音、拍照摄影、不要太多的应用数据、海量的音乐电影等放在 256GB 内存卡上，也不会影响手机的速度。</p><p><img src="https://cdn.sspai.com/2021/10/20/1c9e7c231c477da0160c1db0c162bde6.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>我目前在手机上使用的是三星的 256G 内存卡</p><p>至于 Nintendo Switch 和无损音乐播放器这两个设备使用内存卡的实际情况刚好和大部分人想象中反过来。</p><p>大家会觉得 NS 往往需要比较高性能的内存卡，不然游戏会卡加载会慢，但实际上我试过高速和低速内存卡，游戏运行没有区别，加载速度低速内存卡略微减慢，但内存卡本来就慢，所以也感觉不太出来。</p><p>反到是 HiFi 播放器对内存卡更加敏感，如果你使用一般的低速内存卡播放 192Khz 36Bit 以上的 FLAC 或者 DSD 无损音乐，播放会稍微卡顿，听着有点难受。一般要听这种级别的无损音乐，至少也要 V30 以上的内存卡（另外讲个比较玄学好玩的事情，部分发烧友是真的会认为内存卡会影响音质的～）。</p><p><img src="https://cdn.sspai.com/2021/10/20/5df4afe35d84493864f87f738bd0cacb.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 的内存卡搭配爱国者 Aigo 的 HiFi 播放器</p><h4 id="小卡套卡套当大卡用可以吗"><a href="#小卡套卡套当大卡用可以吗" class="headerlink" title="小卡套卡套当大卡用可以吗"></a>小卡套卡套当大卡用可以吗</h4><p>理论上如果不是在特别高速或者长时间持续写入的情况下是不会有任何区别的，但是实际上经过转换会稍微有点性能损失。</p><p>而且用的不是内存卡送的原装卡套的话，还会因为公差导致插得不够紧，插件数码相机等地方长时间摇晃震动有时候会出现链接丢失的情况。我自己用的相机就是小卡转大卡，目前没有出现过任何状况。当然如果你是特别高端的相机，经常拍 4K60 或者 8K Raw 这类超高清视频，或者数据特别重要，就靠内存卡上的数据恰饭或者只有一次机会捕捉数据，那就别用小卡套卡套了，老老实实地买高速 SD 卡或者外接固态。</p><p><img src="https://cdn.sspai.com/2021/10/20/9df35ee55dc2e2d771f4723b2a99fea7.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>别到时候出现这个心脏骤停的提示就完蛋了，图片来源：什么值得买@Sail_0702</p><h3 id="U-盘和内存卡的实际速度和性能测试"><a href="#U-盘和内存卡的实际速度和性能测试" class="headerlink" title="U 盘和内存卡的实际速度和性能测试"></a>U 盘和内存卡的实际速度和性能测试</h3><p>了解完两个储存设备的结构原理和参数，接下来我们就教大家如何测试一下自己 U 盘和内存卡的实际速度，这里可以用我们之前测试机械硬盘和固态硬盘的软件来测试，但是我推荐另一款专门测试 U 盘内存卡等闪存设备的软件 <strong>ATTO Disk Benchmark</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/20/77cc2b29e50e820c107d1487b30b3d73.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>ATTO Disk Benchmark 的应用界面</p><p>ATTO Disk Benchmark 比起其他测试软件的优势在于，它可以一次性模拟很多个块大小，精准反映出不同文件大小比例对闪存设备速度的影响，覆盖比较广的用户日常使用情景，一次性给出的结果也比较直观。</p><blockquote><p>测试前要注意两件事，一个是测试的时候记得<strong>插在电脑最快的接口上</strong>，另一个则是使用<strong>最快的或者说速度等级正确的 USB 读卡器</strong>。不然测试出来的结果通常不是设备的速度，而是接口或者读卡器的速度上限。</p></blockquote><p>接着我们直接使用 CrystalDiskMark 和 ATTO Disk Benchmark 来对爱国者 Nvme 固态硬盘、爱国者高速固态 U 盘、UFS 芯片自制的 U 盘、爱国者内存卡和三星内存卡进行一下跑分。</p><p><img src="https://cdn.sspai.com/2021/10/20/2dbae41260e4e5150d05a95d3c76f660.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo Nvme 固态硬盘、爱国者 Aigo 高速固态 U 盘、UFS 芯片自制的 U 盘、爱国者 Aigo 内存卡和三星 Samsung 内存卡的 CrystalDiskMark 读写速度跑分结果</p><p><img src="https://cdn.sspai.com/2021/10/20/5e2c8bef38dbfd0e04ae3545182f3ae4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo Nvme 固态硬盘、爱国者 Aigo 高速固态 U 盘、UFS 芯片自制的 U 盘、爱国者 Aigo 内存卡的 ATTO Disk Benchmark 读写速度跑分结果</p><p><img src="https://cdn.sspai.com/2021/10/20/e38b5cf91233a99c0fb2fc20b73b4d73.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo Nvme 固态硬盘、爱国者 Aigo 高速固态 U 盘、UFS 芯片自制的 U 盘、爱国者 Aigo 内存卡的 ATTO Disk Benchmark IOPS 跑分结果</p><blockquote><p>看不到文字的话可以点击图片放大查看图片。</p></blockquote><p>可以看到固态硬盘、U盘、内存卡三个不同类型的储存设备，读写速度和 IOPS 差距形成了明显的三个层级。</p><p>大家还可以<strong>多进行几次测试，测试一下 U 盘的散热情况，还有过热掉速的性能</strong>，某些 U 盘和内存卡即使初始速度很好，但是持续写入之后很快会过热，速度哗哗地掉。</p><h3 id="关于扩容-U-盘和扩容卡"><a href="#关于扩容-U-盘和扩容卡" class="headerlink" title="关于扩容 U 盘和扩容卡"></a>关于扩容 U 盘和扩容卡</h3><p>关于购买时常见的扩容 U 盘和扩容内存卡，以及其他常见的坑，我们放到选购这一章再讲。</p><h3 id="U盘和内存卡读卡器用完直接拔可以吗"><a href="#U盘和内存卡读卡器用完直接拔可以吗" class="headerlink" title="U盘和内存卡读卡器用完直接拔可以吗"></a>U盘和内存卡读卡器用完直接拔可以吗</h3><p>以前上电脑课或者在日常使用的时候，我们应该会有被老师朋友或者同事说过一定要在拔出 U 盘或者读卡器之前先右下角弹出或者卸载驱动器再拔。但是这玩意儿很讨厌，有时候明明没有任何应用打开，却卸载不了驱动器。</p><p><img src="https://cdn.sspai.com/2021/10/20/7fe7186900c5d4db545dea7c2d34b5a1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>心跳骤停的大容量存储设备卸载失败提示</p><p>就因为如此有些人，比如我，有时候是忘记有时候是实在懒得卸载，直接就把 U 盘或者读卡器拔掉，那么这样子做会不会对储存设备有损害呢？</p><p>在以前可能还会有损害，毕竟卸载不掉驱动器的时候有可能后台会有一些写入，直接中断可能会造成文件系统混乱，很多人也见过 U 盘里面的文件名变成乱码，或者多一些信息怪怪的文件，就是文件系统混乱。Windows 对于移动驱动器的优化也会导致文件丢失，简单来讲就是 Windows 会提前显示文件复制完成成，然后再在后台慢慢放到 U 盘或者内存卡里，这个时候如果立刻拔掉，其实文件是没有写到 U 盘里面的。</p><p>但是现在基本不用担心了，<strong>直接拔 U 盘和内存卡并不会造成损害</strong>，因为微软知道其实没有人会每次认认真真的卸载驱动器，Win10 1809 之后默认驱动器策略就是「快速删除」，用稍微降低读取写入速度的代价换来随用随拔的方便。</p><p><img src="https://cdn.sspai.com/2021/10/20/fc001a7cabb50a682adace3eeb908b7d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>在 Windows 键上右键选择磁盘管理，在对应磁盘右键选择属性 -&gt; 策略，就可以更改是更好的性能还是快速删除</p><p><strong>相关文献</strong>：</p><p>[1]. 内存卡相关的标准和速度等级可以直接查看国际 SD 联盟网站制作的一系列很详细的<a href="https://www.sdcard.org/developers/sd-standard-overview/">规格介绍</a>。<br>[2]. 关于谁是 U 盘发明者直到现在争议还蛮大的，我找了很久也没有找到比较合适的资料，感兴趣的同学可以自己找找看。<br>[3]. 对三星倒腾的 UFS 内存卡感兴趣的朋友，可以直接在这个地址下载到它们的<a href="https://www.samsung.com/semiconductor/cn/insights/tech-leadership/samsung-ufs-card/">白皮书</a>。<br>[4]. ATTO Disk Benchmark 官方<a href="https://www.atto.com/disk-benchmark/">下载地址</a>，不需要填邮件的 <a href="https://www.techpowerup.com/download/atto-disk-benchmark/">TechPowerUp 源下载地址</a>。</p><h2 id="移动硬盘简单介绍"><a href="#移动硬盘简单介绍" class="headerlink" title="移动硬盘简单介绍"></a>移动硬盘简单介绍</h2><p>U 盘和内存卡虽然一个比一个小，便携性拉满，但很多时候人们并不需要这么便携，反而对容量速度还有稳定性有比较高的要求，这个时候移动硬盘就是比较好的选择了。</p><p>其实无论是机械移动硬盘还是固态移动硬盘，她们的本子都是一个<strong>独立的硬盘套壳</strong>，再加上一个电路板用来将硬盘协议转化成 USB 协议以及给硬盘供电。</p><p><img src="https://cdn.sspai.com/2021/10/20/50a95932c1362fbbd73643dedba0e5e0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><img src="https://cdn.sspai.com/2021/10/20/9c0c5433920b6f09c9ee68b8d202b7cd.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同类型的移动硬盘内部，图片来源：iFixit &amp; The SSD Review</p><p>市面上绝大部分移动硬盘都是这样，直接把市面上卖的硬盘套进一个自己设计的壳子里。毕竟移动硬盘对便携性要求不是太高，要是集成度太高移动硬盘的性价比就没有了（虽然也有为了数据安全做成一体的三防移动硬盘与指纹识别移动硬盘）。所以市面上更多的是卖各种移动硬盘盒，让用户自己购买里面的硬盘。</p><p><img src="https://cdn.sspai.com/2021/10/20/39ee080a754d7075df67a222ecb9cf56.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>网上在卖的各种移动硬盘盒</p><p>但是前面几章我们也学到了，无论是<strong>机械硬盘还是固态硬盘，它们对供电稳定性的敏感度还是很高的</strong>，有时候你摔几下都不一定能摔坏硬盘，但停电一次硬盘就有可能和你的数据一起灰飞烟灭。所以<strong>移动硬盘盒的性能和安全性还是得看它的主控，主控型号和性能就是移动硬盘最重要的参数</strong>，而不是一些花里胡哨的透明外壳之类的。</p><p>对于机械硬盘来讲，移动硬盘盒的主控性能对寿命影响比较大，速度上可能看不太出来；但随着 USB3.1，3.2 接口的普及，主控性能对固态移动硬盘的影响就比较明显了，比如我们手上如果有一块 M.2 的 PCie3.0&#x2F;4.0 固态，动不动就能跑 3GB&#x2F;s，那么它对供电质量的要求是非常高的，如果是普通的固态硬盘盒不仅速度会比性能好的主控慢，供电不稳还容易导致固态硬盘寿命缩短。</p><blockquote><p>比如某个主控某个固件版本会有不安全断电的 BUG，每拔出一次就会增加一次固态硬盘的不安全断电次数，对固态硬盘特别是对高端固态硬盘的伤害是特别大的，但用户完全不会知道。</p></blockquote><p>以前人们为了大容量性价比通常会选择机械硬盘来做移动硬盘，但现在大容量固态硬盘的价格逐渐下来，加上 <strong>USB 接口的速度上限也超过了 SATA 接口</strong>，而固态硬盘不仅重量更轻，能做得更小，还没有机械硬盘怕震动怕摔的毛病。所以除非是有很大容量要求，<strong>现在购买移动固态硬盘或者移动固态硬盘盒的用户越来越多</strong>。</p><p>市面上也出现了像爱国者 S7 Pro 这种迷你固态移动硬盘，既不用像 U 盘那样为了体积牺牲性能速度和寿命，也不像机械硬盘那样有机械部件的限制，体积特别大才能做到大容量。把体积稍微放宽到两个 U 盘那么大之后，就能轻松的塞进去 1TB 的 NAND 闪存颗粒和一个不错的主控，同时也能放进像是证件夹甚至钱包等小地方，保持非常好的便携性。</p><p><img src="https://cdn.sspai.com/2021/10/20/dd6bffb6fb7aaa62faf0dd89b743e3dd.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 迷你固态移动硬盘体积差不多是削了一半的 Airpods 充电盒，速度也挺不错的</p><p><img src="https://cdn.sspai.com/2021/10/20/f0360fb6fadfaf57558f4fae2e29c057.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 迷你固态移动硬盘 S7 Pro 的 CrystalDiskMark 读写速度跑分结果</p><p>当然如果你比较追求性价比，极致性能或者 DIY 的话，也可以像我一样去挑个自己满意的主控版，然后定制自己喜欢的外壳材料和图案，最后再买个自己满意的 M.2 固态，做一个比 U 盘大不了多少，同时没有妥协的 DIY 移动固态硬盘出来。</p><p><img src="https://cdn.sspai.com/2021/10/20/3b7195328a6563c6cc972cd8586f0b25.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>DIY 固态移动固态硬盘，主控 RTL9210 最新固件，速度可以说是杠杆的</p><p><img src="https://cdn.sspai.com/2021/10/20/88e46efaf64108751127daad73d565d8.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>自制 Nvme 移动固态硬盘 S7 Pro 的 CrystalDiskMark 读写速度跑分结果</p><blockquote><p>在使用章节我会详细教大家怎么去更好地使用移动硬盘和一些简单的 DIY 技巧。</p></blockquote><h2 id="手机上的储存芯片"><a href="#手机上的储存芯片" class="headerlink" title="手机上的储存芯片"></a>手机上的储存芯片</h2><p>其实有一个非常普遍使用的储存设备往往被人们忽略，那就是我们每天都在使用的智能手机。</p><p>到现在智能手机已经逐渐取代其他设备，成为人们日常使用的绝对主力数码设备。通常来讲，手机里面的空间寸土寸金，智能手机的容量速度要求也越来越大，但体积却不能变还要给电池让空间，所以储存芯片也和手机里其它部件一样需要不断缩小，按理说应该会出现和 U 盘内存卡一样的困境。</p><p>但也正因为智能手机成为人们使用的主力数码设备，利润空间充足，各种技术也围绕着它来研发，所以<strong>手机上的储存芯片反而容量，速度和技术含量都比较高</strong>。</p><h3 id="手机储存芯片的结构原理"><a href="#手机储存芯片的结构原理" class="headerlink" title="手机储存芯片的结构原理"></a>手机储存芯片的结构原理</h3><p>和电脑等其他设备使用习惯不同，人们在移动设备上不仅会经常切换应用，而且 ARM 移动设备虚拟机沙盒机制让清理后台的频率也会比 X86 设备频繁（iOS 甚至就没有真后台）。这样系统需要频繁将应用数据在运行内存和储存芯片中来回倒腾，加上网络越来越快对于储存芯片速度要求越来越高，根据木桶原理，<strong>储存芯片性能对移动设备速度的影响甚至比运行内存还要大</strong>。苹果 iOS 系统之所以这么流畅，除了归功于优秀的系统动画设计，很大一部分重点是 iPhone&#x2F;iPad 等设备很早就用上了 Nvme 固态硬盘（后台墓碑机制也部分得益于此）。</p><p><img src="https://cdn.sspai.com/2021/10/20/4afb3cde993fefa690091b27f3393750.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>iPhone6s 的储存芯片跑分速度，也就是从它开始苹果 Apple 在手机上使用 Nvme，图片来源：The SSD Review</p><p><img src="https://cdn.sspai.com/2021/10/20/399e68dcaeefd196290a1033356f457b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>UFS 储存芯片一般长这个样子，图片来源：三星 Samsung Semiconductor</p><p>其实手机的储存芯片结构反而很简单，或者说是没有结构，<strong>就单纯是 NAND 闪存颗粒</strong>。因为对性能要求很高，同时因为空间原因上不了多个颗粒平衡磨损，所以<strong>旗舰智能手机也是目前少有的还在大量使用 MLC 颗粒的设备</strong>，不过中低端智能手机一般就是 TLC 了（目前 QLC 好像还没有）。</p><p>那么固态硬盘上另外两个重要的部件——主控和缓存去哪里了呢？聪明的朋友可能已经猜到了，没错智能手机把这两个部件做到了极致 —— 主控（内存控制器）直接做进了 SoC（System on Chip，就是各种不同功能的控制器，包括 CPU 和网络控制器，GPU 等都集合在一个芯片里，我们常听说的骁龙芯片就是 SoC），缓存则直接使用运行内存，这就是为什么手机上储存芯片集成度那么高，性能却能这么好。</p><blockquote><p>试想下一个骁龙 888 里面的内存控制器做主控，LPDDR5 运行内存做缓存芯片的固态硬盘要卖多少钱，智能手机刚好自带这两个部件。</p></blockquote><h3 id="手机储存芯片的速度等级"><a href="#手机储存芯片的速度等级" class="headerlink" title="手机储存芯片的速度等级"></a>手机储存芯片的速度等级</h3><p>除了<strong>苹果使用的是自己的协议之外，Android 和其他移动设备之前通常使用的是 eMMC 协议，现在则是 UFS 协议</strong>。</p><p>我们看手机发布会通常就会听见这些名词，其实 <strong>eMMC，UFS 这些就和电脑上的 SATA，Nvme 一样是储存设备的接口和协议</strong>，只不过直接走 SoC 内部总线而已。</p><p><strong>eMMC 和 UFS 都是为移动设备而诞生的标准，目标是在性能和功耗体积之间取得平衡</strong>。</p><p><strong>eMMC</strong>（embedded Multi Media Card，嵌入式多媒体储存卡），名字听起来就不像很现代的储存技术，它就是我们以前移动设备常用的标准，脱胎于 SD 卡的标准，2011 年左右开始广泛在智能手机等移动设备上使用（Android 等智能手机刚出现的时代），主控最多支持 8 个内存通道同时工作，但只能半双工并行传输（也就是<strong>同一时刻只能读或写</strong>，很有 SD 卡那味）。</p><p><img src="https://cdn.sspai.com/2021/10/20/d0f25d996783f903ada1b4a9230c3ba3.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>手机上的 eMMC 芯片，图片来源：Dangerous Payload</p><p>eMMC 有不同版本（最新版本是 5.1A），每个版本的速度也还有 SD 卡那味：</p><p><img src="https://cdn.sspai.com/2021/10/20/32703b6143b0f18b5f38599f1a2df4eb.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>不同 eMMC 版本和对应的速度与 IOPS，图片来源：三星 Samsung Semiconductor</p><p>可以看到即使是 eMMC5.1 速度也就和 U 盘拼一下，把它当做手机上装载系统数据和应用的储存芯片显然「小才大用」了，<strong>Android 系统之前版本大家觉得很卡，反应很慢，用久了会越来越卡，原因就是因为这个（毕竟即使是刚出来的四核骁龙 600，性能也是足够的了）。</strong>即使到现在，eMMC 也广泛被低端手机和低端平板（比如 Surface Go……）使用，毕竟它也还是有一些优点的，比如协议简单技能要求低、容量大、功耗相对较低等等。</p><p>后来储存厂商和手机厂商们都顶不住 eMMC 的速度，终于推出了 UFS（Universal Flash Storage） 标准，只有两个内存通道，但是每个通道的速度吊打 eMMC，而且支持串行传输全双工模式（也就是<strong>同时读和写</strong>），而且还有 eMMC 没有的高级功能，比如<strong>对于多任务非常非常重要的队列（这样就能同时执行多条指令）</strong>、深度睡眠等等。</p><p><img src="https://cdn.sspai.com/2021/10/20/1a194857637f21668295c637449c1d06.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>eMMC 与 UFS 工作方式的区别，图片来源：三星 Samsung Semiconductor</p><p>特别是队列 CQ 支持，对操作系统而言十分重要，毕竟操作系统每分每秒都要产生和读取很多个临时或者永久的小文件，<strong>储存设备 IOPS 越高系统就越流畅</strong>。而深度睡眠技术让芯片不工作的时候耗电更加少，提升手机续航，总之 UFS 看起来终于像是个正儿八经的移动储存设备标准而不是 SD 卡标准魔改。</p><p>可惜 UFS1 速度拉不开差距没啥人用，等到 2014 年 UFS2.0 出现之后才逐渐被厂商大规模使用，自从用上 UFS2.0 以后，Android 手机使用体验有了质的飞跃：开机更快，安装应用更快，游戏加载更快，系统反应更快，切换应用更快，下载复制文件更快，同时不会像以前那样越用越卡，让 Android 手机彻底摆脱慢和卡。</p><blockquote><p>直接查看手机对应型号的官网商品详情或者使用<strong>隐秘参数</strong>之类的软件就可以看到自己手机上使用的储存芯片类型和版本。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/20/9ca3daedf01f357e9dd46022e91dcf14.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>查看自己手机上的储存芯片类型</p><p>UFS 也迭代了几个版本，每个版本的读取和写入速度都有巨大的提升，到最新一代 UFS3.1 在手机上已经可以打平普通 Pcie3.0 Nvme 固态了。同时未来 UFS 将会应用到相机，汽车，工业化设备等等更多领域上，有希望成为移动设备通用储存标准。</p><p><img src="https://cdn.sspai.com/2021/10/20/92c6d685980dba3ebd5f5307e437ab44.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>UFS 不同版本的速度，图片来源：APPuals</p><h3 id="手机储存芯片实际速度测试"><a href="#手机储存芯片实际速度测试" class="headerlink" title="手机储存芯片实际速度测试"></a>手机储存芯片实际速度测试</h3><p>大部分数码爱好者和评测博主什么的都喜欢用 AndroBench 这款软件来测试手机的储存芯片速度，测试过程比较直观，<del>也有提供其他设备的排行榜，方便对比自己的手机处在什么样的位置</del>。</p><p><img src="https://cdn.sspai.com/2021/10/19/ba51d407e51215bb17ebbbd12facde12.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>AndroBench 界面与我自己手机的测试结果</p><p>但是 AndroBench 最后更新是 2016 年了，到现在界面都不适配，虽然有排行榜功能但是貌似打不开了，而且各平台也不好横向比较。这里我给大家推荐另一款<strong>开源跨平台的储存性能测试软件 CPDT Benchmark</strong>。</p><p>CPDT Benchmark 有着很酷的命令行界面，而且<strong>支持跨平台</strong>（Windows，macOS，Linux 和 Android，iOS），更新很勤快而且开源，简单排行榜什么的也都有，最重要的是<strong>可以调整测试文件大小，可以测试关闭内存和写入缓存后的速度</strong>，是我首选的手机储存性能测试工具。</p><p><img src="https://cdn.sspai.com/2021/10/19/8fabda6e9962a17d218da098a7ffcba6.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CPDT Benchmark 界面与手机储存性能测试结果，第二个结果是打开内存和写入缓存测试的</p><blockquote><p>记住 CPDT Benchmark 默认是关闭内存和写入缓存的，<strong>测试结果不可以直接和其他软件比较</strong>。</p></blockquote><p>按照 CPDT Benchmark 官网的建议，为了让结果更加准确，大家测试的时候要关闭所有后台程序，如果不确定有没有后台下载，最好关闭网络连接。同时要进行三次以上的测试，选最高的一项，如果设备性能比较好可以把测试文件用量从 1GB 提升到 2GB。</p><p>另一个重要的点是要**保持可用储存空间容量不要超过 70%**，在手机上剩余储存空间对手机性能影响很大，原因是系统会生成很多临时文件用来加速平时的运行（比如 Android 内置储存 DCIM 目录下的 .thumbnail 文件夹就放着所有照片的低分辨率缩略图，Data 目录下还会有每个应用生成的临时文件），这些文件的容量可不小，如果储存空间不足，以放置这些临时文件，那么系统自然就会变慢（打开相册的时候列表加载不出来，应用打开之后要空白好久重新生成数据等）。</p><blockquote><p>其实设备的总容量也会对性能有很大的影响，比如 iPad Mini6 就有 64G 和 256G 两个版本，储存芯片速度相差好几倍，刚好和容量相差倍数差不多，估计就是内存通道数量差别，不过实际使用体验倒是差别不大</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/19/e2ccb4c1597bcfc7fbc651ca37dcf786.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>iPad Mini6 不同储存容量的读写速度差别，图片来源：极客湾 Geekerwan</p><p><strong>相关文献</strong>：</p><p>[1]. eMMC 标准的 JEDEC <a href="https://www.jedec.org/standards-documents/technology-focus-areas/flash-memory-ssds-ufs-emmc/e-mmc">标准规范文档</a>。<br>[2]. UFS 标准的 JEDEC <a href="https://www.jedec.org/standards-documents/focus/flash/universal-flash-storage-ufs">标准规范文档</a>。<br>[3]. 隐秘参数<a href="https://www.coolapk.com/apk/com.x1y9.probe">应用市场地址</a>。<br>[4]. CPDT Benchmark <a href="https://maxim-saplin.github.io/cpdt_results/?about=">Github 项目地址</a>，<a href="https://play.google.com/store/apps/details?id=com.Saplin.CPDT">Play 商店地址</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我带大家了解了 U 盘、内存卡、移动硬盘和手机储存芯片的结构原理和常见的参数，让大家知道为什么这几个储存设备工作方式类似，但是却有着截然不同的容量速度和寿命。看完这篇内容，特别是后面几个储存设备的介绍，大家印象最深刻的应该是主控真的特别重要了吧。</p><p>而且到这里我们已经把现在常见的储存设备仔仔细细里里外外都介绍了一遍，从最根本的原理到实际的参数全面覆盖，可以说你现在已经是大部分储存设备的半个专家了（恭喜恭喜👏👏👏🎉🎉🎉）。在下一章我们将正式开始选购的内容，首先就是关于机械硬盘的选购，我将给大家仔细讲解各种类型的机械硬盘，还有叠瓦盘的具体介绍，并且给出针对大家不同使用需求和不同预算等级的购买建议。</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
      <category>数据存储历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理解 U 盘内存卡移动硬盘和手机储存芯片构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路分析与设计</title>
    <link href="/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>电路分析与设计是集成电路设计的基础</p><p>[[1电路基本概念]]</p><p>主要掌握KVL和KCL对数字电路和模拟电路进行分析：</p><p>[[2KVL和KCL分析]]</p><p>等效定理在后期出难题的时候经常出现</p><p>[[3电路定理与等效]]</p><p>[[4具体电路分析]]</p><p>运算放大器是最基本的元件模型，主要关注虚短虚断特性</p><p>[[5运算放大器]]</p><p>电容电感作为电阻以外的基本元件，在之后的学习中非常重要</p><p>电容能够记忆电压的变化（积分形式），其电流正比于电压变化率</p><p>电感能够记忆电流的变化（积分形式），其电压正比于电流变化率</p><p>[[6电容和电感]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫编程基础</title>
    <link href="/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Urlib"><a href="#Urlib" class="headerlink" title="Urlib"></a>Urlib</h1><p>首先我们介绍一个 Python 库，叫做 urllib，利用它我们可以实现 HTTP 请求的发送，而不用去关心 HTTP 协议本身甚至更低层的实现。我们只需要指定请求的 URL、请求头、请求体等信息即可实现 HTTP 请求的发送，同时 urllib 还可以把服务器返回的响应转化为 Python 对象，通过该对象我们便可以方便地获取响应的相关信息了，如响应状态码、响应头、响应体等等。</p><blockquote><p>注意：在 Python 2 中，有 urllib 和 urllib2 两个库来实现请求的发送。而在 Python 3 中，已经不存在 urllib2 这个库了，统一为 urllib，其官方文档链接为：<a href="https://docs.python.org/3/library/urllib.html">https://docs.python.org/3/library/urllib.html</a>。</p></blockquote><p>首先，我们来了解一下 urllib 库的使用方法，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用。它包含如下 4 个模块。</p><ul><li><strong>request</strong>：它是最基本的 HTTP 请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程了。</li><li><strong>error</strong>：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。</li><li><strong>parse</strong>：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析和合并等。</li><li><strong>robotparser</strong>：主要用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。</li></ul><h2 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1. 发送请求"></a><a href="https://cuiqingcai.com/202221.html#1-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" title="1. 发送请求"></a>1. 发送请求</h2><p>使用 urllib 的 request 模块，我们可以方便地实现请求的发送并得到响应。我们先来看下它的具体用法。</p><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a><a href="https://cuiqingcai.com/202221.html#urlopen" title="urlopen"></a><code>urlopen</code></h3><p>urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理授权验证（Authentication）、重定向（Redirection)、浏览器 Cookie 以及其他内容。</p><p>下面我们来看一下它的强大之处。这里以 Python 官网为例，我们来把这个网页抓下来：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a href="https://www.python.org/">https://www.python.org</a>‘)  <br>print(response.read().decode(‘utf-8’))</td></tr></tbody></table><p>运行结果如图所示。</p><p><img src="https://cdn.cuiqingcai.com/yqq2r.png" alt="image-20200315212839610"></p><p>图 运行结果</p><p>这里我们只用了两行代码，便完成了 Python 官网的抓取，输出了网页的源代码。得到源代码之后呢？我们想要的链接、图片地址、文本信息不就都可以提取出来了吗？</p><p>接下来，看看它返回的到底是什么。利用 <code>type</code> 方法输出响应的类型：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a href="https://www.python.org/">https://www.python.org</a>‘)  <br>print(type(response))</td></tr></tbody></table><p>输出结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;class ‘http.client.HTTPResponse’&gt;</td></tr></tbody></table><p>可以发现，它是一个 <code>HTTPResposne</code> 类型的对象，主要包含 <code>read</code>、<code>readinto</code>、<code>getheader</code>、<code>getheaders</code>、<code>fileno</code> 等方法，以及 <code>msg</code>、<code>version</code>、<code>status</code>、<code>reason</code>、<code>debuglevel</code>、<code>closed</code> 等属性。</p><p>得到这个对象之后，我们把它赋值为 <code>response</code> 变量，然后就可以调用这些方法和属性，得到返回结果的一系列信息了。</p><p>例如，调用 <code>read</code> 方法可以得到返回的网页内容，调用 <code>status</code> 属性可以得到返回结果的状态码，如 200 代表请求成功，404 代表网页未找到等。</p><p>下面再通过一个实例来看看：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a href="https://www.python.org/">https://www.python.org</a>‘)  <br>print(response.status)  <br>print(response.getheaders())  <br>print(response.getheader(‘Server’))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>200  <br>[(‘Server’, ‘nginx’), (‘Content-Type’, ‘text&#x2F;html; charset&#x3D;utf-8’), (‘X-Frame-Options’, ‘DENY’), (‘Via’, ‘1.1 vegur’), (‘Via’, ‘1.1 varnish’), (‘Content-Length’, ‘48775’), (‘Accept-Ranges’, ‘bytes’), (‘Date’, ‘Sun, 15 Mar 2020 13:29:01 GMT’), (‘Via’, ‘1.1 varnish’), (‘Age’, ‘708’), (‘Connection’, ‘close’), (‘X-Served-By’, ‘cache-bwi5120-BWI, cache-tyo19943-TYO’), (‘X-Cache’, ‘HIT, HIT’), (‘X-Cache-Hits’, ‘2, 518’), (‘X-Timer’, ‘S1584278942.717942,VS0,VE0’), (‘Vary’, ‘Cookie’), (‘Strict-Transport-Security’, ‘max-age&#x3D;63072000; includeSubDomains’)]  <br>nginx</td></tr></tbody></table><p>可见，前两个输出分别输出了响应的状态码和响应的头信息，最后一个输出通过调用 <code>getheader</code> 方法并传递一个参数 <code>Server</code> 获取了响应头中的 <code>Server</code> 值，结果是 <code>nginx</code>，意思是服务器是用 Nginx 搭建的。</p><p>利用最基本的 <code>urlopen</code> 方法，可以完成最基本的简单网页的 GET 请求抓取。</p><p>如果想给链接传递一些参数，该怎么实现呢？首先看一下 <code>urlopen</code> 方法的 API：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>urllib.request.urlopen(url, data&#x3D;None, [timeout,]*, cafile&#x3D;None, capath&#x3D;None, cadefault&#x3D;False, context&#x3D;None)</td></tr></tbody></table><p>可以发现，除了第一个参数可以传递 URL 之外，我们还可以传递其他内容，比如 <code>data</code>（附加数据）、<code>timeout</code>（超时时间）等。</p><p>下面我们详细说明这几个参数的用法。</p><h4 id="data-参数"><a href="#data-参数" class="headerlink" title="data 参数"></a><a href="https://cuiqingcai.com/202221.html#data-%E5%8F%82%E6%95%B0" title="data 参数"></a><code>data</code> 参数</h4><p><code>data</code> 参数是可选的。如果要添加该参数，需要使用 <code>bytes</code> 方法将参数转化为字节流编码格式的内容，即 <code>bytes</code> 类型。另外，如果传递了这个参数，则它的请求方式就不再是 GET 方式，而是 POST 方式。</p><p>下面用实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.parse  <br>import urllib.request  <br>  <br>data &#x3D; bytes(urllib.parse.urlencode({‘name’: ‘germey’}), encoding&#x3D;’utf-8’)  <br>response &#x3D; urllib.request.urlopen(‘<a href="https://httpbin.org/post">https://httpbin.org/post</a>‘, data&#x3D;data)  <br>print(response.read().decode(‘utf-8’))</td></tr></tbody></table><p>这里我们传递了一个参数 <code>word</code>，值是 <code>hello</code>。它需要被转码成 <code>bytes</code>（字节流）类型。其中转字节流采用了 <code>bytes</code> 方法，该方法的第一个参数需要是 <code>str</code>（字符串）类型，需要用 <code>urllib.parse</code> 模块里的 <code>urlencode</code> 方法来将参数字典转化为字符串；第二个参数指定编码格式，这里指定为 <code>utf-8</code>。</p><p>这里请求的站点是 httpbin.org，它可以提供 HTTP 请求测试。本次我们请求的 URL 为 <a href="https://httpbin.org/post">https://httpbin.org/post</a>，这个链接可以用来测试 POST 请求，它可以输出 Request 的一些信息，其中就包含我们传递的 <code>data</code> 参数。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept-Encoding”: “identity”,  <br>    “Content-Length”: “11”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “Python-urllib&#x2F;3.7”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5ed27e43-9eee361fec88b7d3ce9be9db”  <br>  },  <br>  “json”: null,  <br>  “origin”: “17.220.233.154”,  <br>  “url”: “<a href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td></tr></tbody></table><p>我们传递的参数出现在了 <code>form</code> 字段中，这表明是模拟了表单提交的方式，以 POST 方式传输数据。</p><h4 id="timeout-参数"><a href="#timeout-参数" class="headerlink" title="timeout 参数"></a><a href="https://cuiqingcai.com/202221.html#timeout-%E5%8F%82%E6%95%B0" title="timeout 参数"></a><code>timeout</code> 参数</h4><p><code>timeout</code> 参数用于设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。如果不指定该参数，就会使用全局默认时间。它支持 HTTP、HTTPS、FTP 请求。</p><p>下面用实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;0.1)  <br>print(response.read())</td></tr></tbody></table><p>运行结果可能如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>During handling of the above exception, another exception occurred:  <br>Traceback (most recent call last): File “&#x2F;var&#x2F;py&#x2F;python&#x2F;urllibtest.py”, line 4, in <module> response &#x3D;  <br>urllib.request.urlopen(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;0.1)  <br>…  <br>urllib.error.URLError: <urlopen error _ssl.c:1059: The handshake operation timed out></td></tr></tbody></table><p>这里我们设置的超时时间是 1 秒。程序运行 1 秒过后，服务器依然没有响应，于是抛出了 <code>URLError</code> 异常。该异常属于 <code>urllib.error</code> 模块，错误原因是超时。</p><p>因此，可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。这可以利用 <code>try…except</code> 语句来实现，相关代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import socket  <br>import urllib.request  <br>import urllib.error  <br>  <br>try:  <br>    response &#x3D; urllib.request.urlopen(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;0.1)  <br>except urllib.error.URLError as e:  <br>    if isinstance(e.reason, socket.timeout):  <br>        print(‘TIME OUT’)</td></tr></tbody></table><p>这里我们请求了 <a href="https://httpbin.org/get">https://httpbin.org/get</a> 这个测试链接，设置的超时时间是 0.1 秒，然后捕获了 <code>URLError</code> 这个异常，然后判断异常类型是 <code>socket.timeout</code>，意思就是超时异常。因此，得出它确实是因为超时而报错，打印输出了 <code>TIME OUT</code>。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>TIME OUT</td></tr></tbody></table><p>按照常理来说，0.1 秒内基本不可能得到服务器响应，因此输出了 <code>TIME OUT</code> 的提示。</p><p>通过设置 <code>timeout</code> 这个参数来实现超时处理，有时还是很有用的。</p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a><a href="https://cuiqingcai.com/202221.html#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0" title="其他参数"></a>其他参数</h4><p>除了 <code>data</code> 参数和 <code>timeout</code> 参数外，还有 <code>context</code> 参数，它必须是 <code>ssl.SSLContext</code> 类型，用来指定 SSL 设置。</p><p>此外，<code>cafile</code> 和 <code>capath</code> 这两个参数分别指定 CA 证书和它的路径，这个在请求 HTTPS 链接时会有用。</p><p><code>cadefault</code> 参数现在已经弃用了，其默认值为 <code>False</code>。</p><p>前面讲解了 <code>urlopen</code> 方法的用法，通过这个最基本的方法，我们可以完成简单的请求和网页抓取。若需更加详细的信息，可以参见官方文档：<a href="https://docs.python.org/3/library/urllib.request.html">https://docs.python.org/3/library/urllib.request.html</a>。</p><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a><a href="https://cuiqingcai.com/202221.html#Request" title="Request"></a><code>Request</code></h3><p>我们知道利用 <code>urlopen</code> 方法可以实现最基本请求的发起，但这几个简单的参数并不足以构建一个完整的请求。如果请求中需要加入 <code>Headers</code> 等信息，就可以利用更强大的 <code>Request</code> 类来构建。</p><p>首先，我们用实例来感受一下 <code>Request</code> 类的用法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request  <br>  <br>request &#x3D; urllib.request.Request(‘<a href="https://python.org/">https://python.org</a>‘)  <br>response &#x3D; urllib.request.urlopen(request)  <br>print(response.read().decode(‘utf-8’))</td></tr></tbody></table><p>可以发现，我们依然用 <code>urlopen</code> 方法来发送这个请求，只不过这次该方法的参数不再是 URL，而是一个 <code>Request</code> 类型的对象。通过构造这个数据结构，一方面我们可以将请求独立成一个对象，另一方面可更加丰富和灵活地配置参数。</p><p>下面我们看一下 <code>Request</code> 可以通过怎样的参数来构造，它的构造方法如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>class urllib.request.Request(url, data&#x3D;None, headers&#x3D;{}, origin_req_host&#x3D;None, unverifiable&#x3D;False, method&#x3D;None)</td></tr></tbody></table><p>其中，第一个参数 <code>url</code> 用于请求 URL，这是必传参数，其他都是可选参数。</p><p>第二个参数 <code>data</code> 如果要传，必须传 <code>bytes</code>（字节流）类型的。如果它是字典，可以先用 <code>urllib.parse</code> 模块里的 <code>urlencode()</code> 编码。</p><p>第三个参数 <code>headers</code> 是一个字典，它就是请求头。我们在构造请求时，既可以通过 <code>headers</code> 参数直接构造，也可以通过调用请求实例的 <code>add_header()</code> 方法添加。</p><p>添加请求头最常用的方法就是通过修改 <code>User-Agent</code> 来伪装浏览器。默认的 <code>User-Agent</code> 是 <code>Python-urllib</code>，我们可以通过修改它来伪装浏览器。比如要伪装火狐浏览器，你可以把它设置为：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Mozilla&#x2F;5.0 (X11; U; Linux i686) Gecko&#x2F;20071127 Firefox&#x2F;2.0.0.11</td></tr></tbody></table><p>第四个参数 <code>origin_req_host</code> 指的是请求方的 host 名称或者 IP 地址。</p><p>第五个参数 <code>unverifiable</code> 表示这个请求是否是无法验证的，默认是 <code>False</code>，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 <code>unverifiable</code> 的值就是 <code>True</code>。</p><p>第六个参数 <code>method</code> 是一个字符串，用来指示请求使用的方法，比如 GET、POST 和 PUT 等。</p><p>下面我们传入多个参数来构建请求：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib import request, parse  <br>  <br>url &#x3D; ‘<a href="https://httpbin.org/post">https://httpbin.org/post</a>‘  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)’,  <br>    ‘Host’: ‘httpbin.org’  <br>}  <br>dict &#x3D; {‘name’: ‘germey’}  <br>data &#x3D; bytes(parse.urlencode(dict), encoding&#x3D;’utf-8’)  <br>req &#x3D; request.Request(url&#x3D;url, data&#x3D;data, headers&#x3D;headers, method&#x3D;’POST’)  <br>response &#x3D; request.urlopen(req)  <br>print(response.read().decode(‘utf-8’))</td></tr></tbody></table><p>这里我们通过 4 个参数构造了一个请求，其中 <code>url</code> 即请求 URL，<code>headers</code> 中指定了 <code>User-Agent</code> 和 <code>Host</code>，参数 <code>data</code> 用 <code>urlencode</code> 和 <code>bytes</code> 方法转成字节流。另外，指定了请求方式为 POST。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept-Encoding”: “identity”,  <br>    “Content-Length”: “11”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5ed27f77-884f503a2aa6760df7679f05”  <br>  },  <br>  “json”: null,  <br>  “origin”: “17.220.233.154”,  <br>  “url”: “<a href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td></tr></tbody></table><p>观察结果可以发现，我们成功设置了 <code>data</code>、<code>headers</code> 和 <code>method</code>。</p><p>另外，<code>headers</code> 也可以用 <code>add_header</code> 方法来添加：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>req &#x3D; request.Request(url&#x3D;url, data&#x3D;data, method&#x3D;’POST’)  <br>req.add_header(‘User-Agent’, ‘Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)’)</td></tr></tbody></table><p>如此一来，我们就可以更加方便地构造请求，实现请求的发送啦。</p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a><a href="https://cuiqingcai.com/202221.html#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" title="高级用法"></a>高级用法</h3><p>在上面的过程中，我们虽然可以构造请求，但是对于一些更高级的操作（比如 Cookies 处理、代理设置等），该怎么办呢？</p><p>接下来，就需要更强大的工具 Handler 登场了。简而言之，我们可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookie 的，有处理代理设置的。利用它们，我们几乎可以做到 HTTP 请求中所有的事情。</p><p>首先，介绍一下 <code>urllib.request</code> 模块里的 <code>BaseHandler</code> 类，它是所有其他 Handler 的父类，它提供了最基本的方法，例如 <code>default_open</code>、<code>protocol_request</code> 等。</p><p>接下来，就有各种 Handler 子类继承这个 <code>BaseHandler</code> 类，举例如下。</p><ul><li><code>HTTPDefaultErrorHandler</code> 用于处理 HTTP 响应错误，错误都会抛出 <code>HTTPError</code> 类型的异常。</li><li><code>HTTPRedirectHandler</code> 用于处理重定向。</li><li><code>HTTPCookieProcessor</code> 用于处理 Cookies。</li><li><code>ProxyHandler</code> 用于设置代理，默认代理为空。</li><li><code>HTTPPasswordMgr</code> 用于管理密码，它维护了用户名和密码的表。</li><li><code>HTTPBasicAuthHandler</code> 用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。</li></ul><p>另外，还有其他的 Handler 类，这里就不一一列举了，详情可以参考官方文档： <a href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a>。</p><p>关于怎么使用它们，现在先不用着急，后面会有实例演示。</p><p>另一个比较重要的类就是 <code>OpenerDirector</code>，我们可以称为 Opener。我们之前用过 <code>urlopen</code> 这个方法，实际上它就是 urllib 为我们提供的一个 Opener。</p><p>那么，为什么要引入 Opener 呢？因为需要实现更高级的功能。之前使用的 <code>Request</code> 和 <code>urlopen</code> 相当于类库为你封装好了极其常用的请求方法，利用它们可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以需要深入一层进行配置，使用更底层的实例来完成操作，所以这里就用到了 Opener。</p><p>Opener 可以使用 <code>open</code> 方法，返回的类型和 <code>urlopen</code> 如出一辙。那么，它和 Handler 有什么关系呢？简而言之，就是利用 Handler 来构建 Opener。</p><p>下面用几个实例来看看它们的用法。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><a href="https://cuiqingcai.com/202221.html#%E9%AA%8C%E8%AF%81" title="验证"></a>验证</h4><p>在访问某些设置了身份认证的网站时，例如 <a href="https://ssr3.scrape.center/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AE%A4%E8%AF%81%E7%AA%97%E5%8F%A3%EF%BC%8C%E5%A6%82%E5%9B%BE">https://ssr3.scrape.center/，我们可能会遇到这样的认证窗口，如图</a> 2- 所示：</p><p><img src="https://cdn.cuiqingcai.com/fries.png" alt="image-20210704202140395"></p><p>图 2- 认证窗口</p><p>如果遇到了这种情况，那么这个网站就是启用了基本身份认证，英文叫作 HTTP Basic Access Authentication，它是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。</p><p>那么，如果要请求这样的页面，该怎么办呢？借助 <code>HTTPBasicAuthHandler</code> 就可以完成，相关代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.request import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener  <br>from urllib.error import URLError  <br>  <br>username &#x3D; ‘admin’  <br>password &#x3D; ‘admin’  <br>url &#x3D; ‘<a href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>‘  <br>  <br>p &#x3D; HTTPPasswordMgrWithDefaultRealm()  <br>p.add_password(None, url, username, password)  <br>auth_handler &#x3D; HTTPBasicAuthHandler(p)  <br>opener &#x3D; build_opener(auth_handler)  <br>  <br>try:  <br>    result &#x3D; opener.open(url)  <br>    html &#x3D; result.read().decode(‘utf-8’)  <br>    print(html)  <br>except URLError as e:  <br>    print(e.reason)</td></tr></tbody></table><p>这里首先实例化 <code>HTTPBasicAuthHandler</code> 对象，其参数是 <code>HTTPPasswordMgrWithDefaultRealm</code> 对象，它利用 <code>add_password</code> 方法添加进去用户名和密码，这样就建立了一个处理验证的 Handler。</p><p>接下来，利用这个 Handler 并使用 <code>build_opener</code> 方法构建一个 Opener，这个 Opener 在发送请求时就相当于已经验证成功了。</p><p>接下来，利用 Opener 的 <code>open</code> 方法打开链接，就可以完成验证了。这里获取到的结果就是验证后的页面源码内容。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a><a href="https://cuiqingcai.com/202221.html#%E4%BB%A3%E7%90%86" title="代理"></a>代理</h4><p>在做爬虫的时候，免不了要使用代理，如果要添加代理，可以这样做：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.error import URLError  <br>from urllib.request import ProxyHandler, build_opener  <br>  <br>proxy_handler &#x3D; ProxyHandler({  <br>    ‘http’: ‘<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>‘,  <br>    ‘https’: ‘<a href="https://127.0.0.1:8080/">https://127.0.0.1:8080</a>‘  <br>})  <br>opener &#x3D; build_opener(proxy_handler)  <br>try:  <br>    response &#x3D; opener.open(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>    print(response.read().decode(‘utf-8’))  <br>except URLError as e:  <br>    print(e.reason)</td></tr></tbody></table><p>这里我们在本地需要先事先搭建一个 HTTP 代理，运行在 8080 端口上。</p><p>这里使用了 <code>ProxyHandler</code>，其参数是一个字典，键名是协议类型（比如 HTTP 或者 HTTPS 等），键值是代理链接，可以添加多个代理。</p><p>然后，利用这个 Handler 及 <code>build_opener</code> 方法构造一个 Opener，之后发送请求即可。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><a href="https://cuiqingcai.com/202221.html#Cookie" title="Cookie"></a>Cookie</h4><p>Cookie 的处理就需要相关的 Handler 了。</p><p>我们先用实例来看看怎样将网站的 Cookie 获取下来，相关代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import http.cookiejar, urllib.request  <br>  <br>cookie &#x3D; http.cookiejar.CookieJar()  <br>handler &#x3D; urllib.request.HTTPCookieProcessor(cookie)  <br>opener &#x3D; urllib.request.build_opener(handler)  <br>response &#x3D; opener.open(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>for item in cookie:  <br>    print(item.name + “&#x3D;” + item.value)</td></tr></tbody></table><p>首先，我们必须声明一个 <code>CookieJar</code> 对象。接下来，就需要利用 <code>HTTPCookieProcessor</code> 来构建一个 Handler，最后利用 <code>build_opener</code> 方法构建出 Opener，执行 <code>open</code> 函数即可。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>BAIDUID&#x3D;A09E6C4E38753531B9FB4C60CE9FDFCB:FG&#x3D;1  <br>BIDUPSID&#x3D;A09E6C4E387535312F8AA46280C6C502  <br>H_PS_PSSID&#x3D;31358_1452_31325_21088_31110_31253_31605_31271_31463_30823  <br>PSTM&#x3D;1590854698  <br>BDSVRTM&#x3D;10  <br>BD_HOME&#x3D;1</td></tr></tbody></table><p>可以看到，这里输出了每个 Cookie 条目的名称和值。</p><p>不过既然能输出，那可不可以输出成文件格式呢？我们知道 Cookie 实际上也是以文本形式保存的。</p><p>答案当然是肯定的，这里通过下面的实例来看看：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request, http.cookiejar  <br>  <br>filename &#x3D; ‘cookie.txt’  <br>cookie &#x3D; http.cookiejar.MozillaCookieJar(filename)  <br>handler &#x3D; urllib.request.HTTPCookieProcessor(cookie)  <br>opener &#x3D; urllib.request.build_opener(handler)  <br>response &#x3D; opener.open(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>cookie.save(ignore_discard&#x3D;True, ignore_expires&#x3D;True)</td></tr></tbody></table><p>这时 <code>CookieJar</code> 就需要换成 <code>MozillaCookieJar</code>，它在生成文件时会用到，是 <code>CookieJar</code> 的子类，可以用来处理 Cookie 和文件相关的事件，比如读取和保存 Cookie，可以将 Cookie 保存成 Mozilla 型浏览器的 Cookie 格式。</p><p>运行之后，可以发现生成了一个 cookie.txt 文件，其内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td># Netscape HTTP Cookie File  <br># <a href="http://curl.haxx.se/rfc/cookie_spec.html">http://curl.haxx.se/rfc/cookie_spec.html</a>  <br># This is a generated file!  Do not edit.  <br>  <br>.baidu.comTRUE&#x2F;FALSE1622390755BAIDUID0B4A68D74B0C0E53E5B82AFD9BF9178F:FG&#x3D;1  <br>.baidu.comTRUE&#x2F;FALSE3738338402BIDUPSID0B4A68D74B0C0E53471FA6329280FA58  <br>.baidu.comTRUE&#x2F;FALSEH_PS_PSSID31262_1438_31325_21127_31110_31596_31673_31464_30823_26350  <br>.baidu.comTRUE&#x2F;FALSE3738338402PSTM1590854754  <br><a href="http://www.baidu.com/">www.baidu.com</a>FALSE&#x2F;FALSEBDSVRTM0  <br><a href="http://www.baidu.com/">www.baidu.com</a>FALSE&#x2F;FALSEBD_HOME1</td></tr></tbody></table><p>另外，<code>LWPCookieJar</code> 同样可以读取和保存 Cookie，但是保存的格式和 <code>MozillaCookieJar</code> 不一样，它会保存成 libwww-perl（LWP）格式的 Cookie 文件。</p><p>要保存成 LWP 格式的 Cookie 文件，可以在声明时就改为：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>cookie &#x3D; http.cookiejar.LWPCookieJar(filename)</td></tr></tbody></table><p>此时生成的内容如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>#LWP-Cookies-2.0  <br>Set-Cookie3: BAIDUID&#x3D;”1F30EEDA35C7A94320275F991CA5B3A5:FG&#x3D;1”; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; expires&#x3D;”2021-05-30 16:06:39Z”; comment&#x3D;bd; version&#x3D;0  <br>Set-Cookie3: BIDUPSID&#x3D;1F30EEDA35C7A9433C97CF6245CBC383; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; expires&#x3D;”2088-06-17 19:20:46Z”; version&#x3D;0  <br>Set-Cookie3: H_PS_PSSID&#x3D;31626_1440_21124_31069_31254_31594_30841_31673_31464_31715_30823; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; discard; version&#x3D;0  <br>Set-Cookie3: PSTM&#x3D;1590854799; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; expires&#x3D;”2088-06-17 19:20:46Z”; version&#x3D;0  <br>Set-Cookie3: BDSVRTM&#x3D;11; path&#x3D;”&#x2F;“; domain&#x3D;”<a href="http://www.baidu.com/">www.baidu.com</a>“; path_spec; discard; version&#x3D;0  <br>Set-Cookie3: BD_HOME&#x3D;1; path&#x3D;”&#x2F;“; domain&#x3D;”<a href="http://www.baidu.com/">www.baidu.com</a>“; path_spec; discard; version&#x3D;0</td></tr></tbody></table><p>由此看来，生成的格式还是有比较大差异的。</p><p>那么，生成了 Cookie 文件后，怎样从文件中读取并利用呢？</p><p>下面我们以 <code>LWPCookieJar</code> 格式为例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import urllib.request, http.cookiejar  <br>  <br>cookie &#x3D; http.cookiejar.LWPCookieJar()  <br>cookie.load(‘cookie.txt’, ignore_discard&#x3D;True, ignore_expires&#x3D;True)  <br>handler &#x3D; urllib.request.HTTPCookieProcessor(cookie)  <br>opener &#x3D; urllib.request.build_opener(handler)  <br>response &#x3D; opener.open(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>print(response.read().decode(‘utf-8’))</td></tr></tbody></table><p>可以看到，这里调用 <code>load</code> 方法来读取本地的 Cookie 文件，获取到了 Cookie 的内容。不过前提是我们首先生成了 <code>LWPCookieJar</code> 格式的 Cookie，并保存成文件，然后读取 Cookie 之后使用同样的方法构建 Handler 和 Opener 即可完成操作。</p><p>运行结果正常的话，会输出百度网页的源代码。</p><p>通过上面的方法，我们可以实现绝大多数请求功能的设置了。</p><p>这便是 urllib 库中 request 模块的基本用法，如果想实现更多的功能，可以参考官方文档的说明：<a href="https://docs.python.org/3/library/urllib.request.html#basehandler-objects">https://docs.python.org/3/library/urllib.request.html#basehandler-objects</a>。</p><h2 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2. 处理异常"></a><a href="https://cuiqingcai.com/202221.html#2-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8" title="2. 处理异常"></a>2. 处理异常</h2><p>在前一节中，我们了解了请求的发送过程，但是在网络不好的情况下，如果出现了异常，该怎么办呢？这时如果不处理这些异常，程序很可能因报错而终止运行，所以异常处理还是十分有必要的。</p><p>urllib 的 error 模块定义了由 request 模块产生的异常。如果出现了问题，request 模块便会抛出 error 模块中定义的异常。</p><h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a><a href="https://cuiqingcai.com/202221.html#URLError" title="URLError"></a><code>URLError</code></h3><p><code>URLError</code> 类来自 urllib 库的 error 模块，它继承自 <code>OSError</code> 类，是 error 异常模块的基类，由 request 模块产生的异常都可以通过捕获这个类来处理。</p><p>它具有一个属性 <code>reason</code>，即返回错误的原因。</p><p>下面用一个实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib import request, error  <br>  <br>try:  <br>    response &#x3D; request.urlopen(‘<a href="https://cuiqingcai.com/404">https://cuiqingcai.com/404</a>‘)  <br>except error.URLError as e:  <br>    print(e.reason)</td></tr></tbody></table><p>我们打开一个不存在的页面，照理来说应该会报错，但是这时我们捕获了 <code>URLError</code> 这个异常，运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Not Found</td></tr></tbody></table><p>程序没有直接报错，而是输出了如上内容，这样就可以避免程序异常终止，同时异常得到了有效处理。</p><h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a><a href="https://cuiqingcai.com/202221.html#HTTPError" title="HTTPError"></a><code>HTTPError</code></h3><p>它是 <code>URLError</code> 的子类，专门用来处理 HTTP 请求错误，比如认证请求失败等。它有如下 3 个属性。</p><ul><li><code>code</code>：返回 HTTP 状态码，比如 404 表示网页不存在，500 表示服务器内部错误等。</li><li><code>reason</code>：同父类一样，用于返回错误的原因。</li><li><code>headers</code>：返回请求头。</li></ul><p>下面我们用几个实例来看看：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib import request, error  <br>  <br>try:  <br>    response &#x3D; request.urlopen(‘<a href="https://cuiqingcai.com/404">https://cuiqingcai.com/404</a>‘)  <br>except error.HTTPError as e:  <br>    print(e.reason, e.code, e.headers, sep&#x3D;’\n’)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Not Found  <br>404  <br>Server: nginx&#x2F;1.10.3 (Ubuntu)  <br>Date: Sat, 30 May 2020 16:08:42 GMT  <br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8  <br>Transfer-Encoding: chunked  <br>Connection: close  <br>Set-Cookie: PHPSESSID&#x3D;kp1a1b0o3a0pcf688kt73gc780; path&#x3D;&#x2F;  <br>Pragma: no-cache  <br>Vary: Cookie  <br>Expires: Wed, 11 Jan 1984 05:00:00 GMT  <br>Cache-Control: no-cache, must-revalidate, max-age&#x3D;0  <br>Link: <a href="https://cuiqingcai.com/wp-json/">https://cuiqingcai.com/wp-json/</a>; rel&#x3D;”<a href="https://api.w.org/">https://api.w.org/</a>“</td></tr></tbody></table><p>依然是同样的网址，这里捕获了 <code>HTTPError</code> 异常，输出了 <code>reason</code>、<code>code</code> 和 <code>headers</code> 属性。</p><p>因为 <code>URLError</code> 是 <code>HTTPError</code> 的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误，所以上述代码的更好写法如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib import request, error  <br>  <br>try:  <br>    response &#x3D; request.urlopen(‘<a href="https://cuiqingcai.com/404">https://cuiqingcai.com/404</a>‘)  <br>except error.HTTPError as e:  <br>    print(e.reason, e.code, e.headers, sep&#x3D;’\n’)  <br>except error.URLError as e:  <br>    print(e.reason)  <br>else:  <br>    print(‘Request Successfully’)</td></tr></tbody></table><p>这样就可以做到先捕获 <code>HTTPError</code>，获取它的错误原因、状态码、<code>headers</code> 等信息。如果不是 <code>HTTPError</code> 异常，就会捕获 <code>URLError</code> 异常，输出错误原因。最后，用 <code>else</code> 来处理正常的逻辑。这是一个较好的异常处理写法。</p><p>有时候，<code>reason</code> 属性返回的不一定是字符串，也可能是一个对象。再看下面的实例：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import socket  <br>import urllib.request  <br>import urllib.error  <br>  <br>try:  <br>    response &#x3D; urllib.request.urlopen(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘, timeout&#x3D;0.01)  <br>except urllib.error.URLError as e:  <br>    print(type(e.reason))  <br>    if isinstance(e.reason, socket.timeout):  <br>        print(‘TIME OUT’)</td></tr></tbody></table><p>这里我们直接设置超时时间来强制抛出 <code>timeout</code> 异常。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;class’socket.timeout’&gt;  <br>TIME OUT</td></tr></tbody></table><p>可以发现，<code>reason</code> 属性的结果是 <code>socket.timeout</code> 类。所以，这里我们可以用 <code>isinstance</code> 方法来判断它的类型，作出更详细的异常判断。</p><p>本节中，我们讲述了 error 模块的相关用法，通过合理地捕获异常可以做出更准确的异常判断，使程序更加稳健。</p><h2 id="3-解析链接"><a href="#3-解析链接" class="headerlink" title="3. 解析链接"></a><a href="https://cuiqingcai.com/202221.html#3-%E8%A7%A3%E6%9E%90%E9%93%BE%E6%8E%A5" title="3. 解析链接"></a>3. 解析链接</h2><p>前面说过，urllib 库里还提供了 parse 模块，它定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取、合并以及链接转换。它支持如下协议的 URL 处理：<code>file</code>、<code>ftp</code>、<code>gopher</code>、<code>hdl</code>、<code>http</code>、<code>https</code>、<code>imap</code>、<code>mailto</code>、<code>mms</code>、<code>news</code>、<code>nntp</code>、<code>prospero</code>、<code>rsync</code>、<code>rtsp</code>、<code>rtspu</code>、<code>sftp</code>、<code>sip</code>、<code>sips</code>、<code>snews</code>、<code>svn</code>、<code>svn+ssh</code>、<code>telnet</code> 和 <code>wais</code>。本节中，我们介绍一下该模块中常用的方法来看一下它的便捷之处。</p><h3 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a><a href="https://cuiqingcai.com/202221.html#urlparse" title="urlparse"></a><code>urlparse</code></h3><p>该方法可以实现 URL 的识别和分段，这里先用一个实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘)  <br>print(type(result))  <br>print(result)</td></tr></tbody></table><p>这里我们利用 <code>urlparse</code> 方法进行了一个 URL 的解析。首先，输出了解析结果的类型，然后将结果也输出出来。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;class ‘urllib.parse.ParseResult’&gt;  <br>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’<a href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html’, params&#x3D;’user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td></tr></tbody></table><p>可以看到，返回结果是一个 <code>ParseResult</code> 类型的对象，它包含 6 个部分，分别是 <code>scheme</code>、<code>netloc</code>、<code>path</code>、<code>params</code>、<code>query</code> 和 <code>fragment</code>。</p><p>观察一下该实例的 URL：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a></td></tr></tbody></table><p>可以发现，<code>urlparse</code> 方法将其拆分成了 6 个部分。大体观察可以发现，解析时有特定的分隔符。比如，<code>://</code> 前面的就是 <code>scheme</code>，代表协议；第一个 <code>/</code> 符号前面便是 <code>netloc</code>，即域名，后面是 <code>path</code>，即访问路径；分号 <code>;</code> 后面是 <code>params</code>，代表参数；问号 <code>?</code> 后面是查询条件 <code>query</code>，一般用作 GET 类型的 URL；井号 <code>#</code> 后面是锚点，用于直接定位页面内部的下拉位置。</p><p>所以，可以得出一个标准的链接格式，具体如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>scheme:&#x2F;&#x2F;netloc&#x2F;path;params?query#fragment</td></tr></tbody></table><p>一个标准的 URL 都会符合这个规则，利用 <code>urlparse</code> 方法可以将它拆分开来。</p><p>除了这种最基本的解析方式外，<code>urlparse</code> 方法还有其他配置吗？接下来，看一下它的 API 用法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>urllib.parse.urlparse(urlstring, scheme&#x3D;’’, allow_fragments&#x3D;True)</td></tr></tbody></table><p>可以看到，它有 3 个参数。</p><ul><li><code>urlstring</code>：这是必填项，即待解析的 URL。</li><li><code>scheme</code>：它是默认的协议（比如 <code>http</code> 或 <code>https</code> 等）。假如这个链接没有带协议信息，会将这个作为默认的协议。我们用实例来看一下：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a href="http://www.baidu.com/index.html;user?id=5#comment">www.baidu.com/index.html;user?id=5#comment</a>‘, scheme&#x3D;’https’)  <br>print(result)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’’, path&#x3D;’<a href="http://www.baidu.com/index.html">www.baidu.com/index.html</a>‘, params&#x3D;’user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td></tr></tbody></table><p>可以发现，我们提供的 URL 没有包含最前面的 <code>scheme</code> 信息，但是通过默认的 <code>scheme</code> 参数，返回的结果是 <code>https</code>。</p><p>假设我们带上了 <code>scheme</code>：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result &#x3D; urlparse(‘<a href="http://www.baidu.com/index.html;user?id=5#comment">http://www.baidu.com/index.html;user?id=5#comment</a>‘, scheme&#x3D;’https’)</td></tr></tbody></table><p>则结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>ParseResult(scheme&#x3D;’http’, netloc&#x3D;’<a href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html’, params&#x3D;’user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td></tr></tbody></table><p>可见，<code>scheme</code> 参数只有在 URL 中不包含 <code>scheme</code> 信息时才生效。如果 URL 中有 <code>scheme</code> 信息，就会返回解析出的 <code>scheme</code>。</p><ul><li><code>allow_fragments</code>：即是否忽略 <code>fragment</code>。如果它被设置为 <code>False</code>，<code>fragment</code> 部分就会被忽略，它会被解析为 <code>path</code>、<code>parameters</code> 或者 <code>query</code> 的一部分，而 <code>fragment</code> 部分为空。</li></ul><p>下面我们用实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘, allow_fragments&#x3D;False)  <br>print(result)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’<a href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html’, params&#x3D;’user’, query&#x3D;’id&#x3D;5#comment’, fragment&#x3D;’’)</td></tr></tbody></table><p>假设 URL 中不包含 <code>params</code> 和 <code>query</code>，我们再通过实例看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a href="https://www.baidu.com/index.html#comment">https://www.baidu.com/index.html#comment</a>‘, allow_fragments&#x3D;False)  <br>print(result)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’<a href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html#comment’, params&#x3D;’’, query&#x3D;’’, fragment&#x3D;’’)</td></tr></tbody></table><p>可以发现，当 URL 中不包含 <code>params</code> 和 <code>query</code> 时，<code>fragment</code> 便会被解析为 <code>path</code> 的一部分。</p><p>返回结果 <code>ParseResult</code> 实际上是一个元组，我们既可以用索引顺序来获取，也可以用属性名获取。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a href="https://www.baidu.com/index.html#comment">https://www.baidu.com/index.html#comment</a>‘, allow_fragments&#x3D;False)  <br>print(result.scheme, result[0], result.netloc, result[1], sep&#x3D;’\n’)</td></tr></tbody></table><p>这里我们分别用索引和属性名获取了 <code>scheme</code> 和 <code>netloc</code>，其运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>https  <br>https  <br><a href="http://www.baidu.com/">www.baidu.com</a>  <br><a href="http://www.baidu.com/">www.baidu.com</a></td></tr></tbody></table><p>可以发现，二者的结果是一致的，两种方法都可以成功获取。</p><h3 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a><a href="https://cuiqingcai.com/202221.html#urlunparse" title="urlunparse"></a><code>urlunparse</code></h3><p>有了 <code>urlparse</code> 方法，相应地就有了它的对立方法 <code>urlunparse</code>。它接收的参数是一个可迭代对象，但是它的长度必须是 6，否则会抛出参数数量不足或者过多的问题。先用一个实例看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlunparse  <br>  <br>data &#x3D; [‘https’, ‘<a href="http://www.baidu.com/">www.baidu.com</a>‘, ‘index.html’, ‘user’, ‘a&#x3D;6’, ‘comment’]  <br>print(urlunparse(data))</td></tr></tbody></table><p>这里参数 <code>data</code> 用了列表类型。当然，你也可以用其他类型，比如元组或者特定的数据结构。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/index.html;user?a=6#comment">https://www.baidu.com/index.html;user?a=6#comment</a></td></tr></tbody></table><p>这样我们就成功实现了 URL 的构造。</p><h3 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a><a href="https://cuiqingcai.com/202221.html#urlsplit" title="urlsplit"></a><code>urlsplit</code></h3><p>这个方法和 <code>urlparse</code> 方法非常相似，只不过它不再单独解析 <code>params</code> 这一部分，只返回 5 个结果。上面例子中的 <code>params</code> 会合并到 <code>path</code> 中。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlsplit  <br>  <br>result &#x3D; urlsplit(‘<a href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘)  <br>print(result)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>SplitResult(scheme&#x3D;’https’, netloc&#x3D;’<a href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html;user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td></tr></tbody></table><p>可以发现，返回结果是 <code>SplitResult</code>，它其实也是一个元组类型，既可以用属性获取值，也可以用索引来获取。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlsplit  <br>  <br>result &#x3D; urlsplit(‘<a href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘)  <br>print(result.scheme, result[0])</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>https https</td></tr></tbody></table><h3 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a><a href="https://cuiqingcai.com/202221.html#urlunsplit" title="urlunsplit"></a><code>urlunsplit</code></h3><p>与 <code>urlunparse</code> 方法类似，它也是将链接各个部分组合成完整链接的方法，传入的参数也是一个可迭代对象，例如列表、元组等，唯一的区别是长度必须为 5。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlunsplit  <br>  <br>data &#x3D; [‘https’, ‘<a href="http://www.baidu.com/">www.baidu.com</a>‘, ‘index.html’, ‘a&#x3D;6’, ‘comment’]  <br>print(urlunsplit(data))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/index.html?a=6#comment">https://www.baidu.com/index.html?a=6#comment</a></td></tr></tbody></table><h3 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a><a href="https://cuiqingcai.com/202221.html#urljoin" title="urljoin"></a><code>urljoin</code></h3><p>有了 <code>urlunparse</code> 和 <code>urlunsplit</code> 方法，我们可以完成链接的合并，不过前提是必须要有特定长度的对象，链接的每一部分都要清晰分开。</p><p>此外，生成链接还有另一个方法，那就是 <code>urljoin</code> 方法。我们可以提供一个 <code>base_url</code>（基础链接）作为第一个参数，将新的链接作为第二个参数，该方法会分析 <code>base_url</code>的 <code>scheme</code>、<code>netloc</code> 和 <code>path</code> 这 3 个内容并对新链接缺失的部分进行补充，最后返回结果。</p><p>下面通过几个实例看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urljoin  <br>  <br>print(urljoin(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘, ‘FAQ.html’))  <br>print(urljoin(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘, ‘<a href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>‘))  <br>print(urljoin(‘<a href="https://www.baidu.com/about.html">https://www.baidu.com/about.html</a>‘, ‘<a href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>‘))  <br>print(urljoin(‘<a href="https://www.baidu.com/about.html">https://www.baidu.com/about.html</a>‘, ‘<a href="https://cuiqingcai.com/FAQ.html?question=2">https://cuiqingcai.com/FAQ.html?question=2</a>‘))  <br>print(urljoin(‘<a href="https://www.baidu.com/?wd=abc">https://www.baidu.com?wd=abc</a>‘, ‘<a href="https://cuiqingcai.com/index.php">https://cuiqingcai.com/index.php</a>‘))  <br>print(urljoin(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘, ‘?category&#x3D;2#comment’))  <br>print(urljoin(‘<a href="http://www.baidu.com/">www.baidu.com</a>‘, ‘?category&#x3D;2#comment’))  <br>print(urljoin(‘<a href="http://www.baidu.com/#comment">www.baidu.com#comment</a>‘, ‘?category&#x3D;2’))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/FAQ.html">https://www.baidu.com/FAQ.html</a>  <br><a href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>  <br><a href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>  <br><a href="https://cuiqingcai.com/FAQ.html?question=2">https://cuiqingcai.com/FAQ.html?question=2</a>  <br><a href="https://cuiqingcai.com/index.php">https://cuiqingcai.com/index.php</a>  <br><a href="https://www.baidu.com/?category=2#comment">https://www.baidu.com?category=2#comment</a>  <br><a href="http://www.baidu.com/?category=2#comment">www.baidu.com?category=2#comment</a>  <br><a href="http://www.baidu.com/?category=2">www.baidu.com?category=2</a></td></tr></tbody></table><p>可以发现，<code>base_url</code> 提供了三项内容 <code>scheme</code>、<code>netloc</code> 和 <code>path</code>。如果这 3 项在新的链接里不存在，就予以补充；如果新的链接存在，就使用新的链接的部分。而 <code>base_url</code> 中的 <code>params</code>、<code>query</code> 和 <code>fragment</code> 是不起作用的。</p><p>通过 <code>urljoin</code> 方法，我们可以轻松实现链接的解析、拼合与生成。</p><h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a><a href="https://cuiqingcai.com/202221.html#urlencode" title="urlencode"></a><code>urlencode</code></h3><p>这里我们再介绍一个常用的方法 —— <code>urlencode</code>，它在构造 GET 请求参数的时候非常有用，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import urlencode  <br>  <br>params &#x3D; {  <br>    ‘name’: ‘germey’,  <br>    ‘age’: 25  <br>}  <br>base_url &#x3D; ‘<a href="https://www.baidu.com/">https://www.baidu.com</a>?’  <br>url &#x3D; base_url + urlencode(params)  <br>print(url)</td></tr></tbody></table><p>这里首先声明一个字典来将参数表示出来，然后调用 <code>urlencode</code> 方法将其序列化为 GET 请求参数。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/?name=germey&age=25">https://www.baidu.com?name=germey&amp;age=25</a></td></tr></tbody></table><p>可以看到，参数成功地由字典类型转化为 GET 请求参数了。</p><p>这个方法非常常用。有时为了更加方便地构造参数，我们会事先用字典来表示。要转化为 URL 的参数时，只需要调用该方法即可。</p><h3 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs"></a><a href="https://cuiqingcai.com/202221.html#parse-qs" title="parse_qs"></a><code>parse_qs</code></h3><p>有了序列化，必然就有反序列化。如果我们有一串 GET 请求参数，利用 <code>parse_qs</code> 方法，就可以将它转回字典，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import parse_qs  <br>  <br>query &#x3D; ‘name&#x3D;germey&amp;age&#x3D;25’  <br>print(parse_qs(query))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{‘name’: [‘germey’], ‘age’: [‘25’]}</td></tr></tbody></table><p>可以看到，这样就成功转回为字典类型了。</p><h3 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a><a href="https://cuiqingcai.com/202221.html#parse-qsl" title="parse_qsl"></a><code>parse_qsl</code></h3><p>另外，还有一个 <code>parse_qsl</code> 方法，它用于将参数转化为元组组成的列表，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import parse_qsl  <br>  <br>query &#x3D; ‘name&#x3D;germey&amp;age&#x3D;25’  <br>print(parse_qsl(query))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[(‘name’, ‘germey’), (‘age’, ‘25’)]</td></tr></tbody></table><p>可以看到，运行结果是一个列表，而列表中的每一个元素都是一个元组，元组的第一个内容是参数名，第二个内容是参数值。</p><h3 id="quote"><a href="#quote" class="headerlink" title="quote"></a><a href="https://cuiqingcai.com/202221.html#quote" title="quote"></a><code>quote</code></h3><p>该方法可以将内容转化为 URL 编码的格式。URL 中带有中文参数时，有时可能会导致乱码的问题，此时可以用这个方法可以将中文字符转化为 URL 编码，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import quote  <br>  <br>keyword &#x3D; ‘壁纸’  <br>url &#x3D; ‘<a href="https://www.baidu.com/s?wd=">https://www.baidu.com/s?wd=</a>‘ + quote(keyword)  <br>print(url)</td></tr></tbody></table><p>这里我们声明了一个中文的搜索文字，然后用 <code>quote</code> 方法对其进行 URL 编码，最后得到的结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</a></td></tr></tbody></table><h3 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a><a href="https://cuiqingcai.com/202221.html#unquote" title="unquote"></a><code>unquote</code></h3><p>有了 <code>quote</code> 方法，当然还有 <code>unquote</code> 方法，它可以进行 URL 解码，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.parse import unquote  <br>  <br>url &#x3D; ‘<a href="https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</a>‘  <br>print(unquote(url))</td></tr></tbody></table><p>这是上面得到的 URL 编码后的结果，这里利用 <code>unquote</code> 方法还原，结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8">https://www.baidu.com/s?wd=壁纸</a></td></tr></tbody></table><p>可以看到，利用 <code>unquote</code> 方法可以方便地实现解码。</p><p>本节中，我们介绍了 parse 模块的一些常用 URL 处理方法。有了这些方法，我们可以方便地实现 URL 的解析和构造，建议熟练掌握。</p><h2 id="4-分析-Robots-协议"><a href="#4-分析-Robots-协议" class="headerlink" title="4. 分析 Robots 协议"></a><a href="https://cuiqingcai.com/202221.html#4-%E5%88%86%E6%9E%90-Robots-%E5%8D%8F%E8%AE%AE" title="4. 分析 Robots 协议"></a>4. 分析 Robots 协议</h2><p>利用 urllib 的 robotparser 模块，我们可以实现网站 Robots 协议的分析。本节中，我们来简单了解一下该模块的用法。</p><h3 id="1-Robots-协议"><a href="#1-Robots-协议" class="headerlink" title="1. Robots 协议"></a><a href="https://cuiqingcai.com/202221.html#1-Robots-%E5%8D%8F%E8%AE%AE" title="1. Robots 协议"></a>1. Robots 协议</h3><p>Robots 协议也称作爬虫协议、机器人协议，它的全名叫作网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作 robots.txt 的文本文件，一般放在网站的根目录下。</p><p>当搜索爬虫访问一个站点时，它首先会检查这个站点根目录下是否存在 robots.txt 文件，如果存在，搜索爬虫会根据其中定义的爬取范围来爬取。如果没有找到这个文件，搜索爬虫便会访问所有可直接访问的页面。</p><p>下面我们看一个 robots.txt 的样例：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: *  <br>Disallow: &#x2F;  <br>Allow: &#x2F;public&#x2F;</td></tr></tbody></table><p>这实现了对所有搜索爬虫只允许爬取 public 目录的功能，将上述内容保存成 robots.txt 文件，放在网站的根目录下，和网站的入口文件（比如 index.php、index.html 和 index.jsp 等）放在一起。</p><p>上面的 <code>User-agent</code> 描述了搜索爬虫的名称，这里将其设置为 <code>*</code> 则代表该协议对任何爬取爬虫有效。比如，我们可以设置：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: Baiduspider</td></tr></tbody></table><p>这就代表我们设置的规则对百度爬虫是有效的。如果有多条 <code>User-agent</code> 记录，就有多个爬虫会受到爬取限制，但至少需要指定一条。</p><p><code>Disallow</code> 指定了不允许抓取的目录，比如上例子中设置为 <code>/</code> 则代表不允许抓取所有页面。</p><p><code>Allow</code> 一般和 <code>Disallow</code> 一起使用，一般不会单独使用，用来排除某些限制。上例中我们设置为 <code>/public/</code>，则表示所有页面不允许抓取，但可以抓取 public 目录。</p><p>下面我们再来看几个例子。禁止所有爬虫访问任何目录的代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: *  <br>Disallow: &#x2F;</td></tr></tbody></table><p>允许所有爬虫访问任何目录的代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: *  <br>Disallow:</td></tr></tbody></table><p>另外，直接把 robots.txt 文件留空也是可以的。</p><p>禁止所有爬虫访问网站某些目录的代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: *  <br>Disallow: &#x2F;private&#x2F;  <br>Disallow: &#x2F;tmp&#x2F;</td></tr></tbody></table><p>只允许某一个爬虫访问的代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: WebCrawler  <br>Disallow:  <br>User-agent: *  <br>Disallow: &#x2F;</td></tr></tbody></table><p>这些是 robots.txt 的一些常见写法。</p><h3 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a><a href="https://cuiqingcai.com/202221.html#%E7%88%AC%E8%99%AB%E5%90%8D%E7%A7%B0" title="爬虫名称"></a>爬虫名称</h3><p>大家可能会疑惑，爬虫名是从哪儿来的？为什么就叫这个名？其实它是有固定名字的了，比如百度的就叫作 BaiduSpider。表 2- 列出了一些常见搜索爬虫的名称及对应的网站。</p><p>表 一些常见搜索爬虫的名称及其对应的网站</p><table><thead><tr><th>爬虫名称</th><th>名称</th><th>网站</th></tr></thead><tbody><tr><td>BaiduSpider</td><td>百度</td><td><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td>Googlebot</td><td>谷歌</td><td><a href="http://www.google.com/">www.google.com</a></td></tr><tr><td>360Spider</td><td>360 搜索</td><td><a href="http://www.so.com/">www.so.com</a></td></tr><tr><td>YodaoBot</td><td>有道</td><td><a href="http://www.youdao.com/">www.youdao.com</a></td></tr><tr><td>ia_archiver</td><td>Alexa</td><td><a href="http://www.alexa.cn/">www.alexa.cn</a></td></tr><tr><td>Scooter</td><td>altavista</td><td><a href="http://www.altavista.com/">www.altavista.com</a></td></tr><tr><td>Bingbot</td><td>必应</td><td><a href="http://www.bing.com/">www.bing.com</a></td></tr></tbody></table><h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a><a href="https://cuiqingcai.com/202221.html#robotparser" title="robotparser"></a>robotparser</h3><p>了解 Robots 协议之后，我们就可以使用 robotparser 模块来解析 robots.txt 了。该模块提供了一个类 <code>RobotFileParser</code>，它可以根据某网站的 robots.txt 文件来判断一个爬虫是否有权限来爬取这个网页。</p><p>该类用起来非常简单，只需要在构造方法里传入 robots.txt 的链接即可。首先看一下它的声明：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>urllib.robotparser.RobotFileParser(url&#x3D;’’)</td></tr></tbody></table><p>当然，也可以在声明时不传入，默认为空，最后再使用 <code>set_url</code> 方法设置一下即可。</p><p>下面列出了这个类常用的几个方法。</p><ul><li><code>set_url</code>：用来设置 robots.txt 文件的链接。如果在创建 <code>RobotFileParser</code> 对象时传入了链接，那么就不需要再使用这个方法设置了。</li><li><code>read</code>：读取 robots.txt 文件并进行分析。注意，这个方法执行一个读取和分析操作，如果不调用这个方法，接下来的判断都会为 <code>False</code>，所以一定记得调用这个方法。这个方法不会返回任何内容，但是执行了读取操作。</li><li><code>parse</code>：用来解析 robots.txt 文件，传入的参数是 robots.txt 某些行的内容，它会按照 robots.txt 的语法规则来分析这些内容。</li><li><code>can_fetch</code>：该方法用两个参数，第一个是 <code>User-Agent</code>，第二个是要抓取的 URL。返回的内容是该搜索引擎是否可以抓取这个 URL，返回结果是 <code>True</code> 或 <code>False</code>。</li><li><code>mtime</code>：返回的是上次抓取和分析 robots.txt 的时间，这对于长时间分析和抓取的搜索爬虫是很有必要的，你可能需要定期检查来抓取最新的 robots.txt。</li><li><code>modified</code>：它同样对长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析 robots.txt 的时间。</li></ul><p>下面我们用实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.robotparser import RobotFileParser  <br>  <br>rp &#x3D; RobotFileParser()  <br>rp.set_url(‘<a href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a>‘)  <br>rp.read()  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘))  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))  <br>print(rp.can_fetch(‘Googlebot’, ‘<a href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))</td></tr></tbody></table><p>这里以百度为例，首先创建 <code>RobotFileParser</code> 对象，然后通过 <code>set_url</code> 方法设置了 robots.txt 的链接。当然，不用这个方法的话，可以在声明时直接用如下方法设置：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>rp &#x3D; RobotFileParser(‘<a href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a>‘)</td></tr></tbody></table><p>接着利用 <code>can_fetch</code> 方法判断网页是否可以被抓取。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>True  <br>True  <br>False</td></tr></tbody></table><p>这里同样可以使用 <code>parse</code> 方法执行读取和分析，示例如下：<br>可以看到这里我们利用 Baiduspider 可以抓取百度等首页以及 homepage 页面，但是 Googlebot 就不能抓取 homepage 页面。</p><p>打开百度的 robots.txt 文件看下，可以看到如下的信息：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>User-agent: Baiduspider  <br>Disallow: &#x2F;baidu  <br>Disallow: &#x2F;s?  <br>Disallow: &#x2F;ulink?  <br>Disallow: &#x2F;link?  <br>Disallow: &#x2F;home&#x2F;news&#x2F;data&#x2F;  <br>Disallow: &#x2F;bh  <br>  <br>User-agent: Googlebot  <br>Disallow: &#x2F;baidu  <br>Disallow: &#x2F;s?  <br>Disallow: &#x2F;shifen&#x2F;  <br>Disallow: &#x2F;homepage&#x2F;  <br>Disallow: &#x2F;cpro  <br>Disallow: &#x2F;ulink?  <br>Disallow: &#x2F;link?  <br>Disallow: &#x2F;home&#x2F;news&#x2F;data&#x2F;  <br>Disallow: &#x2F;bh</td></tr></tbody></table><p>由此我们可以看到，Baiduspider 没有限制 homepage 页面的抓取，而 Googlebot 则限制了 homepage 页面的抓取。</p><p>这里同样可以使用 parse 方法执行读取和分析，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from urllib.request import urlopen  <br>from urllib.robotparser import RobotFileParser  <br>  <br>rp &#x3D; RobotFileParser()  <br>rp.parse(urlopen(‘<a href="https://www.baidu.com/robots.txt').read().decode('utf-8').split('/n')">https://www.baidu.com/robots.txt&#39;).read().decode(&#39;utf-8&#39;).split(&#39;\n&#39;)</a>)  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘))  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))  <br>print(rp.can_fetch(‘Googlebot’, ‘<a href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))</td></tr></tbody></table><p>运行结果一样：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>True  <br>True  <br>False</td></tr></tbody></table><p>本节介绍了 robotparser 模块的基本用法和实例，利用它，我们可以方便地判断哪些页面可以抓取，哪些页面不可以抓取。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><a href="https://cuiqingcai.com/202221.html#5-%E6%80%BB%E7%BB%93" title="5. 总结"></a>5. 总结</h2><p>本节内容比较多，我们介绍了 urllib 的 request、error、parse、robotparser 模块的基本用法。这些是一些基础模块，其中有一些模块的实用性还是很强的，比如我们可以利用 parse 模块来进行 URL 的各种处理。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/UrllibTest">https://github.com/Python3WebSpider/UrllibTest</a>。</p><h1 id="Request库"><a href="#Request库" class="headerlink" title="Request库"></a>Request库</h1><p>上一节中，我们了解了 urllib 的基本用法，但是其中确实有不方便的地方，比如处理网页验证和 Cookie 时，需要写 Opener 和 Handler 来处理。另外我们要实现 POST、PUT 等请求时写法也不太方便。</p><p>为了更加方便地实现这些操作，就有了更为强大的库 requests，有了它，Cookie、登录验证、代理设置等操作都不是事儿。</p><p>接下来，让我们领略一下它的强大之处吧。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a><a href="https://cuiqingcai.com/202222.html#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1. 准备工作"></a>1. 准备工作</h2><p>在开始之前，请确保已经正确安装好了 requests 库，如尚未安装可以使用 pip3 来安装：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>pip3 install requests</td></tr></tbody></table><p>更加详细的安装说明可以参考 <a href="https://setup.scrape.center/requests%E3%80%82">https://setup.scrape.center/requests。</a></p><h2 id="2-实例引入"><a href="#2-实例引入" class="headerlink" title="2. 实例引入"></a><a href="https://cuiqingcai.com/202222.html#2-%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5" title="2. 实例引入"></a>2. 实例引入</h2><p>urllib 库中的 urlopen 方法实际上是以 GET 方式请求网页，而 requests 中相应的方法就是 get 方法，是不是感觉表达更明确一些？下面通过实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://www.baidu.com/">https://www.baidu.com/</a>‘)  <br>print(type(r))  <br>print(r.status_code)  <br>print(type(r.text))  <br>print(r.text[:100])  <br>print(r.cookies)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;class ‘requests.models.Response’&gt;  <br>200  <br>&lt;class ‘str’&gt;  <br><!DOCTYPE html>  <br><!--STATUS OK--><html> <head>&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;charse  <br>&lt;RequestsCookieJar[&lt;Cookie BDORZ&#x3D;27315 for .baidu.com&#x2F;&gt;]&gt;</td></tr></tbody></table><p>这里我们调用 get 方法实现与 urlopen 相同的操作，得到一个 Response 对象，然后分别输出了 Response 的类型、状态码、响应体的类型、内容以及 Cookie。</p><p>通过运行结果可以发现，它的返回类型是 <code>requests.models.Response</code>，响应体的类型是字符串 str，Cookie 的类型是 RequestsCookieJar。</p><p>使用 get 方法成功实现一个 GET 请求，这倒不算什么，更方便之处在于其他的请求类型依然可以用一句话来完成，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘)  <br>r &#x3D; requests.post(‘<a href="https://httpbin.org/post">https://httpbin.org/post</a>‘)  <br>r &#x3D; requests.put(‘<a href="https://httpbin.org/put">https://httpbin.org/put</a>‘)  <br>r &#x3D; requests.delete(‘<a href="https://httpbin.org/delete">https://httpbin.org/delete</a>‘)  <br>r &#x3D; requests.patch(‘<a href="https://httpbin.org/patch">https://httpbin.org/patch</a>‘)</td></tr></tbody></table><p>这里分别用 post、put、delete 等方法实现了 POST、PUT、DELETE 等请求。是不是比 urllib 简单太多了？</p><p>其实这只是冰山一角，更多的还在后面。</p><h2 id="3-GET-请求"><a href="#3-GET-请求" class="headerlink" title="3. GET 请求"></a><a href="https://cuiqingcai.com/202222.html#3-GET-%E8%AF%B7%E6%B1%82" title="3. GET 请求"></a>3. GET 请求</h2><p>HTTP 中最常见的请求之一就是 GET 请求，下面首先来详细了解一下利用 requests 构建 GET 请求的方法。</p><h4 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a><a href="https://cuiqingcai.com/202222.html#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B" title="基本实例"></a>基本实例</h4><p>首先，构建一个最简单的 GET 请求，请求的链接为 <a href="https://httpbin.org/get">https://httpbin.org/get</a>，该网站会判断如果客户端发起的是 GET 请求的话，它返回相应的请求信息：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘)  <br>print(r.text)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {},  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.22.0”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e6e3a2e-6b1a28288d721c9e425a462a”  <br>  },  <br>  “origin”: “17.20.233.237”,  <br>  “url”: “<a href="https://httpbin.org/get">https://httpbin.org/get</a>“  <br>}</td></tr></tbody></table><p>可以发现，我们成功发起了 GET 请求，返回结果中包含请求头、URL、IP 等信息。</p><p>那么，对于 GET 请求，如果要附加额外的信息，一般怎样添加呢？比如现在想添加两个参数，其中 name 是 germey，age 是 25，URL 就可以写成如下内容：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><a href="https://httpbin/get?name=germey&age=25">https://httpbin/get?name=germey&amp;age=25</a></td></tr></tbody></table><p>要构造这个请求链接，是不是要直接写成这样呢？</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>r &#x3D; requests.get(‘<a href="https://httpbin.org/get?name=germey&age=25">https://httpbin.org/get?name=germey&amp;age=25</a>‘)</td></tr></tbody></table><p>这样也可以，但是是不是有点不人性化呢？这些参数还需要我们手动去拼接，实现起来有点不优雅。</p><p>一般情况下，这种信息我们利用 params 这个参数就可以直接传递了，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>data &#x3D; {  <br>    ‘name’: ‘germey’,  <br>    ‘age’: 25  <br>}  <br>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, params&#x3D;data)  <br>print(r.text)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {  <br>    “age”: “25”,  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.10.0”  <br>  },  <br>  “origin”: “122.4.215.33”,  <br>  “url”: “<a href="https://httpbin.org/get?age=22&name=germey">https://httpbin.org/get?age=22&amp;name=germey</a>“  <br>}</td></tr></tbody></table><p>在这里我们把 URL 参数通过一个字典的形式传给 get 方法的 params 参数，通过返回信息我们可以判断，请求的链接自动被构造成了：<a href="https://httpbin.org/get?age=22&amp;name=germey">https://httpbin.org/get?age=22&name=germey</a>，这样我们就不用再去自己构造 URL 了，非常方便。</p><p>另外，网页的返回类型实际上是 str 类型，但是它很特殊，是 JSON 格式的。所以，如果想直接解析返回结果，得到一个 JSON 格式的数据的话，可以直接调用 json 方法。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘)  <br>print(type(r.text))  <br>print(r.json())  <br>print(type(r.json()))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;class’str’&gt;  <br>{‘headers’: {‘Accept-Encoding’: ‘gzip, deflate’, ‘Accept’: ‘<em>&#x2F;</em>‘, ‘Host’: ‘httpbin.org’, ‘User-Agent’: ‘python-requests&#x2F;2.10.0’}, ‘url’: ‘<a href="http://httpbin.org/get">http://httpbin.org/get</a>‘, ‘args’: {}, ‘origin’: ‘182.33.248.131’}  <br>&lt;class ‘dict’&gt;</td></tr></tbody></table><p>可以发现，调用 json 方法，就可以将返回结果是 JSON 格式的字符串转化为字典。</p><p>但需要注意的是，如果返回结果不是 JSON 格式，便会出现解析错误，抛出 json.decoder.JSONDecodeError 异常。</p><h4 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a><a href="https://cuiqingcai.com/202222.html#%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5" title="抓取网页"></a>抓取网页</h4><p>上面的请求链接返回的是 JSON 形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容了。下面以一个实例页面 <a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a> 来试一下，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>import re  <br>  <br>r &#x3D; requests.get(‘<a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘)  <br>pattern &#x3D; re.compile(‘&lt;h2.<em>?&gt;(.</em>?)</h2>‘, re.S)  <br>titles &#x3D; re.findall(pattern, r.text)  <br>print(titles)</td></tr></tbody></table><p>在这个例子中我们用到了最基础的正则表达式来匹配出所有的问题内容。关于正则表达式的相关内容，我们会在下一节详细介绍，这里作为实例来配合讲解。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[‘肖申克的救赎 - The Shawshank Redemption’, ‘霸王别姬 - Farewell My Concubine’, ‘泰坦尼克号 - Titanic’, ‘罗马假日 - Roman Holiday’, ‘这个杀手不太冷 - Léon’, ‘魂断蓝桥 - Waterloo Bridge’, ‘唐伯虎点秋香 - Flirting Scholar’, ‘喜剧之王 - The King of Comedy’, ‘楚门的世界 - The Truman Show’, ‘活着 - To Live’]</td></tr></tbody></table><p>我们发现，这里成功提取出了所有的电影标题，一个最基本的抓取和提取流程就完成了。</p><h4 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a><a href="https://cuiqingcai.com/202222.html#%E6%8A%93%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE" title="抓取二进制数据"></a>抓取二进制数据</h4><p>在上面的例子中，我们抓取的是网站的一个页面，实际上它返回的是一个 HTML 文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？</p><p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。</p><p>下面以示例网站的站点图标为例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://scrape.center/favicon.ico">https://scrape.center/favicon.ico</a>‘)  <br>print(r.text)  <br>print(r.content)</td></tr></tbody></table><p>这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/1sfy2.png" alt="image-20210704202919308"></p><p>这里打印了 Response 对象的两个属性，一个是 text，另一个是 content。</p><p>运行结果如图所示，分别是 r.text 和 r.content 的结果。</p><p><img src="https://cdn.cuiqingcai.com/vexbl.png" alt="image-20210704203039567"></p><p><img src="https://cdn.cuiqingcai.com/xfo4w.png" alt="image-20210704202959490"></p><p>可以注意到，前者出现了乱码，后者结果前带有一个 b，这代表是 bytes 类型的数据。由于图片是二进制数据，所以前者在打印时转化为 str 类型，也就是图片直接转化为字符串，这理所当然会出现乱码。</p><p>上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，我们将刚才提取到的信息保存下来就好了，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://scrape.center/favicon.ico">https://scrape.center/favicon.ico</a>‘)  <br>with open(‘favicon.ico’, ‘wb’) as f:  <br>    f.write(r.content)</td></tr></tbody></table><p>这里用了 open 方法，它的第一个参数是文件名称，第二个参数代表以二进制写的形式打开，可以向文件里写入二进制数据。</p><p>运行结束之后，可以发现在文件夹中出现了名为 favicon.ico 的图标，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/16oto.png" alt="image-20210704203204899"></p><p>这样，我们就把二进制数据成功保存成一张图片了，这个小图标就被我们成功爬取下来了。</p><p>同样地，音频和视频文件我们也可以用这种方法获取。</p><h4 id="添加-headers"><a href="#添加-headers" class="headerlink" title="添加 headers"></a><a href="https://cuiqingcai.com/202222.html#%E6%B7%BB%E5%8A%A0-headers" title="添加 headers"></a>添加 headers</h4><p>我们知道，在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，那么这个怎么来设置呢？</p><p>很简单，我们使用 headers 参数就可以完成了。</p><p>在刚才的实例中，实际上我们是没有设置 Request Headers 信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p><p>要添加 Headers 信息，比如我们这里想添加一个 User-Agent 字段，我们可以这么来写：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;52.0.2743.116 Safari&#x2F;537.36’  <br>}  <br>r &#x3D; requests.get(‘<a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘, headers&#x3D;headers)  <br>print(r.text)</td></tr></tbody></table><p>当然，我们可以在 headers 这个参数中任意添加其他的字段信息。</p><h2 id="4-POST-请求"><a href="#4-POST-请求" class="headerlink" title="4. POST 请求"></a><a href="https://cuiqingcai.com/202222.html#4-POST-%E8%AF%B7%E6%B1%82" title="4. POST 请求"></a>4. POST 请求</h2><p>前面我们了解了最基本的 GET 请求，另外一种比较常见的请求方式是 POST。使用 requests 实现 POST 请求同样非常简单，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>data &#x3D; {‘name’: ‘germey’, ‘age’: ‘25’}  <br>r &#x3D; requests.post(“<a href="https://httpbin.org/post">https://httpbin.org/post</a>“, data&#x3D;data)  <br>print(r.text)</td></tr></tbody></table><p>这里还是请求 <a href="https://httpbin.org/post">https://httpbin.org/post</a>，该网站可以判断如果请求是 POST 方式，就把相关请求信息返回。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “age”: “25”,  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Content-Length”: “18”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.22.0”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e6e3b52-0f36782ea980fce53c8c6524”  <br>  },  <br>  “json”: null,  <br>  “origin”: “17.20.232.237”,  <br>  “url”: “<a href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td></tr></tbody></table><p>可以发现，我们成功获得了返回结果，其中 form 部分就是提交的数据，这就证明 POST 请求成功发送了。</p><h2 id="5-响应"><a href="#5-响应" class="headerlink" title="5. 响应"></a><a href="https://cuiqingcai.com/202222.html#5-%E5%93%8D%E5%BA%94" title="5. 响应"></a>5. 响应</h2><p>发送请求后，得到的自然就是响应。在上面的实例中，我们使用 text 和 content 获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如状态码、响应头、Cookie 等。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘)  <br>print(type(r.status_code), r.status_code)  <br>print(type(r.headers), r.headers)  <br>print(type(r.cookies), r.cookies)  <br>print(type(r.url), r.url)  <br>print(type(r.history), r.history)</td></tr></tbody></table><p>这里分别打印输出 status_code 属性得到状态码，输出 headers 属性得到响应头，输出 cookies 属性得到 Cookie，输出 url 属性得到 URL，输出 history 属性得到请求历史。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;class ‘int’&gt; 200  <br>&lt;class ‘requests.structures.CaseInsensitiveDict’&gt; {‘Server’: ‘nginx&#x2F;1.17.8’, ‘Date’: ‘Sat, 30 May 2020 16:56:40 GMT’, ‘Content-Type’: ‘text&#x2F;html; charset&#x3D;utf-8’, ‘Transfer-Encoding’: ‘chunked’, ‘Connection’: ‘keep-alive’, ‘Vary’: ‘Accept-Encoding’, ‘X-Frame-Options’: ‘DENY’, ‘X-Content-Type-Options’: ‘nosniff’, ‘Strict-Transport-Security’: ‘max-age&#x3D;15724800; includeSubDomains’, ‘Content-Encoding’: ‘gzip’}  <br>&lt;class ‘requests.cookies.RequestsCookieJar’&gt; &lt;RequestsCookieJar[]&gt;  <br>&lt;class ‘str’&gt; <a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>  <br>&lt;class ‘list’&gt; []</td></tr></tbody></table><p>可以看到，headers 和 cookies 这两个属性得到的结果分别是 CaseInsensitiveDict 和 RequestsCookieJar 类型。</p><p>在第一章我们知道，状态码是用来表示响应状态的，比如返回 200 代表我们得到的响应是没问题的，上面的例子正好输出的结果也是 200，所以我们可以通过判断 Response 的状态码来知道爬取是否爬取成功。</p><p>requests 还提供了一个内置的状态码查询对象 requests.codes，用法示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘)  <br>exit() if not r.status_code &#x3D;&#x3D; requests.codes.ok else print(‘Request Successfully’)</td></tr></tbody></table><p>这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用 requests.codes.ok 得到的是成功的状态码 200。</p><p>这样的话，我们就不用再在程序里面写状态吗对应的数字了，用字符串表示状态码会显得更加直观。</p><p>当然，肯定不能只有 ok 这个条件码。</p><p>下面列出了返回码和相应的查询条件：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td># 信息性状态码  <br>100: (‘continue’,),  <br>101: (‘switching_protocols’,),  <br>102: (‘processing’,),  <br>103: (‘checkpoint’,),  <br>122: (‘uri_too_long’, ‘request_uri_too_long’),  <br>  <br># 成功状态码  <br>200: (‘ok’, ‘okay’, ‘all_ok’, ‘all_okay’, ‘all_good’, ‘\o&#x2F;‘, ‘✓’),  <br>201: (‘created’,),  <br>202: (‘accepted’,),  <br>203: (‘non_authoritative_info’, ‘non_authoritative_information’),  <br>204: (‘no_content’,),  <br>205: (‘reset_content’, ‘reset’),  <br>206: (‘partial_content’, ‘partial’),  <br>207: (‘multi_status’, ‘multiple_status’, ‘multi_stati’, ‘multiple_stati’),  <br>208: (‘already_reported’,),  <br>226: (‘im_used’,),  <br>  <br># 重定向状态码  <br>300: (‘multiple_choices’,),  <br>301: (‘moved_permanently’, ‘moved’, ‘\o-‘),  <br>302: (‘found’,),  <br>303: (‘see_other’, ‘other’),  <br>304: (‘not_modified’,),  <br>305: (‘use_proxy’,),  <br>306: (‘switch_proxy’,),  <br>307: (‘temporary_redirect’, ‘temporary_moved’, ‘temporary’),  <br>308: (‘permanent_redirect’,  <br>      ‘resume_incomplete’, ‘resume’,), # These 2 to be removed in 3.0  <br>  <br># 客户端错误状态码  <br>400: (‘bad_request’, ‘bad’),  <br>401: (‘unauthorized’,),  <br>402: (‘payment_required’, ‘payment’),  <br>403: (‘forbidden’,),  <br>404: (‘not_found’, ‘-o-‘),  <br>405: (‘method_not_allowed’, ‘not_allowed’),  <br>406: (‘not_acceptable’,),  <br>407: (‘proxy_authentication_required’, ‘proxy_auth’, ‘proxy_authentication’),  <br>408: (‘request_timeout’, ‘timeout’),  <br>409: (‘conflict’,),  <br>410: (‘gone’,),  <br>411: (‘length_required’,),  <br>412: (‘precondition_failed’, ‘precondition’),  <br>413: (‘request_entity_too_large’,),  <br>414: (‘request_uri_too_large’,),  <br>415: (‘unsupported_media_type’, ‘unsupported_media’, ‘media_type’),  <br>416: (‘requested_range_not_satisfiable’, ‘requested_range’, ‘range_not_satisfiable’),  <br>417: (‘expectation_failed’,),  <br>418: (‘im_a_teapot’, ‘teapot’, ‘i_am_a_teapot’),  <br>421: (‘misdirected_request’,),  <br>422: (‘unprocessable_entity’, ‘unprocessable’),  <br>423: (‘locked’,),  <br>424: (‘failed_dependency’, ‘dependency’),  <br>425: (‘unordered_collection’, ‘unordered’),  <br>426: (‘upgrade_required’, ‘upgrade’),  <br>428: (‘precondition_required’, ‘precondition’),  <br>429: (‘too_many_requests’, ‘too_many’),  <br>431: (‘header_fields_too_large’, ‘fields_too_large’),  <br>444: (‘no_response’, ‘none’),  <br>449: (‘retry_with’, ‘retry’),  <br>450: (‘blocked_by_windows_parental_controls’, ‘parental_controls’),  <br>451: (‘unavailable_for_legal_reasons’, ‘legal_reasons’),  <br>499: (‘client_closed_request’,),  <br>  <br># 服务端错误状态码  <br>500: (‘internal_server_error’, ‘server_error’, ‘&#x2F;o\‘, ‘✗’),  <br>501: (‘not_implemented’,),  <br>502: (‘bad_gateway’,),  <br>503: (‘service_unavailable’, ‘unavailable’),  <br>504: (‘gateway_timeout’,),  <br>505: (‘http_version_not_supported’, ‘http_version’),  <br>506: (‘variant_also_negotiates’,),  <br>507: (‘insufficient_storage’,),  <br>509: (‘bandwidth_limit_exceeded’, ‘bandwidth’),  <br>510: (‘not_extended’,),  <br>511: (‘network_authentication_required’, ‘network_auth’, ‘network_authentication’)</td></tr></tbody></table><p>比如，如果想判断结果是不是 404 状态，可以用 <code>requests.codes.not_found</code> 来比对。</p><h2 id="6-高级用法"><a href="#6-高级用法" class="headerlink" title="6. 高级用法"></a><a href="https://cuiqingcai.com/202222.html#6-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" title="6. 高级用法"></a>6. 高级用法</h2><p>前面我们了解了 requests 的基本用法，如基本的 GET、POST 请求以及 Response 对象。下面我们再来了解下 requests 的一些高级用法，如文件上传、Cookie 设置、代理设置等。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><a href="https://cuiqingcai.com/202222.html#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0" title="文件上传"></a>文件上传</h3><p>我们知道 requests 可以模拟提交一些数据。假如有的网站需要上传文件，我们也可以用它来实现，这非常简单，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>files &#x3D; {‘file’: open(‘favicon.ico’, ‘rb’)}  <br>r &#x3D; requests.post(‘<a href="https://httpbin.org/post">https://httpbin.org/post</a>‘, files&#x3D;files)  <br>print(r.text)</td></tr></tbody></table><p>在前一节中我们保存了一个文件 favicon.ico，这次用它来模拟文件上传的过程。需要注意的是，favicon.ico 需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {  <br>    “file”: “data:application&#x2F;octet-stream;base64,AAABAAI…”  <br>  },  <br>  “form”: {},  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Content-Length”: “6665”,  <br>    “Content-Type”: “multipart&#x2F;form-data; boundary&#x3D;41fc691282cc894f8f06adabb24f05fb”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.22.0”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e6e3c0b-45b07bdd3a922e364793ef48”  <br>  },  <br>  “json”: null,  <br>  “origin”: “16.20.232.237”,  <br>  “url”: “<a href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td></tr></tbody></table><p>以上省略部分内容，这个网站会返回响应，里面包含 files 这个字段，而 form 字段是空的，这证明文件上传部分会单独有一个 files 字段来标识。</p><h3 id="Cookie-设置"><a href="#Cookie-设置" class="headerlink" title="Cookie 设置"></a><a href="https://cuiqingcai.com/202222.html#Cookie-%E8%AE%BE%E7%BD%AE" title="Cookie 设置"></a>Cookie 设置</h3><p>前面我们使用 urllib 处理过 Cookie，写法比较复杂，而有了 requests，获取和设置 Cookie 只需一步即可完成。</p><p>我们先用一个实例看一下获取 Cookie 的过程：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>print(r.cookies)  <br>for key, value in r.cookies.items():  <br>    print(key + ‘&#x3D;’ + value)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;RequestsCookieJar[&lt;Cookie BDORZ&#x3D;27315 for .baidu.com&#x2F;&gt;]&gt;  <br>BDORZ&#x3D;27315</td></tr></tbody></table><p>这里我们首先调用 cookies 属性即可成功得到 Cookie，可以发现它是 RequestCookieJar 类型。然后用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 条目的名称和值，实现 Cookie 的遍历解析。</p><p>当然，我们也可以直接用 Cookie 来维持登录状态，下面我们以 GitHub 为例来说明一下，首先我们登录 GitHub，然后将 Headers 中的 Cookie 内容复制下来，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/odrdk.png" alt="image-20200301214840166"></p><p>这里可以替换成你自己的 Cookie，将其设置到 Headers 里面，然后发送请求，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>headers &#x3D; {  <br>    ‘Cookie’: ‘_octo&#x3D;GH1.1.1849343058.1576602081; _ga&#x3D;GA1.2.90460451.1576602111; _<em>Host-user_session_same_site&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; <em>device_id&#x3D;a7ca73be0e8f1a81d1e2ebb5349f9075; user_session&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; logged_in&#x3D;yes; dotcom_user&#x3D;Germey; tz&#x3D;Asia%2FShanghai; has_recent_activity&#x3D;1; _gat&#x3D;1; _gh_sess&#x3D;your_session_info’,  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36’,  <br>}  <br>r &#x3D; requests.get(‘<a href="https://github.com/">https://github.com/</a>‘, headers&#x3D;headers)  <br>print(r.text)</td></tr></tbody></table><p>我们发现，结果中包含了登录后才能包含的结果，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/3j50b.png" alt="image-20200301215251376"></p><p>可以看到这里包含了我的 GitHub 用户名信息，你如果尝试之后同样可以得到你的用户信息。</p><p>得到这样类似的结果，就说明我们用 Cookie 就成功模拟了登录状态，这样我们就能爬取登录之后才能看到的页面了。</p><p>当然，我们也可以通过 cookies 参数来设置 Cookie 的信息，这里我们可以构造一个 RequestsCookieJar 对象，然后把刚才复制的 Cookie 处理下并赋值，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>cookies &#x3D; ‘_octo&#x3D;GH1.1.1849343058.1576602081; _ga&#x3D;GA1.2.90460451.1576602111; _<em>Host-user_session_same_site&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; <em>device_id&#x3D;a7ca73be0e8f1a81d1e2ebb5349f9075; user_session&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; logged_in&#x3D;yes; dotcom_user&#x3D;Germey; tz&#x3D;Asia%2FShanghai; has_recent_activity&#x3D;1; _gat&#x3D;1; _gh_sess&#x3D;your_session_info’  <br>jar &#x3D; requests.cookies.RequestsCookieJar()  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36’  <br>}  <br>for cookie in cookies.split(‘;’):  <br>    key, value &#x3D; cookie.split(‘&#x3D;’, 1)  <br>    jar.set(key, value)  <br>r &#x3D; requests.get(‘<a href="https://github.com/">https://github.com/</a>‘, cookies&#x3D;jar, headers&#x3D;headers)  <br>print(r.text)</td></tr></tbody></table><p>这里我们首先新建了一个 RequestCookieJar 对象，然后将复制下来的 cookies 利用 split 方法分割，接着利用 set 方法设置好每个 Cookie 的 key 和 value，然后通过调用 requests 的 get 方法并传递给 cookies 参数即可。</p><p>测试后，发现同样可以正常登录。</p><h3 id="Session-维持"><a href="#Session-维持" class="headerlink" title="Session 维持"></a><a href="https://cuiqingcai.com/202222.html#Session-%E7%BB%B4%E6%8C%81" title="Session 维持"></a>Session 维持</h3><p>在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，也就是说相当于你用了两个浏览器打开了不同的页面。</p><p>设想这样一个场景，第一个请求利用 requests 的 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次 requests 的 get 方法去请求个人信息页面。</p><p>实际上，这相当于打开了两个浏览器，是两个完全独立的操作，对应两个完全不相关的 Session，能成功获取个人信息吗？那当然不能。</p><p>有人可能说了，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来显得很烦琐，我们有更简单的解决方法。</p><p>其实解决这个问题的主要方法就是维持同一个 Session，也就是相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但是我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 —— Session 对象。</p><p>利用它，我们可以方便地维护一个 Session，而且不用担心 Cookie 的问题，它会帮我们自动处理好。</p><p>我们先做一个小实验吧，如果沿用之前的写法，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>requests.get(‘<a href="https://httpbin.org/cookies/set/number/123456789">https://httpbin.org/cookies/set/number/123456789</a>‘)  <br>r &#x3D; requests.get(‘<a href="https://httpbin.org/cookies">https://httpbin.org/cookies</a>‘)  <br>print(r.text)</td></tr></tbody></table><p>这里我们请求了一个测试网址 <a href="https://httpbin.org/cookies/set/number/123456789">https://httpbin.org/cookies/set/number/123456789</a>。请求这个网址时，可以设置一个 Cookie 条目，名称叫作 number，内容是 123456789，随后又请求了 <a href="https://httpbin.org/cookies">https://httpbin.org/cookies</a>，此网址可以获取当前的 Cookie 信息。</p><p>这样能成功获取到设置的 Cookie 吗？试试看。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “cookies”: {}  <br>}</td></tr></tbody></table><p>这并不行。</p><p>这时候，我们再用刚才所说的 Session 试试看：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>s &#x3D; requests.Session()  <br>s.get(‘<a href="https://httpbin.org/cookies/set/number/123456789">https://httpbin.org/cookies/set/number/123456789</a>‘)  <br>r &#x3D; s.get(‘<a href="https://httpbin.org/cookies">https://httpbin.org/cookies</a>‘)  <br>print(r.text)</td></tr></tbody></table><p>再看下运行结果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “cookies”: {“number”: “123456789”}  <br>}</td></tr></tbody></table><p>这些可以看到 Cookies 被成功获取了！这下能体会到同一个会话和不同会话的区别了吧！</p><p>所以，利用 Session，可以做到模拟同一个会话而不用担心 Cookie 的问题。它通常用于模拟登录成功之后再进行下一步的操作。</p><p>Session 在平常用得非常广泛，可以用于模拟在一个浏览器中打开同一站点的不同页面，后面会有专门的章节来讲解这部分内容。</p><h3 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a><a href="https://cuiqingcai.com/202222.html#SSL-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81" title="SSL 证书验证"></a>SSL 证书验证</h3><p>现在很多网站都要求使用 HTTPS 协议，但是有些网站可能并没有设置好 HTTPS 证书，或者网站的 HTTPS 证书可能并不被 CA 机构认可，这时候，这些网站可能就会出现 SSL 证书错误的提示。</p><p>比如这个示例网站：<a href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>，如果我们用 Chrome 浏览器打开这个 URL，则会提示「您的连接不是私密连接」这样的错误，如图所示：</p><p><img src="https://cdn.cuiqingcai.com/gyo9f.png" alt="image-20210704204017465"></p><p>我们可以在浏览器中通过一些设置来忽略证书的验证。</p><p>但是如果我们想用 requests 来请求这类网站，会遇到什么问题呢？我们用代码来试一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>response &#x3D; requests.get(‘<a href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘)  <br>print(response.status_code)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>requests.exceptions.SSLError: HTTPSConnectionPool(host&#x3D;’ssr2.scrape.center’, port&#x3D;443): Max retries exceeded with url: &#x2F; (Caused by SSLError(SSLCertVerificationError(1, ‘[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)’)))</td></tr></tbody></table><p>可以看到，这里直接抛出了 SSLError 错误，原因就是因为我们请求的 URL 的证书是无效的。</p><p>那如果我们一定要爬取这个网站怎么办呢？我们可以使用 verify 参数控制是否验证证书，如果将其设置为 False，在请求时就不会再验证证书是否有效。如果不加 verify 参数的话，默认值是 True，会自动验证。</p><p>我们改写代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>response &#x3D; requests.get(‘<a href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, verify&#x3D;False)  <br>print(response.status_code)</td></tr></tbody></table><p>这样就会打印出请求成功的状态码：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;urllib3&#x2F;connectionpool.py:857: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: <a href="https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings">https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings</a>  <br>  InsecureRequestWarning)  <br>200</td></tr></tbody></table><p>不过我们发现报了一个警告，它建议我们给它指定证书。我们可以通过设置忽略警告的方式来屏蔽这个警告：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>from requests.packages import urllib3  <br>  <br>urllib3.disable_warnings()  <br>response &#x3D; requests.get(‘<a href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, verify&#x3D;False)  <br>print(response.status_code)</td></tr></tbody></table><p>或者通过捕获警告到日志的方式忽略警告：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import logging  <br>import requests  <br>  <br>logging.captureWarnings(True)  <br>response &#x3D; requests.get(‘<a href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, verify&#x3D;False)  <br>print(response.status_code)</td></tr></tbody></table><p>当然，我们也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>response &#x3D; requests.get(‘<a href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, cert&#x3D;(‘&#x2F;path&#x2F;server.crt’, ‘&#x2F;path&#x2F;server.key’))  <br>print(response.status_code)</td></tr></tbody></table><p>当然，上面的代码是演示实例，我们需要有 crt 和 key 文件，并且指定它们的路径。另外注意，本地私有证书的 key 必须是解密状态，加密状态的 key 是不支持的。</p><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a><a href="https://cuiqingcai.com/202222.html#%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE" title="超时设置"></a>超时设置</h3><p>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到 timeout 参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;1)  <br>print(r.status_code)</td></tr></tbody></table><p>通过这样的方式，我们可以将超时时间设置为 1 秒，如果 1 秒内没有响应，那就抛出异常。</p><p>实际上，请求分为两个阶段，即连接（connect）和读取（read）。</p><p>上面设置的 timeout 将用作连接和读取这二者的 timeout 总和。</p><p>如果要分别指定，就可以传入一个元组：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;(5, 30))</td></tr></tbody></table><p>如果想永久等待，可以直接将 timeout 设置为 None，或者不设置直接留空，因为默认是 None。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;None)</td></tr></tbody></table><p>或直接不加参数：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>r &#x3D; requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘)</td></tr></tbody></table><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a><a href="https://cuiqingcai.com/202222.html#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81" title="身份认证"></a>身份认证</h3><p>在上一节我们讲到，在访问启用了基本身份认证的网站时，我们会首先遇到一个认证窗口，例如：<a href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>，如图所示。</p><p><img src="https://cdn.cuiqingcai.com/4cha6.png" alt="image-20210704202140395"></p><p>这个网站就是启用了基本身份认证，在上一节中我们可以利用 urllib 来实现身份的校验，但实现起来相对繁琐。那在 reqeusts 中怎么做呢？当然也有办法。</p><p>我们可以使用 requests 自带的身份认证功能，通过 auth 参数即可设置，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>from requests.auth import HTTPBasicAuth  <br>  <br>r &#x3D; requests.get(‘<a href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>‘, auth&#x3D;HTTPBasicAuth(‘admin’, ‘admin’))  <br>print(r.status_code)</td></tr></tbody></table><p>这个示例网站的用户名和密码都是 admin，在这里我们可以直接设置。</p><p>如果用户名和密码正确的话，请求时就会自动认证成功，会返回 200 状态码；如果认证失败，则返回 401 状态码。</p><p>当然，如果参数都传一个 HTTPBasicAuth 类，就显得有点烦琐了，所以 requests 提供了一个更简单的写法，可以直接传一个元组，它会默认使用 HTTPBasicAuth 这个类来认证。</p><p>所以上面的代码可以直接简写如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>r &#x3D; requests.get(‘<a href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>‘, auth&#x3D;(‘admin’, ‘admin’))  <br>print(r.status_code)</td></tr></tbody></table><p>此外，requests 还提供了其他认证方式，如 OAuth 认证，不过此时需要安装 oauth 包，安装命令如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>pip3 install requests_oauthlib</td></tr></tbody></table><p>使用 OAuth1 认证的示例方法如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>from requests_oauthlib import OAuth1  <br>  <br>url &#x3D; ‘<a href="https://api.twitter.com/1.1/account/verify_credentials.json">https://api.twitter.com/1.1/account/verify_credentials.json</a>‘  <br>auth &#x3D; OAuth1(‘YOUR_APP_KEY’, ‘YOUR_APP_SECRET’,  <br>              ‘USER_OAUTH_TOKEN’, ‘USER_OAUTH_TOKEN_SECRET’)  <br>requests.get(url, auth&#x3D;auth)</td></tr></tbody></table><p>更多详细的功能就可以参考 requests_oauthlib 的官方文档：<a href="https://requests-oauthlib.readthedocs.org/">https://requests-oauthlib.readthedocs.org/</a>，在此就不再赘述了。</p><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a><a href="https://cuiqingcai.com/202222.html#%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE" title="代理设置"></a>代理设置</h3><p>对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模爬取，对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的 IP，导致一定时间段内无法访问。</p><p>那么，为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到 proxies 参数。可以用这样的方式设置：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>proxies &#x3D; {  <br>  ‘http’: ‘<a href="http://10.10.10.10:1080/">http://10.10.10.10:1080</a>‘,  <br>  ‘https’: ‘<a href="http://10.10.10.10:1080/">http://10.10.10.10:1080</a>‘,  <br>}  <br>requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, proxies&#x3D;proxies)</td></tr></tbody></table><p>当然，直接运行这个实例可能不行，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。</p><p>若代理需要使用上文所述的身份认证，可以使用类似 <a href="http://user:password@host:port">http://user:password@host:port</a> 这样的语法来设置代理，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>proxies &#x3D; {‘https’: ‘<a href="http://user:password@10.10.10.10:1080/',%7D">http://user:password@10.10.10.10:1080/&#39;,}</a>  <br>requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, proxies&#x3D;proxies)</td></tr></tbody></table><p>除了基本的 HTTP 代理外，requests 还支持 SOCKS 协议的代理。</p><p>首先，需要安装 socks 这个库：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>pip3 install “requests[socks]”</td></tr></tbody></table><p>然后就可以使用 SOCKS 协议代理了，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import requests  <br>  <br>proxies &#x3D; {  <br>    ‘http’: ‘socks5:&#x2F;&#x2F;user:password@host:port’,  <br>    ‘https’: ‘socks5:&#x2F;&#x2F;user:password@host:port’  <br>}  <br>requests.get(‘<a href="https://httpbin.org/get">https://httpbin.org/get</a>‘, proxies&#x3D;proxies)</td></tr></tbody></table><h3 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a><a href="https://cuiqingcai.com/202222.html#Prepared-Request" title="Prepared Request"></a>Prepared Request</h3><p>我们使用 requests 库的 get 和 post 方法当然直接可以发送请求，但有没有想过，这个请求在 requests 内部是怎么实现的呢？</p><p>实际上，requests 在发送请求的时候，是在内部构造了一个 Request 对象，并给这个对象赋予了各种参数，包括 url、headers、data 等等，然后直接把这个 Request 对象发送出去，请求成功后会再得到一个 Response 对象，再解析即可。</p><p>那么这个 Request 是什么类型呢？实际上它就是 Prepared Request。</p><p>我们深入一下，不用 get 方法，直接构造一个 Prepared Request 对象来试试，代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>from requests import Request, Session  <br>  <br>url &#x3D; ‘<a href="https://httpbin.org/post">https://httpbin.org/post</a>‘  <br>data &#x3D; {‘name’: ‘germey’}  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36’  <br>    }  <br>s &#x3D; Session()  <br>req &#x3D; Request(‘POST’, url, data&#x3D;data, headers&#x3D;headers)  <br>prepped &#x3D; s.prepare_request(req)  <br>r &#x3D; s.send(prepped)  <br>print(r.text)</td></tr></tbody></table><p>这里我们引入了 Request 这个类，然后用 url、data 和 headers 参数构造了一个 Request 对象，这时需要再调用 Session 的 prepare_request 方法将其转换为一个 Prepared Request 对象，然后调用 send 方法发送，运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Content-Length”: “11”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e5bd6a9-6513c838f35b06a0751606d8”  <br>  },  <br>  “json”: null,  <br>  “origin”: “167.220.232.237”,  <br>  “url”: “<a href="http://httpbin.org/post">http://httpbin.org/post</a>“  <br>}</td></tr></tbody></table><p>可以看到，我们达到了同样的 POST 请求效果。</p><p>有了 Request 这个对象，就可以将请求当作独立的对象来看待，这样在一些场景中我们可以直接操作这个 Request 对象，更灵活地实现请求的调度和各种操作。</p><p>更多的用法可以参考 requests 的官方文档：<a href="http://docs.python-requests.org/">http://docs.python-requests.org/</a>。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><a href="https://cuiqingcai.com/202222.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>本节的 requests 库的基本用法就介绍到这里了，怎么样？有没有感觉它比 urllib 使用起来更为方便。本节内容需要好好掌握，在后文我们会在实战中使用 requests 完成一个网站的爬取，巩固 requests 的相关知识。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/RequestsTest%E3%80%82">https://github.com/Python3WebSpider/RequestsTest。</a></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>在上一节中，我们已经可以用 requests 来获取网页的源代码，得到 HTML 代码。但我们真正想要的数据是包含在 HTML 代码之中的，怎么才能从 HTML 代码中获取我们想要的信息呢？正则表达式就是其中一个有效的方法。</p><p>本节中，我们了解一下正则表达式的相关用法。正则表达式是处理字符串的强大工具，它有自己特定的语法结构，有了它，实现字符串的检索、替换、匹配验证都不在话下。</p><p>当然，对于爬虫来说，有了它，从 HTML 里提取想要的信息就非常方便了。</p><h3 id="1-实例引入"><a href="#1-实例引入" class="headerlink" title="1. 实例引入"></a><a href="https://cuiqingcai.com/202223.html#1-%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5" title="1. 实例引入"></a>1. 实例引入</h3><p>说了这么多，可能我们对它到底是个什么还是比较模糊，下面就用几个实例来看一下正则表达式的用法。</p><p>打开开源中国提供的正则表达式测试工具 <a href="http://tool.oschina.net/regex/">http://tool.oschina.net/regex/</a>，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。例如，这里输入待匹配的文本，具体如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>Hello, my phone number is 010-86432100 and email is <a href="mailto:&#99;&#x71;&#x63;&#x40;&#99;&#x75;&#105;&#113;&#x69;&#110;&#103;&#99;&#x61;&#105;&#46;&#x63;&#111;&#x6d;">&#99;&#x71;&#x63;&#x40;&#99;&#x75;&#105;&#113;&#x69;&#110;&#103;&#99;&#x61;&#105;&#46;&#x63;&#111;&#x6d;</a>, and my website is <a href="https://cuiqingcai.com/">https://cuiqingcai.com</a></td></tr></tbody></table><p>这段字符串中包含了一个电话号码和一个电子邮件和一个 URL，接下来就尝试用正则表达式提取出来，如图所示。</p><p>在网页右侧选择「匹配 Email 地址」，就可以看到下方出现了文本中的 E-mail。</p><p><img src="https://cdn.cuiqingcai.com/lsdsz.png"></p><p>如果选择「匹配网址 URL」，就可以看到下方出现了文本中的 URL。</p><p>在网页右侧选择 “匹配 Email 地址”，就可以看到下方出现了文本中的 E-mail。如果选择 “匹配网址 URL”，就可以看到下方出现了文本中的 URL。是不是非常神奇？</p><p><img src="https://cdn.cuiqingcai.com/ijr13.png"></p><p>其实，这里就是用了正则表达式匹配，也就是用一定的规则将特定的文本提取出来。比如，电子邮件开头是一段字符串，然后是一个 <code>@</code> 符号，最后是某个域名，这是有特定的组成格式的。另外，对于 URL，开头是协议类型，然后是冒号加双斜线，最后是域名加路径。</p><p>对于 URL 来说，可以用下面的正则表达式匹配：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[a-zA-z]+:&#x2F;&#x2F;[^\s]*</td></tr></tbody></table><p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似 URL 的文本，就会被提取出来。</p><p>这个正则表达式看上去是乱糟糟的一团，其实不然，这里面都是有特定的语法规则的。比如，<code>a-z</code> 代表匹配任意的小写字母，<code>\s</code> 表示匹配任意的空白字符，<code>*</code> 就代表匹配前面的字符任意多个，这一长串的正则表达式就是这么多匹配规则的组合。</p><p>写好正则表达式后，就可以拿它去一个长字符串里匹配查找了。不论这个字符串里面有什么，只要符合我们写的规则，统统可以找出来。对于网页来说，如果想找出网页源代码里有多少 URL，用匹配 URL 的正则表达式去匹配即可。</p><p>上面我们说了几个匹配规则，表 2- 列出了常用的匹配规则。</p><p>表 2- 常用的匹配规则</p><table><thead><tr><th>模　　式</th><th>描　　述</th></tr></thead><tbody><tr><td><code>\w</code></td><td>匹配字母、数字及下划线</td></tr><tr><td><code>\W</code></td><td>匹配不是字母、数字及下划线的字符</td></tr><tr><td><code>\s</code></td><td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td></tr><tr><td><code>\S</code></td><td>匹配任意非空字符</td></tr><tr><td><code>\d</code></td><td>匹配任意数字，等价于 <code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配任意非数字的字符</td></tr><tr><td><code>\A</code></td><td>匹配字符串开头</td></tr><tr><td><code>\Z</code></td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td><code>\z</code></td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td><code>\G</code></td><td>匹配最后匹配完成的位置</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符</td></tr><tr><td><code>^</code></td><td>匹配一行字符串的开头</td></tr><tr><td><code>$</code></td><td>匹配一行字符串的结尾</td></tr><tr><td><code>.</code></td><td>匹配任意字符，除了换行符，当 <code>re.DOTALL</code> 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td><code>[...]</code></td><td>用来表示一组字符，单独列出，比如 <code>[amk]</code> 匹配 <code>a</code>、<code>m</code> 或 <code>k</code></td></tr><tr><td><code>[^...]</code></td><td>不在 <code>[]</code> 中的字符，比如 匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 之外的字符</td></tr><tr><td><code>*</code></td><td>匹配 0 个或多个表达式</td></tr><tr><td><code>+</code></td><td>匹配 1 个或多个表达式</td></tr><tr><td><code>?</code></td><td>匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td><code>&#123;n&#125;</code></td><td>精确匹配 n 个前面的表达式</td></tr><tr><td><code>&#123;n, m&#125;</code></td><td>匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>&#96;a</td><td>b&#96;</td></tr><tr><td><code>()</code></td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table><p>看完了之后，可能有点晕晕的吧，不过不用担心，后面我们会详细讲解一些常见规则的用法。</p><p>其实正则表达式不是 Python 独有的，它也可以用在其他编程语言中。Python 的 re 库提供了整个正则表达式的实现，利用这个库，可以在 Python 中使用正则表达式。在 Python 中写正则表达式几乎都用这个库，下面就来了解它的一些常用方法。</p><h2 id="2-match"><a href="#2-match" class="headerlink" title="2. match"></a><a href="https://cuiqingcai.com/202223.html#2-match" title="2. match"></a>2. <code>match</code></h2><p>这里首先介绍第一个常用的匹配方法 —— <code>match</code>，向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p><p><code>match</code> 方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回 <code>None</code>。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘Hello 123 4567 World_This is a Regex Demo’  <br>print(len(content))  <br>result &#x3D; re.match(‘^Hello\s\d\d\d\s\d{4}\s\w{10}’, content)  <br>print(result)  <br>print(result.group())  <br>print(result.span())</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>41  <br>&lt;_sre.SRE_Match object; span&#x3D;(0, 25), match&#x3D;’Hello 123 4567 World_This’&gt;  <br>Hello 123 4567 World_This  <br>(0, 25)</td></tr></tbody></table><p>这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>^Hello\s\d\d\d\s\d{4}\s\w{10}</td></tr></tbody></table><p>用它来匹配这个长字符串。开头的 <code>^</code> 是匹配字符串的开头，也就是以 <code>Hello</code> 开头；然后 <code>\s</code> 匹配空白字符，用来匹配目标字符串的空格；<code>\d</code> 匹配数字，3 个 <code>\d</code> 匹配 <code>123</code>；然后再写 1 个 <code>\s</code> 匹配空格；后面还有 <code>4567</code>，我们其实可以依然用 4 个 <code>\d</code> 来匹配，但是这么写比较烦琐，所以后面可以跟 <code>&#123;4&#125;</code> 以代表匹配前面的规则 4 次，也就是匹配 4 个数字；后面再紧接 1 个空白字符，最后的 <code>\w&#123;10&#125;</code> 匹配 10 个字母及下划线。我们注意到，这里其实并没有把目标字符串匹配完，不过这样依然可以进行匹配，只不过匹配结果短一点而已。</p><p>而在 <code>match</code> 方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。</p><p>打印输出结果，可以看到结果是 <code>SRE_Match</code> 对象，这证明成功匹配。该对象有两个方法：<code>group</code> 方法可以输出匹配到的内容，结果是 <code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code> 方法可以输出匹配的范围，结果是 <code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p><p>通过上面的例子，我们基本了解了如何在 Python 中使用正则表达式来匹配一段文字。</p><h3 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a><a href="https://cuiqingcai.com/202223.html#%E5%8C%B9%E9%85%8D%E7%9B%AE%E6%A0%87" title="匹配目标"></a>匹配目标</h3><p>刚才我们用 <code>match</code> 方法得到匹配到的字符串内容，但是如果想从字符串中提取一部分内容，该怎么办呢？就像最前面的实例一样，从一段文本中提取出邮件或电话号码等内容。</p><p>这里可以使用括号 <code>()</code> 将想提取的子字符串括起来。<code>()</code> 实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用 <code>group</code> 方法传入分组的索引即可获取提取的结果。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘Hello 1234567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^Hello\s(\d+)\sWorld’, content)  <br>print(result)  <br>print(result.group())  <br>print(result.group(1))  <br>print(result.span())</td></tr></tbody></table><p>这里我们想把字符串中的 <code>1234567</code> 提取出来，此时可以将数字部分的正则表达式用 <code>()</code> 括起来，然后调用了 <code>group(1)</code> 获取匹配结果。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;_sre.SRE_Match object; span&#x3D;(0, 19), match&#x3D;’Hello 1234567 World’&gt;  <br>Hello 1234567 World  <br>1234567  <br>(0, 19)</td></tr></tbody></table><p>可以看到，我们成功得到了 <code>1234567</code>。这里用的是 <code>group(1)</code>，它与 <code>group()</code> 有所不同，后者会输出完整的匹配结果，而前者会输出第一个被 <code>()</code> 包围的匹配结果。假如正则表达式后面还有 <code>()</code> 包括的内容，那么可以依次用 <code>group(2)</code>、<code>group(3)</code> 等来获取。</p><h3 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a><a href="https://cuiqingcai.com/202223.html#%E9%80%9A%E7%94%A8%E5%8C%B9%E9%85%8D" title="通用匹配"></a>通用匹配</h3><p>刚才我们写的正则表达式其实比较复杂，出现空白字符我们就写 <code>\s</code> 匹配，出现数字我们就用 <code>\d</code> 匹配，这样的工作量非常大。其实完全没必要这么做，因为还有一个万能匹配可以用，那就是 <code>.*</code>。其中 <code>.</code> 可以匹配任意字符（除换行符），<code>*</code> 代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符匹配了。</p><p>接着上面的例子，我们可以改写一下正则表达式：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘Hello 123 4567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^Hello.*Demo$’, content)  <br>print(result)  <br>print(result.group())  <br>print(result.span())</td></tr></tbody></table><p>这里我们将中间部分直接省略，全部用 <code>.*</code> 来代替，最后加一个结尾字符串就好了。运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;_sre.SRE_Match object; span&#x3D;(0, 41), match&#x3D;’Hello 123 4567 World_This is a Regex Demo’&gt;  <br>Hello 123 4567 World_This is a Regex Demo  <br>(0, 41)</td></tr></tbody></table><p>可以看到，<code>group</code> 方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容；<code>span</code> 方法输出 <code>(0, 41)</code>，这是整个字符串的长度。</p><p>因此，我们可以使用 <code>.*</code> 简化正则表达式的书写。</p><h3 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a><a href="https://cuiqingcai.com/202223.html#%E8%B4%AA%E5%A9%AA%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA" title="贪婪与非贪婪"></a>贪婪与非贪婪</h3><p>使用上面的通用匹配 <code>.*</code> 时，可能有时候匹配到的并不是我们想要的结果。看下面的例子：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘Hello 1234567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^He.*(\d+).*Demo$’, content)  <br>print(result)  <br>print(result.group(1))</td></tr></tbody></table><p>这里我们依然想获取中间的数字，所以中间依然写的是 <code>(\d+)</code>。而数字两侧由于内容比较杂乱，所以想省略来写，都写成 <code>.*</code>。最后，组成 <code>^He.*(\d+).*Demo$</code>，看样子并没有什么问题。我们看下运行结果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;_sre.SRE_Match object; span&#x3D;(0, 40), match&#x3D;’Hello 1234567 World_This is a Regex Demo’&gt;  <br>7</td></tr></tbody></table><p>奇怪的事情发生了，我们只得到了 7 这个数字，这是怎么回事呢？</p><p>这里就涉及贪婪匹配与非贪婪匹配的问题了。在贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符。正则表达式中 <code>.*</code> 后面是 <code>\d+</code>，也就是至少一个数字，并没有指定具体多少个数字，因此，<code>.*</code> 就尽可能匹配多的字符，这里就把 <code>123456</code> 匹配了，给 <code>\d+</code> 留下一个可满足条件的数字 7，最后得到的内容就只有数字 7 了。</p><p>但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是 <code>.*?</code>，多了一个 <code>?</code>，那么它可以达到怎样的效果？我们再用实例看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘Hello 1234567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^He.*?(\d+).*Demo$’, content)  <br>print(result)  <br>print(result.group(1))</td></tr></tbody></table><p>这里我们只是将第一个<code>.*</code> 改成了 <code>.*?</code>，转变为非贪婪匹配。结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;_sre.SRE_Match object; span&#x3D;(0, 40), match&#x3D;’Hello 1234567 World_This is a Regex Demo’&gt;  <br>1234567</td></tr></tbody></table><p>此时就可以成功获取 <code>1234567</code> 了。原因可想而知，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当 <code>.*?</code> 匹配到 <code>Hello</code> 后面的空白字符时，再往后的字符就是数字了，而 <code>\d+</code> 恰好可以匹配，那么这里 <code>.*?</code> 就不再进行匹配，交给 <code>\d+</code> 去匹配后面的数字。所以这样 <code>.*?</code> 匹配了尽可能少的字符，<code>\d+</code> 的结果就是 <code>1234567</code>了。</p><p>所以说，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 <code>.*?</code> 来代替 <code>.*</code>，以免出现匹配结果缺失的情况。</p><p>但这里需要注意，如果匹配的结果在字符串结尾，<code>.*?</code> 就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘<a href="http://weibo.com/comment/kEraCN">http://weibo.com/comment/kEraCN</a>‘  <br>result1 &#x3D; re.match(‘http.<em>?comment&#x2F;(.</em>?)’, content)  <br>result2 &#x3D; re.match(‘http.<em>?comment&#x2F;(.</em>)’, content)  <br>print(‘result1’, result1.group(1))  <br>print(‘result2’, result2.group(1))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result1  <br>result2 kEraCN</td></tr></tbody></table><p>可以观察到，<code>.*?</code> 没有匹配到任何结果，而 <code>.*</code> 则尽量匹配多的内容，成功得到了匹配结果。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a href="https://cuiqingcai.com/202223.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6" title="修饰符"></a>修饰符</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配模式。修饰符被指定为一个可选的标志。我们用实例来看一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘’’Hello 1234567 World_This  <br>is a Regex Demo  <br>‘’’  <br>result &#x3D; re.match(‘^He.<em>?(\d+).</em>?Demo$’, content)  <br>print(result.group(1))</td></tr></tbody></table><p>和上面的例子相仿，我们在字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>AttributeError Traceback (most recent call last)  <br><ipython-input-18-c7d232b39645> in <module>()  <br>      5 ‘’’  <br>      6 result &#x3D; re.match(‘^He.<em>?(\d+).</em>?Demo$’, content)  <br>—-&gt; 7 print(result.group(1))  <br>  <br>AttributeError: ‘NoneType’ object has no attribute ‘group’</td></tr></tbody></table><p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为 <code>None</code>，而我们又调用了 <code>group</code> 方法导致 <code>AttributeError</code>。</p><p>那么，为什么加了一个换行符，就匹配不到了呢？这是因为。匹配的是除换行符之外的任意字符，当遇到换行符时，<code>.*?</code> 就不能匹配了，所以导致匹配失败。这里只需加一个修饰符 <code>re.S</code>，即可修正这个错误：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result &#x3D; re.match(‘^He.<em>?(\d+).</em>?Demo$’, content, re.S)</td></tr></tbody></table><p>这个修饰符的作用是使。匹配包括换行符在内的所有字符。此时运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>1234567</td></tr></tbody></table><p>这个 <code>re.S</code> 在网页匹配中经常用到。因为 HTML 节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p><p>另外，还有一些修饰符，在必要的情况下也可以使用，如表 2- 所示。</p><p>表 2- 修饰符及其描述</p><table><thead><tr><th>修饰符</th><th>描　　述</th></tr></thead><tbody><tr><td><code>re.I</code></td><td>使匹配对大小写不敏感</td></tr><tr><td><code>re.L</code></td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td><code>re.M</code></td><td>多行匹配，影响 <code>^</code> 和 <code>$</code></td></tr><tr><td><code>re.S</code></td><td>使。匹配包括换行符在内的所有字符</td></tr><tr><td><code>re.U</code></td><td>根据 Unicode 字符集解析字符。这个标志影响 <code>\w</code>、<code>\W</code>、<code>\b</code> 和 <code>\B</code></td></tr><tr><td><code>re.X</code></td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td></tr></tbody></table><p>在网页匹配中，较为常用的有 <code>re.S</code> 和 <code>re.I</code>。</p><h3 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a><a href="https://cuiqingcai.com/202223.html#%E8%BD%AC%E4%B9%89%E5%8C%B9%E9%85%8D" title="转义匹配"></a>转义匹配</h3><p>我们知道正则表达式定义了许多匹配模式，如 <code>.</code> 匹配除换行符以外的任意字符，但是如果目标字符串里面就包含 <code>.</code>，那该怎么办呢？</p><p>这里就需要用到转义匹配了，示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘(百度) <a href="http://www.baidu.com/">www.baidu.com</a>‘  <br>result &#x3D; re.match(‘(百度 ) www.baidu.com’, content)  <br>print(result)</td></tr></tbody></table><p>当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例如可以用 <code>\.</code> 来匹配 <code>.</code>，运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;_sre.SRE_Match object; span&#x3D;(0, 17), match&#x3D;’(百度) <a href="http://www.baidu.com'>">www.baidu.com&#39;&gt;</a></td></tr></tbody></table><p>可以看到，这里成功匹配到了原字符串。</p><p>这些是写正则表达式常用的几个知识点，熟练掌握它们对后面写正则表达式非常有帮助。</p><h2 id="3-search"><a href="#3-search" class="headerlink" title="3. search"></a><a href="https://cuiqingcai.com/202223.html#3-search" title="3. search"></a>3. <code>search</code></h2><p>前面提到过，<code>match</code> 方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了。我们看下面的例子：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘Extra stings Hello 1234567 World_This is a Regex Demo Extra stings’  <br>result &#x3D; re.match(‘Hello.<em>?(\d+).</em>?Demo’, content)  <br>print(result)</td></tr></tbody></table><p>这里的字符串以 <code>Extra</code> 开头，但是正则表达式以 <code>Hello</code> 开头，整个正则表达式是字符串的一部分，但是这样匹配是失败的。运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>None</td></tr></tbody></table><p>因为 <code>match</code> 方法在使用时需要考虑到开头的内容，这在做匹配时并不方便。它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p><p>这里就有另外一个方法 <code>search</code>，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。也就是说，正则表达式可以是字符串的一部分，在匹配时，<code>search</code> 方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回 <code>None</code>。</p><p>我们把上面代码中的 <code>match</code> 方法修改成 <code>search</code>，再看一下运行结果：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;_sre.SRE_Match object; span&#x3D;(13, 53), match&#x3D;’Hello 1234567 World_This is a Regex Demo’&gt;  <br>1234567</td></tr></tbody></table><p>这时就得到了匹配结果。</p><p>因此，为了匹配方便，我们可以尽量使用 <code>search</code> 方法。</p><p>下面再用几个实例来看看 <code>search</code> 方法的用法。</p><p>首先，这里有一段待匹配的 HTML 文本，接下来写几个正则表达式实例来实现相应信息的提取：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>html &#x3D; ‘’’  <br><div id="songs-list">  <br>  <h2 class="title">经典老歌</h2>  <br>  <p class="introduction">经典老歌列表</p>  <br>  <ul id="list" class="list-group">  <br>    <li data-view="2">一路上有你</li>  <br>    <li data-view="7">  <br>      <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>  <br>    </li>  <br>    <li data-view="4" class="active">  <br>      <a href="/3.mp3" singer="齐秦">往事随风</a>  <br>    </li>  <br>    <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>  <br>    <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>  <br>    <li data-view="5">  <br>      <a href="/6.mp3" singer="邓丽君">但愿人长久</a>  <br>    </li>  <br>  </ul>  <br></div>  <br>‘’’</td></tr></tbody></table><p>可以观察到，<code>ul</code> 节点里有许多 <code>li</code> 节点，其中 <code>li</code> 节点中有的包含 <code>a</code> 节点，有的不包含 <code>a</code> 节点，<code>a</code> 节点还有一些相应的属性 —— 超链接和歌手名。</p><p>首先，我们尝试提取 <code>class</code> 为 <code>active</code> 的 <code>li</code> 节点内部的超链接包含的歌手名和歌名，此时需要提取第三个 <code>li</code> 节点下 <code>a</code> 节点的 <code>singer</code> 属性和文本。</p><p>此时正则表达式可以以 <code>li</code> 开头，然后寻找一个标志符 <code>active</code>，中间的部分可以用 <code>.*?</code> 来匹配。接下来，要提取 <code>singer</code> 这个属性值，所以还需要写入 <code>singer=&quot;(.*?)&quot;</code>，这里需要提取的部分用小括号括起来，以便用 <code>group</code> 方法提取出来，它的两侧边界是双引号。然后还需要匹配 <code>a</code> 节点的文本，其中它的左边界是 <code>&gt;</code>，右边界是 <code>&lt;/a&gt;</code>。然后目标内容依然用 <code>(.*?)</code> 来匹配，所以最后的正则表达式就变成了：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>&lt;li.<em>?active.<em>?singer&#x3D;”(.</em>?)”&gt;(.</em>?)</a></td></tr></tbody></table><p>然后再调用 <code>search</code> 方法，它会搜索整个 HTML 文本，找到符合正则表达式的第一个内容返回。</p><p>另外，由于代码有换行，所以这里第三个参数需要传入 <code>re.S</code>。整个匹配代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result &#x3D; re.search(‘&lt;li.<em>?active.<em>?singer&#x3D;”(.</em>?)”&gt;(.</em>?)</a>‘, html, re.S)  <br>if result:  <br>    print(result.group(1), result.group(2))</td></tr></tbody></table><p>由于需要获取的歌手和歌名都已经用小括号包围，所以可以用 <code>group</code> 方法获取。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>齐秦 往事随风</td></tr></tbody></table><p>可以看到，这正是 <code>class</code> 为 <code>active</code> 的 <code>li</code> 节点内部的超链接包含的歌手名和歌名。</p><p>如果正则表达式不加 <code>active</code>（也就是匹配不带 <code>class</code> 为 <code>active</code> 的节点内容），那会怎样呢？我们将正则表达式中的 <code>active</code> 去掉，代码改写如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result &#x3D; re.search(‘&lt;li.<em>?singer&#x3D;”(.*?)”&gt;(.</em>?)</a>‘, html, re.S)  <br>if result:  <br>    print(result.group(1), result.group(2))</td></tr></tbody></table><p>由于 <code>search</code> 方法会返回第一个符合条件的匹配目标，这里结果就变了：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>任贤齐 沧海一声笑</td></tr></tbody></table><p>把 <code>active</code> 标签去掉后，从字符串开头开始搜索，此时符合条件的节点就变成了第二个 <code>li</code> 节点，后面的就不再匹配，所以运行结果就变成第二个 <code>li</code> 节点中的内容了。</p><p>注意，在上面的两次匹配中，<code>search</code> 方法的第三个参数都加了 <code>re.S</code>，这使得 <code>.*?</code> 可以匹配换行，所以含有换行符的 <code>li</code> 节点被匹配到了。如果我们将其去掉，结果会是什么？代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>result &#x3D; re.search(‘&lt;li.<em>?singer&#x3D;”(.*?)”&gt;(.</em>?)</a>‘, html)  <br>if result:  <br>    print(result.group(1), result.group(2))</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>beyond 光辉岁月</td></tr></tbody></table><p>可以看到，结果变成了第四个 <code>li</code> 节点的内容。这是因为第二个和第三个 <code>li</code> 节点都包含了换行符，去掉 <code>re.S</code> 之后，<code>.*?</code> 已经不能匹配换行符，所以正则表达式不会匹配到第二个和第三个 <code>li</code> 节点，而第四个 <code>li</code> 节点中不包含换行符，所以成功匹配。</p><p>由于绝大部分的 HTML 文本都包含了换行符，所以尽量都需要加上 <code>re.S</code> 修饰符，以免出现匹配不到的问题。</p><h2 id="4-findall"><a href="#4-findall" class="headerlink" title="4. findall"></a><a href="https://cuiqingcai.com/202223.html#4-findall" title="4. findall"></a>4. <code>findall</code></h2><p>前面我们介绍了 <code>search</code> 方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要获取匹配正则表达式的所有内容，那该怎么办呢？这时就要借助 <code>findall</code> 方法了。该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p><p>还是上面的 HTML 文本，如果想获取所有 <code>a</code> 节点的超链接、歌手和歌名，就可以将 <code>search</code> 方法换成 <code>findall</code> 方法。如果有返回结果的话，就是列表类型，所以需要遍历一下来依次获取每组内容。代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>results &#x3D; re.findall(‘&lt;li.<em>?href&#x3D;”(.<em>?)”.</em>?singer&#x3D;”(.*?)”&gt;(.</em>?)</a>‘, html, re.S)  <br>print(results)  <br>print(type(results))  <br>for result in results:  <br>    print(result)  <br>    print(result[0], result[1], result[2])</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>[(‘&#x2F;2.mp3’, ‘ 任贤齐 ‘, ‘ 沧海一声笑 ‘), (‘&#x2F;3.mp3’, ‘ 齐秦 ‘, ‘ 往事随风 ‘), (‘&#x2F;4.mp3’, ‘beyond’, ‘ 光辉岁月 ‘), (‘&#x2F;5.mp3’, ‘ 陈慧琳 ‘, ‘ 记事本 ‘), (‘&#x2F;6.mp3’, ‘ 邓丽君 ‘, ‘ 但愿人长久 ‘)]  <br>&lt;class ‘list’&gt;  <br>(‘&#x2F;2.mp3’, ‘ 任贤齐 ‘, ‘ 沧海一声笑 ‘)  <br>&#x2F;2.mp3 任贤齐 沧海一声笑  <br>(‘&#x2F;3.mp3’, ‘ 齐秦 ‘, ‘ 往事随风 ‘)  <br>&#x2F;3.mp3 齐秦 往事随风  <br>(‘&#x2F;4.mp3’, ‘beyond’, ‘ 光辉岁月 ‘)  <br>&#x2F;4.mp3 beyond 光辉岁月  <br>(‘&#x2F;5.mp3’, ‘ 陈慧琳 ‘, ‘ 记事本 ‘)  <br>&#x2F;5.mp3 陈慧琳 记事本  <br>(‘&#x2F;6.mp3’, ‘ 邓丽君 ‘, ‘ 但愿人长久 ‘)  <br>&#x2F;6.mp3 邓丽君 但愿人长久</td></tr></tbody></table><p>可以看到，返回的列表中的每个元素都是元组类型，我们用对应的索引依次取出即可。</p><p>如果只是获取第一个内容，可以用 <code>search</code> 方法。当需要提取多个内容时，可以用 <code>findall</code> 方法。</p><h2 id="5-sub"><a href="#5-sub" class="headerlink" title="5. sub"></a><a href="https://cuiqingcai.com/202223.html#5-sub" title="5. sub"></a>5. <code>sub</code></h2><p>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的 <code>replace</code> 方法，那就太烦琐了，这时可以借助 <code>sub</code> 方法。示例如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content &#x3D; ‘54aK54yr5oiR54ix5L2g’  <br>content &#x3D; re.sub(‘\d+’, ‘’, content)  <br>print(content)</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>aKyroiRixLg</td></tr></tbody></table><p>这里只需要给第一个参数传入 <code>\d+</code> 来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串。</p><p>在上面的 HTML 文本中，如果想获取所有 <code>li</code> 节点的歌名，直接用正则表达式来提取可能比较烦琐。比如，可以写成这样子：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>results &#x3D; re.findall(‘&lt;li.<em>?&gt;\s</em>?(&lt;a.<em>?&gt;)?(\w+)(</a>)?\s</em>?</li>‘, html, re.S)  <br>for result in results:  <br>    print(result[1])</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>一路上有你  <br>沧海一声笑  <br>往事随风  <br>光辉岁月  <br>记事本  <br>但愿人长久</td></tr></tbody></table><p>此时借助 <code>sub</code> 方法就比较简单了。可以先用 <code>sub</code> 方法将 <code>a</code> 节点去掉，只留下文本，然后再利用 <code>findall</code> 提取就好了：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>html &#x3D; re.sub(‘&lt;a.<em>?&gt;|</a>‘, ‘’, html)  <br>print(html)  <br>results &#x3D; re.findall(‘&lt;li.*?&gt;(.</em>?)</li>‘, html, re.S)  <br>for result in results:  <br>    print(result.strip())</td></tr></tbody></table><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><div id="songs-list">  <br>    <h2 class="title"> 经典老歌 </h2>  <br>    <p class="introduction">  <br>        经典老歌列表  <br>    </p>  <br>    <ul id="list" class="list-group">  <br>        <li data-view="2"> 一路上有你 </li>  <br>        <li data-view="7">  <br>            沧海一声笑  <br>        </li>  <br>        <li data-view="4" class="active">  <br>            往事随风  <br>        </li>  <br>        <li data-view="6"> 光辉岁月 </li>  <br>        <li data-view="5"> 记事本 </li>  <br>        <li data-view="5">  <br>            但愿人长久  <br>        </li>  <br>    </ul>  <br></div>  <br>一路上有你  <br>沧海一声笑  <br>往事随风  <br>光辉岁月  <br>记事本  <br>但愿人长久</td></tr></tbody></table><p>可以看到，<code>a</code> 节点经过 <code>sub</code> 方法处理后就没有了，然后再通过 <code>findall</code> 方法直接提取即可。可以看到，在适当的时候，借助 <code>sub</code> 方法可以起到事半功倍的效果。</p><h2 id="6-compile"><a href="#6-compile" class="headerlink" title="6. compile"></a><a href="https://cuiqingcai.com/202223.html#6-compile" title="6. compile"></a>6. <code>compile</code></h2><p>前面所讲的方法都是用来处理字符串的方法，最后再介绍一下 <code>compile</code> 方法，这个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。示例代码如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>import re  <br>  <br>content1 &#x3D; ‘2019-12-15 12:00’  <br>content2 &#x3D; ‘2019-12-17 12:55’  <br>content3 &#x3D; ‘2019-12-22 13:21’  <br>pattern &#x3D; re.compile(‘\d{2}:\d{2}’)  <br>result1 &#x3D; re.sub(pattern, ‘’, content1)  <br>result2 &#x3D; re.sub(pattern, ‘’, content2)  <br>result3 &#x3D; re.sub(pattern, ‘’, content3)  <br>print(result1, result2, result3)</td></tr></tbody></table><p>例如，这里有 3 个日期，我们想分别将 3 个日期中的时间去掉，这时可以借助 <code>sub</code> 方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写 3 个同样的正则表达式，此时可以借助 <code>compile</code> 方法将正则表达式编译成一个正则表达式对象，以便复用。</p><p>运行结果如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>2019-12-15  2019-12-17  2019-12-22</td></tr></tbody></table><p>另外，<code>compile</code> 还可以传入修饰符，例如 <code>re.S</code> 等修饰符，这样在 <code>search</code>、<code>findall</code> 等方法中就不需要额外传了。所以，<code>compile</code> 方法可以说是给正则表达式做了一层封装，以便我们更好地复用。</p><h2 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a><a href="https://cuiqingcai.com/202223.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>到此为止，正则表达式的基本用法就介绍完了，后面会通过具体的实例来讲解正则表达式的用法。</p><p>本节代码：<a href="https://github.com/Python3WebSpider/RegexTest%E3%80%82">https://github.com/Python3WebSpider/RegexTest。</a></p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>03高级语言</category>
      
      <category>Python</category>
      
      <category>python爬虫学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路定理与等效</title>
    <link href="/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E7%AD%89%E6%95%88/"/>
    <url>/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E7%AD%89%E6%95%88/</url>
    
    <content type="html"><![CDATA[<ol><li>核心定理​**​<ul><li>​​叠加定理​​：独立源单独作用后叠加（受控源保留）</li><li>​​源变换​​：电压源串联电阻 ↔ 电流源并联电阻</li><li>​​戴维宁定理​​：Vth​&#x3D;Voc​，Rth​&#x3D;Isc​Voc​​</li><li>​​诺顿定理​​：In​&#x3D;Isc​，Rn​&#x3D;Rth​</li><li>​​最大功率传输​​：RL​&#x3D;Rth​，Pmax​&#x3D;4Rth​Vth2​​</li></ul></li></ol><ul><li>​​</li></ul><ol start="2"><li><p>动态元件特性​​</p><p> |元件|电压-电流关系|能量存储|串并联等效|<br> |—|—|—|—|<br> |电容|iC​&#x3D;Cdtdv​|WC​&#x3D;21​Cv2|串联：Ceq​1​&#x3D;∑Ci​1​|<br> |电感|vL​&#x3D;Ldtdi​|WL​&#x3D;21​Li2|并联：Leq​1​&#x3D;∑Li​1​||</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路定理与等效</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路基本概念</title>
    <link href="/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="电路基础概念​​"><a href="#电路基础概念​​" class="headerlink" title="电路基础概念​​"></a><strong>电路基础概念​</strong>​</h3><ol><li><p>​<strong>​基本物理量​</strong>​</p><ul><li>电流：i&#x3D;dtdq​</li><li>电流密度：J&#x3D;AI​&#x3D;σE</li><li>电压：v&#x3D;dqdw​</li><li>电阻：R&#x3D;Aρl​</li><li>功率：p&#x3D;vi（功率正负由电流流向和电压极性决定）</li></ul></li><li><p>​<strong>​元件连接规则​</strong>​</p><ul><li>串联电阻：Req​&#x3D;∑Ri​</li><li>并联电阻：Req​1​&#x3D;∑Ri​1​</li><li>电压源串联：合并需无并联电阻</li><li>电流源并联：合并需无串联电阻</li></ul></li></ol><hr><h3 id="电路信号与函数​​"><a href="#电路信号与函数​​" class="headerlink" title="电路信号与函数​​"></a>电路信号与函数​​</h3><ol><li><p>​<strong>​基本信号类型​</strong>​</p><table><thead><tr><th>信号</th><th>表达式</th><th>特性</th></tr></thead><tbody><tr><td>阶跃函数</td><td>u(t)</td><td>t&lt;0时为0，t≥0时为1</td></tr><tr><td>斜坡函数</td><td>r(t)&#x3D;t⋅u(t)</td><td>线性增长</td></tr><tr><td>指数衰减</td><td>f(t)&#x3D;e−at</td><td>衰减速率由a决定</td></tr><tr><td>狄拉克函数</td><td>δ(t)</td><td>∫f(t)δ(t−a)dt&#x3D;f(a)</td></tr></tbody></table></li><li><p>​<strong>​信号合成与绘图​</strong>​</p><ul><li>分段函数示例：f(t)&#x3D;2tu(t)−4(t−1)u(t−1)+…</li><li>方波&#x2F;三角波：用阶跃函数组合表示</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路基本概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目录挂载</title>
    <link href="/Blogs/2025/08/28/%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD/"/>
    <url>/Blogs/2025/08/28/%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h1><h3 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h3><ul><li>使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很是麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><blockquote><p>目录挂载解决以上问题</p></blockquote><blockquote><p>本文档课件配套 <a href="https://www.bilibili.com/video/BV11L411g7U1?p=4">视频教程</a></p></blockquote><h3 id="几种挂载方式"><a href="#几种挂载方式" class="headerlink" title="几种挂载方式"></a>几种挂载方式</h3><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p>文档参考：<a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p><p><img src="https://cos.easydoc.net/46901064/files/kv96dc4q.png" alt="image.png"></p><h3 id="挂载演示"><a href="#挂载演示" class="headerlink" title="挂载演示"></a>挂载演示</h3><p><code>bind mount</code> 方式用绝对路径 <code>-v D:/code:/app</code></p><p><code>volume</code> 方式，只需要一个名字 <code>-v db-data:/app</code></p><p>示例：<br><code>docker run -p 8080:8080 --name test-hello -v D:/code:/app -d test:v1</code></p><blockquote><p>注意！<br>因为挂载后，容器里的代码就会替换为你本机的代码了，如果你代码目录没有<code>node_modules</code>目录，你需要在代码目录执行下<code>npm install --registry=https://registry.npm.taobao.org</code>确保依赖库都已经安装，否则可能会提示“Error: Cannot find module ‘koa’”<br>如果你的电脑没有安装 <a href="https://nodejs.org/en/">nodejs</a>，你需要安装一下才能执行上面的命令。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录挂载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/Blogs/2025/08/28/%E7%9F%A9%E9%98%B5/"/>
    <url>/Blogs/2025/08/28/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="矩阵基础​​"><a href="#矩阵基础​​" class="headerlink" title="矩阵基础​​"></a><strong>矩阵基础​</strong>​</h3><ol><li><p>​<strong>​特殊矩阵类型​</strong>​</p><ul><li>对角阵、零矩阵、单位阵（含初等矩阵、置换矩阵）</li><li>对称矩阵（AT&#x3D;A）、三角矩阵</li><li>行阶梯矩阵（Reduced echelon form 需化简至主元为1且上下清零）</li></ul></li><li><p>​<strong>​矩阵运算​</strong>​</p><ul><li>​<strong>​乘法规则​</strong>​：C&#x3D;AB（行×列），分块乘法（子矩阵维度需匹配）</li><li>​<strong>​性质​</strong>​：结合律&#x2F;分配律成立，但​<strong>​无交换律​</strong>​⚠️、无消去律</li><li>​<strong>​初等变换​</strong>​：行交换、数乘行、行加减（列变换同理）</li></ul></li><li><p>​<strong>​逆矩阵​</strong>​</p><ul><li>​<strong>​可逆条件​</strong>​：A 满秩（行列式detA&#x3D;0）</li><li>​<strong>​求法​</strong>​：<ul><li>_数值矩阵_：Gauss-Jordan法（[A∣I]→[I∣A−1]）</li><li>_抽象矩阵_：利用 AB&#x3D;I 或分解法（如 A&#x3D;(I−B)−1）</li></ul></li><li>​<strong>​性质​</strong>​：(AB)−1&#x3D;B−1A−1，(kA)−1&#x3D;k−1A−1（k&#x3D;0）</li></ul></li><li><p>​<strong>​转置与伴随​</strong>​</p><ul><li>(AB)T&#x3D;BTAT，(AT)−1&#x3D;(A−1)T</li><li>伴随矩阵 A∗：AA∗&#x3D;A∗A&#x3D;(detA)I，∣A∗∣&#x3D;∣A∣n−1</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件实现技术MSI与Verilog</title>
    <link href="/Blogs/2025/08/28/%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AFMSI%E4%B8%8EVerilog/"/>
    <url>/Blogs/2025/08/28/%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AFMSI%E4%B8%8EVerilog/</url>
    
    <content type="html"><![CDATA[<h3 id="四、硬件实现技术"><a href="#四、硬件实现技术" class="headerlink" title="四、硬件实现技术"></a>四、硬件实现技术</h3><ol><li><p>​<strong>​MSI器件应用​</strong>​</p><ul><li>74系列芯片：<ul><li>74x138（3-8译码器）</li><li>74x151（8选1 MUX）</li><li>74x163（同步计数器）</li></ul></li></ul></li><li><p>​<strong>​Verilog设计​</strong>​</p><ul><li>描述层次：<ul><li>数据流（assign语句）</li><li>结构（门级实例化）</li><li>行为（always块）</li></ul></li><li>测试基准（Testbench）：<ul><li>时钟生成</li><li>激励施加</li><li>结果监测</li></ul></li></ul></li></ol><h3 id="五、性能指标"><a href="#五、性能指标" class="headerlink" title="五、性能指标"></a>五、性能指标</h3><ol><li><p>​<strong>​时序参数​</strong>​</p><ul><li>时钟周期&#x2F;频率</li><li>建立&#x2F;保持时间</li><li>关键路径延迟</li></ul></li><li><p>​<strong>​计算指标​</strong>​</p><ul><li>CPI（指令平均周期数）</li><li>MIPS（百万指令&#x2F;秒）</li><li>存储带宽</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件实现技术MSI与Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>积分</title>
    <link href="/Blogs/2025/08/28/%E7%A7%AF%E5%88%86/"/>
    <url>/Blogs/2025/08/28/%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="积分（Integration）​​"><a href="#积分（Integration）​​" class="headerlink" title="积分（Integration）​​"></a><strong>积分（Integration）​</strong>​</h3><p>​<strong>​核心目标：​</strong>​ 计算累积量（面积、体积）、求解反导数。  ​</p><h4 id="​​1-理论基础（Chap-5）​​"><a href="#​​1-理论基础（Chap-5）​​" class="headerlink" title="​​1. 理论基础（Chap 5）​​"></a>​<strong>​1. 理论基础（Chap 5）​</strong>​</h4><ul><li>​<strong>​积分的起源：​</strong>​<ul><li>黎曼和：∑k&#x3D;1n​f(xk∗​)Δx → 面积近似（5.1）。</li><li>Σ记号与求和极限（5.2）。</li></ul></li><li>​<strong>​定积分定义：​</strong>​<ul><li>∫ab​f(x)dx&#x3D;lim∥P∥→0​∑f(xk∗​)Δxk​（5.3）。</li></ul></li></ul><h4 id="​​2-核心定理与方法（Chap-5）​​"><a href="#​​2-核心定理与方法（Chap-5）​​" class="headerlink" title="​​2. 核心定理与方法（Chap 5）​​"></a>​<strong>​2. 核心定理与方法（Chap 5）​</strong>​</h4><ul><li>​<strong>​微积分基本定理（FTC）：​</strong>​<ul><li>​<strong>​FTC1：​</strong>​ dxd​∫ax​f(t)dt&#x3D;f(x)（5.4）。</li><li>​<strong>​FTC2：​</strong>​ ∫ab​f(x)dx&#x3D;F(b)−F(a)，其中 F′(x)&#x3D;f(x)（5.4）。</li></ul></li><li>​<strong>​积分技巧：​</strong>​<ul><li>不定积分（反导数）：∫f(x)dx&#x3D;F(x)+C（5.5）。</li><li>换元法：∫f(g(x))g′(x)dx&#x3D;∫f(u)du（5.5）。</li><li>定积分换元与曲线间面积（5.6）。</li></ul></li></ul><h4 id="​​3-积分应用（Chap-6）​​"><a href="#​​3-积分应用（Chap-6）​​" class="headerlink" title="​​3. 积分应用（Chap 6）​​"></a>​<strong>​3. 积分应用（Chap 6）​</strong>​</h4><ul><li>​<strong>​几何应用：​</strong>​<ul><li>截面法求体积：V&#x3D;∫ab​A(x)dx（6.1）。</li><li>柱壳法求体积：V&#x3D;2π∫ab​xf(x)dx（6.2）。</li><li>弧长公式：L&#x3D;∫ab​1+(f′(x))2​dx（6.3）。</li><li>旋转体表面积：S&#x3D;2π∫ab​y1+(y′)2​dx（6.4）。</li></ul></li><li>​<strong>​物理应用：​</strong>​<ul><li>变力做功：W&#x3D;∫ab​F(x)dx（6.5）。</li><li>流体静压力：F&#x3D;ρg∫ab​深度⋅宽度 dy（6.5）。</li><li>质心坐标：xˉ&#x3D;M1​∫xdm（6.6）。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微电子专业知识体系</title>
    <link href="/Blogs/2025/08/28/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
    <url>/Blogs/2025/08/28/%E5%BE%AE%E7%94%B5%E5%AD%90%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>[[Microelectronic system嵌入式系统]] ：大一的重要课程，为后面的嵌入式系统做出铺垫</p><p>[[半导体物理]] ： 一旦涉及器件内部工作原理就绕不开，核心是固体物理和量子物理</p><p>[[集成电路设计]] ：通过电路分析基础，将基于半导体物理设计的元件组成电路；主要分为数字和模拟电路，数字电路分为组合电路和时序电路，模拟电路</p><p>[[制造工艺]] ：</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微电子专业知识体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稚晖君笔记</title>
    <link href="/Blogs/2025/08/28/%E7%A8%9A%E6%99%96%E5%90%9B%E7%AC%94%E8%AE%B0/"/>
    <url>/Blogs/2025/08/28/%E7%A8%9A%E6%99%96%E5%90%9B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>高三暑假看到的，现在基本都知道并且会用了-2025.7</p></blockquote><h1 id="WorkFlow"><a href="#WorkFlow" class="headerlink" title="WorkFlow"></a>WorkFlow</h1><h2 id="创意收集与整理软件"><a href="#创意收集与整理软件" class="headerlink" title="创意收集与整理软件"></a>创意收集与整理软件</h2><p>Xmind，Typora，有道云笔记</p><h3 id="创意来源"><a href="#创意来源" class="headerlink" title="创意来源"></a>创意来源</h3><p>想清楚功能与技术路线<br>提前规划好项目的需求与实现路线，不仅能提高项目实现的效率，还能在分享时更加系统地输出</p><h3 id="项目落地"><a href="#项目落地" class="headerlink" title="项目落地"></a>项目落地</h3><p>有道云对Markdown的支持最友好，且私有云图床</p><h2 id="专业类软件"><a href="#专业类软件" class="headerlink" title="专业类软件"></a>专业类软件</h2><h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p>Altium Desinger（AD），Eagle，Fritizing</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>犀牛（3D），参数化精确建模<br>Fuision 360（3D）全能，个人用户免费<br>Autodesk雕刻机刀路文件</p><h3 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h3><p>Visual Studio<br>Android Studio<br>Jet Brain<br>Xshell连接服务器必备</p><p>Bcompare对比代码<br>Arduino硬件开发入门必备</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>新概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>稚晖君笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类脑芯片</title>
    <link href="/Blogs/2025/08/28/%E7%B1%BB%E8%84%91%E8%8A%AF%E7%89%87/"/>
    <url>/Blogs/2025/08/28/%E7%B1%BB%E8%84%91%E8%8A%AF%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>[[类脑芯片简介]]</p><p>兴趣始于 [[GEB]]，主要讲了：</p><blockquote><p><strong>从哥德尔不完全性定理引申到对人脑结构和心智本质的探讨再深入到计算机程序和人工智能</strong>，<strong>介绍了一个同时存在于数理逻辑，分子生物学缠结层次系统，这些内容在巴赫和埃舍尔的作品里有类似的对应物</strong></p></blockquote><p>[[0非线性动力学]] : 一个动力系统的非线性性是混沌的必要条件</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类脑芯片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类脑芯片简介</title>
    <link href="/Blogs/2025/08/28/%E7%B1%BB%E8%84%91%E8%8A%AF%E7%89%87%E7%AE%80%E4%BB%8B/"/>
    <url>/Blogs/2025/08/28/%E7%B1%BB%E8%84%91%E8%8A%AF%E7%89%87%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能背景"><a href="#人工智能背景" class="headerlink" title="人工智能背景"></a>人工智能背景</h1><h2 id="芯片瓶颈"><a href="#芯片瓶颈" class="headerlink" title="芯片瓶颈"></a>芯片瓶颈</h2><p>随着半导体行业进入了22纳米以下的工艺节点，虽然集成密度仍在持续提升，但是计算效果提升效率远不如前，具体原因包括：</p><ol><li><p>计算频率不再增加；</p></li><li><p>晶体管的能量密度逐渐趋缓，导致计算能效逐渐趋缓；</p></li><li><p>晶体管的成本在不同节点之间，几乎持平；在5nm&#x2F;3nm最先进的工艺节点上，单位成本是处于爬升趋势。</p></li></ol><h2 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h2><p>未来的10年是计算架构的黄金十年。他提出了特定领域架构设计思路：<strong>DSA</strong>。针对特定领域，进行可编程处理器的定制研发，从而获得计算加速，达到更好的性能</p><ul><li>沿计算机科学发展而来AI加速器途径</li><li>神经形态计算途径</li></ul><h3 id="AI加速器"><a href="#AI加速器" class="headerlink" title="AI加速器"></a>AI加速器</h3><p>主要是以高效支持当前的深度学习为主要架构优化目标，通过大规模的并行计算提升计算密度，从而获得性能提升，典型的代表包括谷歌的TPU、Graphcore的IPU、阿里的含光800等。</p><p>AI加速器的发展思路，可分为3个方面：</p><p>①计算密度，根据计算特点，开发并行计算能力更强的计算模块；</p><p>②通信带宽，采用带宽更高的通信模式；</p><p>③量身定制，通过计算权重的低精度化和稀疏计算等模式，节省计算开销。</p><h3 id="神经形态架构"><a href="#神经形态架构" class="headerlink" title="神经形态架构"></a>神经形态架构</h3><p>基于脑科学发展而来，通过模拟神经元和突触的典型特征，比如存算一体、脉冲编码、异步计算、动力学模型等特点，希望通过这些模拟从而达到更高的智能水平。其典型代表包括IBM TrueNorth,、Intel Loihi 和基于ARM架构发展而来的SpiNNaker</p><h1 id="类脑计算趋势"><a href="#类脑计算趋势" class="headerlink" title="类脑计算趋势"></a>类脑计算趋势</h1><h2 id="深度学习与脑科学融合"><a href="#深度学习与脑科学融合" class="headerlink" title="深度学习与脑科学融合"></a>深度学习与脑科学融合</h2><p>深度学习和脑科学的发展有着各自的特点。一个是沿着计算机科学的导向，以精确的数值和矩阵计算为主，神经元处于连续值状态。另一个沿着脑模拟的方向发展而来，以0&#x2F;1脉冲序列表达信息流，所以也叫脉冲神经网络，编码里包含了时间信息；另外，神经元内部具有动力学特征，具有事件驱动、稀疏发放等特点。</p><p><img src="https://pic4.zhimg.com/80/v2-137692eef8cc676b5e45ea3e4e8165cf_1440w.webp" alt="img"></p><p>在深度学习和脉冲神经网络融合的探索方面，清华大学类脑计算研究中心早在2014年就开始探索，于2019、2020和2021年连续发表了三篇Nature论文，分别从架构、软件编译和算法模型三个方面进行研究。首篇论文（Figure 16）讲述的是异构融合架构的类脑芯片设计，如何在架构层面支持ANN和SNN的融合。第二篇（Figure 17）讲述的是类脑编译软件系统架构，提出了类脑计算完备性。第三篇（Figure 18）在自然通讯发表的类脑算法文章，首次融合了全局学习和本地学习的融合算法，为类脑融合算法模型的训练和在线学习机制提供支撑。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>深度学习网络处理</p><p>脑科学研究</p><p>类脑芯片</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类脑芯片简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/Blogs/2025/08/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/Blogs/2025/08/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-线性代数date-2020-04-25-20-18-31tags-数学categories-技术mathjax-true"><a href="#title-线性代数date-2020-04-25-20-18-31tags-数学categories-技术mathjax-true" class="headerlink" title="title: 线性代数date: 2020-04-25 20:18:31tags:- 数学categories: 技术mathjax: true"></a>title: 线性代数<br>date: 2020-04-25 20:18:31<br>tags:<br>- 数学<br>categories: 技术<br>mathjax: true</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>线性代数是<a href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E5%AD%A6">代数学</a>的一个分支，主要处理线性关系问题。线性关系意即数学对象之间的关系是以一次形式来表达的。</p><p>最重要的</p><span id="more"></span><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><p>Scalar，单独数字，通常小写</p><p>s $\in$ R : 定义实数标量s</p><p>n $\in$ N: 定义整数标量</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>Vector，有序的一列数，通过次序索引，可确定一个每个单独的数</p><p><img src="https://s1.ax1x.com/2020/04/26/JgttDe.png" alt="JgttDe.png"></p><p>两向量相加遵循平行四边形法则</p><h4 id="向量的模"><a href="#向量的模" class="headerlink" title="向量的模"></a>向量的模</h4><p>$$a &#x3D; [x_{1} + x_{2} + x_{3}…+x_{n}]$$</p><p>$$|a| &#x3D; \sqrt{x_{1}^2 + x_{2}^2 + x_{3}^2…+x_{n}^2}$$</p><h4 id="向量与标量"><a href="#向量与标量" class="headerlink" title="向量与标量"></a>向量与标量</h4><p>$$a &#x3D; [x_{1} + x_{2} + x_{3}…+x_{n}]$$</p><ul><li>向量与标量相加</li></ul><p>s $\in$ R ，</p><p>$$ s+a&#x3D;[s+x_{1},s+x_{2},s+x_{3},…s+x_{n}] $$</p><ul><li>向量与标量相加</li></ul><p>s $\in$ R ，</p><p>$$ sa&#x3D;[sx_{1},sx_{2},sx_{3},…sx_{n}] $$</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>[[01矩阵]]</p><p>Matrix是二维数组，每个元素由两个索引确定，通常为大写字母。</p><ul><li>A$\in R^{m*n}$,高度为m，宽度为n的实体矩阵</li><li>$A_{ij}$第i行第j列的元素</li></ul><p>形状一样的矩阵才能相加</p><p>$$C_{i,j}&#x3D;A_{i,j}+B_{i,j}$$</p><p>矩阵加或乘标量都是每一项分别加或乘</p><h4 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h4><p>[[02行列式]]</p><p>行列式是由一些数据排列成的方阵经过规定的计算方法而得到的一个数。当然，如果行列式中含有未知数，那么行列式就是一个多项式。它本质上代表一个数值。</p><p>一阶行列式</p><p>$$|a_{1}|&#x3D;a_{1}$$</p><p>二阶行列式</p><p><img src="https://images0.cnblogs.com/blog/585228/201312/25221220-2cb65b89f54f4d41ac20625a6f04ff96.png" alt="img"></p><p>三阶行列式</p><p><img src="https://images0.cnblogs.com/blog/585228/201312/25221223-9495bca891c845128392344653056d64.png" alt="img"></p><h4 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h4><p>（Tensor）三维的数组</p><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p><strong>向量乘法</strong></p><p>具有相同维度的向量，相乘得到一个标量</p><p>$$\overline{a}*\overline{b}&#x3D;|a||b|cos\theta$$</p><p><strong>矩阵与向量相乘</strong></p><p>矩阵列数（竖）&#x3D;向量行数（横）</p><p>结果行数&#x3D;矩阵行数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">D=np.diag([<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>])<span class="hljs-comment">#创建对角矩阵</span><br>X=np.array([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>])<span class="hljs-comment">#创建向量</span><br>np.dot(D,X)<span class="hljs-comment">#相乘</span><br><span class="hljs-comment">#得到array([6,8,6,7])</span><br></code></pre></td></tr></table></figure><p>向量*矩阵&#x3D;另一个向量（Application：解方程组（Creamer‘s rule））</p><p><img src="https://s1.ax1x.com/2020/04/26/JgtaEd.png" alt="JgtaEd.png"></p><p><strong>Creamer’s rule</strong></p><p>算四次行列式。。。</p><p>对于如下四元一次方程组：</p><p>$$a_{1}x_{1}+b_{1}x_{1}+c_{1}x_{3}+d_{1}x_{4}&#x3D;e_{1}$$</p><p>$$a_{2}x_{1}+b_{2}x_{1}+c_{2}x_{3}+d_{2}x_{4}&#x3D;e_{2}$$</p><p>$$a_{3}x_{1}+b_{3}x_{1}+c_{3}x_{3}+d_{3}x_{4}&#x3D;e_{3}$$</p><p>$$a_{4}x_{1}+b_{4}x_{1}+c_{4}x_{3}+d_{4}x_{4}&#x3D;e_{4}$$</p><p>设如下行列式：</p><p><img src="https://s1.ax1x.com/2020/04/26/Jgtrgf.png" alt="Jgtrgf.png"></p><p>则原四元一次方程组的解为：</p><p>$$x_{1}&#x3D;\cfrac{D_{1}}{D}$$</p><p>$$x_{2}&#x3D;\cfrac{D_{2}}{D}$$</p><p>$$x_{3}&#x3D;\cfrac{D_{3}}{D}$$</p><p>$$x_{4}&#x3D;\cfrac{D_{4}}{D}$$</p><p><strong>矩阵相乘</strong></p><p><img src="https://s1.ax1x.com/2020/04/26/Jgd0eS.png" alt="Jgd0eS.png"></p><p>意义：</p><p><img src="https://s1.ax1x.com/2020/04/26/JgtdUA.png" alt="JgtdUA.png"></p><p><strong>矩阵转置</strong></p><p>Transpose：一对角线为轴的镜像</p><p>$$(A^{T})_{i,j}&#x3D;A{j,i}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>A = np.array([<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">1</span>,-<span class="hljs-number">9</span>,<span class="hljs-number">8</span>])<br>A.T<br></code></pre></td></tr></table></figure><h4 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h4><h5 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h5><p>除对角线外，其余元素皆为0的矩阵</p><p>python生成方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">np.diag([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><span class="hljs-comment">#array([2,0,0]</span><br><span class="hljs-comment">#[0,3,0]</span><br><span class="hljs-comment">#[0,0,4])</span><br></code></pre></td></tr></table></figure><h5 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h5><p>$$A&#x3D;A^{T}$$</p><h5 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h5><p>Identity matrix，主对角线&#x3D;1，其余位置元素为0</p><p><img src="https://s1.ax1x.com/2020/04/26/JgtD8P.png" alt="JgtD8P.png"></p><p>A*I&#x3D;A</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>)<span class="hljs-comment">#生成3*3的单位矩阵</span><br></code></pre></td></tr></table></figure><h5 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h5><p>$$A*A^{-1}&#x3D;I$$</p><p>逆矩阵需要:行数&#x3D;列数</p><p>列向量之间<strong>线性无关</strong></p><p><strong>线性无关概念</strong>：</p><p>如果$$\overline{a}&#x3D;x\overline{b}+y\overline{c}$$</p><p>则a是b，c的线性组合</p><p>如果在一组向量中，任意向量都不能表示为其他向量的线性组合</p><p>则该向量<strong>线性无关</strong></p><p>求法（<strong>高斯消元</strong>）：</p><p>2X2</p><p><img src="https://i.loli.net/2020/04/26/i7Z4Y3cvhNLlqBR.png" alt="matrix-inverse-2x2.png"></p><p>3X3(多X多)</p><p><strong>高斯－若尔当 方法</strong></p><p>。。。。。。玩玩这些行 （加、乘或对换） 直至把矩阵 <strong>A</strong> 变成单位矩阵 <strong>I。</strong></p><p>在单位矩阵上也做一模一样的运算， 单位矩阵便会奇妙的变成 逆矩阵！</p><p><img src="https://i.loli.net/2020/04/26/RoQ1nUcpgZXVfIv.jpg" alt="-matrix-gauss-jordan1-98164240.jpg"></p><p>**”初等行运算”**是简单的运算，像把行相加，乘，对换位置。。。</p><p><strong>Ex.</strong></p><p><img src="https://i.loli.net/2020/04/26/CG5f4SnypDYrFNu.png" alt="matrix-gauss-jordan2.png"></p><p><strong>余子式、代数余子式和伴随</strong></p><ul><li>求余子式矩阵，</li><li>转成代数余子式矩阵，</li><li>转成伴随矩阵，</li><li>乘以 1&#x2F;行列式。</li></ul><p><strong>一余子式</strong></p><p>矩阵去掉使用在本行与本列的元素</p><p>$$M_{i,j}&#x3D;$$<img src="https://i.loli.net/2020/04/26/FrEH23OTxzsDhw4.jpg" alt="20171027140549973.jpeg"></p><p><strong>二求代数余子式</strong></p><p>$$C_{i,j}&#x3D;(-1)^{i+j}M_{i,j}$$</p><p><strong>Ex.</strong></p><p><img src="https://i.loli.net/2020/04/26/9Y8LRAZjkJMW5On.png" alt="matrix-cofactors.png"></p><p><strong>三伴随</strong></p><p>“转置” 以上的矩阵。。。。。。就是沿对角线对调元素的位置（在对角线上的元素不变）</p><p><strong>Ex.</strong></p><p><img src="https://i.loli.net/2020/04/26/nYKeJZXADiwWagq.gif" alt="matrix-adjugate.gif"></p><p><strong>四乘以1&#x2F;行列式</strong></p><p><img src="https://i.loli.net/2020/04/26/rAmX3Ujd5BtshZa.gif" alt="matrix-3x3-det-c.gif"></p><p>Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">A=np.array([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">7</span>])<br>A<br>np.linalg.inv(A)<br></code></pre></td></tr></table></figure><p>[[03特征向量]]</p><p>[[04向量空间]]</p><p>[[05对称矩阵]]</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合电路设计</title>
    <link href="/Blogs/2025/08/28/%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="组合电路方法"><a href="#组合电路方法" class="headerlink" title="组合电路方法"></a>组合电路方法</h2><h3 id="代数方法"><a href="#代数方法" class="headerlink" title="代数方法"></a>代数方法</h3><p>（真值表-最小-门<br>从电路输入开始<br>通过逻辑门传播表达式到输出<br>        填写真值表<br>        描述逻辑函数<br>        简化逻辑函数<br>            卡诺图<br>        按照逻辑函数画出电路图</p><h3 id="基于MSI"><a href="#基于MSI" class="headerlink" title="基于MSI"></a>基于MSI</h3><p>使用已经存在的器件进行设计</p><p>[[5.multiplexer&amp;demultiplexer]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组合电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计推断</title>
    <link href="/Blogs/2025/08/28/%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD/"/>
    <url>/Blogs/2025/08/28/%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<ol><li><ul><li><p>​<strong>​参数估计​</strong>​</p><ul><li>​<strong>​矩估计​</strong>​：用样本矩替代总体矩（如 μ^​&#x3D;Xˉ）</li><li>​<strong>​最大似然估计​</strong>​：<ul><li>似然函数：L(θ)&#x3D;∏f(xi​;θ)</li><li>求解：dθdlnL(θ)​&#x3D;0</li></ul></li><li>​<strong>​估计量评价​</strong>​：<ul><li>无偏性：E(θ^)&#x3D;θ</li><li>有效性：Var(θ^1​)&lt;Var(θ^2​)</li></ul></li></ul></li><li><p>​<strong>​假设检验​</strong>​</p><ul><li><p>​<strong>​两类错误​</strong>​：</p><table><thead><tr><th>错误类型</th><th>定义</th><th>概率</th></tr></thead><tbody><tr><td>弃真错误</td><td>H0​为真时拒绝H0​</td><td>α</td></tr><tr><td>取伪错误</td><td>H0​为假时接受H0​</td><td>β</td></tr></tbody></table></li><li><p>​<strong>​检验方法​</strong>​：</p><ul><li>Z检验（方差已知）</li><li>t检验（方差未知，小样本）</li><li>χ2检验（方差检验）</li></ul></li><li><p>​<strong>​P值法则​</strong>​：P-value&lt;α⇒ 拒绝H0​</p></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>概率与统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计推断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程学习基础</title>
    <link href="/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <url>/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>git版本管理 [[git学习笔记]]</p><p>命令行 [[linuxcmd]]</p><p>Markdown笔记 [[Markdown-guide]]</p><p>位运算 [[位运算]]</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>02基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程学习基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程实战</title>
    <link href="/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    <url>/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>[[ffmpeg]] </p><p>[[搭建Outline-VPN]]</p><p>[[Python爬虫]]</p><p>[[树莓派使用Aria2搭建BT远程下载机]] </p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程杂谈</title>
    <link href="/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/"/>
    <url>/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>[[01储存设备的历史]]</p><p>[[VR与元宇宙]]</p><p>[[稚晖君笔记]]</p><p>[[芯片]]</p><p>[[蚂蚁与芯片]]</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>新概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程素养</title>
    <link href="/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E7%B4%A0%E5%85%BB/"/>
    <url>/Blogs/2025/08/28/%E7%BC%96%E7%A8%8B%E7%B4%A0%E5%85%BB/</url>
    
    <content type="html"><![CDATA[<p>[[0高级搜索]]</p><p>[[1提问的艺术]]</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>01素养</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程素养</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自指和怪圈</title>
    <link href="/Blogs/2025/08/28/%E8%87%AA%E6%8C%87%E5%92%8C%E6%80%AA%E5%9C%88/"/>
    <url>/Blogs/2025/08/28/%E8%87%AA%E6%8C%87%E5%92%8C%E6%80%AA%E5%9C%88/</url>
    
    <content type="html"><![CDATA[<p>我们再来看哥德尔定理的证明，整个过程的关键有两点：</p><p>第一是构建一个类似说谎者悖论的句子，”我的这句话是假的”这句话的悖论性是来源于自指<strong>，</strong>自指导致我们陷入怪圈</p><p><img src="https://pic3.zhimg.com/v2-65798f529b1f8eaede8d58d05bf2574e_1440w.png"></p><p>怪圈也叫缠结的层次结构，是指你一直往一个方向向上或者向下走，但最后却回到原点，就像埃舍尔的无穷楼梯。而这样的<strong>怪圈</strong>（缠结的层次结构）<strong>其实就是智能的核心所在</strong></p><p>**我们大脑就是一个多层次的系统，一个层次中有某些关于思维的规则，在这个规则层次下有修改规则的元规则层次，在元规则层次下有修改元规则的元元规则层次….. 一句真话是一个层次，谈论这句是否是真话是另一个层次，自指之所以导致悖论就是因为“指”就是在谈论！</p><p>思维是涉及多个层次的复杂活动，不同层次缠结在一起，这就是大脑的样子</p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>对人脑结构和心智本质的探讨到计算机程序和人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自指和怪圈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>芯片</title>
    <link href="/Blogs/2025/08/28/%E8%8A%AF%E7%89%87/"/>
    <url>/Blogs/2025/08/28/%E8%8A%AF%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>芯片，可以说是数字时代的电子石油。不管是5G、光伏、新能源汽车、物联网还是元宇宙，不管这些汹涌的大潮如何难以预测，反正都得塞芯片；它们每一项产品从概念到应用的壮大普及，都必然会推动芯片技术与产业不断攀高</p><h1 id="三种芯片"><a href="#三种芯片" class="headerlink" title="三种芯片"></a>三种芯片</h1><h2 id="逻辑芯片"><a href="#逻辑芯片" class="headerlink" title="逻辑芯片"></a>逻辑芯片</h2><p>手机电脑里面，酷睿骁龙天玑提供算力</p><h2 id="存储器芯片"><a href="#存储器芯片" class="headerlink" title="存储器芯片"></a>存储器芯片</h2><p>内存条、硬盘、SD卡之类的</p><h2 id="信号链（Signal-Chain）芯片"><a href="#信号链（Signal-Chain）芯片" class="headerlink" title="信号链（Signal Chain）芯片"></a>信号链（Signal Chain）芯片</h2><p>这个复杂一点，比如说我让车智能驾驶，它就需要加装各种东西，东西里就会有采集现实数据并处理让它变成电路信号的传感芯片，和给信号保熟保真的各种放大器、比较器，这些可以统称为信号链芯片。其它还有各种控制电压电流的芯片，都属于这个范畴。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>新概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>芯片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蚂蚁与芯片</title>
    <link href="/Blogs/2025/08/28/%E8%9A%82%E8%9A%81%E4%B8%8E%E8%8A%AF%E7%89%87/"/>
    <url>/Blogs/2025/08/28/%E8%9A%82%E8%9A%81%E4%B8%8E%E8%8A%AF%E7%89%87/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 蚂蚁与芯片<br>date: 2022-06-20 15:40:03<br>tags:<br>categories: 技术</p><hr><h1 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h1><p>所有芯片都有蚁群的影子</p><h2 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h2><p>每一只蚂蚁相当于一颗晶体管</p><h3 id="CPU复杂计算"><a href="#CPU复杂计算" class="headerlink" title="CPU复杂计算"></a>CPU复杂计算</h3><p>CPU性能&#x3D;时钟频率*IPC</p><p>因为CPU功能性强，其内部结构设计的全面复杂，长时间高强度的单一运算指令会使CPU效率变低</p><h3 id="GPU图像内容处理"><a href="#GPU图像内容处理" class="headerlink" title="GPU图像内容处理"></a>GPU图像内容处理</h3><p>通过大量堆核，处理类型一致，长时间单一指令的命令时轻松</p><h3 id="集成基带对外通信"><a href="#集成基带对外通信" class="headerlink" title="集成基带对外通信"></a>集成基带对外通信</h3><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>主要负责处理照相</p><h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><h3 id="蚁群算法"><a href="#蚁群算法" class="headerlink" title="蚁群算法"></a>蚁群算法</h3><p>解决网络路由，路径规划，TSP问题，属于广义仿生科技</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>新概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蚂蚁与芯片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>行列式</title>
    <link href="/Blogs/2025/08/28/%E8%A1%8C%E5%88%97%E5%BC%8F/"/>
    <url>/Blogs/2025/08/28/%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="行列式​​"><a href="#行列式​​" class="headerlink" title="行列式​​"></a><strong>行列式​</strong>​</h3><ol><li><p>​<strong>​性质与计算​</strong>​</p><ul><li>按行展开值不变，两行成比例则 detA&#x3D;0</li><li>​<strong>​初等变换影响​</strong>​：<ul><li>行交换→变号，行乘k→行列式乘k</li><li>行加减→行列式不变</li></ul></li><li>​<strong>​实用公式​</strong>​：det(AB)&#x3D;detA⋅detB，detAT&#x3D;detA</li></ul></li><li><p>​<strong>​克拉默法则​</strong>​</p><ul><li>Ax&#x3D;b 的解 xi​&#x3D;detAi​&#x2F;detA（Ai​为第i列替换为b）</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行列式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>证明</title>
    <link href="/Blogs/2025/08/28/%E8%AF%81%E6%98%8E/"/>
    <url>/Blogs/2025/08/28/%E8%AF%81%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>我们可以用数学符号表述<strong>5是素数</strong>这样的数论陈述，但怎么表述 <strong>我不是一条定理</strong> 这种意思？这好像是文字才能办得到的事，要怎么用数学的陈述来谈论数学陈述自己呢？ 这就是哥德尔伟大的地方，他发现了用数学公式谈论数学公式自己的方法！我们看下他如何用数学符号表述 ”<strong>我不是一条定理“</strong></p><blockquote><p>1，表述“<strong>不是一条定理”</strong>： 表示“是定理”要用到<strong>证明对</strong>的概念如果n是一条定理 ，那么就有一个陈述（公式）可以和n形成一对证明对<br>用形式系统的符号表示就可以写成公式</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">存在一个a 让&#123;a,n&#125;形成证明对<br></code></pre></td></tr></table></figure><blockquote><p>所以<strong>某陈述不是一条定理</strong>就可以写成</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不存在一个a 让&#123;a, 某陈述&#125;形成证明对<br></code></pre></td></tr></table></figure><blockquote><p>**（ 注意！：1.此处为方便理解，把形式系统的数论陈述用中文表示出来，所有用TNT系统的符号表述的语言都会用加上灰框做背景，原本的陈述是 ~∃a …. } 这样的符号组成的公式<br><strong>2.<strong>证明对这个概念本身具有一种</strong>原始递归的数学性质可以保证说出来的都是真话，</strong>比如像</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">存在一个a 让&#123;a,1+1=3&#125;形成证明对<br></code></pre></td></tr></table></figure><blockquote><p>这样的公式是不合法的，你可以理解为这样的假公式写不出来！<strong>）</strong></p></blockquote><blockquote><p>2，表述“<strong>我” ：</strong>要用到<strong>㧟摁</strong>的概念，<strong>㧟摁</strong> 就是把自己带入它自己的意思<br>公式：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">㧟摁&#123;x,n&#125; <br></code></pre></td></tr></table></figure><blockquote><p>意思是：含有自变量的公式ｘ把自己带入自己的自变量后就是n<br><strong>（注意！：</strong> ｘ把自己带入自己不会造成x里面有x里面有x …这样的无限循环，因为公式X并不是直接带入自身，而是用自己的哥德尔编码的数字形态带入自己的，这个知识点会在后面解释<strong>）</strong><br>接下来我们先写出一个陈述（公式）：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不存在一个a 让&#123;a, n&#125;形成证明对 并 㧟摁&#123;x,n&#125;  <br></code></pre></td></tr></table></figure><blockquote><p>意思是 ：<strong>当n是公式x带入它自己的自变量时，n就不是定理</strong><br>作者把这个公式取了一个奇怪的名字叫做”<strong>G的服号串”</strong> 简称 <strong>“G服”</strong><br>最后一步：把<strong>G服带入X！</strong>我们就得到了传说中的”<strong>G”</strong> ：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不存在一个a 让&#123;a, n&#125;形成证明对 并 㧟摁&#123;G服,n&#125;<br></code></pre></td></tr></table></figure><blockquote><p>他的意思就是： <strong>当n是公式G服带入它自己的自变量时，n就不是定理</strong><br>而此时<strong>n就是G服带入他自己的自变量！</strong>所以此时n就不是定理！<br>所以这条陈述<strong>G：</strong><br>不存在一个a 让{a, n}形成证明对 并 㧟摁{G服 ,n}<br>就是我们要找的说”<strong>我不是定理“</strong>的那句话 ，哥德尔不完全性定理证明完毕，<strong>G</strong>的存在就是形式系统不完全的原因！</p></blockquote><p><strong>（</strong>把<strong>G</strong>拆开看更明白</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不存在一个a 让&#123;a, n&#125;形成证明对    <br></code></pre></td></tr></table></figure><p>说的是 ：<strong>n 不是一条定理</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">㧟摁&#123;G服,n&#125;             <br></code></pre></td></tr></table></figure><p>说的是 <strong>n 就是这个句子自己，是对n的解释，即我）</strong></p>]]></content>
    
    
    <categories>
      
      <category>类脑芯片</category>
      
      <category>GEB</category>
      
      <category>哥德尔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>证明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>载流子统计与运输</title>
    <link href="/Blogs/2025/08/28/%E8%BD%BD%E6%B5%81%E5%AD%90%E7%BB%9F%E8%AE%A1%E4%B8%8E%E8%BF%90%E8%BE%93/"/>
    <url>/Blogs/2025/08/28/%E8%BD%BD%E6%B5%81%E5%AD%90%E7%BB%9F%E8%AE%A1%E4%B8%8E%E8%BF%90%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<p>扩散电流的计算考验对 [[01微分]] 的熟悉，载流子的分布则需要通过 [[02随机变量与分布]] 计算</p><p>对载流子运动方向的熟悉对理解器件微观层面运动非常重要 [[04器件物理核心]]</p><h4 id="​​1-载流子浓度​​"><a href="#​​1-载流子浓度​​" class="headerlink" title="​​1. 载流子浓度​​"></a>​<strong>​1. 载流子浓度​</strong>​</h4><ul><li>​<strong>​状态密度 g(E)​</strong>​：单位能量&#x2F;体积的量子态数<ul><li>导带 Nc​∝(mn∗​T)3&#x2F;2，价带 Nv​∝(mp∗​T)3&#x2F;2</li></ul></li><li>​<strong>​费米分布 f(E)​</strong>​：<br>  f(E)&#x3D;1+e(E−EF​)&#x2F;kT1​</li><li>​<strong>​平衡浓度​</strong>​：<ul><li>电子 n0​&#x3D;Nc​e−(Ec​−EF​)&#x2F;kT</li><li>空穴 p0​&#x3D;Nv​e−(EF​−Ev​)&#x2F;kT</li><li>​<strong>​本征载流子​</strong>​：ni​&#x3D;Nc​Nv​​e−Eg​&#x2F;2kT</li></ul></li></ul><h4 id="​​2-掺杂调控​​"><a href="#​​2-掺杂调控​​" class="headerlink" title="​​2. 掺杂调控​​"></a>​<strong>​2. 掺杂调控​</strong>​</h4><ul><li>​<strong>​n型​</strong>​：施主杂质（V族）→ n0​≈ND​</li><li>​<strong>​p型​</strong>​：受主杂质（III族）→ p0​≈NA​</li><li>​<strong>​费米能级 EF​ 移动​</strong>​：<ul><li>n型：EF​ 靠近导带；p型：EF​ 靠近价带</li><li>温度升高 → EF​ 趋近本征能级 Ei​</li></ul></li></ul><h4 id="​​3-载流子输运​​"><a href="#​​3-载流子输运​​" class="headerlink" title="​​3. 载流子输运​​"></a>​<strong>​3. 载流子输运​</strong>​</h4><ul><li>​<strong>​电流组成​</strong>​：<br>  J总​&#x3D;J漂移​+J扩散​</li><li>​<strong>​漂移电流​</strong>​：<ul><li>迁移率 μ：μn​&#x3D;mn∗​eτn​​（散射机制：晶格&#x2F;电离杂质）</li><li>电导率 σ&#x3D;e(nμn​+pμp​)</li></ul></li><li>​<strong>​扩散电流​</strong>​：Jdiff​&#x3D;−eD∇n（爱因斯坦关系：D&#x2F;μ&#x3D;kT&#x2F;e）</li><li>​<strong>​霍尔效应​</strong>​：载流子类型（VH​ 符号）及浓度测量</li></ul><h3 id="电荷载流子Charge-Carrier的计算"><a href="#电荷载流子Charge-Carrier的计算" class="headerlink" title="电荷载流子Charge Carrier的计算"></a>电荷载流子Charge Carrier的计算</h3><p>对态密度与一个量子态被占据的概率P(E)的乘积作为能量的函数积分<br>    中间值<br>        状态密度(Density of State)<br>            在能量空间中，单位能量或单位体积内存在的能量态数量<br>            普通情况<br>                方程<br>                    量子态总个数&#x2F;半导体总体积<br>                根据量子力学的原理和能带结构来推导<br>            扩展到半导体<br>                方程<br>                    导带中的有效电子能态密度<br>                    价带中的有效电子能态密度</p><pre><code class="hljs">    求某一量子态被占据的概率费米(Fermi-Diac)函数        特定能量处量子态被占据的概率        公式            本体                密度数N(E)单位体积单位能量的粒子数                g(E)单位体积单位能量的量子状态            E是能级，Ef是费米能级，k是玻尔兹曼常数，T是温度        图像终值    总图像        电子浓度n            导带中单位体积的总电子浓度                gc(E)是导带中的量子态密度                fF(E)是费米函数（某量子态被电子占据的概率）        空穴浓度p            价带中单位体积的总空穴浓度                1-fF(E)（某量子态不被电子占据（被空穴占据）的概率）    热平衡状态下        电子浓度(Thermal equilibrium concentration)            在导带能量范围内积分                Nc：Effective density of state in conduction band                运算技巧        空穴浓度            在价带能量范围内积分                运算技巧                Nv</code></pre><h3 id="电荷载流子在哪（分布与运动）"><a href="#电荷载流子在哪（分布与运动）" class="headerlink" title="电荷载流子在哪（分布与运动）"></a>电荷载流子在哪（分布与运动）</h3><p>掺杂影响电荷载流子在哪里分布<br>        掺杂<br>            n型<br>                与V族元素掺杂，多出一个e-电子进入导带<br>                此时电子增加，空穴数量不变，但之后游离的h+与e-抵消，h+最终下降<br>            p型<br>                与III族元素掺杂，引入额外h+空穴<br>        载流子浓度与费米能级<br>            本征半导体<br>intrinsic<br>                没有任何掺杂和缺陷的半导体<br>                本征载流子浓度<br>                    本征半导体的电子浓度和空穴浓度分别表示为ni，pi，因为ni&#x3D;pi，所以有<br>                    公式<br>                本征费米能级<br>                    公式<br>                        禁带中央<br>            非本征半导体<br>（表征extrinsic）<br>                n0<em>p0<br>                n型与p型掺杂后的费米能级<br>                    n型掺杂之后<br>                    p型掺杂之后<br>                    E_F随浓度和温度的变化<br>                        随着掺杂水平提高<br>                            n型半导体的费米能级逐渐向导带靠近<br>                            p型半导体的费米能级逐渐向价带靠近<br>                        随温度升高，ni增加，Ef趋近于本征费米能级<br>    电荷载流子运动产生电流<br>        总电流&#x3D;漂移电流+扩散电流<br>            电流基础公式<br>                e 带电量（常数，1.6</em>10^-19 C）<br>                u衡量电子运动能力<br>                n 载流子浓度<br>                E电场<br>            总电流密度<br>                电子漂移与扩散电流➕空穴漂移与扩散电流<br>                一维情况<br>                三维情况<br>        漂移drift电流<br>            研究e-&#x2F;h+外加电场运动形成的电流<br>            总<br>                电子漂移电流密度<br>                    vdn是电子的平均漂移密度<br>                        un是电子的迁移率，为正值<br>                        虽然电子的运动方向与电场方向相反，但漂移电流的方向相同<br>                    n是电子密度<br>                空穴漂移电流密度<br>                    弱电场的情况下，平均漂移速度与电场强度成正比<br>                    p是空穴密度<br>            Mobility迁移率u<br>                迁移率反映载流子的平均漂移速度与电场之间的关系<br>                迁移率<br>                    电子迁移率<br>                        通过合力推出<br>                        tcn是电子受到碰撞的平均时间间隔<br>                    空穴迁移率<br>                    总迁移率<br>                影响因素<br>                    晶格散射lattice scattering<br>                        与电子的热运动有关<br>                            温度上升，散射概率增加，迁移率下降<br>                        只有晶格散射存在时的迁移率<br>                    电离杂质散射Ionized scattering<br>                        室温下杂质已经电离，在电子或空穴与电离杂质之间存在库伦作用<br>                            温度升高，载流子随热运动速度增加，在散射中心附近的时间减少，库伦作用时间减少，收到的影响减少<br>                            掺杂越高，散射概率越高，迁移率越低<br>                        只有电离杂质散射存在时的迁移率<br>                            半导体电离杂质总浓度<br>            Conductivity电导率<br>                载流子浓度与迁移率的函数<br>                电导率与电阻率<br>                    电导率<br>                        非本征半导体的电导率是多数载流子的函数<br>                        本征半导体（电子浓度&#x3D;空穴浓度）的电导率是<br>                    电阻率是电导率的倒数<br>        扩散diffusion电流<br>            e-&#x2F;h+浓度差移动形成的电流<br>            扩散电流密度<br>                电子扩散电流密度<br>                    Dn是扩散电流系数<br>                空穴扩散电流密度<br>                图像<br>        霍尔效应Hall effect<br>            电场与磁场对运动电荷施加力的作用<br>            测量原理图<br>                VH是由磁场引起的电压，由平衡时等式算出<br>                    n为电子浓度<br>                    VH&lt;0为n型半导体，电子为主要载流子<br>                对p型半导体<br>                    VH霍尔电压与空穴浓度<br>                        VH这样推出<br>                            vx&#x3D;<br>                        p通过在VH中提出p来得出<br>                    弱电场下空穴迁移率<br>                        多数载流子的迁移率<br>                        将电场密度和电场强度换算为电流和电压<br>                对n型半导体<br>                    注意n型因为电子带负电，所以为负<br>                    弱电场下电子迁移率</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>载流子统计与运输</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算放大器</title>
    <link href="/Blogs/2025/08/28/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/"/>
    <url>/Blogs/2025/08/28/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>运算放大器（简称运放），它的英文全称是Operation Amplifier,简写为OP AMP</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>初衷是用于执行数学计算，比如加、减、乘、除、函数运算等。在当前的技术条件下，运算放大器的数学运算功能已不再突出，现在主要应用于<strong>信号放大</strong>（测量需求与驱动需求）及<strong>有源滤波器设计</strong></p><p>在多数的常规设计中，我们使用运放的理想模型，忽略其内部结构。把它当作一个“具有放大作用的元件”，接上电源，便可以让它发挥放大的作用。所谓理想的运放，它的输入阻抗无穷大，输出阻抗为零，如图2.1。</p><p><img src="https://pic3.zhimg.com/80/v2-41aa04ec76e3054ab50418931d969516_1440w.webp"></p><p>图2.1 运算放大器模型</p><p>理想的运放电路分析有两大重要原则贯穿始终，即“<strong>虚短</strong>”与“<strong>虚断</strong>”。“虚短”的意思是<strong>正端和负端接近短路</strong>，即V+&#x3D;V-,看起来像“短路”;“虚断”的意思是<strong>流入正端及负端的电流接近于零</strong>，即I+&#x3D;I-&#x3D;0,看起来像断路（因为输入阻抗无穷大）。</p><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><ul><li>开环增益A很大，对于理想运放，有4-》无穷</li><li>传输特性 u0&#x3D;A*（u+ - u-）</li><li>输入阻抗大，输出阻抗小</li><li>两种供电模式：单电源供电与双电源供电</li><li>电压决定输出范围<br>集成运放的<strong>电压传输特性</strong>如下图所示；</li></ul><p><img src="https://pic1.zhimg.com/80/v2-f14254284001904208ed4c63c740a5d8_1440w.webp"></p><ul><li>工作在<strong>线性区</strong>的时候，则曲线的斜率为电压的放大倍数；</li><li>工作在非线性区的时候，即处于饱和状态的情况下，输出电压为或</li></ul><h1 id="虚短和虚断"><a href="#虚短和虚断" class="headerlink" title="虚短和虚断"></a>虚短和虚断</h1><h2 id="虚短"><a href="#虚短" class="headerlink" title="虚短"></a>虚短</h2><p>由于运放的<strong>电压放大倍数很大</strong>，一般通用型运算放大器的开环电压放大倍数都在80 dB以上。而运放的<strong>输出电压是有限</strong>的，一般在 10 V～14 V。因此运放的<strong>差模输入电压不足1 mV，两输入端近似等电位</strong>，相当于 “短路”。开环电压放大<strong>倍数越大</strong>，两输入端的<strong>电位越接近相等</strong>。 “虚短”是指在分析运算放大器处于线性状态时，可<strong>把两输入端视为等电位</strong>，这一特性称为虚假短路，简称虚短。</p><p><del>虚短<strong>前面提到，集成运算放大器的开环放大倍数很大，一般通用型的运算放大器的开环电压放大倍数都在</strong>80 dB<strong>以上，但是运放的输出电压是有限制的，一般在</strong>10V～14V<strong>，然而运放的差模输入电压不足</strong>1 mV<strong>，因此可以输入两端可以近似等电位，就相当于 <strong>短路</strong>。开环电压</strong>放大倍数越大<strong>，两输入端的</strong>电位（电压（对地））越接近相等<strong>，这种特性称之为</strong>虚短**</del></p><h2 id="虚断"><a href="#虚断" class="headerlink" title="虚断"></a>虚断</h2><p>于运放的差模输入<strong>电阻也很大</strong>，一般通用型运算放大器的输入电阻都在1MΩ以上。因此流入运放输入端的电流往往不足1uA，远小于输入端外电路的电流。故 通常可把运放的<strong>两输入端视为开路</strong>，且输入<strong>电阻越大，两输入端越接近开路</strong>。“虚断”是指在分析运放处于线性状态时，可以把<strong>两输入端视为等效开路</strong>，这一特性 称为虚假开路，简称虚断</p><p><del><strong>虚断</strong>集成运算放大器具有输入高阻抗的特性，一般同向输入端和反向输入端的输入电阻都在<strong>1MΩ</strong>以上，所以输入端流入运放的电流往往小于<strong>1uA</strong>，远小于输入端外电路的电流。所以这里通常可把运放的两输入端视为开路，并且运放的输入电阻越大，同向和反向输入两端越接近开路。在运放处于线性状态时，根据这个特性可以把两输入端视为等效开路，简称<strong>虚断</strong>（注意：开路就是断路）</del></p><h2 id="闭环开环"><a href="#闭环开环" class="headerlink" title="闭环开环"></a>闭环开环</h2><p>闭环：输出引电路回输入<br>开环：不引电路回去</p><h1 id="运放的典型应用"><a href="#运放的典型应用" class="headerlink" title="运放的典型应用"></a>运放的典型应用</h1><h2 id="放大电路"><a href="#放大电路" class="headerlink" title="放大电路"></a>放大电路</h2><h3 id="反相比例放大电路"><a href="#反相比例放大电路" class="headerlink" title="反相比例放大电路"></a>反相比例放大电路</h3><p><img src="https://pic2.zhimg.com/80/v2-f63edf4cbe2d26d9f76540c01861ce9d_1440w.webp"></p><p>图2.2 比例放大电路<br>图2.2是典型的比例放大电路，根据“虚短”及“虚断”法则可以很简单的计算得到结果：<br><img src="https://pic1.zhimg.com/80/v2-7e3beb741c5d71697bfa56f796d597a8_1440w.webp"></p><p>等式2.1中负号，代表输出和输入相位相差180°。<br>推导过程：<br>（1）、电流的流入等于流出，所以i1&#x3D;i2+13。由“虚断”法则得知i3&#x3D;0A，所以i1&#x3D;i2。<br>因此，根据第一章介绍的“叠加法则”，得到：<br><img src="https://pic3.zhimg.com/80/v2-1e8d097ba06909490ca6ea07bb63a2aa_1440w.webp"></p><p>（2）、又根据“虚短”法则，得知运放的正负两个端等同于“短路”，所以V+&#x3D;V-。而因为运放的正端子V+被R3下拉至地平面，所以V-&#x3D;V+&#x3D;0V，代入等式2.2可得到：<br><img src="https://pic2.zhimg.com/80/v2-9f84a57253ba5966bf1c8e751f42ba39_1440w.webp"><br>再由等式2.3，进一步得到公式2.1，<br><img src="https://pic1.zhimg.com/80/v2-9fef1e991e3c6da7a8317d05c35256d0_1440w.webp"><br>因为Vout与Vin成线性的比例关系，因此这个典型放大电路被称为比例放大电路。<br>关于R1,R2及R3的选值：<br>1）、R1,R2及R3应该在K级，不宜达到M级；<br>2）、R3应该等于或近似于R1与R2的并联，以消除偏置电流的影响。</p><h3 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h3><p><img src="https://pic1.zhimg.com/80/v2-600c89ea21b42afef003b5ba0b4d4fe4_1440w.webp"></p><p>图2.3 差分放大电路</p><p>图2.3为差分放大电路，它是图2.2反相比例放大电路的“变种”。类似与反相比例放大电路的分析方法，可以得到结论：</p><p><img src="https://pic3.zhimg.com/80/v2-3412ad0c6d08a5228ef37b17081bfcbe_1440w.webp"></p><p>当R1&#x3D;R3并且R2&#x3D;R4时，得到等式2.5。这就是此电路命名的由来，它可以对差分信号进行放大。</p><p><img src="https://pic1.zhimg.com/80/v2-40251e62297b2c8070aeb1111de7bc58_1440w.webp"></p><ul><li><strong>同相放大电路</strong></li></ul><p>上文介绍的放大电路会引起相位翻转180°，图2.4为同相放大电路，顾名思义，输出和输入保持相同的相位。理想的运放具有输入阻抗无穷大，输出阻抗无穷小的特点，同相放大电路保持了运放的这种特性。</p><p><img src="https://pic1.zhimg.com/80/v2-49cbe3379703399fdc35fa48fba4d024_1440w.webp"></p><p>图2.4 同相放大电路</p><p>分析图2.4，应用运放的“虚短”，可知V2&#x3D;V1；此外，因为运放的“虚断”，输出电压的电流全部流经R2和R1，因此V2由R1和R2对Vout分压得到。</p><p><img src="https://pic1.zhimg.com/80/v2-635b249fe2f2b300de8dc5d573c095b0_1440w.webp"></p><p>因此，</p><p><img src="https://pic1.zhimg.com/80/v2-09ce70aae334ba54fdd53566e6d77f30_1440w.webp"></p><p>调节R2可以电路的放大倍数。</p><p>注意，同相放大电路的应用场合具有局限性，一般只用于直流电平的放大，不适合用于交流信号的放大，因为它会将交流信号的直流偏置电压一并放大，从而使其偏置电位发生偏移。带参考电平的反相比例放大电路在信号放大时比较有实用性。</p><p><img src="https://pic3.zhimg.com/80/v2-7ab9234ab315d5f90b8fba641f49864e_1440w.webp"></p><p>实际上只是在图2.3的差分放大器的基础上加一个隔直电容C1,具体原理待日后讲解有源滤波器时再分析。</p><h2 id="前后级隔离"><a href="#前后级隔离" class="headerlink" title="前后级隔离"></a>前后级隔离</h2><p>起隔离作用，防止前级波动影响后级输入，可以提高带载能力</p><h2 id="电压跟随电路"><a href="#电压跟随电路" class="headerlink" title="电压跟随电路"></a>电压跟随电路</h2><p><img src="https://pic2.zhimg.com/80/v2-f444a6b439522a20877911001278aa3d_1440w.webp"></p><p>图2.5 电压跟随电路</p><p>图2.5是运放的一种特殊应用方式，很容易得到结论Vout&#x3D;Vin。输出电压跟随输入电压，因此称之为“电压跟随器”。</p><p>电压跟随电路是图2.4同相放大电路的衍生产物，是放大倍数为1的同相放大电路。前文已介绍理想的同相放大电路的输入阻抗无穷大，输出阻抗无穷小。</p><p>基于此特性，电压跟随电路一般用于信号的隔离。简单举例说明，如图2.6，由R1和R2产生参考电压供给下一级电路使用，因为下一级电路的等效内阻会影响R1和R2的分压比，因此参考电压将会发生变化，如果内阻不是固定的，则此电路将无法使用。</p><p><img src="https://pic4.zhimg.com/80/v2-7e6206ea13c1da459f670d71c88b710f_1440w.webp"></p><p>图2.6 不可靠的参考电压电路</p><p>比较可靠的设计如图2.7所示：</p><p><img src="https://pic4.zhimg.com/80/v2-f8a066ae6f1913399d4950271b267b57_1440w.webp"></p><p>图2.7 可靠的参考电压电路</p><p>仪器放大电路</p><p><img src="https://pic1.zhimg.com/80/v2-a43a8a58daef5e762d9910b3245a9bf8_1440w.webp"></p><p>图2.8 仪器放大电路</p><p>图2.8是典型的仪器放大电路，顾名思义此方法电路使用于小信号的放大，一般用于传感器信号的放大。传感器的输出信号很小，一般只有几毫伏到几十毫伏。</p><p>电路由两级放大电路组成，第一级由A1,A2组成，同相输入，输入阻抗高，电路结构对称，可很好的抑制零点漂移；第二级由A3组成，良好的共模抑制比，输入阻抗高，增益在大范围内可调。</p><p>选值要求：R4&#x3D;R5,R6&#x3D;R7,R8&#x3D;R9（保持电路的对称性），R3为可调电阻，用于调节电路增益。电路输入输出的关系式如下：</p><p><img src="https://pic2.zhimg.com/80/v2-a88427f531311721f51dfb08d25b913d_1440w.webp"></p><p>推导过程：</p><p>实际上，仪器放大电路是前文所述的同相放大电路及差分放大电路的综合体。分析方法可以参考前文的阐述。</p><p>（1）、首先分析由A1和A2组成的同相放大电路。</p><p>由“虚短”及“虚断”原则，推导得到：</p><p><img src="https://pic3.zhimg.com/80/v2-678191a39037e5aedd924ae4c9875ba6_1440w.webp"></p><p>（2）、进一步分析由A3组成的差分放大电路。</p><p>由“虚短”及“虚断”原则，推导得到：</p><p><img src="https://pic2.zhimg.com/80/v2-fe22df522797c30b5e580de0c326cd61_1440w.webp"></p><p>（3）、联合等式2.9和2.10得到结论：</p><p><img src="https://pic2.zhimg.com/80/v2-20bc29ec5ae53a7c011e2d77584ba06d_1440w.webp"></p><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><p><strong>1）、简单的比较器</strong></p><p><img src="https://pic4.zhimg.com/80/v2-3b1524a5a6fbf59beb6d8b7f7ab9ab2b_1440w.webp"></p><p>图2.9 简单的比较器</p><p>图2.9是最简单的比较器电路，它利用的原理是“理想的运放具有无穷大的增益”。因此，V+与V-之间稍有电压差，即可引起输出的翻转。微弱的电压差经运放放大引起输出饱和。</p><p><img src="https://pic2.zhimg.com/80/v2-57648a18ca482054c2cb1ec96581c669_1440w.webp"></p><p>Av为运放的开环放大倍数（一般为100dB左右，即十万倍）。当V+大于V-时，输出为正饱和（接近VCC，但是无法达到）；当V-大于V+时，输出为负饱和（接近-VSS，但是无法达到）。连接V+至地，构成过零比较器，如图2.10所示。</p><p><img src="https://pic3.zhimg.com/80/v2-912ee678218f0167790e0e3e3618a14a_1440w.webp"></p><p>图2.10 过零比较器</p><p>图2.10的过零比较器虽然简单，但是并不实用，它的问题在于比较器只有一个临界电压，输入信号上的杂波易引起输出误操作，如图2.11所示。</p><p><img src="https://pic1.zhimg.com/80/v2-d287bcae440e8a7014de75cf692c1728_1440w.webp"></p><p>图2.11，信号杂波引起的比较器误操作</p><p><strong>2）、迟滞比较器（The hysteresis comparator）</strong></p><p>相对于上文所述的简单比较器，比较实用的是迟滞比较器，如图2.12所示。</p><p><img src="https://pic4.zhimg.com/80/v2-e78ea56facdac558fa0ddcf64fd64b23_1440w.webp"></p><p>图2.12，迟滞比较器</p><p>相比简单比较器，迟滞比较器只是增加了一个电阻R2。这将引起怎样的微妙变化呢？</p><p>通俗地说，R2在输入与输出之间搭起了一座桥梁，输出的变化可以通过R2传递至输入，然后比较器的阈值将随输出的变化而改变，达到了磁滞的目的。</p><p>如果需要定量分析，所有的比较器的原理都是一样的，利用运放的放大倍速为“无穷大”，将V+与V-之间的微弱电压差进行放大，达到饱和输出。所以，首先计算比较器的临界电压值（V+），得到等式2.11。  </p><p><img src="https://pic3.zhimg.com/80/v2-8e6c39dbeb2dc53ee76c1e32bdbd3e5a_1440w.webp"></p><p>显然，R2的作用是将输出电压引入临界电压。因为Vout会有两种状态+Vsat和-Vsat,所以迟滞比较器也将有两个临界电压（Vth_H及Vth_L）。  </p><p><img src="https://pic1.zhimg.com/80/v2-422c9f2e1efdf21a2e053e85a474036c_1440w.webp"></p><p>表格2.1，迟滞比较器的状态表</p><p><img src="https://pic1.zhimg.com/80/v2-39b9f5f7be669afab44908f03471a068_1440w.webp"></p><p>表格2.1可以很好的解释迟滞比较器的工作原理，图2.8是另一种有效的表达迟滞比较器工作原理的方式。设计合适的Vth_H及Vth_L，使(Vth_H-Vth_L)大于杂波幅值，可以有效的避免因为输入信号上的杂波引起的误操作。</p><p><img src="https://pic1.zhimg.com/80/v2-9bd1802ce75cf8dec9d7049ee29692a8_1440w.webp"></p><p>图2.13，迟滞比较器的状态矢量图  </p><p><strong>3）、窗口比较器</strong>  </p><p>窗口比较器用于判别输入电压是否落在某一个范围之内，图2.14是典型的窗口比较器。</p><p>其中，URH&gt;URL，D1和D2不能省略，防止两个运放输出电平相反时损坏运放。比如，运放A1输出VOH，但是运放A2输出VOL,D1导通，但是D2截止，因此电流不会从A1流入A2,避免大电流损坏器件。  </p><p><img src="https://pic1.zhimg.com/80/v2-12909c84ac1737620872540468abc3a4_1440w.webp"></p><p>图2.14，窗口比较器  </p><p>窗口比较的工作原理如图2.15所示。<br>1）、Uin&gt;URH&gt;URL，A1输出UOH,A2输出UOL，D1导通，D2截止，Uout&#x3D;UOH;<br>2）、Uin&lt;URL&lt;URH，A1输出UOL,A2输出UOH，D1截止，D2导通，Uout&#x3D;UOH;<br>3）、URL&lt; Uin&lt;URH，A1输出UOL,A2输出UOL，D1截止，D2截止，Uout&#x3D;UOL;  </p><p><img src="https://pic4.zhimg.com/80/v2-aeaa48cfd7e38a1419382c36885002f7_1440w.webp"></p><p>图2.15，窗口比较器的逻辑</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>0电路分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运算放大器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机变量与分布</title>
    <link href="/Blogs/2025/08/28/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E4%B8%8E%E5%88%86%E5%B8%83/"/>
    <url>/Blogs/2025/08/28/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E4%B8%8E%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<ol><li><ul><li><p>​<strong>​分布类型​</strong>​</p><table><thead><tr><th>分布类型</th><th>概率函数&#x2F;密度函数</th><th>期望</th><th>方差</th><th>应用场景</th></tr></thead><tbody><tr><td>​<strong>​二项分布​</strong>​</td><td>P(X&#x3D;k)&#x3D;Cnk​pk(1−p)n−k</td><td>np</td><td>np(1−p)</td><td>n次独立伯努利试验</td></tr><tr><td>​<strong>​泊松分布​</strong>​</td><td>P(X&#x3D;k)&#x3D;k!λke−λ​</td><td>λ</td><td>λ</td><td>稀有事件发生次数</td></tr><tr><td>​<strong>​指数分布​</strong>​</td><td>f(x)&#x3D;λe−λx (x&gt;0)</td><td>λ1​</td><td>λ21​</td><td>寿命&#x2F;等待时间模型</td></tr><tr><td>​<strong>​正态分布​</strong>​</td><td>f(x)&#x3D;σ2π​1​e−2σ2(x−μ)2​</td><td>μ</td><td>σ2</td><td>自然现象测量误差</td></tr></tbody></table></li><li><p>​<strong>​重要性质​</strong>​</p><ul><li>​<strong>​正态标准化​</strong>​：若 X∼N(μ,σ2)，则 σX−μ​∼N(0,1)</li><li>​<strong>​可加性​</strong>​：<ul><li>二项分布：Xi​∼B(ni​,p)⇒∑Xi​∼B(∑ni​,p)</li><li>正态分布：Xi​∼N(μi​,σi2​)⇒∑ai​Xi​∼N(∑ai​μi​,∑ai2​σi2​)</li></ul></li></ul></li><li><p>​<strong>​随机变量函数​</strong>​</p><ul><li>​<strong>​期望​</strong>​：E[g(X)]&#x3D;{∑g(xk​)pk​∫g(x)f(x)dx​离散连续​</li><li>​<strong>​方差​</strong>​：Var(X)&#x3D;E[X2]−(E[X])2</li><li>​<strong>​协方差​</strong>​：Cov(X,Y)&#x3D;E[XY]−E[X]E[Y]</li><li>​<strong>​相关系数​</strong>​：ρXY​&#x3D;Var(X)Var(Y)​Cov(X,Y)​</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
      <category>概率与统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随机变量与分布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行内存都在运行什么</title>
    <link href="/Blogs/2025/08/28/%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E9%83%BD%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%BB%80%E4%B9%88/"/>
    <url>/Blogs/2025/08/28/%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E9%83%BD%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="数字存储完全指南-05：运行内存都在运行什么？"><a href="#数字存储完全指南-05：运行内存都在运行什么？" class="headerlink" title="数字存储完全指南 05：运行内存都在运行什么？"></a>数字存储完全指南 05：运行内存都在运行什么？</h1><p>恭喜你，看到这里你已经能够全面理解现在主流数字储存设备的结构原理了，除了机械硬盘和固态硬盘外，在数字储存世界还有很多我们日常见到，也比较常用的设备。比如我们电脑中不可或缺的部件 —— 运行内存 RAM 也是一种数字储存设备；而 U 盘和移动硬盘则是大家非常熟悉，使用过无数次的日常随身必备物品，而小巧的内存卡，更是从几十年前的 MP3 到最新的数码相机都必不可少；最后我们更是不能忽略自己天天使用的手机里面 ，存放着系统和我们重要数据，24*7 不间断为我们提供高速存取的储存芯片。</p><p>在本篇文章中，我就给大家来说说除了机械硬盘和固态硬盘之外，一些其他在数字储存世界中占据重要地位的设备，包括<strong>运行内存、U 盘、内存卡、移动硬盘、手机储存芯片</strong>等。在前几章积累的知识上，带大家快速了解它们的结构和原理，并说说它们不同的一些规格参数都代表着什么。最后给大家讲讲这些设备在现在已经发展到了什么程度，相信大部分人看到自己曾经熟悉到不能再熟悉的设备，现在发展的水平，都会惊叹人类科技水平发展的速度之快。</p><p><img src="https://cdn.sspai.com/2021/10/19/063fc479299aebfbb7f46dcdf2c5891d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>我们常用的不同类型其他储存设备</p><h2 id="运行内存-RAM-的结构原理参数"><a href="#运行内存-RAM-的结构原理参数" class="headerlink" title="运行内存 RAM 的结构原理参数"></a>运行内存 RAM 的结构原理参数</h2><p>相信很多人都知道电脑里面有一种叫做内存条的东西，也知道它是电脑必不可少的部件，但它具体是什么，相关的参数怎么看大家就很少去了解了。</p><p><img src="https://cdn.sspai.com/2021/10/19/b6cda0fc6dfe7f297c2cfdcc9b3fba0f.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>插在计算机上的内存条</p><p>电脑里面的内存条和手机里面的运行内存等等，只要是将储存设备里面的数据存入超高速缓冲区，以供处理器交换数据的部件，我们都可以将它称为运行内存 RAM。但其实在上一章我们也学习到很久以前的固态存储设备同样是使用 RAM 来做存储介质的，就是断电会消失数据那种。</p><blockquote><p>很多同学觉得 RAM 运行内存好像不算储存设备，但其实它也是一种储存器，只不过断电数据会消失而已。<strong>只要不让它断电，就和超高速的固态硬盘没有什么区别</strong>，还有专门的企业级内存盘，很多服务器都使用它来储存经常需要交互的数据，甚至我们自己也可以用软件来搭建一个内存盘，存放一些不重要但是经常交互的数据获得飞一般的体验（比如游戏）。</p></blockquote><h3 id="运行内存-RAM-的结构"><a href="#运行内存-RAM-的结构" class="headerlink" title="运行内存 RAM 的结构"></a>运行内存 RAM 的结构</h3><p>由于现在运行内存的参数越来越高，性能越来越好，发热也逐渐增大，也让它成为了计算机里面即将需要独立散热的部件之一，所以我们现在购买的内存条通常都会被一层马甲所包裹用于散热，一般看不见里面的结构。</p><p><img src="https://cdn.sspai.com/2021/10/19/02100169d30b2a5a88f57e5c4dc3bd42.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>爱国者 Aigo 的内存条马甲</p><p>如果我们把内存条的马甲拆开<strong>（通常别拆）</strong>，就能看到一个经典的运行内存条结构：</p><p><img src="https://cdn.sspai.com/2021/10/19/ac98e7993c138712512d6e5c287e817d.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>运行内存结构</p><p>运行内存的结构也算是比较简单，底下就是接口，也就是说我们常说的金手指，接口类型通常是 DIMM&#x2F;SO-DIMM（这个我们下面会介绍），缺口两边的长度不一样长防止我们把内存条插反了，上面的两个缺口是用来给插槽上的卡口卡紧内存条的的。而剩下的<strong>主要就是用来储存数据的 DRAM 颗粒和一个储存这内存条信息的 EEPROM 了</strong>，这个 EEPROM 叫做 <strong>SPD 芯片</strong>，主要作用就是储存这个内存条的相关信息，比如品牌，频率，容量，时序电压等等，<strong>主板就是靠它来识别内存条</strong>。其它的还有时钟缓存之类的通常也会集成在一个地方。</p><p>在每个颗粒底下，我们还能看到一些小小的黑色芯片，这些也是缓存芯片，只不过作用是暂时缓存每个颗粒上读出来的数据。</p><p><img src="https://cdn.sspai.com/2021/10/19/a6a53a567782c8cd18566452eab914f7.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>DRAM 颗粒底下的缓存芯片</p><p>而一些轻薄本或者手机之类的高级程度设备则会更进一步，直接把 DRAM 颗粒焊在主板上，之前我们还学到机械硬盘和固态硬盘都会自带一个控制器来控制数据的输入输出，而<strong>运行内存的内存控制器（Memory Controller）则不是在内存条上，而是在之前的北桥或者现在的处理器内部</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/56295613feb16f1b03e67cc397a5a863.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Windows 平板上的运行内存 DRAM 颗粒</p><h4 id="静态随机储存器和动态随机储存器"><a href="#静态随机储存器和动态随机储存器" class="headerlink" title="静态随机储存器和动态随机储存器"></a>静态随机储存器和动态随机储存器</h4><p>我们都知道运行内存是一种易失性储存器（Volatile memory），但易失性储存器又有静态随机储存器（SRAM）和动态随机储存器（DRAM），我们常说的 DDR 内存条储存单元就是 DRAM，CPU 缓存则是 SRAM。</p><p>无论是什么类型，易失性储存器只要断电数据都会很快丢失。<strong>所谓的静态和动态，区别就在于通电的时候数据能否一直保持</strong>。动态储存器里面储存的数据需要周期性地更新，不然就没办法保持数据完整，下面原理会介绍到为什么。</p><p>从结构上看 <strong>SRAM 和 DRAM 的区别是储存单元的不同</strong>，SRAM 储存单元由 6 个晶体管组成，而 DRAM 储存单元由一个晶体管和一个电容组成。<strong>DRAM 数据其实是储存在储存单元的电容中</strong>，电容的电会慢慢消失，所以需要周期性重新充电维持数据，而 SRAM 不需要这些结构，同时储存数据是利用正反器电路（一种可以保持稳态的电路，感兴趣的同学可以直接搜名字或者英文名 Flip-flop，顺便说一下，这个英文名是人字拖的意思哈哈），没有给电容充电等过程，<strong>所以 SRAM 会比 DRAM 还要快很多</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/088e3dfdc7988a05f8652d1351fe088a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>典型的 SRAM 和 DRAM 的储存单元结构</p><blockquote><p>Transistor 就是晶体管，Capacitor 就是电容，Word line 决定了对应储存单元的通断，Bit line 是用于读取或者写入数据的通道。</p></blockquote><p>但是 SRAM 储存 1bit 需要使用 6 个晶体管，这意味着会占用几倍的晶圆面积，所以 SRAM 造价非常高，通常只能做几十 MB 来当作 CPU 缓存之类的用途。而 DRAM 虽然数据需要周期性刷新，但它简单的结构让造价更加便宜，也可以做大容量，所以就用来做我们的内存条了。</p><h4 id="内部储存器和外部储存器"><a href="#内部储存器和外部储存器" class="headerlink" title="内部储存器和外部储存器"></a>内部储存器和外部储存器</h4><p>另外我们说内存内存，其实就是内部储存器的缩写，而前面介绍的机械硬盘，固态硬盘等等则属于外部储存器。一般来讲能够直接与处理器交互的都称之为内部储存器，而数据需要通过高速缓冲区中转的设备一般叫做外部储存器。</p><p><strong>但人们对这些称呼该怎么用其实还是蛮混乱的</strong>，比如我们都知道 Android 手机把手机自带的储存空间叫做 Internal Storage，也就是内部储存（但其实按照前面的定义它也属于外部储存器），很多人就会把它和运行内存搞混，产生「我的手机有 64G 内存，你的才 4G」这种误解。<strong>所以大家提起 RAM 时建议用运行内存或者运存来称呼</strong>，另外大家通常把 SD 卡叫做内存卡也是类似，其实按照分类 SD 卡应该是外部储存器，叫「外存卡」比较贴切一点。不过这些称呼已经约定俗成了，也没有一个比较统一的标准，所以还会继续混乱下去。</p><p><img src="https://cdn.sspai.com/2021/10/19/5d130346939304764d3a6d574a202f8a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>现在搜索一下还有很多相关问题和文章，购物软件数码产品相关的商品评论里面也经常会有类似的误解</p><h3 id="运行内存-RAM-的原理"><a href="#运行内存-RAM-的原理" class="headerlink" title="运行内存 RAM 的原理"></a>运行内存 RAM 的原理</h3><p>其实通过前几章，我们学习到固态硬盘原理之后，运行内存的原理也就比较好理解了。</p><p>运行内存主要存储数据的是 DRAM 颗粒，而 <strong>DRAM 颗粒储存单元由一个晶体管（MOS）和一个电容组成</strong>。其实这个晶体管的结构就和上一章的浮栅晶体管差不多，只不过不需要永久保存数据，也就没有了中间浮栅的结构。</p><p><img src="https://cdn.sspai.com/2021/10/19/4a94fb869d62b6958d4b91273162778c.gif"></p><p><img src="https://cdn.sspai.com/2021/10/19/0a031bf202b96a5771b66d503b1628af.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>DRAM 晶体管结构和它实际在电子显微镜下的样子，图片来源：三星 Samsung 半导体</p><p>它读取和储存数据的原理和方法就和我们学到浮栅晶体管差不多，<strong>只不过没有了浮栅去存储电子，而是把这部分转移到了电容上</strong>。这样做的好处是节省了量子隧穿效应改变电子量的时间，同时没有量子隧穿效应的磨损，也没有 MLC&#x2F;TLC 等等这种复杂的判断，电容充电就是 1，没有充电就是 0。<strong>所以 DRAM 颗粒比起之前介绍的固态 NAND 颗粒速度能快上几十上百倍，读写寿命近乎无限</strong>。</p><blockquote><p>我们上面提到 DRAM 需要动态刷新保持数据，按照 JEDEC 标准是每 64ms 刷新一次，那么<strong>一天就要刷新 100 多万次</strong>，换成 NAND 颗粒早就挂了。</p></blockquote><p>然后这些储存单元用并联的方式串在地址线数据线上，和我们前一章介绍到的 NOR 闪存类似，也是可以<strong>单独读写到每一个储存单元数据的</strong>。这样做的好处是优秀的随机读写能力，<strong>单个储存单元随机读写的优势在于，无论访问或者写入哪个物理储存单元的数据，用的时间都是一样的</strong>。既不像机械硬盘那样离磁头臂远的地方读写时间就长，也不像固态硬盘那样需要同时读写整个块，最后的结果就是 CPU 每个时钟周期内能获取执行的指令变多，更充分发挥 CPU 的性能，这也是我们要用越来越快的运行内存来做 CPU 和外部储存设备之间「中介」的主要原因。</p><ul><li>很多个储存单元会按照横竖排列成一个 <strong>Bank</strong>（内存银行），每个 Bank 最下方还有一排 Row Buffer，用来缓存每一列的数据，接收到读取对应列上某个储存单元数据的指令，就把缓存里面的数据发出去。</li></ul><p><img src="https://cdn.sspai.com/2021/10/19/643fa782686639a13d3005371651eda7.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>DRAM 颗粒的 Bank 结构，实际上会有好几十万排和列</p><p>现在还有 <strong>3D DRAM</strong> 技术，就是横竖排列基础上再加一个层数，每一层再有一个层数据缓存，也是类似的原理。现在很多密度大的 DRAM 颗粒还会有 DRAM Group 技术，也就是将几个 Bank 分为一组。</p><ul><li>很多个 Bank 层叠起来就成了 Die，通常一个 Die 就是我们看到的一个 <strong>DRAM 颗粒</strong>。</li></ul><p><img src="https://cdn.sspai.com/2021/10/19/9c0e955f393dab57f233cd8803107891.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>DRAM 颗粒和 Bank Group 的结构，很多层 Bank 组成 DRAM 颗粒</p><p>这样对比起来 DRAM 颗粒还是比闪存颗粒结构要简单，比起闪存颗粒动不动每块几十上百亿个晶体管，一根 8GB 的内存条上双面有 16 个 DRAM 颗粒，每个颗粒才 512MB，分 8 层的话每个 Bank 才 64MB。</p><blockquote><p>下面介绍会涉及到<strong>位宽</strong>，这里简单解释一下就是<strong>一个部件每个时钟周期在某个线路能发送的数据</strong>，比如 CPU 和运行内存之间的总线，在一个 CPU 时钟周期内能向运行内存发送或者接收 64bit 的数据，那么这个 CPU 的内存位宽就是 64bit，<strong>我们常说的 32 位或者 64 位处理器指的就是一个 CPU 周期能够处理 64bit 的数据</strong>。</p></blockquote><ul><li>一根内存条上有很多个 DRAM 颗粒，这些颗粒合起来就是一个 <strong>Rank</strong>（内存区块）。<strong>注意 Rank 并不是物理结构而是逻辑结构</strong>，由于现代的 64 位处理器每个内存时钟周期内会向运行内存发送或读取 64bit 的数据，而每个颗粒在这个时间段只能执行 8&#x2F;16&#x2F;32bit 的数据读写，<strong>所以就需要根据颗粒的位宽来把几个颗粒合并成一个 64bit 位宽的组同时读写</strong>，最大化利用上 CPU 的性能，同时增加单条运行内存条的容量。</li></ul><p>刚才我们看到运行内存条一面都会有 8 个颗粒，它们就会按照位宽组成 1-4 个 Rank。关于 Rank 的意义和实际作用我们会在下面相关参数部分讲。</p><p><img src="https://cdn.sspai.com/2021/10/19/e01c4ab4220e4c4774ffede48bbdcef3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>运行内存的 Rank 划分，图片来源 Youtube@LinusTechTips</p><ul><li>电脑主板上插运行内存条的地方叫做 <strong>DIMM 插槽</strong>，笔记本或者便携设备上小的那个叫做 SO-DIMM，通常一个<strong>物理</strong>（记住这点） DIMM 槽就是一个<strong>内存通道（Channel）</strong>。至于意义和实际作用，我们也会在下面相关参数那里再讲。</li></ul><p><img src="https://cdn.sspai.com/2021/10/19/5c586771c1ab6aedcbb47a5f2782bf56.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>插运行内存条的 DIMM 插槽，主板正放的情况下一般都在 CPU 插槽的右边</p><p>其实除了内存条和手机等其他类似功能的部件，还有其他几种类型的 RAM，比如我们现在的空气显卡里面就有专门优化用于交换图形数据的 SGRAM&#x2F;VRAM 等等，基本原理都大同小异。</p><blockquote><p>内存颗粒整个地球上目前基本只有 4 家厂商能够生产：<strong>三星、海力士、镁光、长鑫存储</strong>。</p></blockquote><h3 id="运行内存-RAM-的常见参数解读"><a href="#运行内存-RAM-的常见参数解读" class="headerlink" title="运行内存 RAM 的常见参数解读"></a>运行内存 RAM 的常见参数解读</h3><p>了解了运行内存的基本结构和原理之后，我就开始来给大家解惑最想知道的各种参数了。下面介绍的大部分参数一般都会在商品详情或者包装盒上标注，也可以通过像是 CPU-Z 这样的软件来查看。</p><h4 id="现代运行内存的本质：SDRAM-DDR"><a href="#现代运行内存的本质：SDRAM-DDR" class="headerlink" title="现代运行内存的本质：SDRAM&#x2F;DDR"></a>现代运行内存的本质：SDRAM&#x2F;DDR</h4><p>到这里我们已经提过几次 DDR 技术了，我们平常使用运行内存的时候也会看到像是 DDR3&#x2F;DDR4 这类的字眼。</p><p><strong>我们现在能买到的现代运行内存条，本质上不是 DRAM 而是SDRAM</strong>，不过因为不是 SDRAM 的颗粒太少所以大家通常都直接用 DRAM 来表示这个了。这个 S 是同步（synchronous）的意思，也就是说内存颗粒的读写访问可以通过控制器与 CPU 时钟对齐同步，不会出现 CPU 等运行内存执行指令或者运行内存等 CPU 发送指令的情况。</p><p>DDR（Double Data Rate），从全写就可以看出来，它是可以让数据传输速率翻倍的技术。简单来讲就是原本 Single Data Rate 只是 CPU 每个时钟周期能读写一次运行内存的数据，而 DDR 能让每个时钟周期发送脉冲的上下沿都发送一次数据给 CPU，这样就能让传输速率翻倍。</p><p><img src="https://cdn.sspai.com/2021/10/19/228a6c7f88522098de6f4d072923af25.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>还有 QDR 一个时钟周期发送 4 次数据的技术，图片来源：Youtube@GamerNexus</p><blockquote><p>如果你还对时钟周期相关的概念比较模糊，可以去知乎搜索下这个名词，有很多答主给了一些很棒的比喻来解释。</p></blockquote><p><strong>DDR1 到 DDR4 都是一个内存时钟周期发送两次数据，但不同的是每次发送的数据量变大了</strong>。因为 CPU 指令每个周期需要读写写入的数据量很少（64bit），而指令数据通常都在一块，所以可以通过预测算法预读取数据发送，比如 DDR2 一个时钟周期预读取 4bit 的数据，DDR3 一个时钟周期预读取 8bit，DDR4 根据不同的 Bank 数量预读取 8 或 16bit 放到 CPU 的三级 L3 缓存。这样子就能节省很多个 CPU 周期的命令，节省下来的时间，就可以继续执行 CPU 给的更多命令，从而实现相同的核心频率实现好几倍的工作效率。</p><blockquote><p>之所以 DDR2 开始一次预读取数据越来越大，是因为内存芯片会给更高的时钟频率，所以一个周期变短，同样时间内读取颗粒的次数变多，也就能读取更多的数据了。</p></blockquote><p>另外 DDR1 到 DDR4 运行内存条本身都是不兼容的，它们的接口插槽和金手指形状都不一样，缺口位置也不一样，所以不能通用，也要对应的主板才可以。</p><p><img src="https://cdn.sspai.com/2021/10/19/7147f047c398d6efa9445a6cb92dde5d.gif"></p><p>电脑和笔记本上常见的 SDRAM，DDR1-DDR4 运行内存条金手指对比，图片来源：PCMag（非源地址，知悉源地址的朋友可以联系我）</p><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>和其它储存设备一样，大部分用户看运行内存首先考虑的就是容量。而运行内存和普通储存设备的区别就在于它<strong>不用来实际长期储存数据</strong>，所以并不是买多大的容量就能用多少，毕竟好的运行内存条按照容量算比其它储存设备贵多了，买了用不上，还不如把这些钱花到其它地方。</p><p>在我们日常使用中，<strong>与运行内存最直接相关的就是能够在后台运行程序的数量</strong>，无论是电脑还是手机，运行内存越大能够在后台保留的程序就越多。随着应用游戏甚至系统的内存要求越来越大（比如 Win11 最低运行内存要求居然要 4GB），我们对于主力设备运行内存容量的要求也越来越高，所以我们要根据自己的需求去配置运行内存容量。</p><p><img src="https://cdn.sspai.com/2021/10/19/869c3c78c7d33468443e4aa8a587b827.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>现在常用的容量一般是 16G，开多应用玩绝大部分游戏游戏都能满足</p><blockquote><p>上面的运行内存使用情况是我在开着几个播放器、VS Code 编辑文章、几十个页面的 Chrome、Adobe PS、AI 等大型软件的时候截的，系统是 Windows11。</p></blockquote><p>另外如果你的运行内存容量实在太小，又或者运行一些超大型软件（视频剪辑，特效，3D 等等），那么<strong>运行内存容量不足不仅会让后台运行程序数量变少，也会让前台运行程序和系统变卡</strong>。因为系统为了保证程序不崩溃，会把一些程序在运行内存里面的数据暂时放到储存盘上，等到运行内存有空间时再搬回来（在 Windows 上这个就是虚拟内存，Linux 和手机上一般叫 SWAP）。但无论是机械硬盘还是固态硬盘速度都比运行内存慢很多，所以一旦运行容量不足，部分程序就相当于运行在硬盘上，程序少的时候还好，但当虚拟内存越用越多，卡慢就是自然的了。</p><p><img src="https://cdn.sspai.com/2021/10/19/acf1fbb00ea6448ae33dbcc83e698f44.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>可以用 AIDA64 之类的软件看到虚拟内存的使用情况</p><p><strong>另外一个比较吃运行内存容量的是浏览网页</strong>，特别是后台多标签的时候，有大量数据需要缓存在运存中，比如著名的 Chrome 吃内存梗。不过只要你不开一些大型软件，只是日常使用，即使是多开浏览器微信播放器等等的日常应用 16G 也能剩余很多。</p><p>另外说下游戏，<strong>一般游戏对于运行内存容量的要求并不高，只要能满足推荐设置即可</strong>，反而是我们下面介绍的运行内存频率和时序对游戏帧率的影响更加大（比较出名的就是绝地求生吃鸡了，这个游戏其它配置相同，高频运行内存和低频运行内存帧率能差一半）。</p><p><img src="https://cdn.sspai.com/2021/10/19/b65cac6b9921ea22020a7683a90132be.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>即使是最新的 3A 大作比如赛博朋克 2077，8GB 容量都满足最低要求了</p><blockquote><p>至于如何根据你日常的使用挑选运行内存容量，我就放在选购那一篇给大家讲了。</p></blockquote><h4 id="频率-XMP"><a href="#频率-XMP" class="headerlink" title="频率&#x2F;XMP"></a>频率&#x2F;XMP</h4><p>如果说容量是用户选择运行内存条时的第一反应，那么频率就是大部分用户用户接着会考虑的参数。大部分人都知道频率是越高越好，那么频率到底代表什么呢？简单来讲，<strong>运行内存的频率表示处理器每秒可以对内存颗粒读写多少次</strong>，比如理想状态下 DDR4 3200Mhz 的内存条就能让 CPU 每秒读写 3200*100,0000 &#x3D; 32,0000,0000 也就是 32 亿次，是不是很惊人。</p><blockquote><p>结合上面学到的 64 位处理器，每次读写 64bit 数据，我们就能算出运行内存（单通道）大概的速度，32,0000,0000*64≈23.84GB&#x2F;s，但内存延迟和通道数会影响读写次数，甚至不同主板还有供电的用料都会影响这个速度，DDR4 3200Mhz 双通道实际读写复制速度大概在 40GB&#x2F;s 左右。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/19/fcea30a9befe93a73d9e2a789eba118e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>高频运行内存条的价格也不是很贵</p><p>细心的朋友就会发现，好像这个频率只和 CPU 的处理能力有关，那么为什么要标注成运行内存的参数呢？答案是内存颗粒的体质，每个 DRAM 颗粒生产出来的时候里面晶体管的质量还有数量都不一样，<strong>所以就会导致不同 DRAM 颗粒每秒能让 CPU 读写的最高次数不一样</strong>，再高就会导致数据读写失败甚至损坏 DRAM 的晶体管。</p><p>所以厂商通常会将同一批次不同体制的 DRAM 颗粒做成不同频率的运行内存条，体质好的就做成 3000Mhz，3200Mhz 甚至更高，当做高端运行内存条卖，体质不好的就做成 2400Mhz，2666Mhz 这种。这也是为什么我们经常会看见<strong>同一个牌子型号的运行内存条会有不同频率版本</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/4a7ace96b3f90066d0bf43a5d5422aa7.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><img src="https://cdn.sspai.com/2021/10/19/5c40e55eb42a0854a5a53adaf62448b5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>同一型号不同频率（2400Mhz&#x2F;4000Mhz）的内存条价格对比</p><p>而且厂商为了保证内存条能够稳定运行，通常标称的频率会低很多，而且主板厂商也没办法检测运行内存条颗粒的体质，为了稳定只能设定<strong>运行内存条插上去之后默认会运行在对应 DDR 代数最低的频率</strong>，比如 DDR4 就是 2400Mhz，<strong>需要用户手动在 BIOS 里面调整到标称频率</strong>。</p><p><strong>另外不同处理器和主板对运行内存频率支持也有一个上限</strong>，通常会在处理器或者主板说明书里面标注支持的内存频率，大家购买和使用的时候需要注意。</p><p><img src="https://cdn.sspai.com/2021/10/19/5a4f0c5f06bde586ee04d3bc0b4c75f4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>处理器对支持运行内存频率的说明</p><p><img src="https://cdn.sspai.com/2021/10/19/754e636cc5d9bdc09f8b212281bacb4f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p><img src="https://cdn.sspai.com/2021/10/19/f12ea51c5746249cdf1c64e2a487b95f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>主板对支持运行内存频率的说明，这里的 OC 就是 OverClock 超频的意思，参数分别来自两个品牌的 B560M 主板</p><p>这里细心的同学又发现了，既然频率只是厂商标注的，实际都靠自己手调，那么能不能调高一点呢？没错了，这个就是内存超频玩法，比如买了大厂为了降低售后率通常会把标称频率标低一点，而且大厂用料往往比较好，<strong>所以我们调整内存频率的时候可以调得更高</strong>，正常用料的 2666Mhz 频率运行内存条可以轻松超到 3200Mhz，用料特别好的甚至能超到 3600Mhz 以上。</p><p>很多人推荐运行内存买回来之后，在主板 BIOS 打开 XMP，这里的 XMP（Extreme Memory Profile）就是主板厂商预制好的一些超频配置文件，这些配置文件主板和运行内存生产厂商都会测试过，用户只需要直接选择就可以比较安全地超频。</p><p><img src="https://cdn.sspai.com/2021/10/19/1825eb6475b11b04a796020840a021b9.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>主板 BIOS 上的 XMP 超频选项，图片来源：AnandTech</p><blockquote><p>大家还要超频用用 XMP 就好，千万不要自己乱给运行内存超频，轻则无法开机，重则烧掉运行内存条。至于怎么给自己的运行内存条超频，又怎么调试让它稳定运行，我就放到使用那部分讲了。</p></blockquote><h4 id="频率进阶：核心频率，工作频率和等效频率"><a href="#频率进阶：核心频率，工作频率和等效频率" class="headerlink" title="频率进阶：核心频率，工作频率和等效频率"></a>频率进阶：核心频率，工作频率和等效频率</h4><p>实际上运行内存的频率还分为核心频率，工作频率和等效频率三种，<strong>一般我们在商品详情包装盒和普通软件里面看到的运行内存频率都是等效频率</strong>。</p><p><strong>核心频率就是运行内存控制器和电路的物理时钟频率</strong>，比大家想象中小很多，一般只有 100Mhz~200Mhz，常见的有 133Mhz、166Mhz 和 200Mhz（这也是为啥我们经常看到运行内存频率有零有整的），<strong>从 DDR1 到现在 DDR4 核心频率基本没啥变化</strong>。</p><p>上面我们介绍的 DDR 技术，通过它可以让运行内存一个 CPU 时钟周期发送两次数据，这样能让每个周期读写次数翻倍，<strong>这个 DDR 技术翻倍后的频率就是工作频率</strong>，上面的常见核心频率就变成了 266Mhz，333Mhz，400Mhz。</p><p>上面我们还介绍到了数据预读取，等效频率就是指数据预读取后的效率，比如 DDR4 预读取 8bit，全部预测中的话就相当于每次核心频率读取 1bit 的 8 倍，所以 400Mhz 工作频率的等效频率就变成了 400*8&#x3D;3200Mhz，也就是平常我们看到的频率参数了。</p><p>但现在我们很少看到 4000Mhz 以上的 DDR4 运行内存条，这一方面是因为频率太高，颗粒体质很少跟得上，另一方面则是<strong>预读取技术会让我们下面提到的时序变得越来越高，反而会降低运行内存条的综合性能</strong>。</p><blockquote><p>像是 CPU-Z 这类的软件之所以会把运行内存频率显示的标注频率的一半，就是因为显示的是核心频率的等效频率而不是工作频率的等效频率。</p></blockquote><h4 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h4><p>到这里就进入了大部分商品详情都不会标，大部分用户也不会看，知道这个的人也弄不清楚代表什么的参数范围了。</p><p><strong>时序通常写成「CL16-17-17-35」这样的形式</strong>，每个数字代表的意义要结合我们之前学到的 DRAM 颗粒的结构来看。<strong>所有数字的单位都是 CPU 时钟周期</strong>，下面的 R 指的就是 Bank 里面的行（Row），C 就是列（Column）。</p><p><strong>DRAM 颗粒 Bank 里面的储存单元是按照行列排列的，就跟围棋格子一样</strong>。每次想要访问某个特定组成单元的时候，是先给指定行上的所有储存单元加上阈值电压，然后再检测这行对应列上的那个储存单元的值，将值发送给 Row Buffer。</p><p><img src="https://cdn.sspai.com/2021/10/19/a0a0b034e806d6e74dfd99f0c76b14ed.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>整个寻址的过程大概像是这样子</p><ul><li>第 1 个数字代表 CL（CAS Latency），就是内存控制器发出读写某一个数据的指令到 Row Buffer <strong>准备好</strong>返回数据的延迟。</li></ul><p><strong>这个数字单位是 CPU 时钟周期，是最重要的时序参数</strong>，很多商家也会标出这个数字，延迟自然是越低越好。而换算成时间需要结合频率来算，比如 DDR4 3200Mhz 的运行内存 CL 延迟时间就是 16_2（一个周期读两次）&#x2F;32,0000,0000_10,0000,0000（1 秒等于 10 亿纳秒）&#x3D;10 纳秒。</p><blockquote><p>这个延时的前提是对应数据行的阈值电压已经加好，也就是对应储存单元的电容里面已经有可以检测值的电子。否则还要加上下面介绍的第 3 个数字代表的充电时间。</p></blockquote><p>第 2 个数字代表 RAS to CAS Delay（tRCD），这个数字代表的就是指定行上找到储存单元所在的对应列的时钟周期。</p><p>第 3 个数字代表 RAS Precharge Time（tRP），就是给对应行加阈值电压然后电容充电的时钟周期。</p><p>第 4 个数字代表 RAS Active Time（tRAS），就是保持目标行充电以确保读写成功的时间。</p><p>如果你在查看时序的时候发现后面还跟着个「2T」这样子的参数，这个参数指的就是指令发出到找到对应 DRAM 芯片执行指令的时间，这个参数对于普通用户来讲没什么用。如果你是服务器或者其它插着十几个内存条的设备，那这个参数反映的就是 CPU 执行指令的时候多快找到对应的运行内存条（1T 比 2T 快）。</p><p><img src="https://cdn.sspai.com/2021/10/19/e5d00ed194f5039f85794f0c4f4acbf0.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>服务器上的内存条一般都是插满，图片来源：金士顿 Kingston Technology</p><p>至于实际我们选购使用的时候就不用考虑这么多，<strong>简单来讲就是第一个数字越低越好，基本上可以等于运行内存的等级，在此基础之上，剩下三个数字越低越好</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/d9b8bc9093ee841dabc7fe0e71409305.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>通过 CPU-Z 可以轻松查看自己运行内存条的时序</p><p>另外给大家讲一个很好玩的事情，<strong>那就是内存条上的 RGB 灯效某种情况下真的会影响内存条的性能</strong>，不过不是立刻提升 100%，我看见过分两种情况，一种是因为电压问题，导致运行内存条的时序稍微增大，另一种是因为太多 LED 或者灯光设计问题导致发热，从而影响运行内存条的性能，这种情况我还没有找到验证。</p><p>不过另一种情况就有 YouTuber 验证过了，一般来讲如果电脑上运行内存条有 RGB 灯效的人，通常电脑上还会有其它灯效，这样子所有 LED 加起来的发热和灯效驱动去稍微影响 CPU 性能，特别是某些牌子设计的比较烂的驱动和管理软件，还有电脑里面有几家不同的光效（比如神光同步和 ICUE 啥的），多个软件之间对处理器的影响还会叠加，不过这些相对于现在电脑技能来讲都是不需要介意的，只是有点神奇。</p><p><img src="https://cdn.sspai.com/2021/10/19/f8dc1eeaff6203f662593486b464289a.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>带酷炫的 RGB 灯的运行内存条，图片来源：ThermalTake</p><h3 id="频率和时序的关系与优先级"><a href="#频率和时序的关系与优先级" class="headerlink" title="频率和时序的关系与优先级"></a>频率和时序的关系与优先级</h3><p>时序反映的是每次操作的延时，<strong>延迟低了，每秒的操作次数自然也就越多。越低的时序通常代表着颗粒的体质越好，也就能超到更高的极限频率。</strong></p><p>但也像我上面提到的，过高的频率也会增加时序。主要原则就是<strong>相同频率下时序越低越好，相同时序下频率越高越好</strong>。</p><p>DDR4 之前的运行内存，频率比时序重要得多，而到了 DDR4 时代，频率和时序都同样重要，虽然非要选一个的话，还是优先考虑频率。</p><p>放到实际的情况就是，如果时序一样频率差别不大，比如同样时序的 DDR4 2666Mhz 和 DDR4 3200Mhz，在日常使用中可能感觉不太出来差别，反过来频率相同时序差别不大，也是一样的情况。我看了一圈测试，游戏方面基本只差 1~2FPS，日常软件加载和操作时间也差不多。</p><p><img src="https://cdn.sspai.com/2021/10/19/657cb25924b449a9654ee3e17c1f9850.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Lineus 测试同样配置下不同内存频率相对性能提升的结果</p><p><strong>但对于内存敏感的软件和游戏来讲就不一样了，比如 Adobe 全家桶和开放世界等大容量大型游戏</strong>。这些软件和游戏有一个共同的特点，就是需要频繁的切换运行内存里面的数据，同时数据容量大，CPU 缓存放不下，这个时候 CPU 就会开始频繁请求运行内存数据，就能明显体会出频率的差别了。3200Mhz 和 2400Mhz 在帧率敏感游戏当中会出现几十帧的差距，特别是最低帧率差距明显，就是因为频率低的内存读取速度跟不上显卡的每帧生成时间了。生产力软件也是如此，比如 Adobe 全家桶的文件导入导出，和复杂素材的加载，高频运行内存都会快很多，甚至能快 20%，时序的影响少一点，但也有可以感知的影响。</p><p><img src="https://cdn.sspai.com/2021/10/19/251012fe94312f056993b1217d59a8fe.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>PC Gamer 的 4K 游戏测试，AMD 平台</p><p><img src="https://cdn.sspai.com/2021/10/19/b3286fb86ef576355a476f891aca2ddf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>PC Gamer 的 4K 游戏测试，AMD 平台</p><blockquote><p>至于其它平台测试结果和结论可以直接查看 PC Gamer 的文章 <a href="https://www.pcgamer.com/does-ram-speed-matter-gaming-amd-intel/https://www.pcgamer.com/does-ram-speed-matter-gaming-amd-intel/">「Don’t waste money chasing RAM speed for gaming on AMD or Intel」</a>，更加详细的容量频率和时序购买建议，我会放到选购部分给大家详细讲解。</p></blockquote><h4 id="1Rx4，2Rx8-这类的参数是什么？"><a href="#1Rx4，2Rx8-这类的参数是什么？" class="headerlink" title="1Rx4，2Rx8 这类的参数是什么？"></a>1Rx4，2Rx8 这类的参数是什么？</h4><p>如果我们拥有一些没有马甲的运行内存条，或者在一些大品牌的运行内存条商品详情里面，还会看到内存条容量后面跟着类似「1Rx8，2R*4」这类的参数。</p><p>这个参数里面的 R 其实就是我们上面介绍运行内存条结构时候提到的 Rank，上面提到 Rank 是逻辑结构，其实它是针对运行内存 DIMM 物理插槽的一个优化。</p><p>DIMM（Dual In-line Memory Module）是 S（Single）IMM 进化而来的插槽，在很久以前内存条只有单面有颗粒和金手指。</p><p><img src="https://cdn.sspai.com/2021/10/19/24e1704ea4a7dd70d81adf6b8f027170.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>单面内存条，图片来源：Sierra Indigo</p><p>后来处理器性能飞速增长，单面颗粒的位宽开始追不上 CPU 了，人们就想到了把<strong>运行内存条两面都加上 DRAM 颗粒，然后金手指和插槽两面都弄上金手指，这样就能同时读取两倍的数据，将位宽翻倍了</strong>，这个就是 DIMM 接口。</p><p>再后来<strong>处理器性能还在提升，系统程序越来越复杂，就要求越来越高的运行内存容量</strong>，由于 <strong>DIMM 插槽的位宽根据不同类型只有 32&#x2F;64&#x2F;72bit</strong>，主板上开始出现三个甚至四个 DIMM 槽，但是大家都知道运行内存是特别高频高速和处理器交互的东西，考虑到主板空间和总线的质量，运行内存插槽要离处理器很近并且数量不能很多（不然主板空间不够，而且距离最远的那个插槽信号质量会下降）。</p><p><img src="https://cdn.sspai.com/2021/10/19/fa46a6ceb9829958076f21e32f3ce9a4.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>一般的主板都只会提供 4 个运行内存插槽，也就是 4 个 DIMM</p><p>既然插槽不能多，那就只能增加单条运行内存条的容量了，这个时候人们就想到了 Rank，按照颗粒的位宽将几个颗粒并成一个 64bit 的 Rank，然后一条内存条做几个 Rank，等要读写数据的时候，先确定 Rank 然后在执行对应的指令。<strong>这样人们就能把几个运行内存条的颗粒做到一个内存条上，Rank 就相当于一个虚拟的 DIMM 插槽，最终的效果就是极大增加了单条运行内存条的容量。</strong></p><p>举个例子，我们常见的内存条一面通常有 8 个 DRAM 颗粒，两面就是 16 个，如果是 2R*8 的排列，那就意味着这个内存条有两个 Rank，每个 Rank 有 8 个 DRAM 颗粒，<strong>每个颗粒的位宽就是 64&#x2F;8&#x3D;8bit，也就是后面那个数字的意义</strong>。同样 16GB 1R 的内存，4bit 需要 16 颗 1GB DRAM 颗粒，8bit 需要 8 颗 2GB DRAM 颗粒，16bit 需要 4 颗 4GB DRAM 颗粒，大容量颗粒的成本高，但是节省空间；小容量颗粒成本低，需要多个才能拼成同样的容量，但是数据稳定性比较好。</p><p><img src="https://cdn.sspai.com/2021/10/19/8b9ded4949441eb90a47672becbc7103.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>上面出现过的 Rank 介绍，图片来源：Youtube@LinusTechTips</p><blockquote><p>JEDEC 标准规定的 DRAM 颗粒位宽目前只有 4，8，16bit，Rank 数量只有 1，2，4。</p></blockquote><p>虽然读写数据会增加多一步寻找 Rank 的操作，但因为每个 Rank 都是独立的（这也是它的意义），可以并行读取，所以 <strong>Rank 多的运行内存条速度会快一点</strong>。其实这个参数我们知道它是干什么的就行了，因为<strong>它跟我们日常使用关系不大</strong>，因为民用运行内存条一般都是 x8，除非你用 x16 和 x4 的同一品牌同容量运行内存条去对比才能感觉出 20% 左右的差距。</p><p>另外有一些内存条，常见于服务器的内存条，<strong>我们叫它 ECC 内存条，特点就是一面通常会有 9 个 DRAM 颗粒</strong>。会额外添加 8bit 的纠错码（Error Correct Code）用来校验纠正数据，这样就让一个 rank 的位宽变成 72bit 了。</p><p><img src="https://cdn.sspai.com/2021/10/19/0819ea962f1a3ac93d4d9acc79bc0917.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>服务器用的 ECC 运行内存条，有 9 个 DRAM 颗粒，图片来源：ITinStock</p><blockquote><p>但是 Youtube@LinusTechTips 在这篇文章编写时出了个视频，指出现在芯片短缺的时候有一些厂商会故意把笔记本上的运行内存从 1Rx8 换成 1Rx16，节省了背面的 DRAM 颗粒，根据测试这会让笔记本的性能下降约 20%。在某些内存敏感的游戏中，<strong>极端情况下甚至能差出一个从 RTX3070 到 RTX3080 的提升</strong>。</p></blockquote><p><img src="https://cdn.sspai.com/2021/10/19/a2fdad55503f13f7cfe0393b930bb2e0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>同一品牌型号上的笔记本，拆下来的两条不同的运行内存条，图片来源：Youtube@LinusTechTips</p><p><img src="https://cdn.sspai.com/2021/10/19/59e73e80d6b6d4a1c9e4a6089d14c9e9.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>Linus 针对运行内存条 Rank 对性能影响的测试结果</p><blockquote><p>上面测试的方式是把一个 Rank 的 AMD 笔记本和 2 个 Rank 的 Intel 笔记本运行内存条对调。</p></blockquote><h4 id="双通道-多通道"><a href="#双通道-多通道" class="headerlink" title="双通道&#x2F;多通道"></a>双通道&#x2F;多通道</h4><p>有了之前知识的铺垫，接下来终于可以给大家说一下平常我们为什么要买两根内存条组双通道了。</p><p>上面我们学到内存控制器现在一般在处理器里面，<strong>处理器和运行内存条通过内存总线通道交换数据</strong>。<strong>每个内存控制器可以控制一个内存总线通道的数据</strong>，一个内存总线通道上可以有多个 DIMM 内存插槽。</p><p>现在我们买到的民用主板一般都会有 4 个内存插槽，通常主板厂商会将第 1,2 个插槽弄一个通道，第 3,4 个插槽又弄一个通道（一些主板还会有三通道，甚至多到八通道，不过一般都是服务器比较多，正常用户不会插这么多内存条）。</p><p><img src="https://cdn.sspai.com/2021/10/19/d7dd1d260568362f7fda07f58bc43042.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>主板说明书上一般会标注哪个插槽是哪个通道，图片来源：英特尔 Intel</p><p>当我们有两根内存条的时候，大家都会建议你把它插在第 2,4 个，也就是交错插在比较远的内存插槽，主板上一般也会用不同颜色标注出来应该要插在哪里。我们知道，<strong>这个时候两个内存条分别在两个总线通道，受两个内存控制器控制，这样就能用两条总线同时发送或接收信号，数据也会拆分开来分别放在两根运行内存条中</strong>。</p><p><img src="https://cdn.sspai.com/2021/10/19/0a6116815684bdc1a8aae006e3226b47.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>运行内存组双通道的插法，图片来源：ROG ASUS</p><p>有同学会想 CPU 每个时钟周期不是只能处理 64bit 的数据吗？在上面时序部分我们就知道，运行内存读取数据是有十几个 CPU 时钟周期延迟的，而<strong>第一条运行内存条在读写数据时 CPU 就可以通过第二个总线通道给第二条运行内存条发指令，这样两个运行内存条就能交错给 CPU 提供数据</strong>，从而让运行内存读写速度翻倍。</p><blockquote><p>之所以要插比较远的插槽，是因为处理器到内存总线设计是先接到远的插槽，再从远的插槽接到近的插槽（想知道为什么可以自己搜索一下）。另外由于 AMD ZEN2 内存控制器设计问题，双通道写入速度没有翻倍。</p></blockquote><p>官方一般推荐<strong>要组成双通道的话需要两根运行内存条容量一致，时序一致，并且插在正确的插槽上</strong>。所以平常卖家都是两根运行内存条一起卖，大部分时候两根还是连号的，就是为了保证规格和素质差不多，提高使用的稳定性。</p><p><img src="https://cdn.sspai.com/2021/10/19/d21e65c72aa1bab5f4a6a41784516667.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>连号也算是运行内存的一个卖点了，不过没有太大必要去强求连号，只要批次差不多就没问题</p><p>最后给一些好奇宝宝们回答一下，<strong>对于普通用户四通道甚至更多通道会比双通道更快吗</strong>。</p><p>答案是目前并不会，首先普通主板一般都只有四个插槽两个通道，四通道需要高端主板和高端处理器支持，是一笔额外的钱。另外如果真的不差钱，四通道对运行内存条单条体质和多条一致性的要求也很高，即使这样四通道运行内存条也稳定性不如双通道，还会让最高频率变低，超频能力也变差，得不偿失。最后有人真的用 X299 主板测试过了，实际上也是没有性能提升。</p><h4 id="不同品牌，不同频率，不同容量运行内存混搭"><a href="#不同品牌，不同频率，不同容量运行内存混搭" class="headerlink" title="不同品牌，不同频率，不同容量运行内存混搭"></a>不同品牌，不同频率，不同容量运行内存混搭</h4><p>不是所有人都是重新购买两条运行内存条，很多人都蛮好奇，如果用不同品牌，不同频率甚至不同容量的运行内存条混搭，组双通道会怎么样。</p><p>先说说<strong>不同容量的运行内存调组双通道</strong>，比如一条 8GB 的运行内存条和一条 4GB 的运行内存条组双通道之后，<strong>相同容量部分也就是 4GB 是双通道，而 8GB 运行内存条剩下的 4GB 则是单通道</strong>。</p><p>然后是<strong>同品牌不同频率的运行内存条组双通道</strong>，一般来讲也是没有什么事情的（厂商也都会测试过），但就非常亏。<strong>因为双通道会让两个运行内存条的频率变成最慢的那个运行内存条的频率</strong>，因为要保证数据读取的频率一致，其它的倒是没什么。</p><p>最后是<strong>不同品牌相同容量频率组双通道</strong>，其实也没有什么事情，有小概率过不了自检。如果超频容易蓝屏，不超频正常使用最多是稳定性稍微差一点，小概率死机重启。毕竟学过前面的结构原理我们都知道，现在 <strong>DRAM 颗粒结构大同小异，生产厂家也只有那么几家，主控厂家也是只有几家，只要频率和时序差不多，基本没差别</strong>。</p><p>如果你手上是不同品牌，不同频率，不同容量的运行内存条，那是<strong>便宜卖了买两根成套的运行内存条</strong>吧，不要冒不必要的风险。</p><h4 id="其它-DIMM-类型"><a href="#其它-DIMM-类型" class="headerlink" title="其它 DIMM 类型"></a>其它 DIMM 类型</h4><p>除了我们最常见的 DIMM 和笔记本上的 SO-DIMM，另外还有几种 DIMM 接口类型，这里就简单给大家介绍一下。</p><p><strong>SIMM</strong>：上面介绍过了，DIMM 的单面接口版本。</p><p><strong>SO-DIMM</strong>：就是为了在笔记本和 NUC 迷你主机之类的地方使用，而把标准的 DIMM 插槽针脚改掉，整个接口变短变小。</p><p><img src="https://cdn.sspai.com/2021/10/19/99a7ef45efddb4c900f8932d3bf8a147.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>笔记本主板上的 SO-DIMM 插槽</p><ul><li><strong>RDIMM</strong>：就是普通内存条上有一个额外的芯片，用来缓存 CPU 发过来的指令，还有时钟，内存地址等等，增强负载能力和信号质量。这颗芯片也会用来做 ECC 校验，通常这种运行内存条上的颗粒都会很多。</li></ul><p><img src="https://cdn.sspai.com/2021/10/19/d1387f983133a21f26b8faeb5247cc40.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>RDIMM 运行内存条长这样，图片来源：Amazon</p><ul><li><strong>LDIMM</strong>：普通内存条上多很多颗数据缓存芯片和一颗处理芯片，和机械硬盘缓存的作用差不多，不过是威力加强 x10 版，同样也是会有很多颗粒。</li><li><strong>UDIMM</strong>：特调体质粗暴版运行内存条，没有任何缓冲时序调整控制等等，信号直接从 CPU 干到 DRAM 颗粒上，简单直接粗暴。这要求 CPU 到每个内存颗粒之间的距离相等，并行传输，同时颗粒体质要足够好满足 CPU 的速度，所以 UDIMM 容量低，频率低，造价还特别特别贵。通常用在军事，金融或者其他等等对一丁点延迟都非常敏感的地方。</li></ul><p><img src="https://cdn.sspai.com/2021/10/19/def4ee286cfca6afbb257042c704eec8.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>超高端的 UDIMM，图片来源：UBuy</p><h3 id="查看测试运行内存实际速度和延迟"><a href="#查看测试运行内存实际速度和延迟" class="headerlink" title="查看测试运行内存实际速度和延迟"></a>查看测试运行内存实际速度和延迟</h3><p>最后教给大家一个简单的方法，去查看测试自己的运行内存实际速度和延迟。</p><p>查看的方法很简单，我们只需要下载一个上面提到的 CPU-Z 在内存那一栏就可以看到现在这个内存的类型频率时序和其它一些信息。</p><p><img src="https://cdn.sspai.com/2021/10/19/8c262023e5f046ab199823c0573cff97.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>CPU-Z 查看运行内存信息</p><p>然后上面我们测试速度和延迟的方法就是用 AIDA64 这个经典的电脑信息查看软件。它不仅可以跑出内存的读写复制速度和延迟，也能顺便查看一下 CPU L1L2L3 各个缓存的速度（可以看到 CPU 的缓存是快很多的，那就是以后运行内存的目标）。</p><p><img src="https://cdn.sspai.com/2021/10/19/e8f003a860d326813dd30215a6f4718e.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>AIDA64 的运行内存测试</p><h3 id="手机上的运行内存"><a href="#手机上的运行内存" class="headerlink" title="手机上的运行内存"></a>手机上的运行内存</h3><p>到这里运行内存的大部分内容，我们就讲完了，接下来简单给大家介绍一下我们现在智能手机上使用的运行内存。</p><p>手机上运行内存的作用和运行内存条在电脑上的作用类似，不过通常使用的是 LPDDR 技术（手机发布会上也经常能听见这个名词）。</p><p>手机上的运行内存芯片一般都贴在处理器下面，共享底下的总线，反正数据都要先经过运行内存再到 SoC（System on Chip，就是各种不同功能的控制器，包括 CPU 和网络控制器，GPU 等都集合在一个芯片里，我们常听说的骁龙芯片就是 SoC），这样的设计还能节省空间，运行内存和 SoC 接在一起距离最近，还能最大化性能效率。</p><p><img src="https://cdn.sspai.com/2021/10/19/03a197f7b95bec2e1be47a02afa15819.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1"></p><p>藏在 A14 处理器底下的运行内存，图片来源 Mr·white (Twitter@laobaiTD) </p><p>LPDDR（Low Power Double Data Rate），其实就是低功耗的 DDR 的技术，以满足移动设备续航。它的原理和预读取什么的都和我们上面介绍到的 DDR 一样，只不过由于降低功耗调低了电压，让频率降低了。比如最新的 LPDDR5 其实频率就和电脑上的 DDR4 差不多，6400Mbps 或者 51.2GB&#x2F;s 的速度用在手机上已经绰绰有余，更新换代主要还是在于容量的提升，LPDDR5 最大容量来到了 16GB，并且每一代的电压功耗都会降低，让手机续航有明显的提升。</p><p><strong>相关文献</strong>：</p><p>[1]. 关于运行内存的绝大部分标准参数等等都是 JEDEC 固态技术协会提出的，无论你想了解关于运行内存的什么都可以直接查看 <a href="https://www.jedec.org/standards-documents/dictionary/terms/ram">JEDEC RAM 运行内存技术标准</a>。<br>[2]. 关于 DRAM 颗粒的介绍和实际长什么样可以参考 IBM 的<a href="https://www.ibm.com/blogs/research/2019/09/worlds-smallest-dram/">这篇文章</a>。<br>[3]. 关于运行内存 RAM 容量对性能的影响可以稍微看看 Youtube@LinusTechTips 的视频<a href="https://www.youtube.com/watch?v=kUFWalEf31w">「Will More RAM Make your PC Faster?? (2020)」</a>，哔哩哔哩视频链接 <a href="https://b23.tv/xjhmkV">「【官方双语】2020年了 多大的内存才够爽呢？#linus谈科技」</a>。<br>[4]. 关于运行内存频率对性能的影响，也可以看看 Youtube@LinusTechTips 的视频<a href="https://www.youtube.com/watch?v=D_Yt4vSZKVk">「Does RAM speed REALLY matter?」</a>，哔哩哔哩视频链接<a href="https://b23.tv/Ow789V">「【官方双语】高速内存真的有用吗？主机内存选购指南 #linus谈科技」</a>。<br>[5]. 关于内存混用对于性能的影响，Youtube@LinusTechTips 也做过测试<a href="https://www.youtube.com/watch?v=bTS0ybQ3lCI">「Just How Bad is Mixing Memory?」</a>，哔哩哔哩视频链接<a href="https://b23.tv/Gha0v4">「【官方双语】混用内存影响有多大？#linus谈科技」</a>。<br>[6]. LinusTechTips 其实针对运行内存 RAM 做过蛮多期视频，覆盖内容比较全面，也有娱乐性，不管是图一乐还是学点东西都比较合适，还要了解相关知识的朋友可以直接在 Youtube@LinusTechTips 的频道内搜索「RAM」或者在哔哩哔哩搜索「运行 Linus」（别进频道内搜索，搜不出来）。<br>[7]. CPU-Z 的<a href="https://www.cpuid.com/softwares/cpu-z.html">官方下载地址</a>。<br>[8]. AIDA64 的<a href="https://www.aida64.com/downloads">官方下载地址</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本章中，我带大家了解了运行内存这种特殊的储存器的结构原理和常见的参数，看完之后大家对运行内存应该有一个比较清晰的认识了。由于篇幅原因，我们的其它储存设备介绍部分也被分成了上下篇，下一篇我将继续给大家介绍其它常用的储存设备，其中还会有很多我们熟悉的部分哦。</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
      <category>数字电路</category>
      
      <category>数据存储历史</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运行内存都在运行什么</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信协议</title>
    <link href="/Blogs/2025/08/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/Blogs/2025/08/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>[[7. UART]]</p><p>[[8.SPI]]</p><p>[[9.I2C]]</p><p>在编程中，字符以Ascil码的形式通过通信协议传输：[[2.C语言Char和string]]</p><h1 id="Communication"><a href="#Communication" class="headerlink" title="Communication"></a>Communication</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>Communication between electronic devices is like communication between humans. Both sides need to speak the same language</p><p>In electronics, these languages are called communication protocols.(计算机通信协议)</p><h3 id="Importance"><a href="#Importance" class="headerlink" title="Importance"></a>Importance</h3><p><strong>A Controller Area Network (CAN bus</strong>) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other’s applications <strong>without a host computer</strong></p><p>the <strong>LIN bus (Local Interconnect Network) standard</strong> has been introduced to complement CAN for non-critical subsystems such as air-conditioning and infotainment, where data transmission speed and reliability are less critical.</p><h2 id="Common-protocols"><a href="#Common-protocols" class="headerlink" title="Common protocols"></a>Common protocols</h2><ul><li>Serial Peripheral Interface (SPI)</li><li>Inter-Integrated Circuit (I2C)</li><li>Universal Asynchronous Receiver&#x2F;Transmitter (UART) driven communication</li></ul><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><ul><li>Electronic devices talk to each other <strong>by sending <em>bits</em> of data through wires</strong> physically connected between devices.</li><li>A bit is like <strong>a letter in a word</strong>, a bit is binary and canonly be a <strong>1 or 0.</strong></li><li>Bits are transferred from one device to another by quick changes in voltage.</li><li>In a system operating at 5 V, a 0 bit is communicated as a short pulse of 0 V, and a 1 bit is communicated by a short pulse of 5 V.</li><li>The bits of data can be transmitted <strong>either in parallel or serial form</strong>.</li></ul><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h3 id="Simplex（单工"><a href="#Simplex（单工" class="headerlink" title="Simplex（单工"></a>Simplex（单工</h3><blockquote><p>Uni-directional flow of data</p></blockquote><p>In only one direction</p><h3 id="Half-duplex（半双工"><a href="#Half-duplex（半双工" class="headerlink" title="Half duplex（半双工"></a>Half duplex（半双工</h3><blockquote><p>Bi-directional flow of data (one direction at a time.)</p></blockquote><p>In both direction, but only one TX and one RX at a time</p><h3 id="Full-duplex（全双工"><a href="#Full-duplex（全双工" class="headerlink" title="Full duplex（全双工"></a>Full duplex（全双工</h3><blockquote><p>Bi-directional flow of data in both directions at the same time (simultaneous flow).</p></blockquote><p>Both sides can transmit and receive in the same time</p><h2 id="Serial-VS-Parallel-communication"><a href="#Serial-VS-Parallel-communication" class="headerlink" title="Serial VS Parallel communication"></a>Serial VS Parallel communication</h2><p>The bits of data can be transmitted either <strong>in parallel or serial form</strong>.</p><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><p><strong>In parallel communication</strong>, the bits of data are sent all at the same time, each through a separate wire. The parallel transmission of the letter “C” in binary (01000011) is shown as:</p><p>多线并行</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>The process of sending several bits as a whole, on a link with several parallel<br>channels.</li><li>It requires a separate channel for each bit to _ be transmitted</li><li>A parallel link use simpler hardware as there is no need for a serializer&#x2F; deserializer.</li><li>Usually used for very short distances.Sender</li></ul><h4 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h4><ul><li>Clock skew: Clock signal arrives at differnet components at differnet time</li><li>Crosstalk: It the transmitted signal is badly affected by another nearby signal, when electronmagnetic energy from one cable leaves an imprint on adjacent cables</li></ul><p>Crosstalk is a type of noise signal that corrupts the actual signal while transmission through the communication medium.</p><p>Crosstalk is mainly induced because of coupling between different signals transmitted using parallel adjacent cables.</p><p>Crosstalk is caused due to electrostatic or electromagnetic induction.</p><h5 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h5><ul><li>Very simple.</li><li>Crosstalk places an upper limit on the length of a parallel data connection (usually shorter than a serial connection).</li><li>Clock skew between different channels.</li><li>Low data rate compared to a serial connection for long distances. (Due to the last two reasons).</li><li>Has a cable cost higher than a serial connection.</li></ul><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>In serial communication, the bits are sent one by one through a single wire. The serial transmission of the letter “C” in binary (01000011) is shown:</p><p>单线输出波形</p><ul><li>The process of sending data bit by bit sequentially, over a single channel between sender and receiver.</li><li>For correct data transmission, there has to be some form of synchronization between transmitter and receiver.</li><li>Cost of cable and synchronization difficulties make parallel communication impractical.</li></ul><h4 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h4><ul><li>To reduce the cost of an IC package by reducing the number of pins used for communication between different IC’s, instead of using parallel<br>communication.</li><li>Clock skew between different channels is not an issue (for unclocked asynchronous serial communication links).</li><li>A serial connection requires fewer interconnecting cables and hence occupies less space.</li><li>Serial links can be clocked considerably faster than parallel links, and achieve a higher data rate.</li><li>Used for all long- haul communication and most computer networks</li></ul><h2 id="Bit-rate-and-baud-rate"><a href="#Bit-rate-and-baud-rate" class="headerlink" title="Bit rate and baud rate"></a>Bit rate and baud rate</h2><p>Bit rate is the number of binary bits per second</p><p>Baud rate is the number of symbol changes per second</p><p><strong>N &#x3D; log2(m)</strong></p><p>where <strong>N</strong> *&#x3D; Number of bits required to represent signal or voltage levels<br>* <strong>m</strong> &#x3D; *number of signal or voltage levels<br>* Example: To represent 4 voltage levels you required at least 2 bits. Put m &#x3D; 4 in above formula , you will get N as 2.</p><p>Similarly to represent 16 voltage levels, 4 bits are required (log2(16))</p><h3 id="Bit-rate"><a href="#Bit-rate" class="headerlink" title="Bit rate"></a>Bit rate</h3><p>Bit rate refers to Number of data bits transferred per second. Unit of Bit rate is bits per second(bps)</p><p>每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多</p><h3 id="Baud-rates（传输速率，波特率）"><a href="#Baud-rates（传输速率，波特率）" class="headerlink" title="Baud rates（传输速率，波特率）"></a><strong>Baud rates（传输速率，波特率）</strong></h3><p>Baud rate refers to number of signal or voltage level changes per second. Unit of baud rate is bauds per second. For example baud rate is 9600 means 9600 signal level changes are happening within a second</p><p>UART的波特率是指每秒传输的二进制位数（单位bps），比如9600bps,意思就是每秒钟可以传输9600个位（bit）。</p><p>例如：设字符传输的速率为120字符&#x2F;秒，而每1个字符为10位（bit），那么传送的波特率为：10位&#x2F;字符 * 120 字符&#x2F;秒 &#x3D; 1200 &#x2F;秒 &#x3D; 1200bps。那么每1位二进制位（bit）的传送时间：</p><p>T &#x3D; 1&#x2F;1200 &#x3D; 0.833ms</p><p>UART要求发送与接收两个UART的波特率配置相同。如果发送与接收波特率不同，相差很大，接收端采样点跨过多个电平，造成接收丢失，或者造成波特率不匹配</p><p>常见的波特率有9600、115200、128000、256000等</p><p>1 Baud &#x3D; log2M (bit&#x2F;s)</p><p>其中M是信号的编码级数。</p><p>也可以写成：Rbit &#x3D; Rbaud log2M（Rbit：比特率；Rbaud：波特率）</p><h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>The sender and receiver must agree on a set of rules(protocol) on:</p><ul><li>when data transmission begins and ends</li><li>The used bit rate and data packaging format</li></ul><p>SPI, I2C, and UART are <strong>slower</strong> than protocols like USB, Ethernet, Bluetooth, and WiFi, but they’re a lot <strong>more simple and use less hardware</strong></p><p>SPI, I2C, and UART are ideal for communication between microcontrollers and between microcontrollers and sensors where large amounts of high speed data don’t need to be transferred.</p><h2 id="SYNCHRONIZATION"><a href="#SYNCHRONIZATION" class="headerlink" title="SYNCHRONIZATION"></a>SYNCHRONIZATION</h2><p>For asynchronous transmission:</p><ul><li>A start bit with the value o indicate the beginning of each word, then eight data bits are sent bit by bit, and finally a stop bit with the value 1to indicate the end of the word.<br>Both the transmitter and receiver use the same baud rate</li></ul><p>For svnchronous transmission: </p><p>Synchronization is done using a clock line</p><ul><li>A clock line from one terminal (master) to the other terminal (slave) makes the synchronization.</li><li>Another line is used for data transmission between master and slave(s). </li><li>If the master communicates with many peripheral ICs using the same data and clock lines, a (slave select) line is used to determine which slave to communicate with.</li></ul><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>Notes about Synchronous transmission: Preferred for short-distance transmission.</p><ul><li>Uses its communication time more efficiently because, after the transmitter and receiver are synchronized, theyonly<br>transmit&#x2F;receive data.</li><li>Not used For long-distance transmission as sending the clock signal with the data signal is not an appropriate solution for the additional costs and clock skew.</li><li>In some cases, it’s impossible to use synchronoustransmission and we have to use asynchronous communication Ex. remote control.</li></ul><p><img src="data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAA84AAAG3CAYAAABlpwx4AAAgAElEQVR4nOzdf3BT953v/2e+dKId7jjb3CuG3lqTXcTN3hh1G+FARNhaJtQOt7FNiuVkYwy5snNT7JsN8A2VO01sp9imu7XCHeK013aZCLXBONNY0ASc7yV2m0VuaUSBmPY6yjYX0WblThl0tzt4hqkyy/j7hyTrh2VhCI4NvB4zHoz0Oed8dKzPOed9zvvz+dw2MTExgYiIiIiIiIhk9f/MdQVERERERERE5jMFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkh89c64I7d+68nvUQERG5oX3rW9+a6yqIiIjIdTIxMZH2/2sOnAEOHz78iSojcjOrqKgA1E5EbgUVFRXcd999c10NEZllp06dUlsXuQWcOnVqymtK1RYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIikoMCZxEREREREZEcFDiLiIiIiIiI5KDAWURERERERCQHBc4iIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOn5m1NW/s4p1nV5I33fvjv2TPgw3sn4VNb+p+h+3/+YNZW/9VSdkP595cwaOtc10hmT820fXOdlbmAb99gxVVbelvX/G7k7L8tGWguf8kj/xlrnqc440Vj5Lcevp6cy6p77TIDKS0qYxz36bud9i+IrWxjfPL//EgDQeyrKbldU6uX5L+2iyeS0Xk2k1t22Rtr1c6R6edZ1OOATr/inz65u6Jc95Ktp98nebrvNrm/pNTD1QiN6ONf8M9KV/1JV+81ta0hEdOvkPXxutSKxGZoeznqzxWPnuS11tSX9tE1zsnpwbNED+Xqv2KzB+x9pr1WvQarn2XrD/JO92brlvtROTazXGq9hLW6mAgck022e9Jz+j4yy9+ghtReaysvN63sURkWhu7WBt/yjR+cg8rVqxgxYo9/HI89tqSB7tInB2b+6+UAZLHymev/41oEbkGLY9cob0u4ZH+q2uteSseUfsWmQdmL1U7xdR0kmZeP/kIS4A8Y+wO+mSqyvgveeOf7uGR+J268ZN7eLB+f3qZhLSUl+Q6gfhdvZNsT02BzZI+PuP01mnS4WZaTuT6ak62kd+eg79cQl78RlRb/TTfvqzfzZQU0v/weTYB+9lPw4NpiWSTbSu1PYrItUve+BrnA3+iTe3n5//0JCtX5EGeMXY+Swmwp6Zxp573lvDFFkCpmyJzatPnjfHfMttryvk2fqM7rYNWlnN0Mt3byOeVVSIy5+bf4GB5KycDguQFRTOvn8zSB+QqUtQ2db/DySx9rpesP8nJtDt/sRSb7NtKvaP/yeskcs1avhi/WB7ng4OP8tPfxl7O+89/g3I4ROa//fUPxp8yp/dnXmJMP0ulBthT+z638ej/+CXjqL+jyPyTmcm1n4YHV8Tb/aO0TbuciMxXn0rgvGT9SU6eTP1JPhkej5ybUj6Ztha7SGjuf2QySPjl/0gcdN4gtmQeK5/qYhNtPLpiBW/8NrGSX7JnxYrY0+aNXTyZCMZ/+0Z8+RXsORnPifvLRyb7k23qfjJtsKUVK1aw4s1EHZOp5TOrk8jsaP5ivAWNf8DPD0Dbr+Lf0bx7+JvpbtrEszDS22IyBXT8n36uTAmRuZT6dPm3v6KNlEA63tanONDAgysUNIvMF/vrf8rkle1fPpJyvr1Cd4os5+hkP+kIv8/W/kXkUzW3T5zHf8krU9I+z/HT+vQ00S9O9gN7JeVuexuPvjmDYIHUO/bneCNl5OL99a8k+5N9sRnYxN/852SAPXkh0vorzhELpGNpqp+8TiLXLuX7lwh249/Ra+6rnLUtisinJq0r0Ti/PKjnUSI3pmQmSLolPHLyJCevISvx3Jt6Qi0yH8xd4PzbN1iRrS/weIS0Z9AbP0+it0jk9xml/08kfmDKw/ifpt9U8o59xrrZz+//b/zXeP/O7GJPsycD6etQJ5Frtal77WTGRt6K7VOyOK5qkLBEBob65YvMnYzxN869Oc10VCJyY4hngiQzEVNdzWB+saxGZZSIzA+fSuA8mfKc+pM5Z63IrSznjZtUKVkR05pmtPpE94XULg1/+UhGH38R+VRNCZrTL5LPReLPrabLYtrYxTsnM6evEpH5IfbgZUoXwcRgfqlSztHJH91EE5lP5t/gYJkO/J5I/Ffj5zOCgf9knExri/yf6VeRvPAwkj4L5iY+/x/iv/7f36c/cUsLZOJzaCYCjOtQJ5G0jIe8lTyZFuxuouupqYPZZc7dPJ0rDRLWVpUePGuOSJE5cIWgGWC//4PJLKaVz2ameDbzenx5zfUqMh/EBo49efIkJ9+ZOtbN/t9HJn+fcv0oIvPe/A+caeNXiRGDVzyZctHQzOvr0wdImk7ywiN97ry0gcB+1UZsKpBEkL2SRxJ3AxPByuTTuU9eJxFIualDatp1+qBdcI5fxS+m00fYnZrJMXk3ewZ97NuqknPGpn+PRWT2pd8cm3ZU7AMNk6Pmx4Ln7ANtTh0fREQ+fcnrw6wDcq6fHBo3ZRo6EblR3ACBM7RVpYxW/WzmBcM53kjpn5l8uhw/YPU3w4EGXkkZQTtztMLxk3smL1jSBgxLjAaeZcCWq6mTyHRSv2/TGT/5RnxQkOTczdPdmEl7OnXFQcL207D3l8nyGgle5NPT8kjKzbFss08k+0Cm3uSajgYPEpkfkteHOfz2p0rBFrkB3RCBM5lTTSWM/5I9GXPhpU0DAJMp1/vrH2RFllEOkyNlT66BhgezbItzvJHW12TmdRKZXuz7luz3lCr2VHny+zk5d3OOqaMO/JwPEquaySBhqTeVpqSLi8hsmZxSbkbi87++meVyPN4vUoMHicwXsevDXOd1jfMjcmO6bWJiYuJaFty5cyeHDx++3vURuWlUVFQAqJ2I3AIqKirU1kVuAadOneK+++6b62qIyCw7deoUmWHyDfLEWURERERERGRuKHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkBwXOIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIikoMCZxEREREREZEcFDiLiIiIiIiI5KDAWURERERERCQHBc4iIiIiIiIiOShwFhEREREREcnhM59k4YqKiutVD5GbltqJyK3h1KlTc10FEfkUqK2L3Jr0xFlEREREREQkh0/0xPmFF164XvUQuens3LkTUDsRuRXs3LmTiYmJua6GiMyy2267TW1d5BZw2223TXlNT5xFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkBwXOIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIikoMCZxEREREREZEcFDiLiIiIiIiI5KDAWURERERERCQHBc4iIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHL4dALn024sFkv6T72PyKey8U9mZPcs1/e8j4b4PnGfTtsy7imviYiIiMiNIHK8j/ZtVRSvjF3nFa6tYvvuAYLjc12zbCL46i1Ydo/MdUVmz2k3FksDvvPXe8Wxa/abet8JMOuBc7wRbvZOfWu4heJZ+fLeBM77aLDUkGWviYiIiMh8djmM79lVFD/lZuR2O1vdHjx7u3h+g5nwa41UrW3ANzbXlRSRq/WZ2Vz5yO5iWoZzlfDTstbN0lEX1tmsyHy22EHXqGOuayEiIiIin1iUwItP0nJ0Ec59B3Ddnzf5jm21HUd1Oe0bG2jZ0sOyN7ZQsGAOqyrXiRXX6Ciuua6GzLrZe+J83kePJ/EfO60/HWV0NPHTi3OyoJfBzHTkKandGU+mM9KbJ9OpU1OqU8pYLBYaDiUTrSOHGuKvuxnJKDfjNIvM5Sxu0pZM+QzJbcefwKeWz/gskUMNWNa24E/snc0WLJYavpblc8TE00OyviciIiIin5qPDtL5wzCmZzrSguZJRjvbtpdhNAQJpTx1Hv9gAPe2ClZZLFgsq6jY5mbgw2iyQCLN+MMQvraaWLmVxTR0B4hchvEzXraXr8JisbBqYzu+lGVj171uApEAPU8XU2ixULi2hvZDQcYv5/444x/4aN8cW8ayspiab3oJTF5ujjPkKpx6nf7HIRpXWih8eiBnN8fohwO4U1LZLV+qoK7NR+hSSqFLIXxtdVR8KVZmVXndjOodW64mtu6VxTR4gkSzlbscIdC9PWX923G/FZosG9y7DoulHX/mwpdHcK+0sK47SNZU7csRAp5GatYWxtP0a2j0xP5WM922zD+zFjhHjg/Fgz87rT/twrE49V0rrp+2Ygecr47iKky+M7I7W2q3n5a12QND72YLNZ6UF4ZbKK5voCEl+ATwNxVn6S/spSajHJ6aK/dnPu1OC24n15V64CispbUose19jACRQ82TT+Cdr17NU/Y7+JtGe2xdR4+l1+30YDyl207JauOM1ygiIiIi11do2McIBTjXFUxbJu/hDo759lB2V+z/0dNuNjoa6fsXO67vefC46ykI99H41Srcp1PDqBDe/3cjfRdLad7bRWuVicDLdTS/0MLGp/0U/PeX8LhdrLrYR8tGN4G0CMxPu7OBQWM9e/Z28fw6ONhUxcb/OTJtoBZ5azuljl2MfK6Wtr0ePDtryf9NJ3VfSaSa51Hy9TbsC/3senGIWNftcYa+3cgAZXS0lzHtlem5Puq+2ojvki2eyt5B05fvYOS1FqpeSKwrgu/ZCloCd1C6owvP3i5cRVEONlVR/3p4+j/C5SA9j1XQ8maU4h1deNxbMf+inu2vhNLLRUfoeewh6vZfxJ5Y/4MX8bkqqNod2y8FJU4K6MN/ImMvnRmk75KJyjVZ/s6Xw/i2PkTdbj+Gsufp2tvF82UG/LvrqE3s7xlsW+ahiWv0rW99K+f77724bGLZsmUTy7b0T1yY6UpPdcSWWbZsov5gcqnJdS2rn+j/w8TExB/6J+qXJV7rmHhvYmJiYuLCRP+WZZPLL3sx9mpq2cQ6LxysT5ZLqV/q6x2npvsc7010ZG4jdduTr2XU88WOLMull0lsM/dr8X3wSfazfCq+9a1vXbGdiMjNQW1d5NZwpUvnd/8hdm367r/NcIX/9v5Ed2nsOu6fU5f5t7MT+6qXTSyrPjDxzxMTk9fID/3DuxN/mix0duLAo/Frw3By0T/52yaWLVs+8dJI7P+J69vyF99LWXZi4uz+jRPLlm2cOPC7iYnJa9nENeqf3p1oW7FsYuMPzmbU9+zEgeplE8t3Jetx4Y36ieXLlk+0+f80cfF/uSZ/z+X9Hzgm7GUdE++lFfvTxLu7liev7ePXvh2B9DLHnl8+Yd96JLZfsrg4sG1i2bLyiY5TKSv/t3+OX6snr6P/uW/jxLIVbRPHLqYv/yd/28Tyyf3yzxMHqpdNLGs9lrbv3ntx+cSyRw9MxPZOPDaI77s//bwt6z44u3/jhK2sY+LYxZluW+ZStrY+r6ajGnkn/qS5qJW2Dcl7VNYdidRuP0PH058F29tr409ujRSvsydepXVT/Hnu4mJKEk9+Q5l3p+y07nRM3g0zbmibfErsfWealO2UJ7yT28CI42vx5HPPYDJle7GDtvZ4nTze+HJOendcQ4/uyc+Rug9GGIw/bbevK57+rp6IiIiIzLII4XOx3wwz7bv8oZ+DY1BdU44pdZkFZhybSuGMj+FzyZdLHrRhmPzfHdz+74H7S7DlJ8sYzAXYiBJNS2e249xkTVkWzCWV2BnBP5Ilz/KMn75LRpbefoHA8UDyJ3CB6Ocg2usnGC9qXN9G2xro+04NtU0DLHqiC1eRYeo6UxQ80c+xIy6sacUMLC2wAVEuRoHPmshfCH0vd+I/F4l/HgP29tMce6kMU9Y1R3nv1CBYNuIoTFn5AhPlNdUp5cIEjo6A9Q4+/nUg7TOOjBswM4L/VAQwUbTeCq/5k0/wL48w+FoUa2UR5iw1CJ46SHRhNeWr0/eBuaaXd4+4sOfNdNsy38zq4GBXJ8LZD+O/3r00Iwg0YS4ChuPB7+rkO+a/yBYumlm6OMvLVyxnZOndse3w4VkiWZKpI79LpHnE0sdbppQIcfY8WOPrNW5oo/Vo8TWmaKfXrXidHYb9sXTtDQ6Mk0G8ky0bFDaLiIiIzJ3kdWT0MjCT4PnSRcIUsNQ0NdDM+1w+MEj4jykvZrtyN8CfkV5m6tqyXBsvXooZ8H4YhowwNDIWAiL42urwZa14iLEIWI0ARspanufI2hb8xmo8z9iybD+76HiEsQ/PEv5dkMCJQY4MjQB2LvwrsNiGs93BSFMPDeU9sNBIwepyqv/WwUM2M3lZ9+84F8aAv84nP+Mdw6JFmEh0LI8QOgHQw7bjPdk/YTgMGDE9WIm9rQX/CRf2IkM8TduKa3W20D3C2AdRuM+cfiMko8xMty3zy6wFziazHfDD8BDHzjsy+jgTGxRrbQvmjD7ON53zxxhKGVnc+84IrsJrDJ1Xl2DHjz++T5cmntDXld66o5KLiIiIzBOx698AoY/AtmSaQuf6qHtmEPPXO2i649OsXXaG26d7J9s4RdlFfxMkABA5yOApF7YrPHFmbIiWrY34PogCeZgtJpb+dTkb10fpfC1ZzLSulf4SF6HA2xw5PMDgsJeWIS+71rTyZqcjR3CaheEOpgzXVtfL6JUyQRc/RPm6FpqHR3AV2Qi+00f0XhdFd2Uv/qcrDVx2NduWeWXWUrVjQR7Ensxmztc8gjs+uJZ3c2LQr/hdOog/7U0VJhQPPu3m7IkZ1yb2dDgp11PvGONfJJIyMkcKT/ykH2BG9k8dfGzqIGUztNjBljoAPy373ZNp2s4H1ehERERE5prxPjtWgniPBqctEzp+hMC5MRYtMsLCOzAR5Gx46nBQ438YA2yYZ5RFeSUXiIxnvHT+LCGg5K+WTimdZ8wH/AR/M4Nhqi75cT/bB4930PE49D3rxn8p1wLjDOzehm+8kpfePs3o6Lsc/lE/e5qdlGbLfV6Qh3m1g61/7+HwsdMcbrYT/cfvM/BhlrLksSgf+PUYmVNlR8NnSf5V7sBkAQJBMoYMy7pOe0kp0UODjFyKpWnbHy2dJlXcyFKLAU6FCGcG0Gc6WbW2jr5zV7NtmU9mr4/zZJAHibTm5NRNNSTHzU6mGVsfjPcTHm6hOWUE7ZHdNbM0crSflheSI2injXo9XTBaWDrZ37plf7If9OSUWKkjcp92T4747Xz1WLL/9OaMqauuwuQ+SukzXXozP7EXERERuVHcVcmWxw2EX27EfSIzUoXoh32494xgWLMVhwW4205lPvT1HkkPtC6H8O0fhCV2lmfmHF+TAXxH08f6CR7y4qeU4izTZhnuL6V6YbZ6hfHVW1i1uS8e9EXx795OH2V0/F0ZZX/XQRl9bN/tzzEy9FnePwp8uZSS/JQn05dD+AeSoW30dCdVayvoGU1ZdIGB/M8tyvE5DSx/wIFh1IsvdSTsy2GOvHYwpZyZokorZJYDoifcrFtZTPtw8u+XV1RO2aWD+LsG6btUSvma6eORgvsqMVzq48jx1PVGCfyvAcbHCyi46+q2LfPHrPZxtu44RuuHyf692aT1+S100VvnpcYTmz7K0pRZNv409zzXz3ALxZaMnspFrdROG4xaqW23423yx6au8qS/6/xaYrCxEdybk4Od1RYaMe5sZWhtC3681OwunT49I97nJPFE3puaKlNYihNv8saD0rRFRERE5gkD9h29bP1NDZ21xQQedlJdZsN0e4TQT3y89FqA8SVOet3xqZoWFOD8BydHNrew3hni+SftmC4F8b3SycAHZpyvVmcdgOpa+F+oou53LpwPLGLsaCfu/jHs7V2U3ZntY9hwPmfnYFML6x87g+uZMsyXQgweeom+42acr1ZiBqLDbra/Bva/b6TkToASGp+zM9C0HfeaX9CUNWV7KcsfNuD94Tbq/ryZLV80Ej3vp+/lPt77OBnEGyx27At76NxSx4W/c1B6l5HIRwMc2O3DsKYDxz3ZP2feg1/j+TVHaHm6hgsNtTjugZF9bXQeTw9STetdOPfX4K0tJvhMM1u+mEf41BH6fjjAhftbca5OuaGQZ+Ohh6Ns83hhXQf2bPtsctc5eX7NQVrqq4jsqKf6njxCRztx91/A/ve1WBcAV7NtmTdmeVRtI47uUUZfdU59q6iVY6NT+zdbd2QrH0uLvv59oZ30jiZG7I6r62W025GzO75xQxej8Xmop6tj6lPyyZG7U5/C50zZjgXnSX5CY8n3SuuS7yhNW0RERGQeWVjAFu8x+t3VmH43iPvpOuqeauSlANh3eDj2hgvrwmRxQ6GLA74Oqv+9P1bW1U3QtIWu/68fV+FMh9m6Ejut+9oxj3Sy/akGXjplYsvet+naMH0XSNOGLt7e56Jk4bF4vV4iQDmtvgOxel0K0NnWR7ToeZ4vS145G9e7aLo3Sl9bJ4GsKdt5lOzsp/XxpZx9pZG6pxpo3j+GtaWfwZ5aTAQIno2CwcrWvl6aiiDw3Ubqnqqj8bvvsehJD2935pgjeoEJR+fbeJ40EfQ0UvdUG0cW1uJxZ8QXC624fnSYjrpVXNgfq8euQyFMT3p4e0r/6TyK1sdG5S5bZ5/aVzrb9ncUcGF/M3WJ/b3vbbrWG69h2zJvXOvcVjfynJXJ+ZoTc0DfWJLzWt+Y9b9VzHge5wvvTfS/uG3C8eDy+N/VNlH+31wT+36eMTN3fA7Hybm9Z9upjinzhotIdldq68nzTo6fF+fREf0P7050v3hk4sKVS14H8fljt/Rfn+192sfKTyD2vUg5l198f6K/ZV/Kuf0a982sH78z5vy9nms+WD+vzz2f4NJ5zsz3fSoyH2Vr6/NoOiqZkfM+ehLp4UrTvvGN+Wj4agt+jFhLqtnyeQNcChM4OoT7qSGO1HvofcY642kdRGQ+M2GvKaNgukcVBfNn6pGR/XV0ftiKY64rcouJDHXS0m+md+dc10RERDIpcL5RxKfvSo7Qbad1k8LmG1uUwA924cdO64+7cKQO/vH1cQIvVlHX7ebgI71U3wUUuhgddc1VZUXkEzNT8uTWGU3tIp/ATXWsjHV5u5VuYBg3dDG6Ya5rISIy1Sz3cZbZMjlQmtzAxgl/FIX7SijOHDFzQR62x5wUEOS9YHyc9tNuLBbLZN/4yKEGLBY3gUiAnqeLKbRYsHyphvZDIaJA+K12atYWYrEUUvx0D4HJ4d4j+OotWHYHiJzooSFRZnM7vg+uMIrj5XGChxLrtVC4toZGT4DITOcsFJGZuRwh4GmkrnxVfDaKQood2+k5kT5ZY+RED9sd8fa/spiqbT0EEgNoftRHjSUx5WO6UG8VlpVuRqa03djxocZDfPDM9OUjx700bk5ur+ab3pRjSw6XQgzs3k7Fl2IzUKwq3477rdCUUXcvnOmjceOqyeNL4nh2Vfsl17FyWwWrEnVv8xHKOWVOtmOlhVUb2/F9GIXLYQbaaiheGVtfQ3fKsfC0G4slcyrOHK8Tm52juMkPeKmxWLDsHknWYXLGjhHcFgsNh0KEDrVT8yULFssqKlL/7tP5BMfvyIketsf3+aqN7QyN/SlrufEPfLRP9/0YH6LRYqGqd+oEPLG/0XYG/pj4PWMfzeT7cz7l72tZRcU2NwMfZnzDIgF6tlXF/maJ787xmXyBRURu0cDZuKErPuey68ZJdV7soCtlvujrP1CafPqMLLOa4NQQg9kC1iXV9I+epmNdrvRNP+3ObQTMW9mztwPXfRfpa2qguamBqlc+pryli672akwnOqnb2kfaRBTvtFP79CCLvrYHz/eep5yDtDg20nlmugkkIgy4Sqn69gj5m9rw7PXQtimfUFcdD231TZ2vUESuURT/tx+iriuEsbIZz14PXe1OlkcH6aytpeeDeKnTbmpqe7jwhXra9nrw7KzFdLaTuvJ2AlHgrlIqi8B/9BjpoUGIwBtBTE+Wx0Z3TZOHrcGDax1gcdKx18OW+FQ14UMNPPSUm+C/r6Vtr4eu58oxDLup+0oDvswJU1NdGsH9WAWNr4UpqOvAs7eD+oIwfa4qtr+ZUrNTu6h5epBFj8bKbFl6lr6mKtyTI+HObL9kFz9W3uWkY29XbFCi11qo2hPIMWVO3Dvt1D4bwPzMHjxuF6su9tHydDMtW6vY92/ltL3URWuVicDLdWx7PXyltU1r6XoPHU8UAKW49nrwrJ86t25C6JVtVO0OYX/Og8ddz9KzndSVNzAwbfB87cfv8aONPFTbybv/sZaOvR6aSy7SvXUXQ/+SsYW3tlPq2MXI52onv4/5v+lMfj/yiih/HIJvBDLmro1w7KgfHi7PPlLxDL4/0TM9VJXXse+SHdf3PHi+58J+yUfjV6twn47/haMjuDfW0fMvy6jf6cGzt41a01k6n3qI9uMzmKv4Bha77tUDF5FPSqnaInOo4Ik9bP15De2OVbgXWylZV05xkZV7rQWYFl55eQhhch6lqyo2Kqb9vjzChQ30nSjB82MXtoUANkyXAlR828+ZSDWmRBx+Duyv9k6O2GkrWo5pcwXt3zlI5YFqMsfZjB7vpvnoUlw/7sV5d/zF1TbKHlxOTfkuvIFymlarN7bI9Py0rLXQMs27zlfjN0Ujw/gDt2N/rpuODYkGa8N+3yJqvtLOSDAC9xgJvuMlfH8rr+x0xNurDQLMZ4cAACAASURBVNvdUFXrIzAaxVZo5KH1pbS4hjh23pG8aD4XwDdqovKFgiy1MGC614Y1H7hkxrbaFhu59o8DvNjkZ9ETHvq/YYuPu2DDXmKjfW0Du34QoPw5W9bxGMJvuvGes9J0pJfqJfFPs7oE8x3FNB8eJLS+NPbipQJcP/Iky9xn5MKX6ugbHqFptW3G+yW79GMlq+0spZAaj5/gc7bcN9HPmXC+nehOY8eaF2awvo/Alz28mdgXq018fKqC9uEzRB435ZyZYzp5d9uw/dUiIB/r6kSdsgd04fOmlC4+NmxrzLQXN9D8SoCSLH+Haz5+Xw5yYPcArGmlPzHS72obJV9ws77WD7bEBgJ0vzDI0m8cpveJxORJNmzr7CzfXDH5/bB9uRrDaz4C56oxx//OnD/G0DBUdxeRl+UTX/n7U0TgO52E1ndx7Dk7eQsS+6QcW9sDNLx4kOoD1ZhGB/GO2Wjd1zrZNcpmK4DqjfhOBYmu1ngiIpKbAmeRubSwgC3eX1B25ggHXx9g8HA7Az+MvZV3bzWulm047sk16YGNkgdSQlzDHbET/5ft8aA5xny3DQjxp9SnCkVOalOnuVhgpvRRO+1N8QA7Y0sjw31EjQ4MFwIELqS+E2URUfp+EaRp9Q2TwyEyB3IPDrYsEW0ZS2g6UjK1wF0FWIHApYuAEWO+FTxevv/aUr623hq72Xa3k/6fJadcyXuglFIaGToewREPNoNDXoL5lbRNMwdqNuMnjjFIAU2PZQRleXYcT5roe3mQwA4b9imRR4QzwyNQ1ErpktTXDdib3+VYvMx7APdXUpRaxrCUgvuAc2Ei2DDOcL9kl3GsBEzm2HHx7Hmw5noSd38JtpTuNIZ/F/uQJQ+m7gsz5vuAc9lTmK83w+Nb0sfFWGin/HEDfa8Fst4IuObj90cjDI5BZXN52vQ4hvsdOC1e2hMvnPHTd8mI4/YLBI6nbYDo5yDaG79BcV8plQv78B0PUb0kFmBHjg/hX1iN5/5sYesMvj9jPtrPgPWBj3k/EEhbevx2M5zxEzhfjclowooXb1cfS79WifUuAyww4/zRu2SZNFVEZAoFziJzbYEBU6GDrYUOtgLR8TCh4SH2vdJJiyNA6NVc8zgasrfiz2SUz1bm7qVTLjGNf2EGvLz/EZSlvRMhfA6I+Gh/ype9KqExIliv6UmLyK3hKgcHuxxlfCzE++EQoVPvETh6hEGAP1wEwLS+CddPanG31eBrg7wlNuyVDmrLyihIbONOO6XroPHoMSIbHBgJ4n89jOlROwVXMU9o9NI4YCX/81PfW7TYDIxx4V+BKZ8tzNkTwONTjzdTGODPZlKZK+yXaVd+rVc809UrY32GT/GKymaeOveuyWyDS8HYjYC0dz7B8fuPYYIU4DBlnoMWsegvUrYwFgIi+NrqyL6FEGMRsBptsQD/jQChGjPmeJq2YYMHa9bT3Ay+P+dDBAC6txHIWiDE2B+Aeytp2jFI7e52ag61w51mbEUOHJvKKbPozCUiV6bAWWSeMeSZKHjYScc6K6av1NDzyhC1hWWfYkBqwLAAyNbnraiVY90OBccisypK0NNA7e4A44BhcQHmpWZsmxyUtnljQSLAwgKce9+leizI0LCPwdcHGdrdyMDubpyTN9zysK8rg2eHCfzRQdl5PwfHTFQWZUvTnqVPk3MArqta08z2yy3uz6a7IXJdj9+3c/sdma/Zaf3plfvRWv/LFkyeIwQ+qsZsOMbQsIHKvdOnSc/0+zPZ1WFaBgrqPLxbEyb4k2F8R30MDrlpfNNNd10v/TuUqi0iud2Sg4OJzAtnelhlsdA+PM2gJAuWsvQLwOVZSv37Q4TMIckivwsBJSwzZxbOY1E+MBzk/Zt7DBWRuTfqZfvuAMu/0c+7vxrl9E/76d/bgWuDLWvQY8gvoOzxJvb4jnH6Z10480N4+4Yn23femnKqGWTwF+MEhw8StjgpvYo0bQDDwjxghLHfT33vwvkQYE6On5DGxLI1wIdnyRy7OPJmA6vK3fivMJj/pKvcL3MvROSP6a9EwlNHlL6mNUcuTHktHApAvhXzlJ3xCY7fd5ooIMjZcOaCY4z9OmULxnzAT/A3M9jAPXYq80c4cjw8maZdbpsuZJ3B9+d2EwVAIDjDfWswUfBwNU0v9XPs3XfpesJEyHOA4Zl+D0XklqXAWWSu3GOlfCH0fceNP8tIqNEPfRw5Cibrstm5KHzLx9upI+FeDuJ7xQ/rirFN6YNpiA3qQh99hzNGjR3z0WBZRc1r1+eCUORWF/nNCGFslHy5ID7QUcz4L/wcnPxfmAFXBaueHUi/AXaHiUWfzVihwUZpjYHBd7o5MhjGWlnElHtjV5B3fzGlBPH+KGMU6nE/vlfCGDYsZ1nWJ51G7i2ywvBBBs+lvHw5zLG3/IybzCzLNYxDipntl3li4R2YCBMMpfx14p/5egi/foRA6pPYyAAHXotiqrQzNZfgExy/l9goXwJ9vUfSRt6OnvZxYDRlC/eXUr1wajkuh/HVW1i1uS85kvaCAuyPmhj5xz72HfVPM7p7wgy+P18ownEvBH/gS98nRAl8Zx2Fa9vxj0P4zUYqvhSb8mrSgjxM/3GGX0ARueUpVVtkrhhsuHqcBDZ7aVh7EGNhCeX3mzAQJXziCEOnI0SXOOl9YrZSKv20/G0doR1O7HeOMfCyG995O609ZWS7jDDYnDy/5iAtL6yn6tcutq4zM/7RIL7v9hFY4qR3/dVeiovcakIMvdLJ2LTX6cuofKYEU4EVM53s2trCx8+UYb49QvDwAbqHznL7wsSowyZsRSY+/mYzta6zVJfZMBEmcMhLz6iZLc8XpbRjA9Y1lRi29dF3yYrrxan9YzMZ7jDB8EH2vWWi9F4r1vwyvt5+hPVNdVT93kX93xaQd96Pd7eXAHZaG0qyHjcATOtdOPfX0P5YDeHntmBfPM7IvjY6j5vZcqAc45Tcl+yMM9ov88TddiqXdNL5Qj3u6Bbsd17A3+vGf3u2wDYp9mR/iAO9NqL3L8d29zQFx7w0bL7A1icdFDBCz7c7CSye/nxx7cdvM9WtTnybW6iqD+GqsbPoDwN07valTyllsOF8zs7BphbWP3YG1zNlmC+FGDz0En3HzThfrUy7WVNQVIlpTydeTGx9Jvc57srfHwOVX3dyYLOXuoeCbH1uC9aFYQIDfXjfuoCt3Yk9D7AVY4o20vzfGjm7qRzbYgifOoi3O4i5vokixc8icgUKnEXmkKHQxeGf2un7fh++gB9vd+wCMm+JjZIdHTT+VxvGqxjA56oUteLZEKTzO9vxnr8dc8kWPP9zC7bp+qctMOHofBvTDzro3O+moT8aG1xlXSv92x0UzGj6LJFbWRh/bw/TP3N0Yn+mBNM9W9i3D9pb99H+tC/ezjbSfaSUyIvFbDsVJIwV0/ou3rzDzYsv+9j1dA9RDBgLK2n1bcNxT3rqq+G+Uirpo+/ecoruunJNCx52Uf1OE15XHX31vZx+xoppQxdvL/bS0bWP5qciRBcasa5vorehGmuutJiFVlw/Osyyrk66dzfg/WO8nj924bjbADMMnJnpfpnZ2mbXggK2eD3Q1s6+pga8d5op3fQS+yrCNP/j0LSL5RXV4lpTT+e3GxhY08Gx79myF6zrovfOgzR+u45Q1Ih1/RWOw5/g+G0odHHAZ+alXZ3setoLi61UPtdF+dEG3CnlTBu6eDvfS8fL+3A/7SNKHubV5Vm/j9xTitPSSfu/VmK3TL9tYAbfn1gd+3+8jM7vdrPPVcc4Boz32Nmyt5stq+NfzsVldPnycO/uxPftBnougWGxlcr2fratL1D/ZhG5otsmJiYmrmXBnTt38sILL1zv+ojcNHbu3AkwD9tJBF99MS1ooC+R62XenxMvj+BeVUPouWN0bVCrv3GN4LbU4K3rZXSHpv+bC7fddhu5Lp0jhxoobmJGA6WJyPyVra2rj7OIiMhNLnr8CH2XSilfo6BZRETkWihVW0RE5CYVHurk4Kkw/v4BFtX1UnLnXNdI5OZm3NDF6Ia5roWIzAY9cRYREblJffx7P94fDnFhTRNdDZqnVmS2RQ41YLE04Duf+n83gUiAnm0VrLJYsKwspqbNRyhjjurICS+Nm4spTJT5ppdAYh6u0+7Yek8M0Li2EMvKYuoSo6FfHid4qJ2atYVYLBYK19bQ6AkQuZy+/uiHA7i3VVG80oLFYsHypQrqMutxKYSvrY6KL8XKrCqvo/1QkPGMdY1/4KN9urpOfp4etjuSZaq29RDIMouIyI1CT5xFbjlGHN2jOOa6GiIy68xP9HP6ibmuhVw/Vlyjo7jmuhpylfy0O30setBFx95FXPiFF7enhaoFJn7xnA0DED7UwPomP7evdvL89+ws+qMf7243db++SK9vK7Ee7QF2PR2mfMcePHeMMV5gBiIMuMppHDZR1tDG1nuMRD7wsa+rjodOtfJmpwPTAuBcH3VfbefsaicutwvT7RFCRw/gfq2Fqot/zjF3CXlE8D1bQUu4lC07umIjjw/3sKupimD0KL2Px4bei7y1nXKXH9PDW2nbW4DxX4P4Xumk7isBWn/chSMfoqfd1NT2Yaxy0bbDjPFfg/T9Tzd15Rfw/KyJaafuFpnHFDiLiIiIiMyaECbnUbqq4mO+r7azlEJqPH6Cz9mwRgN4v+2Hx7s41myPZ4bYsFtN1Gw+wOCJWqz/DiCK+ZmXaH08OblX9Hg3zUeX4vpxL87E9GWrbZQ9uJya8l14A+U0rTYQHPYRXuKk+7surPGg1ba6BLPhAep63+OsuwTr+WMMDYNz3x623p8oY2PR+AM0/+IM4cdNmKIBul8YZOk3DtP7RKIeNmzr7CzfXMGuHwQof85G8B0v4ftbeWWnIz7SvQ3b3VBV6yMwGsVWqMhZbjwKnEVEREREZo2NkgfSJ0ozmW1AiLPnwfqHAAcvGagus6d3p1hSTe/PqmO/n46v6Qvpc26PDPcRNTowXAgQuJD6TpRFROn7RZCm1VYKnujn2JTsEwNLC2xAlItR4LMm8hdC38ud2Fo3YrvLiGGBAXv7aY4lFjnjp++SEcftFwgcT9sg0c9BtDd2M8CYbwWPl++/tpSvrbdiWgjc7aT/Z86r2nMi84kCZxERERGRWWPIecUd+V2QKDbM+Ve73gjhc0DER/tTvuxFQmNEsE5OPRkdjzD24VnCvwsSODHIkaERwM6FfwUW23C2Oxhp6qGhvAcWGilYXU713zp4yGYmbwFExkJABF9bHdm3GGIsAtb1Tbh+Uou7rQZfG+QtsWGvdFBbVkaBpumSG5QCZxERERGRuXL5ykVyKmrlWLeDnJPNjQ3RsrUR3wdRIA+zxcTSvy5n4/oona8li5nWtdJf4iIUeJsjhwcYHPbSMuRl15pYf+k/A8A+g3mqC3DufZfqsSBDwz4GXx9kaHcjA7u7cb7aj0up2nID0qjaIiIiIiJzxGguwECA0FjmOyN0fill9Owp8liUDwwHeT+aawvjDOzehm+8kpfePs3o6Lsc/lE/e5qdlJqzFF+Qh3m1g61/7+HwsdMcbrYT/cfvM/Ah5BnzAT/B3+Tc4CRDfgFljzexx3eM0z/rwpkfwts3zPiMlhaZXxQ4i4iIiIjMlXtsVC6M0jfgJzUcjZ4YZOCP4xT8VbboFsCA7cvVGOij73A4/a0xHw2WVdS8FgLO8v5R4MullOSnPOm9HMI/EExu73QnVWsr6BlNWc8CA/mfW5Tc4v2lVC+Evt4jhFOflF8O46u3sGpzHyHCDLgqWPXsQHqAfIeJRZ+dyQ4RmZ+Uqi0iIiIiMlcMNpzP2TnY1EBVxEX93xaQ99EAnbt9XFjTQW0hk4ODTV3UyfNrDtLywnqqfu1i6zoz4x8N4vtuH4ElTnrXm4Fxlj9swPvDbdT9eTNbvmgket5P38t9vPdxXnJdFjv2hT10bqnjwt85KL3LSOSjAQ7s9mFY04HjHoBEXVtY/9gZXM+UYb4UYvDQS/QdN+N8tRIzBu4oMvHxN5updZ2lusyGiTCBQ156Rs1seb6IvOwfR2ReU+AsIiIiIjKHTBu6eDvfS8fL+2h+KkL0TjOlT3rofsqWu+/yAhOOzrcx/aCDzv1uGvqjcKcZ27pW+rc7KFgIkEfJzn5a72im85VG6i4ZMN5jZ2NLPx2LBql6rIfg2SistrK1r5dF3+7kwHcb6fsjEK/HSyn1SK2r+2kfUfIwry6n1bcNxz2xJ9rG9V28eYebF1/2sevpHqIYMBZWppURudHcNjExMXEtC+7cuZMXXnjhetdH5Kaxc+dOALUTkVuAzokit4bbbruNa7x0FpEbSLa2rj7OIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIikoMCZxEREREREZEcFDiLiIiIiIiI5KDAWURERERERCQHBc4iIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOn/kkC+/cufN61UPkpqV2InJruO222+a6CiLyKVBbF7k1faLA+YUXXrhe9RC56SQCZrUTkZvfzp07mZiYmOtqiMgsu+2229TWRW4B2W6QKVVbREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkBwXOIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIikoMCZxEREREREZEcFDiLiIiIiIiI5KDAWURERERERCQHBc4iIiIiIiIiOcx+4HzajcViyfhxMzLrG/6EzvtoiNfXfXquKyM3tcgIvt3bqVpbGG8fq6h4qhHv8Uh6udNuLJYGfOfnpprX5PI4wUMteM/MdUVE5lbkUEOWc2Hqzyy07U+p/UWO9+B+K3m8in3W+XCsGsFtsWDZPf0Vx8juHNckoz2ss1iwPNRD8HKu5bP/FK6tYvvuAYLjsbJX/g7Ef3LUV24AKdeP0/00HIpceT1XKbMdXlfnA/TsHmCW1i5yw/jMbK58ZLeFGk+2d7zUWEK0/rQLx+LZrIHIPDfmo+GrLfgxYi2pZsvnDXApTODoEO6nhjhS76H3GSuGua7ntYq8TWeTD/OrrXNdE5F5wIS9poyCvGzvLWLpwuu8uU+l/Y2w76lOQu2OWdzG3AgOHyS8xIz5XA++gJOm1dMdiUtx7a2mIO21CKGf+HjJ08jgO2H639iC6S/sbKlPKfX7AD1vjmBdvwXb51MWLTBe988inz7TmmrK7rkj63uL/uJ6n9Vntx2O7K+j88NWbr5WLnJ1Zi9wPu+jJ2vQnOCn5QUfxd0OdIqQW1OUwA924cdO64+7cOSnvPX1cQIvVlHX7ebgI71U3zVnlRSR68ZMyZNbdcP4RhAN4HslTMH2l3AMbKO9f4htq8vIes+DfKyrbVgzXrWtLqOooIF1L3TiO+6kqaiarYUpBU67Y4Hzo1vTX5ebgrmknq0bdIUrcjOZvVTtsRD++K/OV0cZHU3+9NbF3xge4lg8lWsy3aneRyQjvTtrSktmCni9L2sKSWYaVfb0mAi++iuvS+T6Gif8URTuK6E4P+OtBXnYHnNSQJD3gjm+jeNBBnZvp+JLse/uqvLtuN8KEY2vf8g19fs8frQx1hbeTHs1VrbNH18Wxj/w0b65mEKLBcvKYmq+6SWQUZXIiR62O5Jlqrb1EEikZ552Y1nbgh/wbr5BumiIzAeXIwQ8jdSVr4qflwopdmyn50R6A7zm9nc+QM+2ClYluoZsczPwYTRlzbEU54b+AAOuYgothRQ/1Ucos57nfTRYavAC/qbiqenZfxyh75s1se2sLKamzUfoUuoKooTecic/g8XCqvI62g+FSNYmXpdDIUKH2qmJd2lZVT51f1xP0ROD9F0yUXpfCUXrrXD0AEc+uvr1mB4owQaMRcavex3lZjCTNgBEAvRsq6J4ZcrxINGdK1c7vBwh0D3dNULcpRC+trqUMnW0HwoyfhkS18c1HmC4heJZSjMXuVF8KoODeb+ffuFu3ZEIorOkag+3ULzZm/aSv6k4rc9P5FADlowysQademGe0thzrCt2Ui6mZThjXfELDpHZY2SZ1QSnhhj8IMtF1ZJq+kdP07FumjvWl0ZwV1fR+NoF7Du68OztoL4gTJ+rgqrdI0TJw7raDsMBRlJWf/Z/DwHgP/N+8uQ5HuDtt6Ds/uUYgMhb2yl17GLkc7W07fXg2VlL/m86qftKA76x2CLR025qanu48IX6yTKms53UlbcTiAJLHHjcTgqA0m948Ox1sPT67DiRm1gU/7cfoq4rhLGyGc9eD13tTpZHB+msraXng3ipa2x/0TM9VJXXse+SHdf3PHi+58J+yUfjV6twn067nCbwnQa6DfXs2dtGfZUNc2ZVP2tjy14XpUDBEx149m7B9tnJpdm1uZ5BYyUdez10PLmUs6+1ULUnMHncCfXWUeHycXH1Vvbs9eBxN/HQnSP0NVXRfDT9mBh6ZRsb91+k9OtdeNwu7AY/nbXb6LuGYPbKxhk61Af5ldjvAdODldgZwftW8KrXFA0FCQB5C2/YDjcyi2bUBqIjuDfW0fMvy6jf6cGzt41a01k6n3qI9uPR6dthdISexx6ibv/F+DVCF64HL+KbvEYAiOB7toKWwB2UJsoURTnYVEX962EgD1uDB9c6wOKkY6+HLfdnz7sQuRXMXqp2YS2tRd5YQDrcQrGlJf6G/cp9m+t6Gd0RS3qa7Cft6cG3qQsHPpqbYiGtvf0YXRuMxILfGrx46TlUS9cGI5FDzfFgOGV7p92xgDuxrsUQOdRDIgR3vjqKq5CU9YnMroIn9rD15zW0O1bhXmylZF05xUVW7rUWYLpCf8fgD7+B95yd1reTad621WXY/7qGiu+4OfhoL9VWOwW4ee9DKCkECBI4GsW8xExoOEgIOwVAdORdBiil4/48iAbofmGQpd84TO8TiUtlG7Z1dpZvrmDXDwKUP2cj+I6X8P2tvLLTgSlR5m6oqvURGI1iKzRju8/MIiD/CzZsSkUUubLIMP7A7dif66ZjMs3Thv2+RdR8pZ2RYATuMV5j+wvT951OQuu7OPacnbwF8eXWlGNre4CGFw9SfaA6vj6ILtnKSzurMS+Ypq4GE9bVVvKB6F/ZsK2O1Td2ozxKwfZ+PDXxY8hqK8Z/eYC6Xj8j37BhWxDE/0YYc103XTsS4zjYsH3ZzO1fqqPvf5+lY10y+Tn8sR3Pj1zYFsbL3ZfH+NoW/KciVN91ndNhz7/NkaNQ8FxprN/y4mJKiqDloJ/gUwUUTLc/Ul2OEvngCJ3f6YOF1ZQXKdiQTDNsA6ODeMdstO5rTZ7rbQVQvRHfqSDR1das7TD8mpvOjyrp+mkT9vjXz7baTvn97TxQH79GMBxjaBic+/aw9f5EGRuLxh+g+RdnCD9ehuleG9Z84JIZ22qbulfKLW0WnzgbcXT34pzyup+WtblGq3bSuyN5srTuSKzDz9DxCJHjQ/EnwU62TF5UWKltt8dKHT1GhAjHjsafF9dtSQbphbW0FiXXRWq5olZqJy/srbhenVpzketuYQFbvL/g6KutOG0GgofbaXyqinUrLaza2I4v25NoAIL4D4bh8WrKM9K8zRUbKWUE33AIllgpzY8ydCr+pOT8+4yM2XD+93JMYyO8H0/nCp44CEVF2O4Ezvjpu2Rk6e0XCBwPJH8CF4h+DqK9foKAMd8KJ7x8/7URwon0y7ud9P/sMFsL9XRFZKrk+W/aEbWNJTQdeTd+UzjFXQVYgQuXLsaKXUv7GwsweAasn/2Y9wMpbfv4COO3m+GMP5nqDWCzTh80X5GNyjWpz6gNLC2wASHCEYACnD86xuEdGYMfGpZScB9w6WJ6OumX7fGgOW7xUsyAPxS+1gpOK/zOQfxYcRQl6m/kofWlMNaDLxDNsoSXmsy/6RcLKX6shbfvqKbD14T9eg/8JvNeLG0614jaM2wDRhNWAni7+hj5KP79W2DG+aN3OTzt4KFhAkdHwHoHH/86kHYuHxk3YGYE/6kIfNZE/kLoe7kT/7kI0csABuztpzn2UtnkTTQRiZnVUbXBimt0FBcRfPUZ6dCAd3MD5synz0XmjIZqwlwEDMdOkOHJBGovNZYsz4SHQ4RZSiixLU8NliyDlMVOtilbuntp+l20fDN2ULq2zL4FBkyFDrYWOtgKRMfDhIaH2PdKJy2OAKFX+3FNuRCOcnEMCsymqSfNO/PJBwb/cBGwYltnoHNwhNBTBeT/Jog/38bWdVZKXJ0EfxOFxSECR6MU/NflGIHIWAiI4Gurw5e1wiHGImBd34TrJ7W422rwtUHeEhv2Sge1ZWUUaPAjkSymG1U7y4jal6OMj4V4PxwidOo9AkePMAjwh1jgbLqW9nc+RACge1vs3ylCjP0BuC7t1zCzK4zLUcYjY5w9G+bsBwEC7xxh6DRQdIHx2FpiPvMp3Yy7HGTAMwL3NlGUMihj3gOllDJIX9ZBwlJH1Y4QPLSPzreilLu7eP7hLMdouSVMN6r2lBG1r9QG7qqkaccgtbvbqTnUDneasRU5cGwqp8wy3fPfCKETAD1sO96TtUQoHAaDDWe7g5GmHhrKe2ChkYLV5VT/rYOHbOZ4VoqIJMxy4JxgxNE9mhzGPpEyHX/y69CogyKTDHkmCh520rHOiukrNfS8MkRtYdk1p0cV3F8JHj/vna/m4shB+HIXBQuWMfYwNI4EaTIFGRwzUXpf6tOhGXSpoADn3nepHgsyNOxj8PVBt9SSoQAAIABJREFUhnY3MrC7G2fWYF/kVjeTUbWjBD0N1O4OxC6aFxdgXmrGtslBaZs3FjwDLLz29pfsljS3wkdb2N7kI3gJuNNMweeXYv0vG6mMdtL3KdUh+m8ZL3zg5+AYMNbOOkv71AWOHuDIR2UZMx2kj6ptW12C9XNV1LjWcyH6Jl0b9NzuVjSTUbVn1gYMFNR5eLcmTPAnw/iO+hgcctP4ppvuul76M59Yp0rp+jgd07pW+ktchAJvc+TwAIPDXlqGvOxa08qbnQ5MCp5FJs1S4Jz6hNlJ76grfZqGlKe5sSe/KQeW4RDpr4Qnnx7b/3/27j+2rfu+9//TcBEWvlC2XMhw71dEA9PIEIm7C+20YepWVJJK9l0l+ztbbhdZcUepayU1i+zVpXqXSPIsKdkixl8k6nol1QjNLpEZNKa8JlLudaQlEbWloQE78nYVBsnMICm1G0PEsmthhhnU4PcPUhJ/64f1w5ZfD8CIcnh+fHh4Pp9z3ufzy2TEOLNlhv0mHP9ivJY6d6GRMGTZhxcJY5k9bsKo4CLL4kIv9+/voqLnPM3FGW5767ew5feBK1czbGzg9gIIBENEMCXfND+bYAKw3hm7mg2W+ynnIIEPAnw+GqH8e0VAHiZLIZHhi/iNPgIFe2m/O7Z5Xn4B4InXRs8d/BoKCil/uJnyh5vhMx/OP27A7RmlfltplqlbRCSrcTeHjvnZ+pNTdFYXztb4RHx0tKe3slpQ/rvDSCHgDwRhW9pQXyvrs0Ge+ZGXqYef40xTKcaZoiaI5391LdFBbsdoBv73RUJYMjQ7DRI8B9xnit/7I/h/1UsIC3X/XyPW1BP4kZeGpwZxvxagqr4wbW+zDFgOddMW3E1rcwPOO/UiUTJYaB4wGCn8VhXN36qi+doUvmf20eA6yegPLJSmZfb4te8PEMSSPrBfqvV5mLZX0ri9ksZrEYIvH2JX+88Z/LCSuruv83uKrCHL1Mc5n5KdtvjfGfr+JIxYbX8wNah1U50w6vXYselBumyUbs8nf3sptvh6vTP9RBKmkzo2lnx8V+9s37FLXhrMif2rE9YbbaVlZn9jOFNH7RZZandbqNgAnqed+C6lfxz50MvAGTBaijLUNhdi22uElzwMTCR/Enz1JEOYsN0Tf0zMs2Athv7TvfjGC9n6e7E7rOn3bRjO9tP1sg/DTivTj4GG+8qo2gCevgFC1xJ2fC2Et97M/Qc8BAkx6NjF/T8aJKkX9u1GNv4uIrJI4Q/GCGGl9JuFSc0kp37to3/m/xaZ/zYXU3kPBH7hxZ8yLZT/6Z1se6gD30rNmvTRewwBpTsTAwbgQx8D40t1EBOWh4xw9ue430qfQif81knc42Aq3hoLqiN+hvoisHM/NTutWLen/Hu4hroCCD3vJWNX50TrjVQ+/gS2DUHcrb2MzbW+3HrmmQdCrzSx6xuHGPwsYZ31eRj/S65X0yaK91pg3I33bPLFFznrZOdXS+gYnSJyvot9D+2iNzHPrTdQ8KWNi/9eImvYsjXVzt/TTtuZ9H7NSZIG5EqQqV/yzCBfldTVtuJzxQdeaE5cyUbbI5b48euwN/twxwdjaU1cLeG4s+tl2p/IMjJYcfTa8R9w0/BQP/nbSqm4z4iBCKGzAwyfDxPZbKfvu5lrNgq/+zT2gWpa/6ia4ON12DZNxfvWBTDV9lF11/Sa+WwtLiTy1BC+DXXUbY4vNhVRSi+DFwxU/VnCMQxW7I/b6G9uZfd3LuB4rBzTlSBDp5/D87YJ+wt7MWHg9mIjn/9FCzWOi1SVWzESwn/aTe+4ibonimO1XRt+hzxg2OPBetXK1u0m1UKL5JBfaMFEF082tvL5Y+WYbgsTePUkPcMXuW0D8QGzjFgXmf/2/tjOyQNuancEaHy8DsuGEP5BD+7XJrF22GdG352/WOsX38snGNxUxj33WvjifDbbvJXyDW7cP6rl9sfrsPxuhNCvPXS99C6ROxaahuymy0n3ozsYmiljLxM8M8DQR1MY7q7D9XCsPm7q7/vxYKBqX5bWMusLKa+10NXuwfP3B7F+a46TVVDJEz8Zxnekl5af2ziVdSAnuSXNMw8YrSUYI020/GkTFx+pwLoJQuf6cfcEMNU3ExuwPT0fGnc7sL9YjbumhMBjLdT9QR6hcwN4/naQyfvasG/Pw/BbG7YNvXTV1TL5Z5WUfTmf8CeDnDzmxfBAJ5Xx2mbD7UYY7efEa0bK7rFgKdCVLLemZR5Ve5zxLKNT218YZ7ynMr0mrbiNkTfasCUssnWMJDW3thzOtF87fUnzQscGJuurTVmtti/luBYc4yPx0bYT9pWSBpHlYNjm4NU3XDQ/bGPjZz7cPb309rjxfbaF0sMuRn7lwJJtNNYNFhyeU3Q+vBHfsQZqv99ET8BI3c/OpPV5Mt1bFqtR2W2ZqVkm726s9wHsxXZv8k3QuKeb1084KN0wgvPRWmodz+GngjbvyZkmh/m7u3nlZ1UYg16efLSW2kefxPtvVtq8J2m8J76/vGJqDtu4+lYHDd934kuv9BGRRHfXceJEI7bI63Q8WkttUw++DRX0DAzQ8QBwLhDrzrTI/GfY5uDU33Viv3eSE474dkEjdcdfX2Rf3ELKD1dh+cRN0/dr6X9/npvdUUr7yTaqNl+k11FL7cEWPJ9YaP/lECf+xAjnAlxcilraDRYcvzxD9+FStsyUsR7eoYjywy5e/2VjvIwNMfDiEBTUUWnNHhQYd+6nDBga9jGfynnjnidoK4ZgTwvu+Z4buTXMNw9sKqfb202VMYj3qQZqv9/Ak6cnsXac4uQPp+/1GfLhBguOX75KZ+39TL7YFN8uiPF7Ll6f7rtssNDo6aO5GPx/00Tt92tp+pt32fg9F693zY6tUvgtB1X3XMTtqKW2f+HzmYusFeui0Wh0MRsePXqUI0eOLFlCZuZrLm5jJFNALXKTOXr0KMCS5hMRuTEt9T1RRG5M69atY5GPziJyE8mU15exxllERERERETk5qfAWURERERERCQHBc4iIiIiIiIiOSzbqNoLZTk8zvjh1U6FiIiIiIiISDLVOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkBwXOIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIiksMXrmfjo0ePLlU6RNYs5RORW8O6detWOwkisgKU10VuTdcVOB85cmSp0iGy5kwHzMonImvf0aNHiUajq50MEVlm69atU14XuQVkekGmptoiIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkBwXOIiIiIiIiIjksX+B8yUuD2YzZbMZc7yWc8nH4dEPsM7OTsWVLRGareexFOe+Mpzf7+cxl7NjitrtR9r+Wxc5djusw/ts7zy/BwaYCeI+4l+6avxbG33OIfQ9ti/3+39jFoR4/4WuL2VkYb70Z87Glz5Gx/N6A99KS71pk3ua8DuP3zIbTS1CKXpsicLoV94Xr31X6vkN4H92WOZ1zlgnxfG7O/m9B338py0dY+jJyPpbzt7pRnXeu7TI54ZmtYzSSdbWb4ll0LeSx1TjmalvreWwVrUyN82grJ5Yq091yxnAecCcvumsL+auTGLmJhYe7aD01uTQ7uxbC27iD2udDmB5px3XcRWftFi7+tJYdjV5CiwqeRWRJhF+nq9nL5FLnw2shBo800PpWhmBgXmWCgS0P1FFXn/6v/G4AE4WmvCVO9PwtaRk574Mu028lNwTPW34yh85hRs74Vjg1q2818tiq5GtZs76wUgdyH3BSNu7AslIHXINsHSN077nxQmbL4XHGD692KmQlRfxunnxrI/YTfTjuM8QWbrdSelcHX6t/Ere/gubthtVNZFz+nm7G96x2KkRublPjXpytT+J9P3MYML8yIQ/Lw43pzwETXhp6DNg6umm858YoN0Sul63Yhu8lH/4mG7bUy/rSCMOjFiz3jDF2K7U2ELnJrWAfZze9czTBytbkd7Y5S7zZQUIzcOf5hO0St01sKp6z+dcYzsSmYpmaiqbsK61ZTVJ6Evc3R/ObtP2mNIc578Rsrma6vtnXXDJ3k5mUZt251k06b6nnaGY/6U09ZraLn6vsTbVTzm2W3yFnOuJmr4FFNulbK6ab33wYxNtezf3zbCI9dsxMSbMPcFOdcp2H33bTdKCEbWYz5q+WUP0XbvxznNrgv4xxG6XY7k1+GjDca6OCCBOXpnJuHz7by6GK+zGbzdy/v4PhiasZ15t630tHtrRNDdNkNrOvL5i+/9MNmM2HGPwsSxPZK0EGjx1i1zdi19L9FYdwvhZMrhm45Kf34K7YOTbfz66DTgY/TA4awmd7OVQ5m759B3vxq2mULIlY+dlwOkjwdAfV35i+Due4xs47MT/Uig9wH0i+D029P4hzjms6o0temr7TiveSBccvu7FnWGXRZcK1IB5HK77iJ3hit3HutGRyOXd5GCsD0u/HictzlZHpIgRfc9IQb5J+//6OWJmc2t3k2hSB0x1Ux9fb9lA1Ta6EtGX9rSIET3dQGy8jzd/YRW27l0DuYjX2nc7OUZ5fC+N3NWVPU8J58Yf99D4a39c3quk4HSsjQ69Nf6dtlDzam7D/RV6z8zlX1wL0Vpgx73AylnjJvt/LLrOZXT8dy1Kzu3pMO0ux4cF3Nj1loTf78RXvZe+9KR/Ef5+Z3968jZLKQ/SeTX0+m30OKPlqwnmeXu0TD9VZnpOCffswf9XJ2EJaOdykeSzrMa8E8bbXJjwD1NJxOsDUXOdkHvmHqcAczxfTXdP8hM/2pnzHSKxlz/Tv+tUSGpLO9fXksVhXmqzpiuelnceS81Lg+C7M5l10XbjRctjqWNHBwXzNLUve3t59wEy1K2HBaCsl9Q00xG9Gs8cuyRBEuqlOCEwBcFUnB4AJN7bk7TL3HXAfSNhfbVnWGvbw6YYM+43fPBfZzzN8ugFzSrPutPMTWxNvffpyX3PJ7LG3lcUfjnwMv51Y8I4xFN/O/mCO9gOXvDSkntvUY8wnHfHvFSv40te7JYNngrj/fB/OT2y0JDWHHMzax3zLbhed3y0EynAcd+HavQWA0OkGdnzfSeA/19B+3EX34xUYRp3U/mED3onsKSj87ineGXdgXZ/ywUcB/EDehuy1RlNnmthR08U7/6WGzuMuWkov09P4JMP/lrxe+LVDlFU+ydiXYmlzHa2h4IOu2bTlFVPxMAR+5Sc5dI43gftWBbY7MiTgyhjO7+yi6aUQhbWduI53Ul8YwuPYx6FXYmcwcqGXfRW1nLhiw/EzF66fObBd8dL0R/twno/dPCLnnVTX9DL5+/Uz6TNe7KK2ogO/7i+yRILPH2TfsSC2x124nPVsudhFbUUDg9nupZsrcTntFAJlP3HhOl7JFmLX6/7KJjz/Fr+mnfUUhjxJ13R2X6Tg4TZO/U8XdvPtGddYbJkQfsVJxwUTjYcqMaZuO08ex8LKw0yylZGZhE4fYp/Dw+S9jXQe78ZxbxDn/oO4kwqiMIOOMvY9NUZBvOl6+yMFBLsTmq5n+a3Cpw+xq9nP7TsddB930X3YRuSVVvbVeQjl+A6h0w3sqHHi+2IFT/wsoTy3d8WCzenm9McCbHykHdfxbp4oN+A7lqmLjY8O+0H8pkaePd6J497LeJobaGluYN/zn1PR2k13RxXGs13UNiana8HX7HzO1fpC7E/WYZpw0/K3gdhm1wL0/riL4OZGOn9o4YZrq3DnDip2ZmquHWL0lTFsO0tIvsoi+J7aQW13kPy9LbiOu+jusLM1MkRXTQ297yeuG8T95/vxXC6j6TkXnYdtGN5O+C2+XMbeYvCdGUnJB0H8vwpg/F4FlgXkt5s1j2U+Zhjvj3bR6r+dssPduI534yiO0N+8j/qXc+Swmfzjw1D+BN0J+afmf8SDzStjOKv20fTSJLbD3QnPF7vYlxKQ8mYHNT/yY3rsWVxOB/df9tD6aAutjfs48dsK2p/rpm2fEf9PazmYkq4F57HIGL3f2UHti5fj6erG8eBlvInputtOe72JkKsF9/S19n4vTc8GMR3qVGugadFF+su//MvcK3x6KlpfVBQtKiqKdp57N9oZ/7vomXej0Wg0OtlfH/v/os7ou/FN3n0mvk7dqehkwq5m162Pnvo0ed+z209GT9VNL5s9TuK69f2TKftLPlbi8ti66elOOk6GYyR+n/mcm9n9Jh+/89z00tk0TKc/s4S0ZvlO08vTzmc0Go2e60xblun3mN/vlvhbZFgvfoz5pSPD+U7a1zzO9yr5y7/8yznzSex75PgO8fMxcz3E/3/rD09Ff/Pb2dWu+tqjW4u2Rtv/8WrWY8XOd8Kx/m0gerCoKLrjr9+JJm11eSTa/pWi6NYnU5bP5be/iZ764dZo0Vfao+9k2/C370V7yjKk398Z3ZH4G199J9r+laLo/l9cTNn+YvRk1Wzarv5je3RrUWX0ZDBhnXj+avddTfjes9fYbzz7o0VF+5O3iV6NjrRZo7Y/PRm9GP1N7BhtI9HLv01dZ2u0qOpk9DfR+G9nPxX9TeIqH5yIVn69IvrcuQWdOVkD5srrqddhmvh1O1vOx8v0r9RHT4US1vuPeeTP+L5myo14viuqS8530d9ejJ6oKpq5pucnlq7c96Pp/c9RJsTz+da2kYWVNdOmy8OU7afLw+nvn1b2RTMvz7Zekni5WfHMu0nH/E1/fXRrQhkWK5v2R098kLJ98GR0f2JZnfpbTd/z/vqdpM2uvtkS3frgwehAKJpZtnMZPBnd//WKaKfvcvTy4MFoUdGOaKc/+WxffjP5/jF9b65/OeGquDoSbS8qihaVdUbf+Y/ZxRdfrIwWFdVHByaj0Xlfs+c6k/LCvM9V9Gr03a6KmfL7vZ9XZCjLl9+cj84J9+3YOW+PjiSe8o9PRvfHv3/SM8DkULS93Jqetz4+Gd2fmOfi+0+9d6eWMbFjp5Q5wZPRyqId0Z7/Pc8vuwbyWNoxp/OcP3Gjq9GRJ7ZGbY0DWcvC2PG2zjxbTLv44v6otbwzOnI5Gn2ve0fsnKfk04u/iD93fByNzj7XJq931dee4Xe9GD357aJo0Q8H4s/Xi8tjv/HsjxZ9pT06cjnlO/li5zCWrmg0evXd6HPlsXvCxd++F+2Z+TvLSVnjMuX1FapxtlDTYYv96apeutH5AFtHTbxWN5+SnbbppbQ9Eq8N3VRCaXHsT18w9U2SjbajlTMDbeXvaactcd3zQ/Ea04T9kU/lD+IN1VxDac1SZtOTXfjt4XhNs52+w7NrJx7f/eYCa51n0gr2H2T+TvGjzw5IUVtH5ab44m018fVma5gtD8a/5+gwI5dSt81emx7ruxNPywuz/dpj+7PTN95N5ab5p2OGq3qmhtlyeJzx8XHGb8l+8waqvpdcO2PYXkHVhgj95wLz3svU2RGGKMT+HWvym/o8G5XfMxLpG5p/zem1ML6nG2h9qwB7rwNrtheTn4wxNAF7H65ITv99ldjNCetd8OG5ks+W2ybxv+2f/eefJPIliPT5CACGe8vYuyGA9+3Z19Dht4fxbaii7L5MiQhzYXQMivdStjlxuQFbyzuMHK/CNOFn6AJYfvdz3vMnHPvtMaZuM8EFH/5LkF9ggbNufv7SGKEr8d3cZefUP7xK4za9mZWlYXi4jsqChAUbbFQ8bCBy2s+8c/uHPvonoKo6Od+x3kTlI2VwwcvoR0uXZmBeZcLU33vwXDFR923bddQWGqnbm7y9YXsZVUTw/OPSj6M7XW7u35tcw2ncbacq4f/HRj1E8rdgmPQnl2H/J8JGInh+ne3Xy8P4ZQOc6qLrrSDheBlseKCN8288S3lBls3e99N/xUBVecq53FxF3z+8iqMY/G8OgdlOZUrZmFdcSV1BBM/fJ9aMWin9WkLTecPtsf1+04Z1w+xi011WAK4m1FYv9Jqd/7kyYPlBO3Wbx3D+eB9NzwaxHX2aqs0ZdnqDyPtaGWUpzbVDbw8wtrOCHZtSVs4vpXngnfSxbL5ciAWYvHI5aXHpg8n37vw7TYCP4ETisZOfpQLDbgIFe7HdvZBvscby2O8aKdgAnp924fsoTCQ+cKGt4zwjz5WTrcNI4Fw/kQ1VVKSM32Kq7uOdAQe2vAC+/hA8XEVFSj417dpPGWN4RxOqzO8rxZqwnuE/xfab/LuaMN0LXEvuzrawPBbCf2YMLLfz+T8nn6uxKQMmxvCdi18jBgt1T9ZhuuCk6TtNdH1ko81ZhWmRrYHWohUbHCx/TzttZ0poHY0NFGbqWJr9mu7MNFiWiS2pBVLmrVPWy2fLXcAo8OFFPjBNX+A+Wh8y05q2fZCLl0gK3DKnJ1koGA8Yi00pGTT5+GEsixg924YpKcMm7DN2dILTf7uqMac1455+wZAfD2LdtI7GCt7K7QkBca5m2tlsczA+vtB0WKj8gZ3W0dhrAV9zCeZmiAXgt2LQDGBN+Y2B9UZM90JkfP7XTeTKFGCh4P9J/2zjJhMwweS/A3PlpWshvI59tJ7ZSFXPCRy5gsbPQgQopNKYus5GNt45+3/hiSAQxtteizfjjoJMhMGSb6XiYQOeX/kJVpswxV/uGPa4sGRMRoiLZ4GHc4xMfymIH6DnYOy/mY79KRh3N+P4+xqc7dV42yFvsxXb3kpqysspnFf5IzI3qyn9Mc5ossKVQOz+M59r7cplQhSyJS3fQd6XCoAhQp8BSxWAzKtMCDHw4hDc0xwfUXuxTOSnZub1WzAVQ+STMPPoFrwg/3cqDFgxfTnzMWPChD4Cwl46vp+5BCM4kaWsNmD9k04qzzXR++guejGQf7eNikeqqCy1km3Q8fDHASKZ7g0zIvzfKeC/FpC2yvqN5JuAicmE82XI/IT4hZTfMsM6c16zySlf2LkyWKhrszN4wE3wvma69yyyX/xKucNG2U5oesuPo9iGgSCj/WOU2XvIOn78tQhTE0HeCwUJnnsX/5kBhgA+TQ6c53yCnz72mRHCeyrJJ4Dv5RDGb9soXFAgdHPnsTQGK/aOSsaae2mo6IUN+RRur6DqjyvZYTWRl/HchJl4PwL3mnJ0KYlweQIKTcb0F4F3xPLd0KeXgXh3FwN8MdNuUn5XwxLkseBZgF4Ovt2bMeXBUPy5HzDcU0d77SDVriDWlu7kAF1WLnCerqmNBUBuWptX7siyWPFa/FEfvjMjjDFbU162bQWTsc3B+Lgjpa+zm2qzG4rbGOmpXLvTc/12geuvz1gML58pP132Bno/KaTxly7qzIutN7qN29K6Ttpoe6N7tjVCFpb/VofRNYD/kypMhhGGRw3sPZ69v1vkSpYPUthfGMeR8zovxH78HaomAgyPehl6eYjhY00MHuvB/sKp3C8QRFL9FiKwoJrXL96ItQDzLRM+GWXgAtg6yrLW8Fy322/jNljSQaM+j1yee6Vpi70/FZTS5j2P4yM/rw94GTzjw908hPspG21/l+VB9iaZzirrNbuAczURGIv14z07wOgnVTd0jTPkYSstA0d8dO1/9eMdL6Pma5nC5ggBVwM1x/xMAYZNhZi2mLA+UklZuzsWPC/02DvL4Uej+D+rpPySj/4JI3uLC6/7W824CfJYpn7Yxp1tnCp1EPS/zsCrgwyNumkddvPkA2280pV5vIWrN3seq+1j/PA8qpuuTRA4F2uh639llOC3VeOcaEUHB2Obg77aFT3iHGI1xrPCXPww/uddW/i9O03x/7HR9sZ00+DEf3M/1GdiNMWblI8GUwb6SD7+4oLB2WY6afuMHX32jV1tX4bvNJ6UsfK3l2IDGB2mN960ej7N0acFP04osuKjiMea6i8sHRCfVmj6sxemm5Hf3HOE3/6lQiDAxSwDcQU/9ANWTEnXWZDwZykrXgsRPAdGi2ne141hQx4wxsS/pn82eSkImDDm2tnEMK1VtfRGKnju7/rmFzTfYaSQABdDqbfZCSb+efb/8vILAB+BD+ZxO77bxt6CMQbeDs00067I2lbcSNEDxFt0JAu/0sD9FU58txkpBPyB9NG6MzEUFFL+cDPPekc4/w/d2AuCuD2jS/4WXm5u09d08OPMn0eCsUG0TAXJmS4YTp9/NBT0Q4EF03wz+4bbMWbMdzD16QTpZcwiLaBMCI/5GMNG6fbrfe2ZqTy8SHAUjF/amPAiYpJwSqYMhTK3KcllY74J8BP8JPWYsTI4Jo+NBcBogPeuI6LI22yl8rFOXAPvcH6gGdsVHz9/LXPz03xTIQb8Kfd/gDG6vlFC7Uv/h9/JA/55grRVrk0SDgKbjUvyEnph1+wCz9VHHlqeGsPyk04c94zR8YSH4A0e0MSaTPfjOxch+LaXwM6yzANXjrs5dMzP1p+c4p1/Guf8G6c4dbwTxx7ron+XvAcqqGKIoV9PERjtJ2S2U7bgFh5rNI+tz8O0vZLGv3Lx6sh5Xm2xEXnr5wx+mGnlfLaYDXAumDKIHnChi/sfqsXzkYHbCyAQDKW/SPgslu+s82iVOh8Ly2O3YzQD/gDzeaoJvtRCxwULDqcDy4UOWl6a37PQrWJlA2fA8kgbtiyfzQaUCcHQJS8tGUZUXho+Wo/MjqAdPt1Ca2JT5ISRpVtfnO3HkX36pfmZCUZxU500enTK8RdiJq2xpvAz41Yn7DN+9Nm+4K7e2ZHBU6b4mjHTR9wHsYSlAAAgAElEQVSHbxSYz4NOYr/y5hOzaYn37XYfMOM8P990JExplTjaeIFp5jpKCs5vMiZLGUb8/NzlS59OKuzj5C8CsNnG1qQahhD9v0oepTN85iSeK0b2bp//m+S8+0ooI4D7lykjfk758D4fwrBnK0XZ3jJeGcNZdxAvdvp+2UbpfJvybLZSsRk8fQNJN5/IeS8nx2f/33BfGVUb0tfjWghvvZn7D3hmbwDrC7F928jYWx5OnPHNMVpoPvcUW2C0n6HEPp3XQoy85mPKaKLo94upvAcCv/DiT6qdjuB/eifbHurANxVi0LGL+380mBwg325k4+/O81zILcXw+1spA9wuN8HUVg9Xgnj6PLChkq0pWTj08kDydRge5ORLEYx7bcw7t99lY29BpvwUxPviUIYyZhEWWCZcDPigwELRdQfs6eVh6BU3HmbLw9hLwgtcTHwQv+Jn6NWFP3FPl5sn+5NHyI28PYBn5ncyYP1mFQY8eF5NGVtlwkuD+X6qsz2MRsboqixhV09ygGzYVMDGXAm728reDRE8g77kdJ0dYvCzKQp/779ifbAMxt14U6ZHmhr10jthoPLeolxHmLeFXbMLOFfXgnie6GBscyPN1eXYWxsx3QwP9nfYKNsZof8tN0O/ClC+05axmXb4gzFCWCn9ZmFSc+GpX/voX+yxDVbKqg0MvdnDwFAIy95iTHNvlWJt5bHI+S72PbSL3oRnDtYbKPhSzhxG4b17MVzxMPB2Uqrw/69BpqYKKfxyIba9RnjJw0DK26ngqycZwoTtnqVpX7OwPGaieK8lY96PnHWy86sldIzGn2TiL6ZMh5qxf8tO8yETY0+14FnqMTBuYivYVDtuUyXtHcMZpxeaHtgAYsFV6lRGy2K0lRJzSu/l4jZqtsH0oGbuZl/GfriJg3AtSOI5yLBfW8fIHE1EM0lI63Qz5izy99Rhb/bhztR3e+a7z6w901w79nkpJXM+6ORTebSN4Yda8WVKS/wY+dvmk47cvwHYqUsdSONmYrbzdO0A1a4GdrxpoXSnFeMGuPwvQwwMB5naUEhdb1XajS70tw1Uhxup2VMI/9RL+0/9FNT2JQ+wlSJ2YxvmZJ+VyH1bsd5Vzo87BtjdXMu+f3VQ/8eF5F3y4T7mxo+NtobSrH2wAn0tuD+Cwm8Z8D3flTat2sav11C1LdPWJqra7HgPtLKvPoij2sbGTwfpOuZNfhNqsGJ/3EZ/cyu7v3MBx2PlmK4EGTr9HJ63Tdhf2Jt0TgqL92J8tgs3Rhofyx1OGHc7sL9YTcd3qgk9Xodt0xRjJ9rpettE3ckK8jGw98d2Th5wU7sjQOPjdVg2hPAPenC/Nom1w44tz0i42Mjnf9FCjeMiVeVWjITwn3bTO26i7oni7P3X5NZ0Ryy/+Zqd7NrhpWxnGabfhci/+hkYHiN8JY+yv/oBpakXzoSbhgOTNH6vkkLG6H2qC/8mO33fzXGdb/gd8oBhjwfrVStbtxdi/2s7Awda2W0P8sT3bBivBPA+38Xg+ybsL6SXMQu1sDIhROh94J4t2Ztpn3diPuCeR5cJI7eNHqQ6XE/NHhNXf+3G6UouD/Pu20H5hkG6fnIIww+rKCSA9/kepu6ykVj9ml5GZsjFd5TT2OJlX3st1Z8mlMHPJw+SZLDaeeKBflqP7GbfPzto3Gli6pMhvH/jwb/ZTt/u+BnP8FvZHrid3p/WUDt5kMpvmsj/9yCDHifeDTY6d2f53WfKzAb2hePl+SexsnXygU5qtkHetR/TNrib1pp9TByup+ruPELx88UDbfzgwSUqtRZ4zc73XMVqwkzUnbTH+ujebae9tp/qp1rwbO+7gZtsx5prRxxddFHOc9szn+f8QgsmuniysZXPHyvHdFuYwKsn6Rm+yG0bFtsc2oDlgb0YDnrwXLHgeGY2x8W6vzGPLlE3dx5LO6bZhm1DL111tUz+WSVlX84n/MkgJ495MTzQSWWWGvmZ49XvIxzPP8EzXThPTWL7q5rYC/vvPo19oJrWP6omGH++CJw+QddrAUy1fVTdNdfvNU8LzGPTzz3umhICj7VQ9wd5hM4N4PnbQSbva8O+PS/hxVTdzH4Kv9uO/eVqOp7wYH1BTbaBlZqOKvXDhKmTUoeln5mOaHYKolzTUSXuO9NUSZmmM0peLzEtyVMeZfouadMnzfld53eO0qehSj9X85r+I+X81fdPZp3ma3ZKpxzffR5pyLb/aOq5zXKMeaUjw7lKP96NZT7TUcVcjf7mzRNRx59WRK3T3+3rFdGa/34i+k7q1DXT01y8+V70RGNs/a0P7o+297+XMnVSBv/xXvTED22x6RxmpjaIRif/8UTU8Uh8+Vds0f1tJ6Pv5jyx8altUn+PlOsul8uBU9H2+DFj6R+JnqhL/+0n/QlpK7JGK/60PXoqcDnDHuNTNpT1RN9L+STjNED/cTE68MzBaMXXi6JFRVujtkfao6c+SJ5i4uoHA9HOxunfZGvUtvdgtOcfk7/Xb97sjB7cO52++H4ypk/Wuvnl9Wh0cuxUtLOxMmr7Sjy/fMUWrWzsjA6kXTfx8vOZkeh7z8ev1a/YovvbTkXfm/MSuxp97/n6+DGmpwqKRi8HEq9pa7SisSc68vFCJ4LKNB3VQsuE6e+WY1Ka1Kn4sq5THz31wWx5WPT1/VGH59208vDqB6llzsXo1XOdyc8LWcrIdFejF/vbo/sf3BotKiqKWqvao6c+GEn/Tr+djL7zvGNmvaKvV0Rr0n6/DL/Vby9H3/U4ojXl1vj5i/1WafeDDJLKzK9XRA92vxOdTJqCLDlNWx/cH233vJu0Tuap07L8ZknT3szzmk2ZKmde5yoUewZImz4xPg1P2lRry2jOR+dM1258iqWiHw9FE09F6pSUk/6e6MHp3/3rFdGatpPRdz+djA79OGHauGx5I9vy+FRlqdPOzTlF3sw+b/I8lumYl9+NnvzvNfFngCx5JZOU41nLD0Z7/Cnf4vJ7Cc8X8XXe/E3CdRuPS1KfYbP8fu8+k7judeSxpOeeoujWByuTvvNvXq7POF1dbMqqlOnpbhGZ8vq6+AcLdvToUY4cObK0UbzIGnL06FGApc0n866FEZGVtPT3xDGc5mrc8x3QZQ0KnarFY3LdHGXdNT/OP6glcPQMrn03+EjPy+bWuGbXrVvHIh+dV8e1MZz3VxN8fCRtqiv/0w2E7Isbr2fFKY9xq+SxG0WmvL7ifZxFREREcroWZLg/knuAwtXwfi+7HtpH74XkxZFzPoYxUJhhmhiR1RTrG1xGxQMpmWnKx9CrBRhvtHE5lMfkBrbyfZxFREREcnl/iLEHm3k6dS7X1XaXjYoNXXQ9Wsvlw3ZsmwyE3/dyonuQyQfaqLpntRMoEhMa7qL/XAjfqUE21vZRmjKS99Soj89b7GSdhGK1KI/JDUyBs4iIiNxYzHU8m2Oww1WzvpA6zynyn3XiPtaA+zMwbLJQ2uCi50+s5GvwHLlBfP6vPtx/GyTvW82caLCkzRGf961m2lYlZXNQHpMbmPo4iyyTZenjLCI3JN0TRW4NN10fZxFZFPVxFhEREREREVkgBc4iIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHL5wPRsfPXp0qdIhsmYpn4jcGtatW7faSRCRFaC8LnJruq7A+ciRI0uVDpE1ZzpgVj4RWfuOHj1KNBpd7WSIyDJbt26d8rrILSDTCzI11RYRERERERHJQYGziIiIiIiISA4KnEVERERERERyUOAsIiIiIiIikoMCZxEREREREZEcFDiLiIiIiIiI5KDAWURERERERCQHBc4iIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOyxc4X/LSYDZjNpsx13sJp3wcPt0Q+8zsZGzZEpHZah57Uc474+nNfj4XLeF3cp5fqp3KolwL4X10Gw2nl+zXFZEbyNT7Xjq+v4v7zWbM5m2UHOjA+/7UaidLRJbTtQC9FWbMx26KJ04RyWFlapxHWzmhoGyRxnAecCcvumsL+auTGFku10IMHmmg9a3IaqdERJZB5LyT/ZWtDGDD8TMXrp89QQX9tFbux3le+V5kbYow9mwTXR+tdjpEZCl8YaUO5D7gpGzcgWWlDrgG2TpG6N6zxCHzpkq6xyuXdp+yIFPjXpytT+J9Xw/PImtTiP5n3ASL2zjzs0qM6wGsWIu3Yjywi45n+qk6WYVxtZMpIksqcraLn7wEpgIIrnZiROS6rWAfZze9czRBHTuWuSnybNPqBryXSGtePLNd4raJTcXN5hzNX8dwJjaDztSUJmVfaU28k9KTuL85moKn7TelufR5J2ZzNdP1zb7mkixNqmePmfQ9E5p4J26T1FQ9Q1PtxN9hbGbdxH2H8dbnSHeWdWZ+P5l1yUvTd1rxXrLg+GU39tVOj4gsvfD7BD41YC21xoPmuPUmrP/NBBdCS9f9RkRuDBNeDj06TOnPnsNuWu3EiMhSWNHBwXzNLUseOLkPmKl2JSwYbaWkvoGGh1rxJR27JENw56Y6ITAFwFWdHLifd2JO2Vdsu8xBoPtAwv5qy7LWsIdPN2TYb+z7LLwfjIWy2thfvmBoZunYm7PfzP3m9D7DjJzxzZk+AEZbqW6eTqGN0u35xIL0ElpH09OdHFinrwM+Wh9S8JzsixQ83Map/+nCbr59tRMjIsshv5S2N87j2pdapzxFYCwIBbdjWJWEiciyuBbC+9SThB5+msb7dG8XWStWJHC2v9AXr0nz0friUg+OYKdvfJzx8RHaiuOLRn34avsYHx9n/I02bPHFwY8zvNMvbmNkfJzx8XFGOuJrjrbScjpMUv/i6f3NHCfbd5lOzzjjh7OEpZe8tEwHpDP7TTi+qzoW5G9zMD7eN1MLaesYYXx8HMe29F1aHoyv5RqK13KHufhhwgofXoy/DAgRjAe09gfnbjg/fczx8W4qN8HYsekXA7PfczrdvuYTsWNfGmF4+hgvxM/F+HJeAzexTeU0t1RSmLfaCRGRlRY530PPGbDUllO42okRkSUTcDXQ+nEdnYcseikmsoasUI2zhZrUoHCJ2Dpq4rWm+ZTsnA6RbbQ9Eg8KN5VQGg+oE2tjZ9Y7Wjkz0Fb+nvaZ4NsXDMH5oXiQmLA/8qn8QWqQmik92YXfHo7XNNvpSwiuE48/W0M8T9vK4oGpm6HzJAWvAIwOM3KJhO9kpyxDAJ7MTl1Sn+oxhuK1+4nfM39PXfKxE7gPTNcwW3DM9UJBROQWEfnQw6E6NxMPtPH0t9W7WWStiJx30vRzI229dRSun3t9Ebl5rFhT7aSg8ICTkSXar+nOTINlmdiyaV5bp6yXz5a74n9+eJEPPp4eysFH60MJfXVnRrkOcjGl2XHm9CQLBeO1zcWmlMFgko+/sD5vRkzx8xv8OAwTwVhwXmzHHq8hD05AePo7zdVMO1P6Ll2cGdxiur917N9s8/Tgx2HYVEld7fRGCedOUzGIiDB1tovq/R3472vmlLMyud+ziNy8rvhw1nkwPv4ElQWrnRgRWWor2Mc5oaYWN63Nqb175frM1rj7zozgjfdvtu2soSa+3P2md6Z/s820vDUclsMpzech1n8850BtIiJrW+j0IcpqeonsfI5XuqowbVjtFInIUgmf8eC5EsHXvDOhciE+5ouegURueis2HRUA2xz01bqTB/NaVbEaY8tMrXNCv+C7tvB7dwYBH2Cj7Y1YH9+MFjjYldFki+13NEgIEuZkTj7+Qieeyt9eig0fvtHW+MBcsQG98okvd7XSyuzyBdu0BRPxMzKvqbHyqewZZ3qyq7FjsYHcfM0nGNujqclE5FYSIXC8lupnAxQeOoXr+4Xq+yiyxuTdV4freOr8GGF8zzbhNjpw7SvEcKcGNRG5Wa3oqNoAlkdmB+tKFQsogdFWTkz3lU0cSGvJ+Wg9MjuCdvh0y8xI0PYHLQn9hpMHtMo2bdZ8xQJcADfVCc2X046/UAn9uWPiTdHjAe+M4lJK5tWUPVXC6N3TA4FBwrRX8f7MWabBmvl9MzRxFxFZy0KnD1H9bABrxyv0KWgWWZMMBRas261p/0z/GYh/ZilQ7he5Wa1sjTPApkraO4YpyRAM5985XZ8Zm97InbbGMhhtpcTcmrysuI2abTA9qJm72RdrYpNSU27/QeWCa4WB5HOQYb+2jpGMI2fPLd5cezR1uqlYwOueHthrZ8ni0k38xYerFR9uqs0pv1BtXaxWflMNbcVuWkez/I7T64mI3Ao+G6brKR+RfCsFoX66fpq6QhF7HytFQ4SJiIjcuFa8xhkSR2FOsc3B+Aspn9T2zU7TtOTs9CVM9zR9vPGexJG2u5OmtIqx0fZG5mmh5ivzfmPTN83dBDrHfu+crVtO7Mc8W9u7yGba0zZV0p3ad5n4tFWHE0Ye7xnP+LslrycisvZNnX2dwStA2I+np5fetH/vLqr1koiIiKycddFoNLqYDY8ePcqRI0eWOj0ia8bRo0cBlE9EbgG6J4rcGtatW8ciH51F5CaSKa+vSo2ziIiIiIiIyM1CgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkBwXOIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERERERERy+ML1bHz06NGlSofImqV8InJrWLdu3WonQURWgPK6yK3pugLnI0eOLFU6RNac6YBZ+URk7Tt69CjRaHS1kyEiy2zdunXK6yK3gEwvyNRUW0RERERERCQHBc4iIiIiIiIiOShwFhEREREREclBgbOIiIiIiIhIDgqcRURERERERHJQ4CwiIiIiIiKSgwJnERERERERkRwUOIuIiIiIiIjkoMBZREREREREJAcFziIiIiIiIiI5KHAWERERERERyUGBs4iIiIiIiEgOCpxFREREREREclDgLCIiIiIiIpKDAmcRERERERGRHBQ4i4iIiIiIiOSgwFlEREREREQkh+ULnC95aTCbMWf7d2xs2Q6dLR3O8ytzSJH5GjuWI4+YzZjNThaSU8KnGxK2CeOtnyuvxdfJcOxtD+3j0DEvY+Hr+opzpXgeaRS5+cXyZgPeS1lWiN+rGk4vLMMl5/mY0JkOqh/aFsvLNV5CGbbLWvZ8Yxe1f+HG90lkQelYGOV7WcPmev5dcD4fw5m4zXln7rJkZp1Mx76fXd9vwv1WiOXM4fNKo8hN6AurdmRXNWaXnb5xB5ZVS4TIjcBCeb0VY8bPishflTRECP2TD5+rlaGXhmk++SxVdxlWJCUich2u+fH8yENgWx2dHVby/1MBG7OubMRWXU5h3uySy//iY2jYScMrXqp6TtBcvDIlkMhaY3ygivK7b8/42cY7V+Z+mpaGfw/ie3MY56ODeKu7OfETG/nrVyQpImvC6gXOALiprjcx0lO5QsGByI3Iwv7HGlf5BVKmNDjgEy8Nla10/Hkvhd5GLIqdRW5s4RBBwLp3P+Xb57qzmij9XiOVmxKXNdI85cdZVYv7Ry1sHeimfFO27UUkG1NpPY17VvfpNlMaGh+fwv/sfmpdh2j5/dfp3q0ncJH5WpE+zvYXxhkfT/zXh336w9FhRuJNOWaajtV7SWzEEmuKZp5t9pHU/Dq1qen8m7amNlVLajqT2NQmoTnZ7DZqgiIrKFuzp+VuDvXlSjqPlsFHvZx8a2pBaZluQuoP++l9tIRtZjPbHqqm43SAqWu5Dzv1vpeOA7FtzF8tofov3PhnsucUw45t6Wn4bJimr5rZ9uggy9q6XGSlXAvjdzVRW3F//L6zjZLKQ/SezXyFh083YH6oFR/gay5ZfBelPCuOpxsxXvHR9UogtmwF8j2X/PQe3MX9001KDzoZ/HC2QenUmSa2pTVzjZcHX21gUPdkualk67KwzF0Z1udhPdRJY0EE3994CSwoLdPNxoMET3dQ/Y3pvNqLf678dy2Mv+cQu74Re46+v+IQzteCs03G3+9ll9nMzmNjSc3IA8d3YTbvouvCsjYuF5mXVRoczILjjTZsAPgYfnvxj7nuAyW0jiYtoXrOQCJWEFS7kpf6mktmC4dNldTVxj9w9cb2d945s42toz3lLb3I2pT3zb1UAYNj7y1iax8d9gaG8ut59ng3T+yE/uZ97P8fY1n7V4VfO0RZ5ZOMfamG9uMuXEdrKPigi9o/bMA7AZBH6Y/bsW3w8eQzw8TC+SmGn2pikHI6O8rVgkXWgAi+p3ZQ2x0kf28LruMuujvsbI0M0VVTQ+/76Vvk3VeHy2mnECj8bieu4y4qNy/y8OYy7GYIvf1exj7SuS0830cu9LKvopYTV2w4fubC9TMHtitemv5oH87zsa3ydjbR/oAB31OdDH8W227qTDtNr0F5R6dqxkXma30hZX9SCBN+3ptY+ObB5w+y71gQ2+MuXM56tlzsorYix8uryBi939lB7YuXsR3uxnW8G8eDl/E6drFvOlC+2057vYmQqwX3dPn2fi9NzwYxHeqk8R41eZPVt3pNtTeVUFoMvlHwBUOw6EddG21vdMeC2EteGh5qxYeP1hfHqDycufFr+HRLPNhO2Pa8E/MBdyxIfiS2zHK4D7urGjc+Wo84CeKO7aC4jfZVbn4jsmIMG9lYAHwUIox1gTk1CA/20XfYggFgu42txmp2PeWk///to+rLKatH/PQcGWLLT16l77um+EIr1p02th7YxZO/8FPxuBXDpnLaWwbY8RdNPLf71xy8Ent4ruppp/SO6//KIsvDR+tDZlpzrGGb/iM8is9/G7bHe+icud9Ysd27keo/7GAsEIa7k3OjocCC9QsXY32af8+Kdc6m2rlsZOOdwGtBwpBlDIZsFpjvCdH/dBfB3d2MPG4jbz2AFesDFVjbv0bDM/1UnazCSD7lre0MVDTR9DcV/PrPPqe9eRAe7qZ9Z17qTkUkh435JmCQ4CWgYGHbhi4Zafu7bioLIJZXTXSUNNDyvJ/Sx62khrih0066PtlL9xvN2OJZ1brdRsV9HXyt3kn/t/uo+rIByw/aqTtTTVebh7IXLAz9uIvgPc28Wlt43d9XZCmsch/n65dU87upkvaOYUqafeAaYuywJUO/0TAjZ3yxP2vrZrfdVkNbsZvW0VgNeOWefMCC4wU77gNuGHXHw2YbbUfVJ1uWkptqszvD8htl8LyN5JvmXiszG/ZHLEk3UVPpXmxPteIbC6c/QF/w4bmST+Vtk/jfnkz6KPIliPT5CDxuxQLk726n/cwOmp6uZuxSgI3fdeEo1htpuZGlD8Y1YyrAYJ9v9v/zS2keKE1f78uFWAD/lcss/oXzfOSR/6XFbrvAfD/hZ+gCWL72Oe/5/UkfTd1mggs+/JeqMG4CZl6aOakemyBwhx3XYVvag7rIavM1l2BuTl9u6xih+waofMnbmH3YwLkYHq6LB81xG2xUPGzA85J/5h49K4T/zBhYrHz+z36ScviUARNj+M6FqfpyPhgs1D1Zx9B+J03fKSDwkY2216swaQAzuUHc9IGz6c7kwif/ThPgA4JcvESGoCNEcLppt6sasyttheQa8G0O+mrdaqItyyjbqNorNaL2XEJMnAPuXcy2Jrak5pdNWzAB7g9DpNZjhSeCQBhvey3ejPsLMhEGSz5APuWtTzDwUCu+/Cpcj6W/5Ra5sWQajCvukpdAYuA87VqEqYkg74WCBM+9i//MAEMAn15e5rSGmQgudtuF5XsuBWMP0z0Hkx+qZwSZ+BSI7zN/dztPvFZC62g+VccbsW5YbDpFlk+2UbVXakTtuYRDi87gWE3pTyxGkxWuBDI8e4cJngXo5eDbvRn3FwzNPncb7qmjvXaQalcQa0t3coAusspWL3C+NMJwPIC1ZciAN44xhhKCa9+ZEcJ7VOMsS+lGGFU7h6kwoStguGvLkl73htuyfZLQhWIOkQ8CsQftcD9D5xxYVeMsa0aEgKuBmmN+pgDDpkJMW0xYH6mkrN0dC56X1SShD4Fi0wKbaeeWPd/HBhJ1bJvHTq68R+AcQJj+v/fj2K4aZ7nx3AijaucyeSkI2DAtcWD6xWy1w7V9jGfpQpnk2gSBc7GRFfyvjBL8tmqc5caxSoODhfEeiY38Cem1xgsR/Dh5YLHwx9Nv0DK88QbAiKk4/mdtX8po3/F/CRk7fLqXpEa0o620LGjiepGlEiT8WfKS63ljPF9TowMMYmDv1xL7GM03LZOEp1IWXbpIECj9vS1pa+flFwA+Ah/MY/TMKz6cP/LAw510PgyeHznxXZl7M5GbwribQ8f8bP3JKd75p3HOv3GKU8c7cexZ6DgDiz2+j/4JsDyQeLzlyffcYaQQ8AfmU55F8B07hIcqOp1V8NIhnKMabVduYp+GSc4u8VZey+laAN/LIbjHhjXxWXmeaQmGJ9OWhYJ+KLBgSiugbsdoBvwB5pPDgy+10HHBgsPpwHKhg5aXlv85R2S+ViRwdh9InvbJbE4YCbu4jZr4G2ajKT4symgrJ6an0LjkpaU5Q/O1OF9zy+wI2onr1pZlqcHLp2Rn/DjTo2XHt52d4ip9f7aOEfpqM3uVVYwAACAASURBVBxTZCVsuB0jIQLBhFvatRAjr2XPG0viEy9NR4Zgcx2VVsMi0jKI90zymLyB0258lFFyX3pHT8N9ZVRtAE/fAKHEqWuuhfDWm7n/gCd+451+eC6n88/KKf+zTsrxcOiYL+uovSI3k/AHY4SwUvrNwvhgWTFTv/bRv9wHn/Lj/EkXoQ3l1OyM1zcvY75nczGV90DgF178SS+/Ivif3sm2hzrwxQ8bGXVy6CUo7zhI+bcO0vktvTSTm5WB38kDLlxMut9Fzg4xuJzX87Up/M820TVhoPxPKuItShaWltDLA8l5NTzIyZciGPfaSB/Gy0TxXguMu/GeTb5DR8462fnVEjpG4xn8Iw8tT41hOtSM/Vt2mg+ZGHuqBc9H1/mdRZbIKvdxTh5oa7Z/cizYzjRcUrpMo5TaaHske3OQ/D112Jt9sdGyU7edCeQTa8Xt1O3Jx0LiKNteSnrUZFtWyF029m7uoutIPc5IHbY7JvH1OfHdlukmtRhjnPxpF7OPwBFCZwcYPh8mssFGW28dhdMP7wtMi+/IPmo/dmD/2kYmznThPDWBraOb8kyjXxus2B+30d/cyu7vXMDxWDmmK0GGTj+H520T9hf2YmL24dn2V03xUbRLaXrcxmDzIZwP/JpmNdmWm1x+oQUTXTzZ2Mrnj5Vjui1M4NWT9Axf5LYNLNELoiDDz3cxkRDLXv6XIQaGg0xhwv5Cwij1y5nvMbL3x3ZOHnBTuyNA4+N1WDaE8A96cL82ibXDHhuJd7qVyQOdNMVH0S798RPYXmvl0DEbv25Rk225meRhLS3H8FoXTT8yUP/HhfC+lxOuKUzFLGIauHTB4R66Qgn9rP89yNCZIYKfgam2L2E0+gWmZcJNw4FJGr9XSSFj9D7VhX+Tnb7vZn4iMe52YH+xGndNCYHHWqj7gzxC5wbw/O0gk/e1Yd+eB9eCeJ7oYGxz3cx+Cr/bjv3lajqe8GB9QU22ZfWtXuCcqa/DNgfjLxCbFiphvRFTb2yk7AzsL4xT9mbinMzzGYnYgmN8nLJjKXM5J6RpdsoqsL8wvT8LNR023M2+eJPtkhtiZES5BawvpM7tgvYOTjQ34L7DRNkjz3FiV4iWt4aX4ABjDPaMJS3J22yltL6JGnvKKMALSouNthOVBH7aziFXmNs2l1F3vIe6HNPkGPd083qBm86fnsD5qJcIeZi2V9DmPUjl3Qa44qer3UOkuI0nymf3k7/bQfPLu+ho76Ls7xwaMEhubnfXceIEdLSdoONRL9xhwrpzPz0DZYSfKeHguQAhLHzxug4SwtfXS+Ld1bCpENvDzVT9oCq5Cecy53vDNgen/q6Irr/p4YSjlikM5N9tS9gugv+nT+K5YqPt8YS52jdV4ni8n11PPUnXTiuO+xQ6y80jb2c7pzpup+WnXTQNQ/62vTSeaGfLK9tYivZkobc89L6VsGBDPoXbq2j+43qqUvLjgtJS203fHf00PVVLMJKPZXcbpw5VUpjtvrvBguOXr1LU3UXPi03UfhYva77nouf7VvLXQ+iUk44LRuwn6rBMZ2ODhcaWKjz1HThPF9O970YeE0luBeui0Wh0MRsePXqUI0eOLHV65mdmvuYFDCYissKOHj0KsHr5ZJWFTzdQ0sy8B/oSuZmt6j3xBqJ8L2vdunXrWOSj8xowhtNcjXu+A32J3MQy5fVVGhxMRERERERE5OagwFlEREREREQkBwXOIiIiIiIiIjms8qjai7Spku7xytVOhYjkkL+nm/E9q50KEVlJyvcia1lscF3HaidDZJWoxllEREREREQkBwXOIiIiIiIiIjkocBYRERERERHJQYGziIiIiIiISA4KnEVERP7/9u4/tsk7zxP4GzGqR1mFXSQj5i5WRzjqiMRzOybd4g7XOC2NyU4J3ILT2QmBruNem3i4AjecM9pO4l6T0OnEoAV3ekmK6ngKIagTk5shqQTJlcbZoRiJYG5kUhXFVVtHVxRrOyJahKui5/7wY+fxrye28wvi90tCIvbz4/t8/X2+jz/+/iIiIiKSwcCZiIiIiIiISAYDZyIiIiIiIiIZDJyJiIiIiIiIZDBwJiIiIiIiIpLBwJmIiIiIiIhIBgNnIiIiIiIiIhkMnImIiIiIiIhkMHAmIiIiIiIiksHAmYiIiIiIiEgGA2ciIiIiIiIiGd+Zz86vv/76QqWDaMXifUKUH1atWrXcSSCiJcB7nSg/rRIEQchpx1WrkOOuRHkh+mDlfUK08vGZSJQfeK8T5YdU9zq7ahMRERERERHJYOBMREREREREJIOBMxEREREREZEMBs5EREREREREMhg4ExEREREREclg4ExEREREREQkg4EzERERERERkQwGzkREREREREQyGDgTERERERERyWDgTERERERERCSDgTMRERERERGRDAbORERERERERDIYOBMRERERERHJYOBMREREREREJIOBMxEREREREZEMBs5EREREREREMhg4ExEREREREclg4ExEREREREQkY/EC59tuWDQaaDQaaBrdCCW8HRqwRN7T2OFbtERkadwupil9uh9I4/YHKx+XiqSM2ceXOzFERERERLRSLU2L85gNPQ98YOODfZ8r/qXHiqFcnsRkLDRggSYx3URERERERLRglqyrtmvfw9Miqm8fhd/vh/+wdrmTQkRERERERMtsCcc4u9A9kGHH58Qu0xoL3LfncWppt/FUXXvH7dBo6hBtt/U0V8h0//XBLh7DMhCSdDmXdjuf3Uaj0UBzLPEng4T303RZjz/27DnFd+Fu1KCi2SP+7UJdYvfyObqex3WXl24rplf+/PLm3jeS/tj5EtKafB7J9g9TN3oiIiIiInroLenkYJ7mljkDYN8xTYquxx7YtmYetEmFBizQbLXBk/C6a1+qgDY7nuYKSeAKAC7UNVpgkQThAABnnSTtPtgT34/uKwmeQwOWhGPPnjOTfEjZhXvMhoqUY6FdqJNsa3pGO6/zZ72vsy4prfHb+mDXVMA2lnAtKT5XIiIiIiKihbYkgbPpVC9MAAAPbKdlgtVxO+qckf/Gukv7/eg1R17LJPCOc9uNlmgAZ+6NHW+0XR95zVkXaVUus8Lvj6Zx9tzWsrlOoEfrh/FpxJgHnvJWjPr9ccf0BIIAgNBAdyRojm3jh/9UdCsXhscBIITRC8npns2HHvighLFLci0wodfvh7/LCKXkumfzMZqWNC3/kvNYyzI5fzo+9IjnNp0Sr88/itZycd8LoylbimPbftiK6BVFt43lWdwxZ/OWiIiIiIhoMS1Ri7MW9YnBagq+S2J4VN6Ktl2z03JpD88G3iOXM291Dl0eEVskTeiVjFdW7mqLBXKuS/NodTY3wLheTOMzs2Gc6WWjOKmYFoZoQH1rEiEAyl2dkcCvywhltPux3ORektZq7eFo0GiF3Ohr6XU3xPJx9jNIDl71aN2b5ohZn18LaywAh9gFO6G1OFF5K+qjP1KsN6LBLH1TEsRLt4MW1lMMnYmIiIiIaPEtWVftuGB1nx2jSVuEMHlL/G/SbNYqqKMtlmLLbSaCgWjApYYqPjUofkz8rxjQ5kKvVqV6Feoiub2kY3XTBZRKGF+eDQqjY64zXXIqdt3Rcc/iv1j36bEA4nNRjeL1C3f+uPHKmcz4nens5YnbFaljrdNERERERESLZQnHOEuDMRdsKcbA5gPfMUmwHO2unarltMwa360cQMoJwBZLrue/7YZFOl76VHxXbSIiIiIioofNkk4OhjLr7FjgJHKtwEEExGAzdStvaiq1GPQltbDKtW4vptnz6ttHxe7a8mJdu6UB9hzrYseuOzruOemffFfveZ1/KjDbPT6jceJZSCwXsXMREREREREtnqUNnAFo97am7V4bGyc8ZkOLZAIr37HoLNR6VG5RImkpozSUWyrFc7lQJ9kuNNASa/U1PbM8azXPjjMOwf1OYndmyXJV0uuTdE0OfJ6+zVl63d0Jy1fNlWcLcX6I5x6OBtfjPfJjnGUpUVEV/QFEWi58sGfSDZyIiIiIiGievrPkZ1xvRFv7SMrliiIt0i7UOcVxtc3xb5tOdcYm48r6XM46aJzxb+vbRxe2RXROYhA45hGXhrKl2S4ykZcrTbqlk34pv68G4EGkG7Ur0v27y4gGsw2elPkoMxFYDudPUmaACS64EFnyayFCW+WuBpiaPXAhdbkgIiIiIiJaTEve4gyIgVCa97SHU435jSz7lEuQq9zVGbfEUZTplB+d6YK/RaTc1ZnQXd2EXskY4Ogs3+nSHRkXLelqXVYfP35Y7JaeOh9N6PVn9uNDxudPooU1YT99+6ikm/cIRrNZUix6zKRx0ib0pkofERERERHRQhNyNI9difICgMzuk+nrQv/Rg4LxmU1CaWmpUFqqE6r/q1Xo+dN0/HbXOoTS0lKh49pipPa60FFaKjSem55707l8e0e4ea5F6PHN/1AxKy2PaMWZ616/frRULLttwui9dFtNC/0N4nZHr2d1/ulzjUJpaYcQ2yvpPhSP3dAvZFeCl7Lci2nM8trzw0OUN19dEbqODmZZzh4e2X7/vXetQ6iW3psPujs3hX5bz8OT3kxc6xBKSxuF/q/Ev1N8T4nUoZJtMsL6cSVLda8vS4szEYmm3LD8pA62s9eh0NWiobEBDS/osWZyBPaXtqHmLR/Cy53GbIUuwtHsxvT9BTreSswjymN98FxNU2Jvj2Ik5/kgEiz0fUiUId9pMxy37i13Mh4IMze6YW5wIbDcCclCaMQBW//0cidjcbF+pBwt/RhnIhKF4f3dEXigR+v/7oRRuv73/5iB92gNzF12nPsvvah9FOISYdblSuwyYR7RSqKHvtyDvo+8sJbroUh4N3R5BJ4faaG94cNcUzhmTwljlx/GBT8uESUJB+HtseHgW17MLHdaKCPKXZ3w71ruVNCDji3ORMtmBsEvwsDjlagoSnhrdSF0PzWhBBO4PiHOJD5uh0ajgV2crTw0YIFGY4c35EX3wR14UqOB5okK1LW5Ebgbf7jQVRea9jwJjUaDsq0WdF8NwXts7jXBZz5xo31fBcqix/5nF7xyO4zbodlqi0xXt08DjcYeCwBmPhmCPZpOzZPYcdCOoVtztRWvwDyiPKZGZZUeOOuBN6noBzH8ew/0z++On0Ni3A6NxgJ34twQ6V6Pvpd0H4orK8TKs/j3MS9CV7th2VoGjaYMFfva4f5kjq/692cwMdCOuq1l4v1ShyanF6E5W2/CCAy0w1wduc80T+2Auc2NCbnT3Q/B62ya3UdThgrjIXRfFW+ymRE0aTSo6U1u04vc/4cw9LXkWF2HsOOpyKoRT1Yfgv2DQHyPlbsBuNvMkm3MaB+YwMxc1zZXOpFtfdSNQ+KxntzTjpGpTFpwIytiWAYCCAy0o+4pMR37uyN10owPruh5n6pD+0D8tYdvDcF+sAYVT2jiPp+4tMnmT6RM1TkhToCqgSW6EkYGZSaaP57x7kjan9oB+9gMcio3y8z32yqY3/JBVXMCztcznY1lfp8fQl64/nn2s9E8UYGag90JzyP5vPQd04iT97pQl7CyypzPumiddHUITVvLoHmiAuazmbS1p6qLIuXefSsM3A9iqK0uUi6fqIClS1puonmW+NBN9zrSfk+JlL9onTqP+jGTvEopl3IeRuADOw4ZxXPF7kmxbDwo9eMKwsCZaNkoUapVAddGMJyqIt5Qi37/ODqq5Cax86DddBDeR03oONmJ1p8VY/KsDTXHvbHKLjxuR329HZ6/MqL1bSfa9hZieH892i/Jpy70wSEYjEfg+1492k464Xy9HkWfOmD+iQXuqTQ7bTDCaTehBIDhl044TxpRLKZhj7EJff+mh/VtJ5z2RpQE+9D0DzWwj8sFzyswjyivFT9dDUOq7tpfjGHwhh6VW4rnf5I092FKl9pRv38Y614+Dufbv0I1zsFm3APHjXT3ZQhDVgNq3vChaG8bnCedaNtbhECnGdsOuBGU+QIVGjiEHc1erKmyovOkE52H9Qj/0Yaahj4EU+4RhueNbTB3BqDc3QLnSSc6203YFB6Go74e3Z8AKCxH9c+AiT94E7rDhjB6wQM8Vw39WgBhH7p/ug3m03egP9wJ58lOWJ+5A7d1B2qORYd7hOD+xQ7YvGtgiG5THsa55ho0/j51CjNOZ8zc9dHMhSZsq3fgyn+oR8dJJ1oq76DrwBGM/JtMEiQC7x7EntN3YHjVic72WqiuOmButsFW2whPSSNOnOyA9fE76Guugf2yeNbP+mD+hya47+pwwO6E82QHmp9dA99ZG2peGxFbTefKn0LoLE5YqwBoTOg46UTD5kJkV2b6cOiAB7pXneg8bILhh4U5lJsHwBo9Dpy8iP7XK1G8Ortdc/r87nrQ/hMzHJ8qYXzVCefJTrS+sAnhEQfMpm5MiHk8V14W73Si44USAAZYTzrh3BmpOTJ/1nlxZH8XvvvycThfb8QenTrzC7/UjvpfeKF+5TicdiuevNMH2/4W2A7UoOfbarSd6ERrjQret8w4KHs/zmFR68fcvxfkUs4DvWbssLpxZ8sBHD/phNPejG1rfehrrkHLhZkHpH5cYRZywDQRzUImk4P9+02ha29kwqtNz+wRrG+eEQb/dFP48t9TbJsw8VVkIotSofH3X8Ztdv3optlJgr69KXQZSoVNP+8Xvvx2dpvIZCXSiYISJri4d0Vo+7tSYc/vJuPT8O2kcKa2VNh05IqQdn6jr/qFRukEXWIaShvi0yB8Oyn01JYKpbVnhC9THWcl5xGtOHPd65HJwTqE68IdYfC/lwqlraNx5ePLvj1iWYuUs9gEMImT2kQlvJ40OVjifZg0OVh0IrJqoeOaJCVi+Z29L+PL/b0/tQmbSvcIPZ8mpCdwRthTuklo+1O6Ui+e780rca/eu9QibHrmoDAYlGwTvfbpYaFtuy554p3Pzwh7ktJkFM4EJNuI19/muTebv3/XJozeiT/UPU/kes58Lskzb9wWwuivNgn6A4Pp66kM0zmv+sjbIWybc9I4sewYOoQrkvpx8rQx+bz3RoW20lJhkyNyvJu/Mwr67R3C9biP755w5YgkbRnmz/Wj8ZPQZVpmovnTckmaiEzKzdLK9vtv0r2ZVu6f3/Rwm1D9n5PriS/79kjqiczyMim9mT7rxOevMXG7OUXrokahX/J53vO0CaWlpcK2N6XP0knhzPOlQunPB1M/l2MSXk+sR5Pqx8TJwXKrH3P/XpBD/SjcFHqe1wvVR6/HH1NMQ3S7Za8fH2Kp7nW2OBMtp4ISNLg+xoVTrTDpFJg4346ml2pQ9YTYTWnOLkE6VP5YFfeKSq0DEMDkbQC3PDg3Bez+WTVUkl+9FWW1MG2WOewND/ruKlH8yDS8l72z/7zTCH8PCPd6MJHpNYppqK2LTwNWq2HcawBuuDH2mcz++ZBHlEcKoa80JHTXDmLsjz4Ydm7Dki+SWG5CfZlktPVqNQzP64EbHtxI0bXQN9aHsLIYimlvfLn/f2GsQxh9H6cr9YVQPaoA+h1wfBRASLx2xdOtGP/wOLYnDsUAAGUlmgevJC8d+WgJtACm796JHONxA3YXTMB9ebZNJXR5BJ6CWhg2KwAE4b3gA7Rr8M2f49Ptm1FADR8810LA36hQVAD0veWA57MQwvcBQAF9+zhGT2xHfC2SfToj5qiPvvBhOFV9tNkIkyZdAhI8q4euYPbPNQXrks+rUKNkMxD+JvJnyQv9GB20Qhs38F6B4hIdgDDuhJFz/mRXZvT4UYk0ETmUm4ddDp+fsrIZ5/81eblR1Q+0AKbxzV0g57zM8lmn+2EWrcxSmyuhk6RB8VeRclD5jE4yH4Qa6scB3F+iyeeyrB9z/16Qy2dTAtP7ozh/WBs/X4aiGCWPA7h7B2E8APXjCsPJwYiW22oFVGVGHCgz4gCA8EwQgbER9LzrgM3oReBUP6xlidMIRSnk7+I7dxCEDiXqxP1VKP4hgFupdwtNBQCE4G4zw51yiwCmQoA2k2/5d+8giBIUq5KvofB7RQCGEfwawAaZY6z0PKK8UvhjAwxogueqFfpyBfDZGNw3DKh/u3DpE/NYcVKwrvy+GoALN78Atse9GULwMwAhN9pfSl3qEZhCCNoUPwAooPunDhivNaF7/w50QwHlRj2q99bCWKmDWu7S74cxMxXAzWAAgWvX4b0wiGEA+EoMSBU6VP9Mgb4/eBGoU0MtdkNU7HKKgWAIgasA0I2Dl7tTJzsYBBQ6mNqN8DV3w1LdDRQoUbKlGrX/aMQ2nRqFc3W5nSudYj7I1kdfBzGBEhiT6st1WPf9Oc4f9Z1UdWHieb+LpNnpAIRnQpi6NYng5xPwXh3G4IgPgB7TfwGwPpf8ybzMpDaPcvOwmsfnh7szCH52E1OfB+C95sXwhWEAEJ+xueVlxs+6zK8wNQXw3VSvJ9wviqWMXLKqH+fzvWCe9WNoCpOTQUx+4oX30iBGxgGUT2MGgOJBqR9XCAbORA8YRaEKJc+Z0FGlheondeh+dwT1ZdtzaokKh+ezUJMerR8m/4L9IGAe0UNtrR6GKqBJnF176rIbE1X1kbFmDwwFFOm+CJW3YrTLmP39VlSJVvc4rJ95cXHQjaELHriah+F6I8Ws+QCAMCacFtQfi8xMrFhfAnWxGrq9RhjaXJGgVKT9+waonIPwflELtWIUI2MK7D6Z0BJj7oX/sPzXe1VVK/orrQh4L2Lw/BCGx1ywjbhw5OlW/NFhjO81k0M6c/cIHlmzIAdKbWoEtgNNcH8SBlAItUaF4v9UjT07w3Ccnd0st/xBRmUm7dxJWZebPHR3Aq6D9bBfngGggHKjGsU/0GHPLgPanZISmHNeZvCs+2LhLufBJ1M/5vq9IIfPJnjBhkPNbkzcBbBWjZL/WAzt3+/B7rADfZLtlrd+XFnYVZtoudzoxpMaDdrH0gRuq4sjLZ7z6JKkWLcOKngxEUg8RwiTaVpSAaBQWQTAg4lPF2CF5II1UGECk8HkY818NQVAB3W6B0y+5BHlGbG79h898IUD8P5hAoZKPdI3KgQQ+jr+lVBwgVaG/SqUtFxO6PMAgEqUJvW4LMS6IgBjE7g5j2JfuEEH4ysdcA5ewfhgM/R3PXjngxQdGP0uHDrmxaZf9uPK//Vj/MN+9J/sgHWXLjkA26jH7iIfBi8HY90Qq3XRr4VroNIA8E5ktp7u6kKotxhx4NdOnB8dx/kWPcIfvYOhdPVBNumcy1oVSlLWl1OY+nO2B8vUDIaOHYR7ZjdOXByH338F59/vx/EWEwypet1mlT8LU2aALMpNHpp47xDslzfB+v4V+P3jGHX3w/lrK3ZvTl0Cs8nLh+FZFwglrDsdmlqYtbOzqh8XJq8y/my+HsLRX7gxs/MELoz74f/X8+h//ziazYbkyc6Ws35cYRg4Ey2XjVpUFwB9v7HDk2JJmfAtNwYvACptae7jHh/TY3cRcO7sYPzMpZ8N49xY+t0Umw2oLQD6ehP2ux+Eu1GDJ/f1Zf5QEtOQfKwA3KeHgQ16bEr3K3e+5BHlncIfG2C4ew7D7w3D7d+O6vI0YXPBGqgQxERA8vXtfhCjH3gWJiEfuHFROtPr/Qm43/UAVRXQJSVJAd2ztVCgD33nE2ZRnXLDonkSdemWnwn74DBWYEdX/BdAxfoirEuTtNCnPgShQ+WzJXHdAGc+9uBc4sarS6B/XgXfR33oueCB6sVqaGP7qFG+Wwv4XXAnzGYevmpH1RMVaB+bQXjcgZqtO9Dtlx5XgaLvpUthDumcywYdqjck1yvhcTfO+NPvNj+TuHkBwLMGVBZJ2qDuB+AZmv28csufeZQZIKdyk39CuOkLApsrUamR3LT3Z+D9SFICc8zLB/tZp8CaIiA4EYgLcIMfDWJBasis6sd55FUun81nNzEMoLKqEnEjO255MJhYVyxj/bjSsKs20XJR6GDtNsG7zwXL1nNQllWierMKCoQRvDqIkfEQwhtM6H2hJPdzrC6B6X/WouclG2oaA7DW6bHuqyE4jg0iUCCzn0IH06t6nGu2YedPb8D6ynao7wYwPHACfZfVMJ3ajbTTfxT8NQoBjPT1QXdPh01bSmB604TBfTbsNAXwqxf1UN2dgPtdB4Y+UcN0qjb9sVZqHhGt1cNQFUbTcQfw3ImUX8IARH7Y2eCA47VG2MMN0K+dhqfXDs8jesiW+qT7MF0/Xw9s/2hG4LAJ+rVTGHrLDvdtPVq7t6dsAVfoTPjV0+dge20nav5sxYEqNWa+GIb7t33wbjChd2eaUq8ogf7pNeh+qx7m6YMwPquG8i8BDPXZ4S7Qo2NnCRI76ypLtFDDgSMHbPjmle1QPxLCxPkz6BqZxCMFQGKbTkn5bqiOO+CCCgdeic8d1U4rTKfr4KqvwMQrLWj420IErw2i770hTG9uhWlLIRTf6qEv6IajwYzp/2aE4VElQl8M4cwxNxRPd8C4MfWlZZtOeWrUtprg3pdYH7kXMTgpxqbnFHC9dxDmv25Bw98qEb7tQd9bfbj+zWwpUGgyyx/FGhUwdg49H6hg+JEW2lzLDJBhucl3SpQ+rgaOH8Gh177BgSo1FH+ZgPt0F0a+eASKaAnMMC8VBYUARnCmV4fw5k3QPTafZ50Pdk0dXBl0A85NCfTPq+E43oLG39xDQ/k6TH/sgv2SAnq5yfSS6sd0V5Bd/Zjz94Ic6kds2ITtBS64fmHGmlcboP2bMIIf98Fx9jrCKYb9LFf9uNIwcCZaRooyK85/qEffO31wez1wdUV+My3coEPl4Q40/ZMOynmOGVFsacZgzzq0t/bAtt8FxXo9Gt52Qumsg01mP9WuTlwscqHjrR7Y97sRRiHUW6rR6j4I48Z0E3EBKCxH/WE9GjvbYflAj47RTmwvs+KMuxRdnV2w73dhBoVQVzag819M0D8qcyys0DwiinbXvjCM7ZW69N20HbBMkQAABuhJREFUV5egweUE2trR02yBa60ahr0n0LMjiJaPRmQOn3gftqXerrwVzl0TcPzmEFy3H4G6sgHO/9UAXbrhE6tVMDouQvW7DjhO22HpDwNr1dBVtaL/kBElaX9sUkD78zPoXdcGx+kTaDo7A4j1gHMwzfk2NqCnB2hv7UH7frd4nj3oGjQgdLQCB69NIAjt7GyuGw0waRxo/8vu5C/NBVpY3z+P0k4Huk43wfx1ZCyy/kUnul4S65DVWhzo68W6Nxw489sm9H0NYK0ahhedOPGSTLfrDNOZcuKjVDlVZsUZtxonjjhwZL8LWK/F7lc7UX3BAnuGx8hOISpf70frmhY43m2C+W5kYqI9tn50rBtGzU+7MTEZBrZklj8lz1lRe6kZLqsZfY29GH9Fm2OZAXIqN3moxNwD5/12tJ9uh6U/8nys3tuFi5UhdFQchO/TIFCmyigvC8vrYX26EY43LBh6ugOjb29/oJ91s9dug+W9Qqgr63HCtR3BZg/S1pApvqfoUm2Xbf2IXL8X5FDO11ai7Uwr1rQ60G01I1ygRMmWPWh7vwPrRmpQ884EJsOAMnrK5aofV5hV4jpV2e+4ahVy3DXeuB2afS5wkh1aaVatWgUAC3OfLLgg3PVVsG10wv/LlI8LYh5RFhbsmbhkQnA3VsCGHCf6IspTD9+9vsym3DCfLYZzUVqcFwvrR0p9r3OMM9FKNjOCpqd2oOmDhC4+U16MXAX0P0iaQiL/MI+IiIgWReD/nEO4iKEnrQzsqk20khXqsO3HUzj4WiPwVT2MGyNj11zHXJGxZVV8mDGPiIiIFsH9CQxf06P516q5tyV6CCxui/O4HRqNJv7fMV9Gu4YGLEn7WgaiLUIhuBvTHO+2GxaNBhqNBW7JLLy+Y+mOlek5iR5Ghah88yKcL6oQON0C80tmWI55sGZXB/r7rNDKji3LF8wjIiKiBbe6BA0nGuYYx0708Fi8Mc6xscspSGfXSzHGOTRgQUVz6onk9e2j6NyllGxjQq/fiujIidjr5dFxCeI4hVTLykjSkck5ibLxYI9xJqKFxHGPRPmB9zpRfljSMc6+S2LQXN6KUb8ffr8fo+36yGvO7rjW4IQ90SMGsKZTkf38/lG0lkfe9VwYRQiAckslIkdzYXg8eV99VQWUAEIDLWLQrEfrh+LxTpkS0hHC6AUxaDb3iuf0o9csnrO5B5m1kxMREREREdFKs/iTg43ZUCF2p1bu6hSDUrnZs7WwioGrtQxid+8ULcbrK1ApBtOuS2JYOz6MSLiuR+UWJeID4obZc5bVi4G4ByOXE7piO+ti3bO1h6OB+2yLNhEREREREeWXRQuctXtbxRZhAM46ccywRaalWUI6Njpdd28oYXw52nI8DB+krdyVqFgPAEEEogF3LA2auEDcEwjGHwuAp7lC3M7OlmYiIiIiIqI8t3gtzuuN6JR2iwYAeGDbOkdAetsNiyRYjnTXnu2qHafMgMjRXRge92HYGXk52k07K2XW+O7k4nHrNBpoGt3gFGFERERERET5afG7aosBqd/vh//D1ti45O50s1VPBSCOcEZvtLt2WloYxHHIrne6ERD3a4hN5KWCOhpwS8Yux/1LWJB9tju5JOgfs6FnHERERERERJSHFilwliwXJW2tXV8MtfjfSBdpOZJJv8Z7Us+KDUD7TDS49UQCbrNBMh5ZiYqqFBOSxZas0sA+DgA+2FMtl1WkjnU3D3zONmciIiIiIqJ8tDzLUUmWnkpejsoHu6YO6facXWYqKn5706nEVmqZ40mOJbccVeKSV0SZ4HJURPmDS9QQ5Qfe60T5YUmXo4p00e6FKekNE3rnmlX7Q8nEYoisozzbbXoEo7fjt6+PjUs2wZDUtTsyS3d0aakYcy/8kgBcuatT0pVcorwVowyaiYiIiIiI8tbitTgT5Tm2OBPlDz4TifID73Wi/LC0Lc5EREREREREKwADZyIiIiIiIiIZDJyJiIiIiIiIZDBwJiIiIiIiIpLBwJmIiIiIiIhIBgNnIiIiIiIiIhkMnImIiIiIiIhkMHAmIiIiIiIiksHAmYiIiIiIiEgGA2ciIiIiIiIiGQyciYiIiIiIiGQwcCYiIiIiIiKSwcCZiIiIiIiISAYDZyIiIiIiIiIZDJyJiIiIiIiIZDBwJiIiIiIiIpLBwJmIiIiIiIhIBgNnIiIiIiIiIhkMnImIiIiIiIhkrBIEQchpx1WrFjotRERERERERMsuMUz+zkIdiIiIiIiIiGglYldtIiIiIiIiIhkMnImIiIiIiIhkMHAmIiIiIiIiksHAmYiIiIiIiEgGA2ciIiIiIiIiGQyciYiIiIiIiGQwcCYiIiIiIiKS8f8Bl5Whn6F5aC0AAAAASUVORK5CYII=" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>MS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集成电路设计</title>
    <link href="/Blogs/2025/08/28/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/Blogs/2025/08/28/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>[[电路分析与设计]] ：KCL和KVl定理，等效模型，在电路分析中绕不开</p><p>[[数字电路]] ：数字电路是处理010101，虽然处理的最小单元很简单，但是一个数字IC可能是有以亿计的简单单元，扛不住规模大，可以类比为需要无数的小学生 ‍ 攻克加减法的过程</p><p>[[模拟电路]] ：处理连续的光、声音、速度、温度等自然模拟信号的IC称之为模拟IC。模拟IC处理的信号都具有连续性，可以转换为正弦波研究，而数字IC处理的是非连续信号，都是脉冲方波。</p><p>[[3. ADC&amp;DAC]]</p>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>集成电路设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集成电路设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非平衡态动力学</title>
    <link href="/Blogs/2025/08/28/%E9%9D%9E%E5%B9%B3%E8%A1%A1%E6%80%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
    <url>/Blogs/2025/08/28/%E9%9D%9E%E5%B9%B3%E8%A1%A1%E6%80%81%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<ol><li><p>​<strong>​产生-复合​</strong>​</p><ul><li>​<strong>​直接产生​</strong>​：Gth​∝e−Eg​&#x2F;kT</li><li>​<strong>​SRH复合​</strong>​（间接）：缺陷能级作为复合中心</li><li>​<strong>​少子寿命 τ​</strong>​：δn(t)&#x3D;δn(0)e−t&#x2F;τ</li></ul></li><li><p>​<strong>​连续性方程​</strong>​<br> ∂t∂n​&#x3D;e1​∇⋅Jn​+(Gn​−Rn​)</p></li><li><p>​<strong>​准费米能级​</strong>​</p><ul><li>非平衡态：n&#x3D;ni​e (EFn​−Ei​)&#x2F;kT, p&#x3D;ni​e (Ei​−EFp​)&#x2F;kT</li></ul></li></ol><h2 id="非平衡过剩载流子excess-electrons"><a href="#非平衡过剩载流子excess-electrons" class="headerlink" title="非平衡过剩载流子excess electrons"></a>非平衡过剩载流子excess electrons</h2><p>计算需要使用Flux<br>    行为<br>        生成与复合过程<br>Generation and Recombination<br>            载流子的产生<br>                电子和空穴的生成created过程<br>                    热平衡中，由于获得足够的热能从价带跳到导带，我们有电子从共价键中分离出来。这会产生自由电子和自由空穴（生成<br>                生成率Generation Rate<br>                    单位时间内单位体积内的电子-空穴对的生成数<br>                产生原理<br>                    热产生<br>                        直接热产生<br>                            价带中的电子被直接激发到导带，在价带中留下空穴<br>                        间接热产生<br>R&#x2F;G center<br>                            由于硅晶格中的缺陷，在band gap中产生一些量子态，作为电子的中间跳板（从价带到导带）<br>                            主要改变载流子浓度的机制<br>                    光产生<br>                        足够能量的光子直接将价带激发到导带<br>            载流子的复合<br>                电子和空穴消失annihilated的过程<br>                    有些自由电子在遇到空穴时会失去一些热能并回落到共价键（复合）中<br>                复合率Recombination Rate<br>                    单位时间内单位体积内的电子-空穴对的复合数<br>            过剩载流子寿命Excess Carrier Lifetime<br>                过剩载流子存在的平均时间<br>        协同运动<br>Ambipolar Transport<br>            过剩电子和过剩空穴不会独立移动。它们具有相同的有效扩散系数、漂移迁移率和寿命。这种现象称为协同输运（Ambipolar Transport<br>    平衡关系对直接间带<br>        热平衡情况Thermal equilibrium<br>            在热平衡状态下，电子从价带跳到导带的速率（生成率）和电子从导带回到价带的速率（复合率<br>            电子和空穴成对出现<br>                Gn0,Gp0是电子和空穴的产生率<br>            成对消失<br>                Rn0,Rp0是电子和空穴的复合率<br>        非平衡下Non-equalibrium state<br>            Recombination rate<br>                外部激励（如光照）可以打破这种平衡，产生额外的电子-空穴对（过剩载流子<br>                    过剩载流子δn+原载流子<br>                        过剩载流子也会以相同的速率复合<br>                    复合速率与载流子(e,h)浓度成正比</p><pre><code class="hljs">                    thermal equilibrium generation rate</code></pre><p>热平衡载流子产生率<br>                        n0相对时间是恒定的，并且n(t) &#x3D;p(t)，导数主要受δn影响，推出<br>                Low-level injection低注入条件<br>（对n-type<br>                    不显著改变多子浓度，但显著改变少子浓度<br>                        过量载流子的数量远小于多数载流子浓度的热平衡值δn&lt;&lt;p0（对p-type），而且n0&lt;&lt;p0（对p-type，所以只有第一项重要<br>                    假设条件<br>将微分方程求解更简单<br>                        n-type<br>                        p-type<br>                        简化为<br>                            求解得<br>                            tn0过剩载流子的寿命<br>                    Carrier Recombination rate<br>                        对p型<br>                            空穴浓度变化率仅取决于少子<br>                            注意p型的话是tn0<br>                        对n型<br>                            注意n型的话是tp0<br>                    Indirect recombination rate<br>最终回到平衡态（以n type为例<br>                        通过陷阱的空穴复合速率<br>                        在low-level injection下，空穴产生率无明显影响<br>                        p的净变化率为<br>            Continuity Equations<br>连续性方程<br>                给出载流子如何运动以及载流子位置<br>                基础<br>                    考虑在一个微小体积内的粒子流入和流出的情况<br>                        Fpx是flux of particle<br>                    Flux of particle<br>                        一维<br>                        二维情况<br>                        三维情况<br>                    考虑盒子内可能发生的生成和重组的影响<br>                Time Dependent Diffusion Equations扩散方程<br>                    推导过程<br>                        Current density<br>                        particle flux<br>                        Continuity Equation<br>                        Use chain rule</p><pre><code class="hljs">                双极扩散</code></pre><p>Ambipolar diffusion<br>                        由于内部电子场会产生吸引电子和空穴的力，因此该电子场会将多余的电子和空穴的脉冲保持在一起。 然后，带负电的电子和带正电的空穴将以同一个有效迁移率或扩散系数一起漂移或扩散<br>                            电子空穴的复合率相同，且δn&#x3D;δp<br>                        推导</p><pre><code class="hljs">                        加起来消去E/X项                    参数                                                    推出                                                仅看电子，满足                            热平衡时有Quasi-Fermi Energy Level准费米能级    在非平衡状态下，电子和空穴分别具有不同的准费米能级 EFn和EFp    同理，费米能级为</code></pre>]]></content>
    
    
    <categories>
      
      <category>微电子知识体系</category>
      
      <category>半导体物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>非平衡态动力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学</title>
    <link href="/Blogs/2025/08/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    <url>/Blogs/2025/08/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>[[微积分]]</p><p>[[线性代数]]</p><p>[[概率与统计]]</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高等数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高等数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级搜索</title>
    <link href="/Blogs/2025/08/28/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/"/>
    <url>/Blogs/2025/08/28/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="高级操作符"><a href="#高级操作符" class="headerlink" title="高级操作符"></a>高级操作符</h1><ul><li>intitle, allintitle</li><li>inurl, allinurl</li><li>filetype</li><li>allintext</li><li>site</li><li>link</li><li>inanchor</li><li>daterange</li><li>cache</li><li>info</li><li>related</li><li>phonebook</li><li>rphonebooks</li><li>bphonebook</li><li>author</li><li>group</li><li>msgid</li><li>insubject</li><li>socks</li><li>define</li></ul><h2 id="谷歌搜索语法"><a href="#谷歌搜索语法" class="headerlink" title="谷歌搜索语法"></a>谷歌搜索语法</h2><p>1 . inurl:id&#x3D;1 中间不能有任何空格，如果有了空格就会把这个当成搜索条件来搜索了<br>2 . all操作符一般不能和别的高级操作符混用<br>3 . intitle:”index of” 这个查询将返回标题包含index of 的页面，也可以写成intitle:index.of 句号可以匹配任意的字符</p><h2 id="各个操作符的用法"><a href="#各个操作符的用法" class="headerlink" title="各个操作符的用法"></a>各个操作符的用法</h2><h3 id="intitle-allintitle-在页面标题中搜索"><a href="#intitle-allintitle-在页面标题中搜索" class="headerlink" title="intitle allintitle: 在页面标题中搜索"></a>intitle allintitle: 在页面标题中搜索</h3><p>intitile:cjk<br>alltitle: cjk 000</p><p>alltitle 后面不管加几个参数都可以，并不能和其他的高级操作符混用</p><h3 id="allintext-在网页内容中查找字符串"><a href="#allintext-在网页内容中查找字符串" class="headerlink" title="allintext:在网页内容中查找字符串"></a>allintext:在网页内容中查找字符串</h3><p>allintext: cjk 000<br>不能和其他的高级操作符混用</p><h3 id="inurl-allinurl-在url中查找文本"><a href="#inurl-allinurl-在url中查找文本" class="headerlink" title="inurl allinurl: 在url中查找文本"></a>inurl allinurl: 在url中查找文本</h3><p>url其实跟title差不多</p><h3 id="site-把搜索精确到特定的站点"><a href="#site-把搜索精确到特定的站点" class="headerlink" title="site:把搜索精确到特定的站点"></a>site:把搜索精确到特定的站点</h3><p>可以这样把所有的二级域名拿到<br>*这个是通配符可以匹配所有的字符串</p><h3 id="filetype-搜索指定类型的文件"><a href="#filetype-搜索指定类型的文件" class="headerlink" title="filetype:搜索指定类型的文件"></a>filetype:搜索指定类型的文件</h3><p>不仅仅可以搜索网页还可以搜索文件包括pdf和word文档</p><h3 id="numrange-搜索数字"><a href="#numrange-搜索数字" class="headerlink" title="numrange:搜索数字"></a>numrange:搜索数字</h3><p>numrange需要两个参数表示范围比如:numrange:1-12222<br>也可以1..12222这样来表示</p><h3 id="不常用的"><a href="#不常用的" class="headerlink" title="不常用的"></a>不常用的</h3><p> link:搜索与当前网页存在链接的的网页</p><p> inanchor: 在链接文本中查找文本</p><p> cache: 显示网页的缓存版本</p><p> related: 显示相关站点</p><p> daterange: 查找在某个特定日期范围内发布的网页</p><p> info: 显示Google的摘要信息</p><p> author: 搜索Groups中新闻组帖子的作者</p><p> Group: 搜索Group标题</p><p> Insubject: 搜索Google Group主题行</p><p> Msgid: 通过消息ID来查找Group帖子</p><p> Stocks: 搜索股票信息</p><p> Define: 显示某个术语定义</p><p> Phonebook: 搜索电话列表</p><hr><h1 id="谷歌-hacker-用法"><a href="#谷歌-hacker-用法" class="headerlink" title="谷歌 hacker 用法"></a>谷歌 hacker 用法</h1><h2 id="通过Google-hacking找注入点"><a href="#通过Google-hacking找注入点" class="headerlink" title="通过Google hacking找注入点"></a>通过Google hacking找注入点</h2><p>之前说的inurl:phpadmin都是小case<br>如果你喜欢拖库的话也可以inurl:id这样来找比较好找到注入点<br>当然这是最基础的</p><h2 id="通过Google-hacking来找到数据库挖掘"><a href="#通过Google-hacking来找到数据库挖掘" class="headerlink" title="通过Google hacking来找到数据库挖掘"></a>通过Google hacking来找到数据库挖掘</h2><table><thead><tr><th>查询</th><th>可能暴露的信息</th></tr></thead><tbody><tr><td>allinurl: admin mdb</td><td>管理数据库</td></tr><tr><td>inurl: backup filetype: mdb</td><td>备份数据库</td></tr><tr><td>inurl: login. asp</td><td>通过登录页面</td></tr><tr><td>inurl: “main. php” “phpMyAdmin” “running on”</td><td>phpMyAdmin</td></tr></tbody></table><h2 id="通过Google-hacking敏感文件"><a href="#通过Google-hacking敏感文件" class="headerlink" title="通过Google hacking敏感文件"></a>通过Google hacking敏感文件</h2><table><thead><tr><th>查询</th><th>说明</th></tr></thead><tbody><tr><td>filetype: log iserror. log</td><td>MS Install Shield日志</td></tr><tr><td>“admin account info” filetype: log</td><td>管理员日志</td></tr><tr><td>“Index of” “chat&#x2F;logs”</td><td>聊天日志</td></tr><tr><td>“your password is” filetype: log</td><td>口令日志</td></tr></tbody></table><h2 id="通过Google-hacking找配置文件"><a href="#通过Google-hacking找配置文件" class="headerlink" title="通过Google hacking找配置文件"></a>通过Google hacking找配置文件</h2><table><thead><tr><th>查询</th><th>说明</th></tr></thead><tbody><tr><td>intitle: index. of config. php</td><td>php配置文件</td></tr><tr><td>inurl: config. php dbuname dbpass</td><td>php配置文件</td></tr><tr><td>filetype: cnf my. cnf -cvs -example</td><td>MySQL配置文件</td></tr><tr><td>inurl:”putty. reg”</td><td>Putty已保存的会话数据</td></tr></tbody></table><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>作者：ckj123<br>链接：<a href="https://www.jianshu.com/p/c8380c98da88">https://www.jianshu.com/p/c8380c98da88</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>程序</category>
      
      <category>01素养</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
