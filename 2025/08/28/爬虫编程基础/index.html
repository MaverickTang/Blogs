

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/Blogs/img/fluid.png">
  <link rel="icon" href="/Blogs/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="唐浩天">
  <meta name="keywords" content="">
  
    <meta name="description" content="Urlib首先我们介绍一个 Python 库，叫做 urllib，利用它我们可以实现 HTTP 请求的发送，而不用去关心 HTTP 协议本身甚至更低层的实现。我们只需要指定请求的 URL、请求头、请求体等信息即可实现 HTTP 请求的发送，同时 urllib 还可以把服务器返回的响应转化为 Python 对象，通过该对象我们便可以方便地获取响应的相关信息了，如响应状态码、响应头、响应体等等。  注">
<meta property="og:type" content="article">
<meta property="og:title" content="爬虫编程基础">
<meta property="og:url" content="http://mavericreate.top/Blogs/2025/08/28/%E7%88%AC%E8%99%AB%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Mavericreate.Blog">
<meta property="og:description" content="Urlib首先我们介绍一个 Python 库，叫做 urllib，利用它我们可以实现 HTTP 请求的发送，而不用去关心 HTTP 协议本身甚至更低层的实现。我们只需要指定请求的 URL、请求头、请求体等信息即可实现 HTTP 请求的发送，同时 urllib 还可以把服务器返回的响应转化为 Python 对象，通过该对象我们便可以方便地获取响应的相关信息了，如响应状态码、响应头、响应体等等。  注">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.cuiqingcai.com/yqq2r.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/fries.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/1sfy2.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/vexbl.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/xfo4w.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/16oto.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/odrdk.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/3j50b.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/gyo9f.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/4cha6.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/lsdsz.png">
<meta property="og:image" content="https://cdn.cuiqingcai.com/ijr13.png">
<meta property="article:published_time" content="2025-08-28T07:00:00.000Z">
<meta property="article:modified_time" content="2025-08-28T13:30:31.902Z">
<meta property="article:author" content="唐浩天">
<meta property="article:tag" content="爬虫编程基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.cuiqingcai.com/yqq2r.png">
  
  
  
  <title>爬虫编程基础 - Mavericreate.Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/Blogs/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/Blogs/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/Blogs/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mavericreate.top","root":"/Blogs/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/Blogs/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/Blogs/js/utils.js" ></script>
  <script  src="/Blogs/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blogs/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blogs/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blogs/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blogs/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blogs/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blogs/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/Blogs/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="爬虫编程基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-28 00:00" pubdate>
          2025年8月28日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          196 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">爬虫编程基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Urlib"><a href="#Urlib" class="headerlink" title="Urlib"></a>Urlib</h1><p>首先我们介绍一个 Python 库，叫做 urllib，利用它我们可以实现 HTTP 请求的发送，而不用去关心 HTTP 协议本身甚至更低层的实现。我们只需要指定请求的 URL、请求头、请求体等信息即可实现 HTTP 请求的发送，同时 urllib 还可以把服务器返回的响应转化为 Python 对象，通过该对象我们便可以方便地获取响应的相关信息了，如响应状态码、响应头、响应体等等。</p>
<blockquote>
<p>注意：在 Python 2 中，有 urllib 和 urllib2 两个库来实现请求的发送。而在 Python 3 中，已经不存在 urllib2 这个库了，统一为 urllib，其官方文档链接为：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/urllib.html">https://docs.python.org/3/library/urllib.html</a>。</p>
</blockquote>
<p>首先，我们来了解一下 urllib 库的使用方法，它是 Python 内置的 HTTP 请求库，也就是说不需要额外安装即可使用。它包含如下 4 个模块。</p>
<ul>
<li><strong>request</strong>：它是最基本的 HTTP 请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入 URL 以及额外的参数，就可以模拟实现这个过程了。</li>
<li><strong>error</strong>：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。</li>
<li><strong>parse</strong>：一个工具模块，提供了许多 URL 处理方法，比如拆分、解析和合并等。</li>
<li><strong>robotparser</strong>：主要用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。</li>
</ul>
<h2 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1. 发送请求"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#1-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82" title="1. 发送请求"></a>1. 发送请求</h2><p>使用 urllib 的 request 模块，我们可以方便地实现请求的发送并得到响应。我们先来看下它的具体用法。</p>
<h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urlopen" title="urlopen"></a><code>urlopen</code></h3><p>urllib.request 模块提供了最基本的构造 HTTP 请求的方法，利用它可以模拟浏览器的一个请求发起过程，同时它还带有处理授权验证（Authentication）、重定向（Redirection)、浏览器 Cookie 以及其他内容。</p>
<p>下面我们来看一下它的强大之处。这里以 Python 官网为例，我们来把这个网页抓下来：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org</a>‘)  <br>print(response.read().decode(‘utf-8’))</td>
</tr>
</tbody></table>
<p>运行结果如图所示。</p>
<p><img src="https://cdn.cuiqingcai.com/yqq2r.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20200315212839610"></p>
<p>图 运行结果</p>
<p>这里我们只用了两行代码，便完成了 Python 官网的抓取，输出了网页的源代码。得到源代码之后呢？我们想要的链接、图片地址、文本信息不就都可以提取出来了吗？</p>
<p>接下来，看看它返回的到底是什么。利用 <code>type</code> 方法输出响应的类型：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org</a>‘)  <br>print(type(response))</td>
</tr>
</tbody></table>
<p>输出结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;class ‘http.client.HTTPResponse’&gt;</td>
</tr>
</tbody></table>
<p>可以发现，它是一个 <code>HTTPResposne</code> 类型的对象，主要包含 <code>read</code>、<code>readinto</code>、<code>getheader</code>、<code>getheaders</code>、<code>fileno</code> 等方法，以及 <code>msg</code>、<code>version</code>、<code>status</code>、<code>reason</code>、<code>debuglevel</code>、<code>closed</code> 等属性。</p>
<p>得到这个对象之后，我们把它赋值为 <code>response</code> 变量，然后就可以调用这些方法和属性，得到返回结果的一系列信息了。</p>
<p>例如，调用 <code>read</code> 方法可以得到返回的网页内容，调用 <code>status</code> 属性可以得到返回结果的状态码，如 200 代表请求成功，404 代表网页未找到等。</p>
<p>下面再通过一个实例来看看：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org</a>‘)  <br>print(response.status)  <br>print(response.getheaders())  <br>print(response.getheader(‘Server’))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>200  <br>[(‘Server’, ‘nginx’), (‘Content-Type’, ‘text&#x2F;html; charset&#x3D;utf-8’), (‘X-Frame-Options’, ‘DENY’), (‘Via’, ‘1.1 vegur’), (‘Via’, ‘1.1 varnish’), (‘Content-Length’, ‘48775’), (‘Accept-Ranges’, ‘bytes’), (‘Date’, ‘Sun, 15 Mar 2020 13:29:01 GMT’), (‘Via’, ‘1.1 varnish’), (‘Age’, ‘708’), (‘Connection’, ‘close’), (‘X-Served-By’, ‘cache-bwi5120-BWI, cache-tyo19943-TYO’), (‘X-Cache’, ‘HIT, HIT’), (‘X-Cache-Hits’, ‘2, 518’), (‘X-Timer’, ‘S1584278942.717942,VS0,VE0’), (‘Vary’, ‘Cookie’), (‘Strict-Transport-Security’, ‘max-age&#x3D;63072000; includeSubDomains’)]  <br>nginx</td>
</tr>
</tbody></table>
<p>可见，前两个输出分别输出了响应的状态码和响应的头信息，最后一个输出通过调用 <code>getheader</code> 方法并传递一个参数 <code>Server</code> 获取了响应头中的 <code>Server</code> 值，结果是 <code>nginx</code>，意思是服务器是用 Nginx 搭建的。</p>
<p>利用最基本的 <code>urlopen</code> 方法，可以完成最基本的简单网页的 GET 请求抓取。</p>
<p>如果想给链接传递一些参数，该怎么实现呢？首先看一下 <code>urlopen</code> 方法的 API：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>urllib.request.urlopen(url, data&#x3D;None, [timeout,]*, cafile&#x3D;None, capath&#x3D;None, cadefault&#x3D;False, context&#x3D;None)</td>
</tr>
</tbody></table>
<p>可以发现，除了第一个参数可以传递 URL 之外，我们还可以传递其他内容，比如 <code>data</code>（附加数据）、<code>timeout</code>（超时时间）等。</p>
<p>下面我们详细说明这几个参数的用法。</p>
<h4 id="data-参数"><a href="#data-参数" class="headerlink" title="data 参数"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#data-%E5%8F%82%E6%95%B0" title="data 参数"></a><code>data</code> 参数</h4><p><code>data</code> 参数是可选的。如果要添加该参数，需要使用 <code>bytes</code> 方法将参数转化为字节流编码格式的内容，即 <code>bytes</code> 类型。另外，如果传递了这个参数，则它的请求方式就不再是 GET 方式，而是 POST 方式。</p>
<p>下面用实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.parse  <br>import urllib.request  <br>  <br>data &#x3D; bytes(urllib.parse.urlencode({‘name’: ‘germey’}), encoding&#x3D;’utf-8’)  <br>response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>‘, data&#x3D;data)  <br>print(response.read().decode(‘utf-8’))</td>
</tr>
</tbody></table>
<p>这里我们传递了一个参数 <code>word</code>，值是 <code>hello</code>。它需要被转码成 <code>bytes</code>（字节流）类型。其中转字节流采用了 <code>bytes</code> 方法，该方法的第一个参数需要是 <code>str</code>（字符串）类型，需要用 <code>urllib.parse</code> 模块里的 <code>urlencode</code> 方法来将参数字典转化为字符串；第二个参数指定编码格式，这里指定为 <code>utf-8</code>。</p>
<p>这里请求的站点是 httpbin.org，它可以提供 HTTP 请求测试。本次我们请求的 URL 为 <a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>，这个链接可以用来测试 POST 请求，它可以输出 Request 的一些信息，其中就包含我们传递的 <code>data</code> 参数。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept-Encoding”: “identity”,  <br>    “Content-Length”: “11”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “Python-urllib&#x2F;3.7”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5ed27e43-9eee361fec88b7d3ce9be9db”  <br>  },  <br>  “json”: null,  <br>  “origin”: “17.220.233.154”,  <br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td>
</tr>
</tbody></table>
<p>我们传递的参数出现在了 <code>form</code> 字段中，这表明是模拟了表单提交的方式，以 POST 方式传输数据。</p>
<h4 id="timeout-参数"><a href="#timeout-参数" class="headerlink" title="timeout 参数"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#timeout-%E5%8F%82%E6%95%B0" title="timeout 参数"></a><code>timeout</code> 参数</h4><p><code>timeout</code> 参数用于设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。如果不指定该参数，就会使用全局默认时间。它支持 HTTP、HTTPS、FTP 请求。</p>
<p>下面用实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request  <br>  <br>response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;0.1)  <br>print(response.read())</td>
</tr>
</tbody></table>
<p>运行结果可能如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>During handling of the above exception, another exception occurred:  <br>Traceback (most recent call last): File “&#x2F;var&#x2F;py&#x2F;python&#x2F;urllibtest.py”, line 4, in <module> response &#x3D;  <br>urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;0.1)  <br>…  <br>urllib.error.URLError: <urlopen error _ssl.c:1059: The handshake operation timed out></td>
</tr>
</tbody></table>
<p>这里我们设置的超时时间是 1 秒。程序运行 1 秒过后，服务器依然没有响应，于是抛出了 <code>URLError</code> 异常。该异常属于 <code>urllib.error</code> 模块，错误原因是超时。</p>
<p>因此，可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。这可以利用 <code>try…except</code> 语句来实现，相关代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import socket  <br>import urllib.request  <br>import urllib.error  <br>  <br>try:  <br>    response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;0.1)  <br>except urllib.error.URLError as e:  <br>    if isinstance(e.reason, socket.timeout):  <br>        print(‘TIME OUT’)</td>
</tr>
</tbody></table>
<p>这里我们请求了 <a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a> 这个测试链接，设置的超时时间是 0.1 秒，然后捕获了 <code>URLError</code> 这个异常，然后判断异常类型是 <code>socket.timeout</code>，意思就是超时异常。因此，得出它确实是因为超时而报错，打印输出了 <code>TIME OUT</code>。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>TIME OUT</td>
</tr>
</tbody></table>
<p>按照常理来说，0.1 秒内基本不可能得到服务器响应，因此输出了 <code>TIME OUT</code> 的提示。</p>
<p>通过设置 <code>timeout</code> 这个参数来实现超时处理，有时还是很有用的。</p>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0" title="其他参数"></a>其他参数</h4><p>除了 <code>data</code> 参数和 <code>timeout</code> 参数外，还有 <code>context</code> 参数，它必须是 <code>ssl.SSLContext</code> 类型，用来指定 SSL 设置。</p>
<p>此外，<code>cafile</code> 和 <code>capath</code> 这两个参数分别指定 CA 证书和它的路径，这个在请求 HTTPS 链接时会有用。</p>
<p><code>cadefault</code> 参数现在已经弃用了，其默认值为 <code>False</code>。</p>
<p>前面讲解了 <code>urlopen</code> 方法的用法，通过这个最基本的方法，我们可以完成简单的请求和网页抓取。若需更加详细的信息，可以参见官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/urllib.request.html">https://docs.python.org/3/library/urllib.request.html</a>。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#Request" title="Request"></a><code>Request</code></h3><p>我们知道利用 <code>urlopen</code> 方法可以实现最基本请求的发起，但这几个简单的参数并不足以构建一个完整的请求。如果请求中需要加入 <code>Headers</code> 等信息，就可以利用更强大的 <code>Request</code> 类来构建。</p>
<p>首先，我们用实例来感受一下 <code>Request</code> 类的用法：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request  <br>  <br>request &#x3D; urllib.request.Request(‘<a target="_blank" rel="noopener" href="https://python.org/">https://python.org</a>‘)  <br>response &#x3D; urllib.request.urlopen(request)  <br>print(response.read().decode(‘utf-8’))</td>
</tr>
</tbody></table>
<p>可以发现，我们依然用 <code>urlopen</code> 方法来发送这个请求，只不过这次该方法的参数不再是 URL，而是一个 <code>Request</code> 类型的对象。通过构造这个数据结构，一方面我们可以将请求独立成一个对象，另一方面可更加丰富和灵活地配置参数。</p>
<p>下面我们看一下 <code>Request</code> 可以通过怎样的参数来构造，它的构造方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>class urllib.request.Request(url, data&#x3D;None, headers&#x3D;{}, origin_req_host&#x3D;None, unverifiable&#x3D;False, method&#x3D;None)</td>
</tr>
</tbody></table>
<p>其中，第一个参数 <code>url</code> 用于请求 URL，这是必传参数，其他都是可选参数。</p>
<p>第二个参数 <code>data</code> 如果要传，必须传 <code>bytes</code>（字节流）类型的。如果它是字典，可以先用 <code>urllib.parse</code> 模块里的 <code>urlencode()</code> 编码。</p>
<p>第三个参数 <code>headers</code> 是一个字典，它就是请求头。我们在构造请求时，既可以通过 <code>headers</code> 参数直接构造，也可以通过调用请求实例的 <code>add_header()</code> 方法添加。</p>
<p>添加请求头最常用的方法就是通过修改 <code>User-Agent</code> 来伪装浏览器。默认的 <code>User-Agent</code> 是 <code>Python-urllib</code>，我们可以通过修改它来伪装浏览器。比如要伪装火狐浏览器，你可以把它设置为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Mozilla&#x2F;5.0 (X11; U; Linux i686) Gecko&#x2F;20071127 Firefox&#x2F;2.0.0.11</td>
</tr>
</tbody></table>
<p>第四个参数 <code>origin_req_host</code> 指的是请求方的 host 名称或者 IP 地址。</p>
<p>第五个参数 <code>unverifiable</code> 表示这个请求是否是无法验证的，默认是 <code>False</code>，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 <code>unverifiable</code> 的值就是 <code>True</code>。</p>
<p>第六个参数 <code>method</code> 是一个字符串，用来指示请求使用的方法，比如 GET、POST 和 PUT 等。</p>
<p>下面我们传入多个参数来构建请求：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib import request, parse  <br>  <br>url &#x3D; ‘<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>‘  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)’,  <br>    ‘Host’: ‘httpbin.org’  <br>}  <br>dict &#x3D; {‘name’: ‘germey’}  <br>data &#x3D; bytes(parse.urlencode(dict), encoding&#x3D;’utf-8’)  <br>req &#x3D; request.Request(url&#x3D;url, data&#x3D;data, headers&#x3D;headers, method&#x3D;’POST’)  <br>response &#x3D; request.urlopen(req)  <br>print(response.read().decode(‘utf-8’))</td>
</tr>
</tbody></table>
<p>这里我们通过 4 个参数构造了一个请求，其中 <code>url</code> 即请求 URL，<code>headers</code> 中指定了 <code>User-Agent</code> 和 <code>Host</code>，参数 <code>data</code> 用 <code>urlencode</code> 和 <code>bytes</code> 方法转成字节流。另外，指定了请求方式为 POST。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept-Encoding”: “identity”,  <br>    “Content-Length”: “11”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5ed27f77-884f503a2aa6760df7679f05”  <br>  },  <br>  “json”: null,  <br>  “origin”: “17.220.233.154”,  <br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td>
</tr>
</tbody></table>
<p>观察结果可以发现，我们成功设置了 <code>data</code>、<code>headers</code> 和 <code>method</code>。</p>
<p>另外，<code>headers</code> 也可以用 <code>add_header</code> 方法来添加：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>req &#x3D; request.Request(url&#x3D;url, data&#x3D;data, method&#x3D;’POST’)  <br>req.add_header(‘User-Agent’, ‘Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)’)</td>
</tr>
</tbody></table>
<p>如此一来，我们就可以更加方便地构造请求，实现请求的发送啦。</p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" title="高级用法"></a>高级用法</h3><p>在上面的过程中，我们虽然可以构造请求，但是对于一些更高级的操作（比如 Cookies 处理、代理设置等），该怎么办呢？</p>
<p>接下来，就需要更强大的工具 Handler 登场了。简而言之，我们可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookie 的，有处理代理设置的。利用它们，我们几乎可以做到 HTTP 请求中所有的事情。</p>
<p>首先，介绍一下 <code>urllib.request</code> 模块里的 <code>BaseHandler</code> 类，它是所有其他 Handler 的父类，它提供了最基本的方法，例如 <code>default_open</code>、<code>protocol_request</code> 等。</p>
<p>接下来，就有各种 Handler 子类继承这个 <code>BaseHandler</code> 类，举例如下。</p>
<ul>
<li><code>HTTPDefaultErrorHandler</code> 用于处理 HTTP 响应错误，错误都会抛出 <code>HTTPError</code> 类型的异常。</li>
<li><code>HTTPRedirectHandler</code> 用于处理重定向。</li>
<li><code>HTTPCookieProcessor</code> 用于处理 Cookies。</li>
<li><code>ProxyHandler</code> 用于设置代理，默认代理为空。</li>
<li><code>HTTPPasswordMgr</code> 用于管理密码，它维护了用户名和密码的表。</li>
<li><code>HTTPBasicAuthHandler</code> 用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。</li>
</ul>
<p>另外，还有其他的 Handler 类，这里就不一一列举了，详情可以参考官方文档： <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler">https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler</a>。</p>
<p>关于怎么使用它们，现在先不用着急，后面会有实例演示。</p>
<p>另一个比较重要的类就是 <code>OpenerDirector</code>，我们可以称为 Opener。我们之前用过 <code>urlopen</code> 这个方法，实际上它就是 urllib 为我们提供的一个 Opener。</p>
<p>那么，为什么要引入 Opener 呢？因为需要实现更高级的功能。之前使用的 <code>Request</code> 和 <code>urlopen</code> 相当于类库为你封装好了极其常用的请求方法，利用它们可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以需要深入一层进行配置，使用更底层的实例来完成操作，所以这里就用到了 Opener。</p>
<p>Opener 可以使用 <code>open</code> 方法，返回的类型和 <code>urlopen</code> 如出一辙。那么，它和 Handler 有什么关系呢？简而言之，就是利用 Handler 来构建 Opener。</p>
<p>下面用几个实例来看看它们的用法。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#%E9%AA%8C%E8%AF%81" title="验证"></a>验证</h4><p>在访问某些设置了身份认证的网站时，例如 <a target="_blank" rel="noopener" href="https://ssr3.scrape.center/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AE%A4%E8%AF%81%E7%AA%97%E5%8F%A3%EF%BC%8C%E5%A6%82%E5%9B%BE">https://ssr3.scrape.center/，我们可能会遇到这样的认证窗口，如图</a> 2- 所示：</p>
<p><img src="https://cdn.cuiqingcai.com/fries.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704202140395"></p>
<p>图 2- 认证窗口</p>
<p>如果遇到了这种情况，那么这个网站就是启用了基本身份认证，英文叫作 HTTP Basic Access Authentication，它是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。</p>
<p>那么，如果要请求这样的页面，该怎么办呢？借助 <code>HTTPBasicAuthHandler</code> 就可以完成，相关代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.request import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener  <br>from urllib.error import URLError  <br>  <br>username &#x3D; ‘admin’  <br>password &#x3D; ‘admin’  <br>url &#x3D; ‘<a target="_blank" rel="noopener" href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>‘  <br>  <br>p &#x3D; HTTPPasswordMgrWithDefaultRealm()  <br>p.add_password(None, url, username, password)  <br>auth_handler &#x3D; HTTPBasicAuthHandler(p)  <br>opener &#x3D; build_opener(auth_handler)  <br>  <br>try:  <br>    result &#x3D; opener.open(url)  <br>    html &#x3D; result.read().decode(‘utf-8’)  <br>    print(html)  <br>except URLError as e:  <br>    print(e.reason)</td>
</tr>
</tbody></table>
<p>这里首先实例化 <code>HTTPBasicAuthHandler</code> 对象，其参数是 <code>HTTPPasswordMgrWithDefaultRealm</code> 对象，它利用 <code>add_password</code> 方法添加进去用户名和密码，这样就建立了一个处理验证的 Handler。</p>
<p>接下来，利用这个 Handler 并使用 <code>build_opener</code> 方法构建一个 Opener，这个 Opener 在发送请求时就相当于已经验证成功了。</p>
<p>接下来，利用 Opener 的 <code>open</code> 方法打开链接，就可以完成验证了。这里获取到的结果就是验证后的页面源码内容。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#%E4%BB%A3%E7%90%86" title="代理"></a>代理</h4><p>在做爬虫的时候，免不了要使用代理，如果要添加代理，可以这样做：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.error import URLError  <br>from urllib.request import ProxyHandler, build_opener  <br>  <br>proxy_handler &#x3D; ProxyHandler({  <br>    ‘http’: ‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>‘,  <br>    ‘https’: ‘<a target="_blank" rel="noopener" href="https://127.0.0.1:8080/">https://127.0.0.1:8080</a>‘  <br>})  <br>opener &#x3D; build_opener(proxy_handler)  <br>try:  <br>    response &#x3D; opener.open(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>    print(response.read().decode(‘utf-8’))  <br>except URLError as e:  <br>    print(e.reason)</td>
</tr>
</tbody></table>
<p>这里我们在本地需要先事先搭建一个 HTTP 代理，运行在 8080 端口上。</p>
<p>这里使用了 <code>ProxyHandler</code>，其参数是一个字典，键名是协议类型（比如 HTTP 或者 HTTPS 等），键值是代理链接，可以添加多个代理。</p>
<p>然后，利用这个 Handler 及 <code>build_opener</code> 方法构造一个 Opener，之后发送请求即可。</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#Cookie" title="Cookie"></a>Cookie</h4><p>Cookie 的处理就需要相关的 Handler 了。</p>
<p>我们先用实例来看看怎样将网站的 Cookie 获取下来，相关代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import http.cookiejar, urllib.request  <br>  <br>cookie &#x3D; http.cookiejar.CookieJar()  <br>handler &#x3D; urllib.request.HTTPCookieProcessor(cookie)  <br>opener &#x3D; urllib.request.build_opener(handler)  <br>response &#x3D; opener.open(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>for item in cookie:  <br>    print(item.name + “&#x3D;” + item.value)</td>
</tr>
</tbody></table>
<p>首先，我们必须声明一个 <code>CookieJar</code> 对象。接下来，就需要利用 <code>HTTPCookieProcessor</code> 来构建一个 Handler，最后利用 <code>build_opener</code> 方法构建出 Opener，执行 <code>open</code> 函数即可。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>BAIDUID&#x3D;A09E6C4E38753531B9FB4C60CE9FDFCB:FG&#x3D;1  <br>BIDUPSID&#x3D;A09E6C4E387535312F8AA46280C6C502  <br>H_PS_PSSID&#x3D;31358_1452_31325_21088_31110_31253_31605_31271_31463_30823  <br>PSTM&#x3D;1590854698  <br>BDSVRTM&#x3D;10  <br>BD_HOME&#x3D;1</td>
</tr>
</tbody></table>
<p>可以看到，这里输出了每个 Cookie 条目的名称和值。</p>
<p>不过既然能输出，那可不可以输出成文件格式呢？我们知道 Cookie 实际上也是以文本形式保存的。</p>
<p>答案当然是肯定的，这里通过下面的实例来看看：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request, http.cookiejar  <br>  <br>filename &#x3D; ‘cookie.txt’  <br>cookie &#x3D; http.cookiejar.MozillaCookieJar(filename)  <br>handler &#x3D; urllib.request.HTTPCookieProcessor(cookie)  <br>opener &#x3D; urllib.request.build_opener(handler)  <br>response &#x3D; opener.open(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>cookie.save(ignore_discard&#x3D;True, ignore_expires&#x3D;True)</td>
</tr>
</tbody></table>
<p>这时 <code>CookieJar</code> 就需要换成 <code>MozillaCookieJar</code>，它在生成文件时会用到，是 <code>CookieJar</code> 的子类，可以用来处理 Cookie 和文件相关的事件，比如读取和保存 Cookie，可以将 Cookie 保存成 Mozilla 型浏览器的 Cookie 格式。</p>
<p>运行之后，可以发现生成了一个 cookie.txt 文件，其内容如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td># Netscape HTTP Cookie File  <br># <a target="_blank" rel="noopener" href="http://curl.haxx.se/rfc/cookie_spec.html">http://curl.haxx.se/rfc/cookie_spec.html</a>  <br># This is a generated file!  Do not edit.  <br>  <br>.baidu.com	TRUE	&#x2F;	FALSE	1622390755	BAIDUID	0B4A68D74B0C0E53E5B82AFD9BF9178F:FG&#x3D;1  <br>.baidu.com	TRUE	&#x2F;	FALSE	3738338402	BIDUPSID	0B4A68D74B0C0E53471FA6329280FA58  <br>.baidu.com	TRUE	&#x2F;	FALSE		H_PS_PSSID	31262_1438_31325_21127_31110_31596_31673_31464_30823_26350  <br>.baidu.com	TRUE	&#x2F;	FALSE	3738338402	PSTM	1590854754  <br><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>	FALSE	&#x2F;	FALSE		BDSVRTM	0  <br><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>	FALSE	&#x2F;	FALSE		BD_HOME	1</td>
</tr>
</tbody></table>
<p>另外，<code>LWPCookieJar</code> 同样可以读取和保存 Cookie，但是保存的格式和 <code>MozillaCookieJar</code> 不一样，它会保存成 libwww-perl（LWP）格式的 Cookie 文件。</p>
<p>要保存成 LWP 格式的 Cookie 文件，可以在声明时就改为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>cookie &#x3D; http.cookiejar.LWPCookieJar(filename)</td>
</tr>
</tbody></table>
<p>此时生成的内容如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>#LWP-Cookies-2.0  <br>Set-Cookie3: BAIDUID&#x3D;”1F30EEDA35C7A94320275F991CA5B3A5:FG&#x3D;1”; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; expires&#x3D;”2021-05-30 16:06:39Z”; comment&#x3D;bd; version&#x3D;0  <br>Set-Cookie3: BIDUPSID&#x3D;1F30EEDA35C7A9433C97CF6245CBC383; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; expires&#x3D;”2088-06-17 19:20:46Z”; version&#x3D;0  <br>Set-Cookie3: H_PS_PSSID&#x3D;31626_1440_21124_31069_31254_31594_30841_31673_31464_31715_30823; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; discard; version&#x3D;0  <br>Set-Cookie3: PSTM&#x3D;1590854799; path&#x3D;”&#x2F;“; domain&#x3D;”.baidu.com”; path_spec; domain_dot; expires&#x3D;”2088-06-17 19:20:46Z”; version&#x3D;0  <br>Set-Cookie3: BDSVRTM&#x3D;11; path&#x3D;”&#x2F;“; domain&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“; path_spec; discard; version&#x3D;0  <br>Set-Cookie3: BD_HOME&#x3D;1; path&#x3D;”&#x2F;“; domain&#x3D;”<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>“; path_spec; discard; version&#x3D;0</td>
</tr>
</tbody></table>
<p>由此看来，生成的格式还是有比较大差异的。</p>
<p>那么，生成了 Cookie 文件后，怎样从文件中读取并利用呢？</p>
<p>下面我们以 <code>LWPCookieJar</code> 格式为例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import urllib.request, http.cookiejar  <br>  <br>cookie &#x3D; http.cookiejar.LWPCookieJar()  <br>cookie.load(‘cookie.txt’, ignore_discard&#x3D;True, ignore_expires&#x3D;True)  <br>handler &#x3D; urllib.request.HTTPCookieProcessor(cookie)  <br>opener &#x3D; urllib.request.build_opener(handler)  <br>response &#x3D; opener.open(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>print(response.read().decode(‘utf-8’))</td>
</tr>
</tbody></table>
<p>可以看到，这里调用 <code>load</code> 方法来读取本地的 Cookie 文件，获取到了 Cookie 的内容。不过前提是我们首先生成了 <code>LWPCookieJar</code> 格式的 Cookie，并保存成文件，然后读取 Cookie 之后使用同样的方法构建 Handler 和 Opener 即可完成操作。</p>
<p>运行结果正常的话，会输出百度网页的源代码。</p>
<p>通过上面的方法，我们可以实现绝大多数请求功能的设置了。</p>
<p>这便是 urllib 库中 request 模块的基本用法，如果想实现更多的功能，可以参考官方文档的说明：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/urllib.request.html#basehandler-objects">https://docs.python.org/3/library/urllib.request.html#basehandler-objects</a>。</p>
<h2 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2. 处理异常"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#2-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8" title="2. 处理异常"></a>2. 处理异常</h2><p>在前一节中，我们了解了请求的发送过程，但是在网络不好的情况下，如果出现了异常，该怎么办呢？这时如果不处理这些异常，程序很可能因报错而终止运行，所以异常处理还是十分有必要的。</p>
<p>urllib 的 error 模块定义了由 request 模块产生的异常。如果出现了问题，request 模块便会抛出 error 模块中定义的异常。</p>
<h3 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#URLError" title="URLError"></a><code>URLError</code></h3><p><code>URLError</code> 类来自 urllib 库的 error 模块，它继承自 <code>OSError</code> 类，是 error 异常模块的基类，由 request 模块产生的异常都可以通过捕获这个类来处理。</p>
<p>它具有一个属性 <code>reason</code>，即返回错误的原因。</p>
<p>下面用一个实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib import request, error  <br>  <br>try:  <br>    response &#x3D; request.urlopen(‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/404">https://cuiqingcai.com/404</a>‘)  <br>except error.URLError as e:  <br>    print(e.reason)</td>
</tr>
</tbody></table>
<p>我们打开一个不存在的页面，照理来说应该会报错，但是这时我们捕获了 <code>URLError</code> 这个异常，运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Not Found</td>
</tr>
</tbody></table>
<p>程序没有直接报错，而是输出了如上内容，这样就可以避免程序异常终止，同时异常得到了有效处理。</p>
<h3 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#HTTPError" title="HTTPError"></a><code>HTTPError</code></h3><p>它是 <code>URLError</code> 的子类，专门用来处理 HTTP 请求错误，比如认证请求失败等。它有如下 3 个属性。</p>
<ul>
<li><code>code</code>：返回 HTTP 状态码，比如 404 表示网页不存在，500 表示服务器内部错误等。</li>
<li><code>reason</code>：同父类一样，用于返回错误的原因。</li>
<li><code>headers</code>：返回请求头。</li>
</ul>
<p>下面我们用几个实例来看看：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib import request, error  <br>  <br>try:  <br>    response &#x3D; request.urlopen(‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/404">https://cuiqingcai.com/404</a>‘)  <br>except error.HTTPError as e:  <br>    print(e.reason, e.code, e.headers, sep&#x3D;’\n’)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Not Found  <br>404  <br>Server: nginx&#x2F;1.10.3 (Ubuntu)  <br>Date: Sat, 30 May 2020 16:08:42 GMT  <br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8  <br>Transfer-Encoding: chunked  <br>Connection: close  <br>Set-Cookie: PHPSESSID&#x3D;kp1a1b0o3a0pcf688kt73gc780; path&#x3D;&#x2F;  <br>Pragma: no-cache  <br>Vary: Cookie  <br>Expires: Wed, 11 Jan 1984 05:00:00 GMT  <br>Cache-Control: no-cache, must-revalidate, max-age&#x3D;0  <br>Link: <a target="_blank" rel="noopener" href="https://cuiqingcai.com/wp-json/">https://cuiqingcai.com/wp-json/</a>; rel&#x3D;”<a target="_blank" rel="noopener" href="https://api.w.org/">https://api.w.org/</a>“</td>
</tr>
</tbody></table>
<p>依然是同样的网址，这里捕获了 <code>HTTPError</code> 异常，输出了 <code>reason</code>、<code>code</code> 和 <code>headers</code> 属性。</p>
<p>因为 <code>URLError</code> 是 <code>HTTPError</code> 的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误，所以上述代码的更好写法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib import request, error  <br>  <br>try:  <br>    response &#x3D; request.urlopen(‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/404">https://cuiqingcai.com/404</a>‘)  <br>except error.HTTPError as e:  <br>    print(e.reason, e.code, e.headers, sep&#x3D;’\n’)  <br>except error.URLError as e:  <br>    print(e.reason)  <br>else:  <br>    print(‘Request Successfully’)</td>
</tr>
</tbody></table>
<p>这样就可以做到先捕获 <code>HTTPError</code>，获取它的错误原因、状态码、<code>headers</code> 等信息。如果不是 <code>HTTPError</code> 异常，就会捕获 <code>URLError</code> 异常，输出错误原因。最后，用 <code>else</code> 来处理正常的逻辑。这是一个较好的异常处理写法。</p>
<p>有时候，<code>reason</code> 属性返回的不一定是字符串，也可能是一个对象。再看下面的实例：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import socket  <br>import urllib.request  <br>import urllib.error  <br>  <br>try:  <br>    response &#x3D; urllib.request.urlopen(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘, timeout&#x3D;0.01)  <br>except urllib.error.URLError as e:  <br>    print(type(e.reason))  <br>    if isinstance(e.reason, socket.timeout):  <br>        print(‘TIME OUT’)</td>
</tr>
</tbody></table>
<p>这里我们直接设置超时时间来强制抛出 <code>timeout</code> 异常。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;class’socket.timeout’&gt;  <br>TIME OUT</td>
</tr>
</tbody></table>
<p>可以发现，<code>reason</code> 属性的结果是 <code>socket.timeout</code> 类。所以，这里我们可以用 <code>isinstance</code> 方法来判断它的类型，作出更详细的异常判断。</p>
<p>本节中，我们讲述了 error 模块的相关用法，通过合理地捕获异常可以做出更准确的异常判断，使程序更加稳健。</p>
<h2 id="3-解析链接"><a href="#3-解析链接" class="headerlink" title="3. 解析链接"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#3-%E8%A7%A3%E6%9E%90%E9%93%BE%E6%8E%A5" title="3. 解析链接"></a>3. 解析链接</h2><p>前面说过，urllib 库里还提供了 parse 模块，它定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取、合并以及链接转换。它支持如下协议的 URL 处理：<code>file</code>、<code>ftp</code>、<code>gopher</code>、<code>hdl</code>、<code>http</code>、<code>https</code>、<code>imap</code>、<code>mailto</code>、<code>mms</code>、<code>news</code>、<code>nntp</code>、<code>prospero</code>、<code>rsync</code>、<code>rtsp</code>、<code>rtspu</code>、<code>sftp</code>、<code>sip</code>、<code>sips</code>、<code>snews</code>、<code>svn</code>、<code>svn+ssh</code>、<code>telnet</code> 和 <code>wais</code>。本节中，我们介绍一下该模块中常用的方法来看一下它的便捷之处。</p>
<h3 id="urlparse"><a href="#urlparse" class="headerlink" title="urlparse"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urlparse" title="urlparse"></a><code>urlparse</code></h3><p>该方法可以实现 URL 的识别和分段，这里先用一个实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘)  <br>print(type(result))  <br>print(result)</td>
</tr>
</tbody></table>
<p>这里我们利用 <code>urlparse</code> 方法进行了一个 URL 的解析。首先，输出了解析结果的类型，然后将结果也输出出来。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;class ‘urllib.parse.ParseResult’&gt;  <br>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html’, params&#x3D;’user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td>
</tr>
</tbody></table>
<p>可以看到，返回结果是一个 <code>ParseResult</code> 类型的对象，它包含 6 个部分，分别是 <code>scheme</code>、<code>netloc</code>、<code>path</code>、<code>params</code>、<code>query</code> 和 <code>fragment</code>。</p>
<p>观察一下该实例的 URL：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a></td>
</tr>
</tbody></table>
<p>可以发现，<code>urlparse</code> 方法将其拆分成了 6 个部分。大体观察可以发现，解析时有特定的分隔符。比如，<code>://</code> 前面的就是 <code>scheme</code>，代表协议；第一个 <code>/</code> 符号前面便是 <code>netloc</code>，即域名，后面是 <code>path</code>，即访问路径；分号 <code>;</code> 后面是 <code>params</code>，代表参数；问号 <code>?</code> 后面是查询条件 <code>query</code>，一般用作 GET 类型的 URL；井号 <code>#</code> 后面是锚点，用于直接定位页面内部的下拉位置。</p>
<p>所以，可以得出一个标准的链接格式，具体如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>scheme:&#x2F;&#x2F;netloc&#x2F;path;params?query#fragment</td>
</tr>
</tbody></table>
<p>一个标准的 URL 都会符合这个规则，利用 <code>urlparse</code> 方法可以将它拆分开来。</p>
<p>除了这种最基本的解析方式外，<code>urlparse</code> 方法还有其他配置吗？接下来，看一下它的 API 用法：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>urllib.parse.urlparse(urlstring, scheme&#x3D;’’, allow_fragments&#x3D;True)</td>
</tr>
</tbody></table>
<p>可以看到，它有 3 个参数。</p>
<ul>
<li><code>urlstring</code>：这是必填项，即待解析的 URL。</li>
<li><code>scheme</code>：它是默认的协议（比如 <code>http</code> 或 <code>https</code> 等）。假如这个链接没有带协议信息，会将这个作为默认的协议。我们用实例来看一下：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html;user?id=5#comment">www.baidu.com/index.html;user?id=5#comment</a>‘, scheme&#x3D;’https’)  <br>print(result)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’’, path&#x3D;’<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html">www.baidu.com/index.html</a>‘, params&#x3D;’user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td>
</tr>
</tbody></table>
<p>可以发现，我们提供的 URL 没有包含最前面的 <code>scheme</code> 信息，但是通过默认的 <code>scheme</code> 参数，返回的结果是 <code>https</code>。</p>
<p>假设我们带上了 <code>scheme</code>：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>result &#x3D; urlparse(‘<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html;user?id=5#comment">http://www.baidu.com/index.html;user?id=5#comment</a>‘, scheme&#x3D;’https’)</td>
</tr>
</tbody></table>
<p>则结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>ParseResult(scheme&#x3D;’http’, netloc&#x3D;’<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html’, params&#x3D;’user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td>
</tr>
</tbody></table>
<p>可见，<code>scheme</code> 参数只有在 URL 中不包含 <code>scheme</code> 信息时才生效。如果 URL 中有 <code>scheme</code> 信息，就会返回解析出的 <code>scheme</code>。</p>
<ul>
<li><code>allow_fragments</code>：即是否忽略 <code>fragment</code>。如果它被设置为 <code>False</code>，<code>fragment</code> 部分就会被忽略，它会被解析为 <code>path</code>、<code>parameters</code> 或者 <code>query</code> 的一部分，而 <code>fragment</code> 部分为空。</li>
</ul>
<p>下面我们用实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘, allow_fragments&#x3D;False)  <br>print(result)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html’, params&#x3D;’user’, query&#x3D;’id&#x3D;5#comment’, fragment&#x3D;’’)</td>
</tr>
</tbody></table>
<p>假设 URL 中不包含 <code>params</code> 和 <code>query</code>，我们再通过实例看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/index.html#comment">https://www.baidu.com/index.html#comment</a>‘, allow_fragments&#x3D;False)  <br>print(result)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>ParseResult(scheme&#x3D;’https’, netloc&#x3D;’<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html#comment’, params&#x3D;’’, query&#x3D;’’, fragment&#x3D;’’)</td>
</tr>
</tbody></table>
<p>可以发现，当 URL 中不包含 <code>params</code> 和 <code>query</code> 时，<code>fragment</code> 便会被解析为 <code>path</code> 的一部分。</p>
<p>返回结果 <code>ParseResult</code> 实际上是一个元组，我们既可以用索引顺序来获取，也可以用属性名获取。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlparse  <br>  <br>result &#x3D; urlparse(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/index.html#comment">https://www.baidu.com/index.html#comment</a>‘, allow_fragments&#x3D;False)  <br>print(result.scheme, result[0], result.netloc, result[1], sep&#x3D;’\n’)</td>
</tr>
</tbody></table>
<p>这里我们分别用索引和属性名获取了 <code>scheme</code> 和 <code>netloc</code>，其运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>https  <br>https  <br><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>  <br><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></td>
</tr>
</tbody></table>
<p>可以发现，二者的结果是一致的，两种方法都可以成功获取。</p>
<h3 id="urlunparse"><a href="#urlunparse" class="headerlink" title="urlunparse"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urlunparse" title="urlunparse"></a><code>urlunparse</code></h3><p>有了 <code>urlparse</code> 方法，相应地就有了它的对立方法 <code>urlunparse</code>。它接收的参数是一个可迭代对象，但是它的长度必须是 6，否则会抛出参数数量不足或者过多的问题。先用一个实例看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlunparse  <br>  <br>data &#x3D; [‘https’, ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, ‘index.html’, ‘user’, ‘a&#x3D;6’, ‘comment’]  <br>print(urlunparse(data))</td>
</tr>
</tbody></table>
<p>这里参数 <code>data</code> 用了列表类型。当然，你也可以用其他类型，比如元组或者特定的数据结构。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/index.html;user?a=6#comment">https://www.baidu.com/index.html;user?a=6#comment</a></td>
</tr>
</tbody></table>
<p>这样我们就成功实现了 URL 的构造。</p>
<h3 id="urlsplit"><a href="#urlsplit" class="headerlink" title="urlsplit"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urlsplit" title="urlsplit"></a><code>urlsplit</code></h3><p>这个方法和 <code>urlparse</code> 方法非常相似，只不过它不再单独解析 <code>params</code> 这一部分，只返回 5 个结果。上面例子中的 <code>params</code> 会合并到 <code>path</code> 中。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlsplit  <br>  <br>result &#x3D; urlsplit(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘)  <br>print(result)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>SplitResult(scheme&#x3D;’https’, netloc&#x3D;’<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, path&#x3D;’&#x2F;index.html;user’, query&#x3D;’id&#x3D;5’, fragment&#x3D;’comment’)</td>
</tr>
</tbody></table>
<p>可以发现，返回结果是 <code>SplitResult</code>，它其实也是一个元组类型，既可以用属性获取值，也可以用索引来获取。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlsplit  <br>  <br>result &#x3D; urlsplit(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/index.html;user?id=5#comment">https://www.baidu.com/index.html;user?id=5#comment</a>‘)  <br>print(result.scheme, result[0])</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>https https</td>
</tr>
</tbody></table>
<h3 id="urlunsplit"><a href="#urlunsplit" class="headerlink" title="urlunsplit"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urlunsplit" title="urlunsplit"></a><code>urlunsplit</code></h3><p>与 <code>urlunparse</code> 方法类似，它也是将链接各个部分组合成完整链接的方法，传入的参数也是一个可迭代对象，例如列表、元组等，唯一的区别是长度必须为 5。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlunsplit  <br>  <br>data &#x3D; [‘https’, ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, ‘index.html’, ‘a&#x3D;6’, ‘comment’]  <br>print(urlunsplit(data))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/index.html?a=6#comment">https://www.baidu.com/index.html?a=6#comment</a></td>
</tr>
</tbody></table>
<h3 id="urljoin"><a href="#urljoin" class="headerlink" title="urljoin"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urljoin" title="urljoin"></a><code>urljoin</code></h3><p>有了 <code>urlunparse</code> 和 <code>urlunsplit</code> 方法，我们可以完成链接的合并，不过前提是必须要有特定长度的对象，链接的每一部分都要清晰分开。</p>
<p>此外，生成链接还有另一个方法，那就是 <code>urljoin</code> 方法。我们可以提供一个 <code>base_url</code>（基础链接）作为第一个参数，将新的链接作为第二个参数，该方法会分析 <code>base_url</code>的 <code>scheme</code>、<code>netloc</code> 和 <code>path</code> 这 3 个内容并对新链接缺失的部分进行补充，最后返回结果。</p>
<p>下面通过几个实例看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urljoin  <br>  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘, ‘FAQ.html’))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘, ‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>‘))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/about.html">https://www.baidu.com/about.html</a>‘, ‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>‘))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/about.html">https://www.baidu.com/about.html</a>‘, ‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/FAQ.html?question=2">https://cuiqingcai.com/FAQ.html?question=2</a>‘))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/?wd=abc">https://www.baidu.com?wd=abc</a>‘, ‘<a target="_blank" rel="noopener" href="https://cuiqingcai.com/index.php">https://cuiqingcai.com/index.php</a>‘))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘, ‘?category&#x3D;2#comment’))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘, ‘?category&#x3D;2#comment’))  <br>print(urljoin(‘<a target="_blank" rel="noopener" href="http://www.baidu.com/#comment">www.baidu.com#comment</a>‘, ‘?category&#x3D;2’))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/FAQ.html">https://www.baidu.com/FAQ.html</a>  <br><a target="_blank" rel="noopener" href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>  <br><a target="_blank" rel="noopener" href="https://cuiqingcai.com/FAQ.html">https://cuiqingcai.com/FAQ.html</a>  <br><a target="_blank" rel="noopener" href="https://cuiqingcai.com/FAQ.html?question=2">https://cuiqingcai.com/FAQ.html?question=2</a>  <br><a target="_blank" rel="noopener" href="https://cuiqingcai.com/index.php">https://cuiqingcai.com/index.php</a>  <br><a target="_blank" rel="noopener" href="https://www.baidu.com/?category=2#comment">https://www.baidu.com?category=2#comment</a>  <br><a target="_blank" rel="noopener" href="http://www.baidu.com/?category=2#comment">www.baidu.com?category=2#comment</a>  <br><a target="_blank" rel="noopener" href="http://www.baidu.com/?category=2">www.baidu.com?category=2</a></td>
</tr>
</tbody></table>
<p>可以发现，<code>base_url</code> 提供了三项内容 <code>scheme</code>、<code>netloc</code> 和 <code>path</code>。如果这 3 项在新的链接里不存在，就予以补充；如果新的链接存在，就使用新的链接的部分。而 <code>base_url</code> 中的 <code>params</code>、<code>query</code> 和 <code>fragment</code> 是不起作用的。</p>
<p>通过 <code>urljoin</code> 方法，我们可以轻松实现链接的解析、拼合与生成。</p>
<h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#urlencode" title="urlencode"></a><code>urlencode</code></h3><p>这里我们再介绍一个常用的方法 —— <code>urlencode</code>，它在构造 GET 请求参数的时候非常有用，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import urlencode  <br>  <br>params &#x3D; {  <br>    ‘name’: ‘germey’,  <br>    ‘age’: 25  <br>}  <br>base_url &#x3D; ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>?’  <br>url &#x3D; base_url + urlencode(params)  <br>print(url)</td>
</tr>
</tbody></table>
<p>这里首先声明一个字典来将参数表示出来，然后调用 <code>urlencode</code> 方法将其序列化为 GET 请求参数。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/?name=germey&age=25">https://www.baidu.com?name=germey&amp;age=25</a></td>
</tr>
</tbody></table>
<p>可以看到，参数成功地由字典类型转化为 GET 请求参数了。</p>
<p>这个方法非常常用。有时为了更加方便地构造参数，我们会事先用字典来表示。要转化为 URL 的参数时，只需要调用该方法即可。</p>
<h3 id="parse-qs"><a href="#parse-qs" class="headerlink" title="parse_qs"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#parse-qs" title="parse_qs"></a><code>parse_qs</code></h3><p>有了序列化，必然就有反序列化。如果我们有一串 GET 请求参数，利用 <code>parse_qs</code> 方法，就可以将它转回字典，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import parse_qs  <br>  <br>query &#x3D; ‘name&#x3D;germey&amp;age&#x3D;25’  <br>print(parse_qs(query))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{‘name’: [‘germey’], ‘age’: [‘25’]}</td>
</tr>
</tbody></table>
<p>可以看到，这样就成功转回为字典类型了。</p>
<h3 id="parse-qsl"><a href="#parse-qsl" class="headerlink" title="parse_qsl"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#parse-qsl" title="parse_qsl"></a><code>parse_qsl</code></h3><p>另外，还有一个 <code>parse_qsl</code> 方法，它用于将参数转化为元组组成的列表，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import parse_qsl  <br>  <br>query &#x3D; ‘name&#x3D;germey&amp;age&#x3D;25’  <br>print(parse_qsl(query))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>[(‘name’, ‘germey’), (‘age’, ‘25’)]</td>
</tr>
</tbody></table>
<p>可以看到，运行结果是一个列表，而列表中的每一个元素都是一个元组，元组的第一个内容是参数名，第二个内容是参数值。</p>
<h3 id="quote"><a href="#quote" class="headerlink" title="quote"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#quote" title="quote"></a><code>quote</code></h3><p>该方法可以将内容转化为 URL 编码的格式。URL 中带有中文参数时，有时可能会导致乱码的问题，此时可以用这个方法可以将中文字符转化为 URL 编码，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import quote  <br>  <br>keyword &#x3D; ‘壁纸’  <br>url &#x3D; ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=">https://www.baidu.com/s?wd=</a>‘ + quote(keyword)  <br>print(url)</td>
</tr>
</tbody></table>
<p>这里我们声明了一个中文的搜索文字，然后用 <code>quote</code> 方法对其进行 URL 编码，最后得到的结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</a></td>
</tr>
</tbody></table>
<h3 id="unquote"><a href="#unquote" class="headerlink" title="unquote"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#unquote" title="unquote"></a><code>unquote</code></h3><p>有了 <code>quote</code> 方法，当然还有 <code>unquote</code> 方法，它可以进行 URL 解码，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.parse import unquote  <br>  <br>url &#x3D; ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</a>‘  <br>print(unquote(url))</td>
</tr>
</tbody></table>
<p>这是上面得到的 URL 编码后的结果，这里利用 <code>unquote</code> 方法还原，结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8">https://www.baidu.com/s?wd=壁纸</a></td>
</tr>
</tbody></table>
<p>可以看到，利用 <code>unquote</code> 方法可以方便地实现解码。</p>
<p>本节中，我们介绍了 parse 模块的一些常用 URL 处理方法。有了这些方法，我们可以方便地实现 URL 的解析和构造，建议熟练掌握。</p>
<h2 id="4-分析-Robots-协议"><a href="#4-分析-Robots-协议" class="headerlink" title="4. 分析 Robots 协议"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#4-%E5%88%86%E6%9E%90-Robots-%E5%8D%8F%E8%AE%AE" title="4. 分析 Robots 协议"></a>4. 分析 Robots 协议</h2><p>利用 urllib 的 robotparser 模块，我们可以实现网站 Robots 协议的分析。本节中，我们来简单了解一下该模块的用法。</p>
<h3 id="1-Robots-协议"><a href="#1-Robots-协议" class="headerlink" title="1. Robots 协议"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#1-Robots-%E5%8D%8F%E8%AE%AE" title="1. Robots 协议"></a>1. Robots 协议</h3><p>Robots 协议也称作爬虫协议、机器人协议，它的全名叫作网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取。它通常是一个叫作 robots.txt 的文本文件，一般放在网站的根目录下。</p>
<p>当搜索爬虫访问一个站点时，它首先会检查这个站点根目录下是否存在 robots.txt 文件，如果存在，搜索爬虫会根据其中定义的爬取范围来爬取。如果没有找到这个文件，搜索爬虫便会访问所有可直接访问的页面。</p>
<p>下面我们看一个 robots.txt 的样例：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: *  <br>Disallow: &#x2F;  <br>Allow: &#x2F;public&#x2F;</td>
</tr>
</tbody></table>
<p>这实现了对所有搜索爬虫只允许爬取 public 目录的功能，将上述内容保存成 robots.txt 文件，放在网站的根目录下，和网站的入口文件（比如 index.php、index.html 和 index.jsp 等）放在一起。</p>
<p>上面的 <code>User-agent</code> 描述了搜索爬虫的名称，这里将其设置为 <code>*</code> 则代表该协议对任何爬取爬虫有效。比如，我们可以设置：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: Baiduspider</td>
</tr>
</tbody></table>
<p>这就代表我们设置的规则对百度爬虫是有效的。如果有多条 <code>User-agent</code> 记录，就有多个爬虫会受到爬取限制，但至少需要指定一条。</p>
<p><code>Disallow</code> 指定了不允许抓取的目录，比如上例子中设置为 <code>/</code> 则代表不允许抓取所有页面。</p>
<p><code>Allow</code> 一般和 <code>Disallow</code> 一起使用，一般不会单独使用，用来排除某些限制。上例中我们设置为 <code>/public/</code>，则表示所有页面不允许抓取，但可以抓取 public 目录。</p>
<p>下面我们再来看几个例子。禁止所有爬虫访问任何目录的代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: *  <br>Disallow: &#x2F;</td>
</tr>
</tbody></table>
<p>允许所有爬虫访问任何目录的代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: *  <br>Disallow:</td>
</tr>
</tbody></table>
<p>另外，直接把 robots.txt 文件留空也是可以的。</p>
<p>禁止所有爬虫访问网站某些目录的代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: *  <br>Disallow: &#x2F;private&#x2F;  <br>Disallow: &#x2F;tmp&#x2F;</td>
</tr>
</tbody></table>
<p>只允许某一个爬虫访问的代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: WebCrawler  <br>Disallow:  <br>User-agent: *  <br>Disallow: &#x2F;</td>
</tr>
</tbody></table>
<p>这些是 robots.txt 的一些常见写法。</p>
<h3 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#%E7%88%AC%E8%99%AB%E5%90%8D%E7%A7%B0" title="爬虫名称"></a>爬虫名称</h3><p>大家可能会疑惑，爬虫名是从哪儿来的？为什么就叫这个名？其实它是有固定名字的了，比如百度的就叫作 BaiduSpider。表 2- 列出了一些常见搜索爬虫的名称及对应的网站。</p>
<p>表 一些常见搜索爬虫的名称及其对应的网站</p>
<table>
<thead>
<tr>
<th>爬虫名称</th>
<th>名称</th>
<th>网站</th>
</tr>
</thead>
<tbody><tr>
<td>BaiduSpider</td>
<td>百度</td>
<td><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></td>
</tr>
<tr>
<td>Googlebot</td>
<td>谷歌</td>
<td><a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a></td>
</tr>
<tr>
<td>360Spider</td>
<td>360 搜索</td>
<td><a target="_blank" rel="noopener" href="http://www.so.com/">www.so.com</a></td>
</tr>
<tr>
<td>YodaoBot</td>
<td>有道</td>
<td><a target="_blank" rel="noopener" href="http://www.youdao.com/">www.youdao.com</a></td>
</tr>
<tr>
<td>ia_archiver</td>
<td>Alexa</td>
<td><a target="_blank" rel="noopener" href="http://www.alexa.cn/">www.alexa.cn</a></td>
</tr>
<tr>
<td>Scooter</td>
<td>altavista</td>
<td><a target="_blank" rel="noopener" href="http://www.altavista.com/">www.altavista.com</a></td>
</tr>
<tr>
<td>Bingbot</td>
<td>必应</td>
<td><a target="_blank" rel="noopener" href="http://www.bing.com/">www.bing.com</a></td>
</tr>
</tbody></table>
<h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#robotparser" title="robotparser"></a>robotparser</h3><p>了解 Robots 协议之后，我们就可以使用 robotparser 模块来解析 robots.txt 了。该模块提供了一个类 <code>RobotFileParser</code>，它可以根据某网站的 robots.txt 文件来判断一个爬虫是否有权限来爬取这个网页。</p>
<p>该类用起来非常简单，只需要在构造方法里传入 robots.txt 的链接即可。首先看一下它的声明：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>urllib.robotparser.RobotFileParser(url&#x3D;’’)</td>
</tr>
</tbody></table>
<p>当然，也可以在声明时不传入，默认为空，最后再使用 <code>set_url</code> 方法设置一下即可。</p>
<p>下面列出了这个类常用的几个方法。</p>
<ul>
<li><code>set_url</code>：用来设置 robots.txt 文件的链接。如果在创建 <code>RobotFileParser</code> 对象时传入了链接，那么就不需要再使用这个方法设置了。</li>
<li><code>read</code>：读取 robots.txt 文件并进行分析。注意，这个方法执行一个读取和分析操作，如果不调用这个方法，接下来的判断都会为 <code>False</code>，所以一定记得调用这个方法。这个方法不会返回任何内容，但是执行了读取操作。</li>
<li><code>parse</code>：用来解析 robots.txt 文件，传入的参数是 robots.txt 某些行的内容，它会按照 robots.txt 的语法规则来分析这些内容。</li>
<li><code>can_fetch</code>：该方法用两个参数，第一个是 <code>User-Agent</code>，第二个是要抓取的 URL。返回的内容是该搜索引擎是否可以抓取这个 URL，返回结果是 <code>True</code> 或 <code>False</code>。</li>
<li><code>mtime</code>：返回的是上次抓取和分析 robots.txt 的时间，这对于长时间分析和抓取的搜索爬虫是很有必要的，你可能需要定期检查来抓取最新的 robots.txt。</li>
<li><code>modified</code>：它同样对长时间分析和抓取的搜索爬虫很有帮助，将当前时间设置为上次抓取和分析 robots.txt 的时间。</li>
</ul>
<p>下面我们用实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.robotparser import RobotFileParser  <br>  <br>rp &#x3D; RobotFileParser()  <br>rp.set_url(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a>‘)  <br>rp.read()  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘))  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))  <br>print(rp.can_fetch(‘Googlebot’, ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))</td>
</tr>
</tbody></table>
<p>这里以百度为例，首先创建 <code>RobotFileParser</code> 对象，然后通过 <code>set_url</code> 方法设置了 robots.txt 的链接。当然，不用这个方法的话，可以在声明时直接用如下方法设置：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>rp &#x3D; RobotFileParser(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/robots.txt">https://www.baidu.com/robots.txt</a>‘)</td>
</tr>
</tbody></table>
<p>接着利用 <code>can_fetch</code> 方法判断网页是否可以被抓取。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>True  <br>True  <br>False</td>
</tr>
</tbody></table>
<p>这里同样可以使用 <code>parse</code> 方法执行读取和分析，示例如下：<br>可以看到这里我们利用 Baiduspider 可以抓取百度等首页以及 homepage 页面，但是 Googlebot 就不能抓取 homepage 页面。</p>
<p>打开百度的 robots.txt 文件看下，可以看到如下的信息：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>User-agent: Baiduspider  <br>Disallow: &#x2F;baidu  <br>Disallow: &#x2F;s?  <br>Disallow: &#x2F;ulink?  <br>Disallow: &#x2F;link?  <br>Disallow: &#x2F;home&#x2F;news&#x2F;data&#x2F;  <br>Disallow: &#x2F;bh  <br>  <br>User-agent: Googlebot  <br>Disallow: &#x2F;baidu  <br>Disallow: &#x2F;s?  <br>Disallow: &#x2F;shifen&#x2F;  <br>Disallow: &#x2F;homepage&#x2F;  <br>Disallow: &#x2F;cpro  <br>Disallow: &#x2F;ulink?  <br>Disallow: &#x2F;link?  <br>Disallow: &#x2F;home&#x2F;news&#x2F;data&#x2F;  <br>Disallow: &#x2F;bh</td>
</tr>
</tbody></table>
<p>由此我们可以看到，Baiduspider 没有限制 homepage 页面的抓取，而 Googlebot 则限制了 homepage 页面的抓取。</p>
<p>这里同样可以使用 parse 方法执行读取和分析，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from urllib.request import urlopen  <br>from urllib.robotparser import RobotFileParser  <br>  <br>rp &#x3D; RobotFileParser()  <br>rp.parse(urlopen(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/robots.txt').read().decode('utf-8').split('/n')">https://www.baidu.com/robots.txt&#39;).read().decode(&#39;utf-8&#39;).split(&#39;\n&#39;)</a>)  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘))  <br>print(rp.can_fetch(‘Baiduspider’, ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))  <br>print(rp.can_fetch(‘Googlebot’, ‘<a target="_blank" rel="noopener" href="https://www.baidu.com/homepage/">https://www.baidu.com/homepage/</a>‘))</td>
</tr>
</tbody></table>
<p>运行结果一样：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>True  <br>True  <br>False</td>
</tr>
</tbody></table>
<p>本节介绍了 robotparser 模块的基本用法和实例，利用它，我们可以方便地判断哪些页面可以抓取，哪些页面不可以抓取。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202221.html#5-%E6%80%BB%E7%BB%93" title="5. 总结"></a>5. 总结</h2><p>本节内容比较多，我们介绍了 urllib 的 request、error、parse、robotparser 模块的基本用法。这些是一些基础模块，其中有一些模块的实用性还是很强的，比如我们可以利用 parse 模块来进行 URL 的各种处理。</p>
<p>本节代码：<a target="_blank" rel="noopener" href="https://github.com/Python3WebSpider/UrllibTest">https://github.com/Python3WebSpider/UrllibTest</a>。</p>
<h1 id="Request库"><a href="#Request库" class="headerlink" title="Request库"></a>Request库</h1><p>上一节中，我们了解了 urllib 的基本用法，但是其中确实有不方便的地方，比如处理网页验证和 Cookie 时，需要写 Opener 和 Handler 来处理。另外我们要实现 POST、PUT 等请求时写法也不太方便。</p>
<p>为了更加方便地实现这些操作，就有了更为强大的库 requests，有了它，Cookie、登录验证、代理设置等操作都不是事儿。</p>
<p>接下来，让我们领略一下它的强大之处吧。</p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1. 准备工作"></a>1. 准备工作</h2><p>在开始之前，请确保已经正确安装好了 requests 库，如尚未安装可以使用 pip3 来安装：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>pip3 install requests</td>
</tr>
</tbody></table>
<p>更加详细的安装说明可以参考 <a target="_blank" rel="noopener" href="https://setup.scrape.center/requests%E3%80%82">https://setup.scrape.center/requests。</a></p>
<h2 id="2-实例引入"><a href="#2-实例引入" class="headerlink" title="2. 实例引入"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#2-%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5" title="2. 实例引入"></a>2. 实例引入</h2><p>urllib 库中的 urlopen 方法实际上是以 GET 方式请求网页，而 requests 中相应的方法就是 get 方法，是不是感觉表达更明确一些？下面通过实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a>‘)  <br>print(type(r))  <br>print(r.status_code)  <br>print(type(r.text))  <br>print(r.text[:100])  <br>print(r.cookies)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;class ‘requests.models.Response’&gt;  <br>200  <br>&lt;class ‘str’&gt;  <br><!DOCTYPE html>  <br><!--STATUS OK--><html> <head>&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;charse  <br>&lt;RequestsCookieJar[&lt;Cookie BDORZ&#x3D;27315 for .baidu.com&#x2F;&gt;]&gt;</td>
</tr>
</tbody></table>
<p>这里我们调用 get 方法实现与 urlopen 相同的操作，得到一个 Response 对象，然后分别输出了 Response 的类型、状态码、响应体的类型、内容以及 Cookie。</p>
<p>通过运行结果可以发现，它的返回类型是 <code>requests.models.Response</code>，响应体的类型是字符串 str，Cookie 的类型是 RequestsCookieJar。</p>
<p>使用 get 方法成功实现一个 GET 请求，这倒不算什么，更方便之处在于其他的请求类型依然可以用一句话来完成，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘)  <br>r &#x3D; requests.post(‘<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>‘)  <br>r &#x3D; requests.put(‘<a target="_blank" rel="noopener" href="https://httpbin.org/put">https://httpbin.org/put</a>‘)  <br>r &#x3D; requests.delete(‘<a target="_blank" rel="noopener" href="https://httpbin.org/delete">https://httpbin.org/delete</a>‘)  <br>r &#x3D; requests.patch(‘<a target="_blank" rel="noopener" href="https://httpbin.org/patch">https://httpbin.org/patch</a>‘)</td>
</tr>
</tbody></table>
<p>这里分别用 post、put、delete 等方法实现了 POST、PUT、DELETE 等请求。是不是比 urllib 简单太多了？</p>
<p>其实这只是冰山一角，更多的还在后面。</p>
<h2 id="3-GET-请求"><a href="#3-GET-请求" class="headerlink" title="3. GET 请求"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#3-GET-%E8%AF%B7%E6%B1%82" title="3. GET 请求"></a>3. GET 请求</h2><p>HTTP 中最常见的请求之一就是 GET 请求，下面首先来详细了解一下利用 requests 构建 GET 请求的方法。</p>
<h4 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B" title="基本实例"></a>基本实例</h4><p>首先，构建一个最简单的 GET 请求，请求的链接为 <a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>，该网站会判断如果客户端发起的是 GET 请求的话，它返回相应的请求信息：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {},  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.22.0”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e6e3a2e-6b1a28288d721c9e425a462a”  <br>  },  <br>  “origin”: “17.20.233.237”,  <br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>“  <br>}</td>
</tr>
</tbody></table>
<p>可以发现，我们成功发起了 GET 请求，返回结果中包含请求头、URL、IP 等信息。</p>
<p>那么，对于 GET 请求，如果要附加额外的信息，一般怎样添加呢？比如现在想添加两个参数，其中 name 是 germey，age 是 25，URL 就可以写成如下内容：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a target="_blank" rel="noopener" href="https://httpbin/get?name=germey&age=25">https://httpbin/get?name=germey&amp;age=25</a></td>
</tr>
</tbody></table>
<p>要构造这个请求链接，是不是要直接写成这样呢？</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get?name=germey&age=25">https://httpbin.org/get?name=germey&amp;age=25</a>‘)</td>
</tr>
</tbody></table>
<p>这样也可以，但是是不是有点不人性化呢？这些参数还需要我们手动去拼接，实现起来有点不优雅。</p>
<p>一般情况下，这种信息我们利用 params 这个参数就可以直接传递了，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>data &#x3D; {  <br>    ‘name’: ‘germey’,  <br>    ‘age’: 25  <br>}  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, params&#x3D;data)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {  <br>    “age”: “25”,  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.10.0”  <br>  },  <br>  “origin”: “122.4.215.33”,  <br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/get?age=22&name=germey">https://httpbin.org/get?age=22&amp;name=germey</a>“  <br>}</td>
</tr>
</tbody></table>
<p>在这里我们把 URL 参数通过一个字典的形式传给 get 方法的 params 参数，通过返回信息我们可以判断，请求的链接自动被构造成了：<a target="_blank" rel="noopener" href="https://httpbin.org/get?age=22&amp;name=germey">https://httpbin.org/get?age=22&name=germey</a>，这样我们就不用再去自己构造 URL 了，非常方便。</p>
<p>另外，网页的返回类型实际上是 str 类型，但是它很特殊，是 JSON 格式的。所以，如果想直接解析返回结果，得到一个 JSON 格式的数据的话，可以直接调用 json 方法。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘)  <br>print(type(r.text))  <br>print(r.json())  <br>print(type(r.json()))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;class’str’&gt;  <br>{‘headers’: {‘Accept-Encoding’: ‘gzip, deflate’, ‘Accept’: ‘<em>&#x2F;</em>‘, ‘Host’: ‘httpbin.org’, ‘User-Agent’: ‘python-requests&#x2F;2.10.0’}, ‘url’: ‘<a target="_blank" rel="noopener" href="http://httpbin.org/get">http://httpbin.org/get</a>‘, ‘args’: {}, ‘origin’: ‘182.33.248.131’}  <br>&lt;class ‘dict’&gt;</td>
</tr>
</tbody></table>
<p>可以发现，调用 json 方法，就可以将返回结果是 JSON 格式的字符串转化为字典。</p>
<p>但需要注意的是，如果返回结果不是 JSON 格式，便会出现解析错误，抛出 json.decoder.JSONDecodeError 异常。</p>
<h4 id="抓取网页"><a href="#抓取网页" class="headerlink" title="抓取网页"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5" title="抓取网页"></a>抓取网页</h4><p>上面的请求链接返回的是 JSON 形式的字符串，那么如果请求普通的网页，则肯定能获得相应的内容了。下面以一个实例页面 <a target="_blank" rel="noopener" href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a> 来试一下，我们再加上一点提取信息的逻辑，将代码完善成如下的样子：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>import re  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘)  <br>pattern &#x3D; re.compile(‘&lt;h2.<em>?&gt;(.</em>?)</h2>‘, re.S)  <br>titles &#x3D; re.findall(pattern, r.text)  <br>print(titles)</td>
</tr>
</tbody></table>
<p>在这个例子中我们用到了最基础的正则表达式来匹配出所有的问题内容。关于正则表达式的相关内容，我们会在下一节详细介绍，这里作为实例来配合讲解。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>[‘肖申克的救赎 - The Shawshank Redemption’, ‘霸王别姬 - Farewell My Concubine’, ‘泰坦尼克号 - Titanic’, ‘罗马假日 - Roman Holiday’, ‘这个杀手不太冷 - Léon’, ‘魂断蓝桥 - Waterloo Bridge’, ‘唐伯虎点秋香 - Flirting Scholar’, ‘喜剧之王 - The King of Comedy’, ‘楚门的世界 - The Truman Show’, ‘活着 - To Live’]</td>
</tr>
</tbody></table>
<p>我们发现，这里成功提取出了所有的电影标题，一个最基本的抓取和提取流程就完成了。</p>
<h4 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E6%8A%93%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE" title="抓取二进制数据"></a>抓取二进制数据</h4><p>在上面的例子中，我们抓取的是网站的一个页面，实际上它返回的是一个 HTML 文档。如果想抓取图片、音频、视频等文件，应该怎么办呢？</p>
<p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。所以，想要抓取它们，就要拿到它们的二进制数据。</p>
<p>下面以示例网站的站点图标为例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://scrape.center/favicon.ico">https://scrape.center/favicon.ico</a>‘)  <br>print(r.text)  <br>print(r.content)</td>
</tr>
</tbody></table>
<p>这里抓取的内容是站点图标，也就是在浏览器每一个标签上显示的小图标，如图所示：</p>
<p><img src="https://cdn.cuiqingcai.com/1sfy2.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704202919308"></p>
<p>这里打印了 Response 对象的两个属性，一个是 text，另一个是 content。</p>
<p>运行结果如图所示，分别是 r.text 和 r.content 的结果。</p>
<p><img src="https://cdn.cuiqingcai.com/vexbl.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704203039567"></p>
<p><img src="https://cdn.cuiqingcai.com/xfo4w.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704202959490"></p>
<p>可以注意到，前者出现了乱码，后者结果前带有一个 b，这代表是 bytes 类型的数据。由于图片是二进制数据，所以前者在打印时转化为 str 类型，也就是图片直接转化为字符串，这理所当然会出现乱码。</p>
<p>上面返回的结果我们并不能看懂，它实际上是图片的二进制数据，没关系，我们将刚才提取到的信息保存下来就好了，代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://scrape.center/favicon.ico">https://scrape.center/favicon.ico</a>‘)  <br>with open(‘favicon.ico’, ‘wb’) as f:  <br>    f.write(r.content)</td>
</tr>
</tbody></table>
<p>这里用了 open 方法，它的第一个参数是文件名称，第二个参数代表以二进制写的形式打开，可以向文件里写入二进制数据。</p>
<p>运行结束之后，可以发现在文件夹中出现了名为 favicon.ico 的图标，如图所示。</p>
<p><img src="https://cdn.cuiqingcai.com/16oto.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704203204899"></p>
<p>这样，我们就把二进制数据成功保存成一张图片了，这个小图标就被我们成功爬取下来了。</p>
<p>同样地，音频和视频文件我们也可以用这种方法获取。</p>
<h4 id="添加-headers"><a href="#添加-headers" class="headerlink" title="添加 headers"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E6%B7%BB%E5%8A%A0-headers" title="添加 headers"></a>添加 headers</h4><p>我们知道，在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，那么这个怎么来设置呢？</p>
<p>很简单，我们使用 headers 参数就可以完成了。</p>
<p>在刚才的实例中，实际上我们是没有设置 Request Headers 信息的，如果不设置，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p>
<p>要添加 Headers 信息，比如我们这里想添加一个 User-Agent 字段，我们可以这么来写：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;52.0.2743.116 Safari&#x2F;537.36’  <br>}  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘, headers&#x3D;headers)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>当然，我们可以在 headers 这个参数中任意添加其他的字段信息。</p>
<h2 id="4-POST-请求"><a href="#4-POST-请求" class="headerlink" title="4. POST 请求"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#4-POST-%E8%AF%B7%E6%B1%82" title="4. POST 请求"></a>4. POST 请求</h2><p>前面我们了解了最基本的 GET 请求，另外一种比较常见的请求方式是 POST。使用 requests 实现 POST 请求同样非常简单，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>data &#x3D; {‘name’: ‘germey’, ‘age’: ‘25’}  <br>r &#x3D; requests.post(“<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>“, data&#x3D;data)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>这里还是请求 <a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>，该网站可以判断如果请求是 POST 方式，就把相关请求信息返回。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “age”: “25”,  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Content-Length”: “18”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.22.0”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e6e3b52-0f36782ea980fce53c8c6524”  <br>  },  <br>  “json”: null,  <br>  “origin”: “17.20.232.237”,  <br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td>
</tr>
</tbody></table>
<p>可以发现，我们成功获得了返回结果，其中 form 部分就是提交的数据，这就证明 POST 请求成功发送了。</p>
<h2 id="5-响应"><a href="#5-响应" class="headerlink" title="5. 响应"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#5-%E5%93%8D%E5%BA%94" title="5. 响应"></a>5. 响应</h2><p>发送请求后，得到的自然就是响应。在上面的实例中，我们使用 text 和 content 获取了响应的内容。此外，还有很多属性和方法可以用来获取其他信息，比如状态码、响应头、Cookie 等。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘)  <br>print(type(r.status_code), r.status_code)  <br>print(type(r.headers), r.headers)  <br>print(type(r.cookies), r.cookies)  <br>print(type(r.url), r.url)  <br>print(type(r.history), r.history)</td>
</tr>
</tbody></table>
<p>这里分别打印输出 status_code 属性得到状态码，输出 headers 属性得到响应头，输出 cookies 属性得到 Cookie，输出 url 属性得到 URL，输出 history 属性得到请求历史。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;class ‘int’&gt; 200  <br>&lt;class ‘requests.structures.CaseInsensitiveDict’&gt; {‘Server’: ‘nginx&#x2F;1.17.8’, ‘Date’: ‘Sat, 30 May 2020 16:56:40 GMT’, ‘Content-Type’: ‘text&#x2F;html; charset&#x3D;utf-8’, ‘Transfer-Encoding’: ‘chunked’, ‘Connection’: ‘keep-alive’, ‘Vary’: ‘Accept-Encoding’, ‘X-Frame-Options’: ‘DENY’, ‘X-Content-Type-Options’: ‘nosniff’, ‘Strict-Transport-Security’: ‘max-age&#x3D;15724800; includeSubDomains’, ‘Content-Encoding’: ‘gzip’}  <br>&lt;class ‘requests.cookies.RequestsCookieJar’&gt; &lt;RequestsCookieJar[]&gt;  <br>&lt;class ‘str’&gt; <a target="_blank" rel="noopener" href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>  <br>&lt;class ‘list’&gt; []</td>
</tr>
</tbody></table>
<p>可以看到，headers 和 cookies 这两个属性得到的结果分别是 CaseInsensitiveDict 和 RequestsCookieJar 类型。</p>
<p>在第一章我们知道，状态码是用来表示响应状态的，比如返回 200 代表我们得到的响应是没问题的，上面的例子正好输出的结果也是 200，所以我们可以通过判断 Response 的状态码来知道爬取是否爬取成功。</p>
<p>requests 还提供了一个内置的状态码查询对象 requests.codes，用法示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a>‘)  <br>exit() if not r.status_code &#x3D;&#x3D; requests.codes.ok else print(‘Request Successfully’)</td>
</tr>
</tbody></table>
<p>这里通过比较返回码和内置的成功的返回码，来保证请求得到了正常响应，输出成功请求的消息，否则程序终止，这里我们用 requests.codes.ok 得到的是成功的状态码 200。</p>
<p>这样的话，我们就不用再在程序里面写状态吗对应的数字了，用字符串表示状态码会显得更加直观。</p>
<p>当然，肯定不能只有 ok 这个条件码。</p>
<p>下面列出了返回码和相应的查询条件：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td># 信息性状态码  <br>100: (‘continue’,),  <br>101: (‘switching_protocols’,),  <br>102: (‘processing’,),  <br>103: (‘checkpoint’,),  <br>122: (‘uri_too_long’, ‘request_uri_too_long’),  <br>  <br># 成功状态码  <br>200: (‘ok’, ‘okay’, ‘all_ok’, ‘all_okay’, ‘all_good’, ‘\o&#x2F;‘, ‘✓’),  <br>201: (‘created’,),  <br>202: (‘accepted’,),  <br>203: (‘non_authoritative_info’, ‘non_authoritative_information’),  <br>204: (‘no_content’,),  <br>205: (‘reset_content’, ‘reset’),  <br>206: (‘partial_content’, ‘partial’),  <br>207: (‘multi_status’, ‘multiple_status’, ‘multi_stati’, ‘multiple_stati’),  <br>208: (‘already_reported’,),  <br>226: (‘im_used’,),  <br>  <br># 重定向状态码  <br>300: (‘multiple_choices’,),  <br>301: (‘moved_permanently’, ‘moved’, ‘\o-‘),  <br>302: (‘found’,),  <br>303: (‘see_other’, ‘other’),  <br>304: (‘not_modified’,),  <br>305: (‘use_proxy’,),  <br>306: (‘switch_proxy’,),  <br>307: (‘temporary_redirect’, ‘temporary_moved’, ‘temporary’),  <br>308: (‘permanent_redirect’,  <br>      ‘resume_incomplete’, ‘resume’,), # These 2 to be removed in 3.0  <br>  <br># 客户端错误状态码  <br>400: (‘bad_request’, ‘bad’),  <br>401: (‘unauthorized’,),  <br>402: (‘payment_required’, ‘payment’),  <br>403: (‘forbidden’,),  <br>404: (‘not_found’, ‘-o-‘),  <br>405: (‘method_not_allowed’, ‘not_allowed’),  <br>406: (‘not_acceptable’,),  <br>407: (‘proxy_authentication_required’, ‘proxy_auth’, ‘proxy_authentication’),  <br>408: (‘request_timeout’, ‘timeout’),  <br>409: (‘conflict’,),  <br>410: (‘gone’,),  <br>411: (‘length_required’,),  <br>412: (‘precondition_failed’, ‘precondition’),  <br>413: (‘request_entity_too_large’,),  <br>414: (‘request_uri_too_large’,),  <br>415: (‘unsupported_media_type’, ‘unsupported_media’, ‘media_type’),  <br>416: (‘requested_range_not_satisfiable’, ‘requested_range’, ‘range_not_satisfiable’),  <br>417: (‘expectation_failed’,),  <br>418: (‘im_a_teapot’, ‘teapot’, ‘i_am_a_teapot’),  <br>421: (‘misdirected_request’,),  <br>422: (‘unprocessable_entity’, ‘unprocessable’),  <br>423: (‘locked’,),  <br>424: (‘failed_dependency’, ‘dependency’),  <br>425: (‘unordered_collection’, ‘unordered’),  <br>426: (‘upgrade_required’, ‘upgrade’),  <br>428: (‘precondition_required’, ‘precondition’),  <br>429: (‘too_many_requests’, ‘too_many’),  <br>431: (‘header_fields_too_large’, ‘fields_too_large’),  <br>444: (‘no_response’, ‘none’),  <br>449: (‘retry_with’, ‘retry’),  <br>450: (‘blocked_by_windows_parental_controls’, ‘parental_controls’),  <br>451: (‘unavailable_for_legal_reasons’, ‘legal_reasons’),  <br>499: (‘client_closed_request’,),  <br>  <br># 服务端错误状态码  <br>500: (‘internal_server_error’, ‘server_error’, ‘&#x2F;o\‘, ‘✗’),  <br>501: (‘not_implemented’,),  <br>502: (‘bad_gateway’,),  <br>503: (‘service_unavailable’, ‘unavailable’),  <br>504: (‘gateway_timeout’,),  <br>505: (‘http_version_not_supported’, ‘http_version’),  <br>506: (‘variant_also_negotiates’,),  <br>507: (‘insufficient_storage’,),  <br>509: (‘bandwidth_limit_exceeded’, ‘bandwidth’),  <br>510: (‘not_extended’,),  <br>511: (‘network_authentication_required’, ‘network_auth’, ‘network_authentication’)</td>
</tr>
</tbody></table>
<p>比如，如果想判断结果是不是 404 状态，可以用 <code>requests.codes.not_found</code> 来比对。</p>
<h2 id="6-高级用法"><a href="#6-高级用法" class="headerlink" title="6. 高级用法"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#6-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" title="6. 高级用法"></a>6. 高级用法</h2><p>前面我们了解了 requests 的基本用法，如基本的 GET、POST 请求以及 Response 对象。下面我们再来了解下 requests 的一些高级用法，如文件上传、Cookie 设置、代理设置等。</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0" title="文件上传"></a>文件上传</h3><p>我们知道 requests 可以模拟提交一些数据。假如有的网站需要上传文件，我们也可以用它来实现，这非常简单，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>files &#x3D; {‘file’: open(‘favicon.ico’, ‘rb’)}  <br>r &#x3D; requests.post(‘<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>‘, files&#x3D;files)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>在前一节中我们保存了一个文件 favicon.ico，这次用它来模拟文件上传的过程。需要注意的是，favicon.ico 需要和当前脚本在同一目录下。如果有其他文件，当然也可以使用其他文件来上传，更改下代码即可。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {  <br>    “file”: “data:application&#x2F;octet-stream;base64,AAABAAI…”  <br>  },  <br>  “form”: {},  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Content-Length”: “6665”,  <br>    “Content-Type”: “multipart&#x2F;form-data; boundary&#x3D;41fc691282cc894f8f06adabb24f05fb”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “python-requests&#x2F;2.22.0”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e6e3c0b-45b07bdd3a922e364793ef48”  <br>  },  <br>  “json”: null,  <br>  “origin”: “16.20.232.237”,  <br>  “url”: “<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>“  <br>}</td>
</tr>
</tbody></table>
<p>以上省略部分内容，这个网站会返回响应，里面包含 files 这个字段，而 form 字段是空的，这证明文件上传部分会单独有一个 files 字段来标识。</p>
<h3 id="Cookie-设置"><a href="#Cookie-设置" class="headerlink" title="Cookie 设置"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#Cookie-%E8%AE%BE%E7%BD%AE" title="Cookie 设置"></a>Cookie 设置</h3><p>前面我们使用 urllib 处理过 Cookie，写法比较复杂，而有了 requests，获取和设置 Cookie 只需一步即可完成。</p>
<p>我们先用一个实例看一下获取 Cookie 的过程：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a>‘)  <br>print(r.cookies)  <br>for key, value in r.cookies.items():  <br>    print(key + ‘&#x3D;’ + value)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;RequestsCookieJar[&lt;Cookie BDORZ&#x3D;27315 for .baidu.com&#x2F;&gt;]&gt;  <br>BDORZ&#x3D;27315</td>
</tr>
</tbody></table>
<p>这里我们首先调用 cookies 属性即可成功得到 Cookie，可以发现它是 RequestCookieJar 类型。然后用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 条目的名称和值，实现 Cookie 的遍历解析。</p>
<p>当然，我们也可以直接用 Cookie 来维持登录状态，下面我们以 GitHub 为例来说明一下，首先我们登录 GitHub，然后将 Headers 中的 Cookie 内容复制下来，如图所示。</p>
<p><img src="https://cdn.cuiqingcai.com/odrdk.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20200301214840166"></p>
<p>这里可以替换成你自己的 Cookie，将其设置到 Headers 里面，然后发送请求，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>headers &#x3D; {  <br>    ‘Cookie’: ‘_octo&#x3D;GH1.1.1849343058.1576602081; _ga&#x3D;GA1.2.90460451.1576602111; _<em>Host-user_session_same_site&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; <em>device_id&#x3D;a7ca73be0e8f1a81d1e2ebb5349f9075; user_session&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; logged_in&#x3D;yes; dotcom_user&#x3D;Germey; tz&#x3D;Asia%2FShanghai; has_recent_activity&#x3D;1; _gat&#x3D;1; _gh_sess&#x3D;your_session_info’,  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36’,  <br>}  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>‘, headers&#x3D;headers)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>我们发现，结果中包含了登录后才能包含的结果，如图所示：</p>
<p><img src="https://cdn.cuiqingcai.com/3j50b.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20200301215251376"></p>
<p>可以看到这里包含了我的 GitHub 用户名信息，你如果尝试之后同样可以得到你的用户信息。</p>
<p>得到这样类似的结果，就说明我们用 Cookie 就成功模拟了登录状态，这样我们就能爬取登录之后才能看到的页面了。</p>
<p>当然，我们也可以通过 cookies 参数来设置 Cookie 的信息，这里我们可以构造一个 RequestsCookieJar 对象，然后把刚才复制的 Cookie 处理下并赋值，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>cookies &#x3D; ‘_octo&#x3D;GH1.1.1849343058.1576602081; _ga&#x3D;GA1.2.90460451.1576602111; _<em>Host-user_session_same_site&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; <em>device_id&#x3D;a7ca73be0e8f1a81d1e2ebb5349f9075; user_session&#x3D;nbDv62kHNjp4N5KyQNYZ208waeqsmNgxFnFC88rnV7gTYQw</em>; logged_in&#x3D;yes; dotcom_user&#x3D;Germey; tz&#x3D;Asia%2FShanghai; has_recent_activity&#x3D;1; _gat&#x3D;1; _gh_sess&#x3D;your_session_info’  <br>jar &#x3D; requests.cookies.RequestsCookieJar()  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36’  <br>}  <br>for cookie in cookies.split(‘;’):  <br>    key, value &#x3D; cookie.split(‘&#x3D;’, 1)  <br>    jar.set(key, value)  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a>‘, cookies&#x3D;jar, headers&#x3D;headers)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>这里我们首先新建了一个 RequestCookieJar 对象，然后将复制下来的 cookies 利用 split 方法分割，接着利用 set 方法设置好每个 Cookie 的 key 和 value，然后通过调用 requests 的 get 方法并传递给 cookies 参数即可。</p>
<p>测试后，发现同样可以正常登录。</p>
<h3 id="Session-维持"><a href="#Session-维持" class="headerlink" title="Session 维持"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#Session-%E7%BB%B4%E6%8C%81" title="Session 维持"></a>Session 维持</h3><p>在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，也就是说相当于你用了两个浏览器打开了不同的页面。</p>
<p>设想这样一个场景，第一个请求利用 requests 的 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，又用了一次 requests 的 get 方法去请求个人信息页面。</p>
<p>实际上，这相当于打开了两个浏览器，是两个完全独立的操作，对应两个完全不相关的 Session，能成功获取个人信息吗？那当然不能。</p>
<p>有人可能说了，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来显得很烦琐，我们有更简单的解决方法。</p>
<p>其实解决这个问题的主要方法就是维持同一个 Session，也就是相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但是我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 —— Session 对象。</p>
<p>利用它，我们可以方便地维护一个 Session，而且不用担心 Cookie 的问题，它会帮我们自动处理好。</p>
<p>我们先做一个小实验吧，如果沿用之前的写法，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/cookies/set/number/123456789">https://httpbin.org/cookies/set/number/123456789</a>‘)  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/cookies">https://httpbin.org/cookies</a>‘)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>这里我们请求了一个测试网址 <a target="_blank" rel="noopener" href="https://httpbin.org/cookies/set/number/123456789">https://httpbin.org/cookies/set/number/123456789</a>。请求这个网址时，可以设置一个 Cookie 条目，名称叫作 number，内容是 123456789，随后又请求了 <a target="_blank" rel="noopener" href="https://httpbin.org/cookies">https://httpbin.org/cookies</a>，此网址可以获取当前的 Cookie 信息。</p>
<p>这样能成功获取到设置的 Cookie 吗？试试看。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “cookies”: {}  <br>}</td>
</tr>
</tbody></table>
<p>这并不行。</p>
<p>这时候，我们再用刚才所说的 Session 试试看：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>s &#x3D; requests.Session()  <br>s.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/cookies/set/number/123456789">https://httpbin.org/cookies/set/number/123456789</a>‘)  <br>r &#x3D; s.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/cookies">https://httpbin.org/cookies</a>‘)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>再看下运行结果：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “cookies”: {“number”: “123456789”}  <br>}</td>
</tr>
</tbody></table>
<p>这些可以看到 Cookies 被成功获取了！这下能体会到同一个会话和不同会话的区别了吧！</p>
<p>所以，利用 Session，可以做到模拟同一个会话而不用担心 Cookie 的问题。它通常用于模拟登录成功之后再进行下一步的操作。</p>
<p>Session 在平常用得非常广泛，可以用于模拟在一个浏览器中打开同一站点的不同页面，后面会有专门的章节来讲解这部分内容。</p>
<h3 id="SSL-证书验证"><a href="#SSL-证书验证" class="headerlink" title="SSL 证书验证"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#SSL-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81" title="SSL 证书验证"></a>SSL 证书验证</h3><p>现在很多网站都要求使用 HTTPS 协议，但是有些网站可能并没有设置好 HTTPS 证书，或者网站的 HTTPS 证书可能并不被 CA 机构认可，这时候，这些网站可能就会出现 SSL 证书错误的提示。</p>
<p>比如这个示例网站：<a target="_blank" rel="noopener" href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>，如果我们用 Chrome 浏览器打开这个 URL，则会提示「您的连接不是私密连接」这样的错误，如图所示：</p>
<p><img src="https://cdn.cuiqingcai.com/gyo9f.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704204017465"></p>
<p>我们可以在浏览器中通过一些设置来忽略证书的验证。</p>
<p>但是如果我们想用 requests 来请求这类网站，会遇到什么问题呢？我们用代码来试一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>response &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘)  <br>print(response.status_code)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>requests.exceptions.SSLError: HTTPSConnectionPool(host&#x3D;’ssr2.scrape.center’, port&#x3D;443): Max retries exceeded with url: &#x2F; (Caused by SSLError(SSLCertVerificationError(1, ‘[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)’)))</td>
</tr>
</tbody></table>
<p>可以看到，这里直接抛出了 SSLError 错误，原因就是因为我们请求的 URL 的证书是无效的。</p>
<p>那如果我们一定要爬取这个网站怎么办呢？我们可以使用 verify 参数控制是否验证证书，如果将其设置为 False，在请求时就不会再验证证书是否有效。如果不加 verify 参数的话，默认值是 True，会自动验证。</p>
<p>我们改写代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>response &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, verify&#x3D;False)  <br>print(response.status_code)</td>
</tr>
</tbody></table>
<p>这样就会打印出请求成功的状态码：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;urllib3&#x2F;connectionpool.py:857: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: <a target="_blank" rel="noopener" href="https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings">https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings</a>  <br>  InsecureRequestWarning)  <br>200</td>
</tr>
</tbody></table>
<p>不过我们发现报了一个警告，它建议我们给它指定证书。我们可以通过设置忽略警告的方式来屏蔽这个警告：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>from requests.packages import urllib3  <br>  <br>urllib3.disable_warnings()  <br>response &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, verify&#x3D;False)  <br>print(response.status_code)</td>
</tr>
</tbody></table>
<p>或者通过捕获警告到日志的方式忽略警告：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import logging  <br>import requests  <br>  <br>logging.captureWarnings(True)  <br>response &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, verify&#x3D;False)  <br>print(response.status_code)</td>
</tr>
</tbody></table>
<p>当然，我们也可以指定一个本地证书用作客户端证书，这可以是单个文件（包含密钥和证书）或一个包含两个文件路径的元组：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>response &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr2.scrape.center/">https://ssr2.scrape.center/</a>‘, cert&#x3D;(‘&#x2F;path&#x2F;server.crt’, ‘&#x2F;path&#x2F;server.key’))  <br>print(response.status_code)</td>
</tr>
</tbody></table>
<p>当然，上面的代码是演示实例，我们需要有 crt 和 key 文件，并且指定它们的路径。另外注意，本地私有证书的 key 必须是解密状态，加密状态的 key 是不支持的。</p>
<h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE" title="超时设置"></a>超时设置</h3><p>在本机网络状况不好或者服务器网络响应太慢甚至无响应时，我们可能会等待特别久的时间才可能收到响应，甚至到最后收不到响应而报错。为了防止服务器不能及时响应，应该设置一个超时时间，即超过了这个时间还没有得到响应，那就报错。这需要用到 timeout 参数。这个时间的计算是发出请求到服务器返回响应的时间。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;1)  <br>print(r.status_code)</td>
</tr>
</tbody></table>
<p>通过这样的方式，我们可以将超时时间设置为 1 秒，如果 1 秒内没有响应，那就抛出异常。</p>
<p>实际上，请求分为两个阶段，即连接（connect）和读取（read）。</p>
<p>上面设置的 timeout 将用作连接和读取这二者的 timeout 总和。</p>
<p>如果要分别指定，就可以传入一个元组：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;(5, 30))</td>
</tr>
</tbody></table>
<p>如果想永久等待，可以直接将 timeout 设置为 None，或者不设置直接留空，因为默认是 None。这样的话，如果服务器还在运行，但是响应特别慢，那就慢慢等吧，它永远不会返回超时错误的。其用法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, timeout&#x3D;None)</td>
</tr>
</tbody></table>
<p>或直接不加参数：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘)</td>
</tr>
</tbody></table>
<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81" title="身份认证"></a>身份认证</h3><p>在上一节我们讲到，在访问启用了基本身份认证的网站时，我们会首先遇到一个认证窗口，例如：<a target="_blank" rel="noopener" href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>，如图所示。</p>
<p><img src="https://cdn.cuiqingcai.com/4cha6.png" srcset="/Blogs/img/loading.gif" lazyload alt="image-20210704202140395"></p>
<p>这个网站就是启用了基本身份认证，在上一节中我们可以利用 urllib 来实现身份的校验，但实现起来相对繁琐。那在 reqeusts 中怎么做呢？当然也有办法。</p>
<p>我们可以使用 requests 自带的身份认证功能，通过 auth 参数即可设置，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>from requests.auth import HTTPBasicAuth  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>‘, auth&#x3D;HTTPBasicAuth(‘admin’, ‘admin’))  <br>print(r.status_code)</td>
</tr>
</tbody></table>
<p>这个示例网站的用户名和密码都是 admin，在这里我们可以直接设置。</p>
<p>如果用户名和密码正确的话，请求时就会自动认证成功，会返回 200 状态码；如果认证失败，则返回 401 状态码。</p>
<p>当然，如果参数都传一个 HTTPBasicAuth 类，就显得有点烦琐了，所以 requests 提供了一个更简单的写法，可以直接传一个元组，它会默认使用 HTTPBasicAuth 这个类来认证。</p>
<p>所以上面的代码可以直接简写如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>r &#x3D; requests.get(‘<a target="_blank" rel="noopener" href="https://ssr3.scrape.center/">https://ssr3.scrape.center/</a>‘, auth&#x3D;(‘admin’, ‘admin’))  <br>print(r.status_code)</td>
</tr>
</tbody></table>
<p>此外，requests 还提供了其他认证方式，如 OAuth 认证，不过此时需要安装 oauth 包，安装命令如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>pip3 install requests_oauthlib</td>
</tr>
</tbody></table>
<p>使用 OAuth1 认证的示例方法如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>from requests_oauthlib import OAuth1  <br>  <br>url &#x3D; ‘<a target="_blank" rel="noopener" href="https://api.twitter.com/1.1/account/verify_credentials.json">https://api.twitter.com/1.1/account/verify_credentials.json</a>‘  <br>auth &#x3D; OAuth1(‘YOUR_APP_KEY’, ‘YOUR_APP_SECRET’,  <br>              ‘USER_OAUTH_TOKEN’, ‘USER_OAUTH_TOKEN_SECRET’)  <br>requests.get(url, auth&#x3D;auth)</td>
</tr>
</tbody></table>
<p>更多详细的功能就可以参考 requests_oauthlib 的官方文档：<a target="_blank" rel="noopener" href="https://requests-oauthlib.readthedocs.org/">https://requests-oauthlib.readthedocs.org/</a>，在此就不再赘述了。</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE" title="代理设置"></a>代理设置</h3><p>对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模爬取，对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的 IP，导致一定时间段内无法访问。</p>
<p>那么，为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到 proxies 参数。可以用这样的方式设置：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>proxies &#x3D; {  <br>  ‘http’: ‘<a target="_blank" rel="noopener" href="http://10.10.10.10:1080/">http://10.10.10.10:1080</a>‘,  <br>  ‘https’: ‘<a target="_blank" rel="noopener" href="http://10.10.10.10:1080/">http://10.10.10.10:1080</a>‘,  <br>}  <br>requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, proxies&#x3D;proxies)</td>
</tr>
</tbody></table>
<p>当然，直接运行这个实例可能不行，因为这个代理可能是无效的，可以直接搜索寻找有效的代理并替换试验一下。</p>
<p>若代理需要使用上文所述的身份认证，可以使用类似 <a href="http://user:password@host:port">http://user:password@host:port</a> 这样的语法来设置代理，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>proxies &#x3D; {‘https’: ‘<a target="_blank" rel="noopener" href="http://user:password@10.10.10.10:1080/',%7D">http://user:password@10.10.10.10:1080/&#39;,}</a>  <br>requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, proxies&#x3D;proxies)</td>
</tr>
</tbody></table>
<p>除了基本的 HTTP 代理外，requests 还支持 SOCKS 协议的代理。</p>
<p>首先，需要安装 socks 这个库：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>pip3 install “requests[socks]”</td>
</tr>
</tbody></table>
<p>然后就可以使用 SOCKS 协议代理了，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import requests  <br>  <br>proxies &#x3D; {  <br>    ‘http’: ‘socks5:&#x2F;&#x2F;user:password@host:port’,  <br>    ‘https’: ‘socks5:&#x2F;&#x2F;user:password@host:port’  <br>}  <br>requests.get(‘<a target="_blank" rel="noopener" href="https://httpbin.org/get">https://httpbin.org/get</a>‘, proxies&#x3D;proxies)</td>
</tr>
</tbody></table>
<h3 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#Prepared-Request" title="Prepared Request"></a>Prepared Request</h3><p>我们使用 requests 库的 get 和 post 方法当然直接可以发送请求，但有没有想过，这个请求在 requests 内部是怎么实现的呢？</p>
<p>实际上，requests 在发送请求的时候，是在内部构造了一个 Request 对象，并给这个对象赋予了各种参数，包括 url、headers、data 等等，然后直接把这个 Request 对象发送出去，请求成功后会再得到一个 Response 对象，再解析即可。</p>
<p>那么这个 Request 是什么类型呢？实际上它就是 Prepared Request。</p>
<p>我们深入一下，不用 get 方法，直接构造一个 Prepared Request 对象来试试，代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>from requests import Request, Session  <br>  <br>url &#x3D; ‘<a target="_blank" rel="noopener" href="https://httpbin.org/post">https://httpbin.org/post</a>‘  <br>data &#x3D; {‘name’: ‘germey’}  <br>headers &#x3D; {  <br>    ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36’  <br>    }  <br>s &#x3D; Session()  <br>req &#x3D; Request(‘POST’, url, data&#x3D;data, headers&#x3D;headers)  <br>prepped &#x3D; s.prepare_request(req)  <br>r &#x3D; s.send(prepped)  <br>print(r.text)</td>
</tr>
</tbody></table>
<p>这里我们引入了 Request 这个类，然后用 url、data 和 headers 参数构造了一个 Request 对象，这时需要再调用 Session 的 prepare_request 方法将其转换为一个 Prepared Request 对象，然后调用 send 方法发送，运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>{  <br>  “args”: {},  <br>  “data”: “”,  <br>  “files”: {},  <br>  “form”: {  <br>    “name”: “germey”  <br>  },  <br>  “headers”: {  <br>    “Accept”: “<em>&#x2F;</em>“,  <br>    “Accept-Encoding”: “gzip, deflate”,  <br>    “Content-Length”: “11”,  <br>    “Content-Type”: “application&#x2F;x-www-form-urlencoded”,  <br>    “Host”: “httpbin.org”,  <br>    “User-Agent”: “Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.116 Safari&#x2F;537.36”,  <br>    “X-Amzn-Trace-Id”: “Root&#x3D;1-5e5bd6a9-6513c838f35b06a0751606d8”  <br>  },  <br>  “json”: null,  <br>  “origin”: “167.220.232.237”,  <br>  “url”: “<a target="_blank" rel="noopener" href="http://httpbin.org/post">http://httpbin.org/post</a>“  <br>}</td>
</tr>
</tbody></table>
<p>可以看到，我们达到了同样的 POST 请求效果。</p>
<p>有了 Request 这个对象，就可以将请求当作独立的对象来看待，这样在一些场景中我们可以直接操作这个 Request 对象，更灵活地实现请求的调度和各种操作。</p>
<p>更多的用法可以参考 requests 的官方文档：<a target="_blank" rel="noopener" href="http://docs.python-requests.org/">http://docs.python-requests.org/</a>。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202222.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>本节的 requests 库的基本用法就介绍到这里了，怎么样？有没有感觉它比 urllib 使用起来更为方便。本节内容需要好好掌握，在后文我们会在实战中使用 requests 完成一个网站的爬取，巩固 requests 的相关知识。</p>
<p>本节代码：<a target="_blank" rel="noopener" href="https://github.com/Python3WebSpider/RequestsTest%E3%80%82">https://github.com/Python3WebSpider/RequestsTest。</a></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>在上一节中，我们已经可以用 requests 来获取网页的源代码，得到 HTML 代码。但我们真正想要的数据是包含在 HTML 代码之中的，怎么才能从 HTML 代码中获取我们想要的信息呢？正则表达式就是其中一个有效的方法。</p>
<p>本节中，我们了解一下正则表达式的相关用法。正则表达式是处理字符串的强大工具，它有自己特定的语法结构，有了它，实现字符串的检索、替换、匹配验证都不在话下。</p>
<p>当然，对于爬虫来说，有了它，从 HTML 里提取想要的信息就非常方便了。</p>
<h3 id="1-实例引入"><a href="#1-实例引入" class="headerlink" title="1. 实例引入"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#1-%E5%AE%9E%E4%BE%8B%E5%BC%95%E5%85%A5" title="1. 实例引入"></a>1. 实例引入</h3><p>说了这么多，可能我们对它到底是个什么还是比较模糊，下面就用几个实例来看一下正则表达式的用法。</p>
<p>打开开源中国提供的正则表达式测试工具 <a target="_blank" rel="noopener" href="http://tool.oschina.net/regex/">http://tool.oschina.net/regex/</a>，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。例如，这里输入待匹配的文本，具体如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Hello, my phone number is 010-86432100 and email is <a href="mailto:&#x63;&#113;&#x63;&#x40;&#99;&#117;&#x69;&#113;&#x69;&#x6e;&#103;&#99;&#x61;&#x69;&#46;&#x63;&#111;&#x6d;">&#x63;&#113;&#x63;&#x40;&#99;&#117;&#x69;&#113;&#x69;&#x6e;&#103;&#99;&#x61;&#x69;&#46;&#x63;&#111;&#x6d;</a>, and my website is <a target="_blank" rel="noopener" href="https://cuiqingcai.com/">https://cuiqingcai.com</a></td>
</tr>
</tbody></table>
<p>这段字符串中包含了一个电话号码和一个电子邮件和一个 URL，接下来就尝试用正则表达式提取出来，如图所示。</p>
<p>在网页右侧选择「匹配 Email 地址」，就可以看到下方出现了文本中的 E-mail。</p>
<p><img src="https://cdn.cuiqingcai.com/lsdsz.png" srcset="/Blogs/img/loading.gif" lazyload></p>
<p>如果选择「匹配网址 URL」，就可以看到下方出现了文本中的 URL。</p>
<p>在网页右侧选择 “匹配 Email 地址”，就可以看到下方出现了文本中的 E-mail。如果选择 “匹配网址 URL”，就可以看到下方出现了文本中的 URL。是不是非常神奇？</p>
<p><img src="https://cdn.cuiqingcai.com/ijr13.png" srcset="/Blogs/img/loading.gif" lazyload></p>
<p>其实，这里就是用了正则表达式匹配，也就是用一定的规则将特定的文本提取出来。比如，电子邮件开头是一段字符串，然后是一个 <code>@</code> 符号，最后是某个域名，这是有特定的组成格式的。另外，对于 URL，开头是协议类型，然后是冒号加双斜线，最后是域名加路径。</p>
<p>对于 URL 来说，可以用下面的正则表达式匹配：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>[a-zA-z]+:&#x2F;&#x2F;[^\s]*</td>
</tr>
</tbody></table>
<p>用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似 URL 的文本，就会被提取出来。</p>
<p>这个正则表达式看上去是乱糟糟的一团，其实不然，这里面都是有特定的语法规则的。比如，<code>a-z</code> 代表匹配任意的小写字母，<code>\s</code> 表示匹配任意的空白字符，<code>*</code> 就代表匹配前面的字符任意多个，这一长串的正则表达式就是这么多匹配规则的组合。</p>
<p>写好正则表达式后，就可以拿它去一个长字符串里匹配查找了。不论这个字符串里面有什么，只要符合我们写的规则，统统可以找出来。对于网页来说，如果想找出网页源代码里有多少 URL，用匹配 URL 的正则表达式去匹配即可。</p>
<p>上面我们说了几个匹配规则，表 2- 列出了常用的匹配规则。</p>
<p>表 2- 常用的匹配规则</p>
<table>
<thead>
<tr>
<th>模　　式</th>
<th>描　　述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\w</code></td>
<td>匹配字母、数字及下划线</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配不是字母、数字及下划线的字符</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配任意数字，等价于 <code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td>
</tr>
<tr>
<td><code>\z</code></td>
<td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td>
</tr>
<tr>
<td><code>\G</code></td>
<td>匹配最后匹配完成的位置</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配一行字符串的开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配一行字符串的结尾</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意字符，除了换行符，当 <code>re.DOTALL</code> 标记被指定时，则可以匹配包括换行符的任意字符</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>用来表示一组字符，单独列出，比如 <code>[amk]</code> 匹配 <code>a</code>、<code>m</code> 或 <code>k</code></td>
</tr>
<tr>
<td><code>[^...]</code></td>
<td>不在 <code>[]</code> 中的字符，比如 匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 之外的字符</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配 0 个或多个表达式</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配 1 个或多个表达式</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>精确匹配 n 个前面的表达式</td>
</tr>
<tr>
<td><code>&#123;n, m&#125;</code></td>
<td>匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>&#96;a</td>
<td>b&#96;</td>
</tr>
<tr>
<td><code>()</code></td>
<td>匹配括号内的表达式，也表示一个组</td>
</tr>
</tbody></table>
<p>看完了之后，可能有点晕晕的吧，不过不用担心，后面我们会详细讲解一些常见规则的用法。</p>
<p>其实正则表达式不是 Python 独有的，它也可以用在其他编程语言中。Python 的 re 库提供了整个正则表达式的实现，利用这个库，可以在 Python 中使用正则表达式。在 Python 中写正则表达式几乎都用这个库，下面就来了解它的一些常用方法。</p>
<h2 id="2-match"><a href="#2-match" class="headerlink" title="2. match"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#2-match" title="2. match"></a>2. <code>match</code></h2><p>这里首先介绍第一个常用的匹配方法 —— <code>match</code>，向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p>
<p><code>match</code> 方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回 <code>None</code>。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘Hello 123 4567 World_This is a Regex Demo’  <br>print(len(content))  <br>result &#x3D; re.match(‘^Hello\s\d\d\d\s\d{4}\s\w{10}’, content)  <br>print(result)  <br>print(result.group())  <br>print(result.span())</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>41  <br>&lt;_sre.SRE_Match object; span&#x3D;(0, 25), match&#x3D;’Hello 123 4567 World_This’&gt;  <br>Hello 123 4567 World_This  <br>(0, 25)</td>
</tr>
</tbody></table>
<p>这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>^Hello\s\d\d\d\s\d{4}\s\w{10}</td>
</tr>
</tbody></table>
<p>用它来匹配这个长字符串。开头的 <code>^</code> 是匹配字符串的开头，也就是以 <code>Hello</code> 开头；然后 <code>\s</code> 匹配空白字符，用来匹配目标字符串的空格；<code>\d</code> 匹配数字，3 个 <code>\d</code> 匹配 <code>123</code>；然后再写 1 个 <code>\s</code> 匹配空格；后面还有 <code>4567</code>，我们其实可以依然用 4 个 <code>\d</code> 来匹配，但是这么写比较烦琐，所以后面可以跟 <code>&#123;4&#125;</code> 以代表匹配前面的规则 4 次，也就是匹配 4 个数字；后面再紧接 1 个空白字符，最后的 <code>\w&#123;10&#125;</code> 匹配 10 个字母及下划线。我们注意到，这里其实并没有把目标字符串匹配完，不过这样依然可以进行匹配，只不过匹配结果短一点而已。</p>
<p>而在 <code>match</code> 方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。</p>
<p>打印输出结果，可以看到结果是 <code>SRE_Match</code> 对象，这证明成功匹配。该对象有两个方法：<code>group</code> 方法可以输出匹配到的内容，结果是 <code>Hello 123 4567 World_This</code>，这恰好是正则表达式规则所匹配的内容；<code>span</code> 方法可以输出匹配的范围，结果是 <code>(0, 25)</code>，这就是匹配到的结果字符串在原字符串中的位置范围。</p>
<p>通过上面的例子，我们基本了解了如何在 Python 中使用正则表达式来匹配一段文字。</p>
<h3 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#%E5%8C%B9%E9%85%8D%E7%9B%AE%E6%A0%87" title="匹配目标"></a>匹配目标</h3><p>刚才我们用 <code>match</code> 方法得到匹配到的字符串内容，但是如果想从字符串中提取一部分内容，该怎么办呢？就像最前面的实例一样，从一段文本中提取出邮件或电话号码等内容。</p>
<p>这里可以使用括号 <code>()</code> 将想提取的子字符串括起来。<code>()</code> 实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用 <code>group</code> 方法传入分组的索引即可获取提取的结果。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘Hello 1234567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^Hello\s(\d+)\sWorld’, content)  <br>print(result)  <br>print(result.group())  <br>print(result.group(1))  <br>print(result.span())</td>
</tr>
</tbody></table>
<p>这里我们想把字符串中的 <code>1234567</code> 提取出来，此时可以将数字部分的正则表达式用 <code>()</code> 括起来，然后调用了 <code>group(1)</code> 获取匹配结果。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;_sre.SRE_Match object; span&#x3D;(0, 19), match&#x3D;’Hello 1234567 World’&gt;  <br>Hello 1234567 World  <br>1234567  <br>(0, 19)</td>
</tr>
</tbody></table>
<p>可以看到，我们成功得到了 <code>1234567</code>。这里用的是 <code>group(1)</code>，它与 <code>group()</code> 有所不同，后者会输出完整的匹配结果，而前者会输出第一个被 <code>()</code> 包围的匹配结果。假如正则表达式后面还有 <code>()</code> 包括的内容，那么可以依次用 <code>group(2)</code>、<code>group(3)</code> 等来获取。</p>
<h3 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#%E9%80%9A%E7%94%A8%E5%8C%B9%E9%85%8D" title="通用匹配"></a>通用匹配</h3><p>刚才我们写的正则表达式其实比较复杂，出现空白字符我们就写 <code>\s</code> 匹配，出现数字我们就用 <code>\d</code> 匹配，这样的工作量非常大。其实完全没必要这么做，因为还有一个万能匹配可以用，那就是 <code>.*</code>。其中 <code>.</code> 可以匹配任意字符（除换行符），<code>*</code> 代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符匹配了。</p>
<p>接着上面的例子，我们可以改写一下正则表达式：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘Hello 123 4567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^Hello.*Demo$’, content)  <br>print(result)  <br>print(result.group())  <br>print(result.span())</td>
</tr>
</tbody></table>
<p>这里我们将中间部分直接省略，全部用 <code>.*</code> 来代替，最后加一个结尾字符串就好了。运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;_sre.SRE_Match object; span&#x3D;(0, 41), match&#x3D;’Hello 123 4567 World_This is a Regex Demo’&gt;  <br>Hello 123 4567 World_This is a Regex Demo  <br>(0, 41)</td>
</tr>
</tbody></table>
<p>可以看到，<code>group</code> 方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容；<code>span</code> 方法输出 <code>(0, 41)</code>，这是整个字符串的长度。</p>
<p>因此，我们可以使用 <code>.*</code> 简化正则表达式的书写。</p>
<h3 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#%E8%B4%AA%E5%A9%AA%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA" title="贪婪与非贪婪"></a>贪婪与非贪婪</h3><p>使用上面的通用匹配 <code>.*</code> 时，可能有时候匹配到的并不是我们想要的结果。看下面的例子：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘Hello 1234567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^He.*(\d+).*Demo$’, content)  <br>print(result)  <br>print(result.group(1))</td>
</tr>
</tbody></table>
<p>这里我们依然想获取中间的数字，所以中间依然写的是 <code>(\d+)</code>。而数字两侧由于内容比较杂乱，所以想省略来写，都写成 <code>.*</code>。最后，组成 <code>^He.*(\d+).*Demo$</code>，看样子并没有什么问题。我们看下运行结果：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;_sre.SRE_Match object; span&#x3D;(0, 40), match&#x3D;’Hello 1234567 World_This is a Regex Demo’&gt;  <br>7</td>
</tr>
</tbody></table>
<p>奇怪的事情发生了，我们只得到了 7 这个数字，这是怎么回事呢？</p>
<p>这里就涉及贪婪匹配与非贪婪匹配的问题了。在贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符。正则表达式中 <code>.*</code> 后面是 <code>\d+</code>，也就是至少一个数字，并没有指定具体多少个数字，因此，<code>.*</code> 就尽可能匹配多的字符，这里就把 <code>123456</code> 匹配了，给 <code>\d+</code> 留下一个可满足条件的数字 7，最后得到的内容就只有数字 7 了。</p>
<p>但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是 <code>.*?</code>，多了一个 <code>?</code>，那么它可以达到怎样的效果？我们再用实例看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘Hello 1234567 World_This is a Regex Demo’  <br>result &#x3D; re.match(‘^He.*?(\d+).*Demo$’, content)  <br>print(result)  <br>print(result.group(1))</td>
</tr>
</tbody></table>
<p>这里我们只是将第一个<code>.*</code> 改成了 <code>.*?</code>，转变为非贪婪匹配。结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;_sre.SRE_Match object; span&#x3D;(0, 40), match&#x3D;’Hello 1234567 World_This is a Regex Demo’&gt;  <br>1234567</td>
</tr>
</tbody></table>
<p>此时就可以成功获取 <code>1234567</code> 了。原因可想而知，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当 <code>.*?</code> 匹配到 <code>Hello</code> 后面的空白字符时，再往后的字符就是数字了，而 <code>\d+</code> 恰好可以匹配，那么这里 <code>.*?</code> 就不再进行匹配，交给 <code>\d+</code> 去匹配后面的数字。所以这样 <code>.*?</code> 匹配了尽可能少的字符，<code>\d+</code> 的结果就是 <code>1234567</code>了。</p>
<p>所以说，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 <code>.*?</code> 来代替 <code>.*</code>，以免出现匹配结果缺失的情况。</p>
<p>但这里需要注意，如果匹配的结果在字符串结尾，<code>.*?</code> 就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘<a target="_blank" rel="noopener" href="http://weibo.com/comment/kEraCN">http://weibo.com/comment/kEraCN</a>‘  <br>result1 &#x3D; re.match(‘http.<em>?comment&#x2F;(.</em>?)’, content)  <br>result2 &#x3D; re.match(‘http.<em>?comment&#x2F;(.</em>)’, content)  <br>print(‘result1’, result1.group(1))  <br>print(‘result2’, result2.group(1))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>result1  <br>result2 kEraCN</td>
</tr>
</tbody></table>
<p>可以观察到，<code>.*?</code> 没有匹配到任何结果，而 <code>.*</code> 则尽量匹配多的内容，成功得到了匹配结果。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6" title="修饰符"></a>修饰符</h3><p>正则表达式可以包含一些可选标志修饰符来控制匹配模式。修饰符被指定为一个可选的标志。我们用实例来看一下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘’’Hello 1234567 World_This  <br>is a Regex Demo  <br>‘’’  <br>result &#x3D; re.match(‘^He.<em>?(\d+).</em>?Demo$’, content)  <br>print(result.group(1))</td>
</tr>
</tbody></table>
<p>和上面的例子相仿，我们在字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>AttributeError Traceback (most recent call last)  <br><ipython-input-18-c7d232b39645> in <module>()  <br>      5 ‘’’  <br>      6 result &#x3D; re.match(‘^He.<em>?(\d+).</em>?Demo$’, content)  <br>—-&gt; 7 print(result.group(1))  <br>  <br>AttributeError: ‘NoneType’ object has no attribute ‘group’</td>
</tr>
</tbody></table>
<p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为 <code>None</code>，而我们又调用了 <code>group</code> 方法导致 <code>AttributeError</code>。</p>
<p>那么，为什么加了一个换行符，就匹配不到了呢？这是因为。匹配的是除换行符之外的任意字符，当遇到换行符时，<code>.*?</code> 就不能匹配了，所以导致匹配失败。这里只需加一个修饰符 <code>re.S</code>，即可修正这个错误：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>result &#x3D; re.match(‘^He.<em>?(\d+).</em>?Demo$’, content, re.S)</td>
</tr>
</tbody></table>
<p>这个修饰符的作用是使。匹配包括换行符在内的所有字符。此时运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1234567</td>
</tr>
</tbody></table>
<p>这个 <code>re.S</code> 在网页匹配中经常用到。因为 HTML 节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p>
<p>另外，还有一些修饰符，在必要的情况下也可以使用，如表 2- 所示。</p>
<p>表 2- 修饰符及其描述</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描　　述</th>
</tr>
</thead>
<tbody><tr>
<td><code>re.I</code></td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td><code>re.L</code></td>
<td>做本地化识别（locale-aware）匹配</td>
</tr>
<tr>
<td><code>re.M</code></td>
<td>多行匹配，影响 <code>^</code> 和 <code>$</code></td>
</tr>
<tr>
<td><code>re.S</code></td>
<td>使。匹配包括换行符在内的所有字符</td>
</tr>
<tr>
<td><code>re.U</code></td>
<td>根据 Unicode 字符集解析字符。这个标志影响 <code>\w</code>、<code>\W</code>、<code>\b</code> 和 <code>\B</code></td>
</tr>
<tr>
<td><code>re.X</code></td>
<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td>
</tr>
</tbody></table>
<p>在网页匹配中，较为常用的有 <code>re.S</code> 和 <code>re.I</code>。</p>
<h3 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#%E8%BD%AC%E4%B9%89%E5%8C%B9%E9%85%8D" title="转义匹配"></a>转义匹配</h3><p>我们知道正则表达式定义了许多匹配模式，如 <code>.</code> 匹配除换行符以外的任意字符，但是如果目标字符串里面就包含 <code>.</code>，那该怎么办呢？</p>
<p>这里就需要用到转义匹配了，示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘(百度) <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>‘  <br>result &#x3D; re.match(‘(百度 ) www.baidu.com’, content)  <br>print(result)</td>
</tr>
</tbody></table>
<p>当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例如可以用 <code>\.</code> 来匹配 <code>.</code>，运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;_sre.SRE_Match object; span&#x3D;(0, 17), match&#x3D;’(百度) <a target="_blank" rel="noopener" href="http://www.baidu.com'>">www.baidu.com&#39;&gt;</a></td>
</tr>
</tbody></table>
<p>可以看到，这里成功匹配到了原字符串。</p>
<p>这些是写正则表达式常用的几个知识点，熟练掌握它们对后面写正则表达式非常有帮助。</p>
<h2 id="3-search"><a href="#3-search" class="headerlink" title="3. search"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#3-search" title="3. search"></a>3. <code>search</code></h2><p>前面提到过，<code>match</code> 方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了。我们看下面的例子：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘Extra stings Hello 1234567 World_This is a Regex Demo Extra stings’  <br>result &#x3D; re.match(‘Hello.<em>?(\d+).</em>?Demo’, content)  <br>print(result)</td>
</tr>
</tbody></table>
<p>这里的字符串以 <code>Extra</code> 开头，但是正则表达式以 <code>Hello</code> 开头，整个正则表达式是字符串的一部分，但是这样匹配是失败的。运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>None</td>
</tr>
</tbody></table>
<p>因为 <code>match</code> 方法在使用时需要考虑到开头的内容，这在做匹配时并不方便。它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p>
<p>这里就有另外一个方法 <code>search</code>，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。也就是说，正则表达式可以是字符串的一部分，在匹配时，<code>search</code> 方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回 <code>None</code>。</p>
<p>我们把上面代码中的 <code>match</code> 方法修改成 <code>search</code>，再看一下运行结果：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;_sre.SRE_Match object; span&#x3D;(13, 53), match&#x3D;’Hello 1234567 World_This is a Regex Demo’&gt;  <br>1234567</td>
</tr>
</tbody></table>
<p>这时就得到了匹配结果。</p>
<p>因此，为了匹配方便，我们可以尽量使用 <code>search</code> 方法。</p>
<p>下面再用几个实例来看看 <code>search</code> 方法的用法。</p>
<p>首先，这里有一段待匹配的 HTML 文本，接下来写几个正则表达式实例来实现相应信息的提取：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>html &#x3D; ‘’’  <br><div id="songs-list">  <br>  <h2 class="title">经典老歌</h2>  <br>  <p class="introduction">经典老歌列表</p>  <br>  <ul id="list" class="list-group">  <br>    <li data-view="2">一路上有你</li>  <br>    <li data-view="7">  <br>      <a href="/2.mp3" singer="任贤齐">沧海一声笑</a>  <br>    </li>  <br>    <li data-view="4" class="active">  <br>      <a href="/3.mp3" singer="齐秦">往事随风</a>  <br>    </li>  <br>    <li data-view="6"><a href="/4.mp3" singer="beyond">光辉岁月</a></li>  <br>    <li data-view="5"><a href="/5.mp3" singer="陈慧琳">记事本</a></li>  <br>    <li data-view="5">  <br>      <a href="/6.mp3" singer="邓丽君">但愿人长久</a>  <br>    </li>  <br>  </ul>  <br></div>  <br>‘’’</td>
</tr>
</tbody></table>
<p>可以观察到，<code>ul</code> 节点里有许多 <code>li</code> 节点，其中 <code>li</code> 节点中有的包含 <code>a</code> 节点，有的不包含 <code>a</code> 节点，<code>a</code> 节点还有一些相应的属性 —— 超链接和歌手名。</p>
<p>首先，我们尝试提取 <code>class</code> 为 <code>active</code> 的 <code>li</code> 节点内部的超链接包含的歌手名和歌名，此时需要提取第三个 <code>li</code> 节点下 <code>a</code> 节点的 <code>singer</code> 属性和文本。</p>
<p>此时正则表达式可以以 <code>li</code> 开头，然后寻找一个标志符 <code>active</code>，中间的部分可以用 <code>.*?</code> 来匹配。接下来，要提取 <code>singer</code> 这个属性值，所以还需要写入 <code>singer=&quot;(.*?)&quot;</code>，这里需要提取的部分用小括号括起来，以便用 <code>group</code> 方法提取出来，它的两侧边界是双引号。然后还需要匹配 <code>a</code> 节点的文本，其中它的左边界是 <code>&gt;</code>，右边界是 <code>&lt;/a&gt;</code>。然后目标内容依然用 <code>(.*?)</code> 来匹配，所以最后的正则表达式就变成了：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&lt;li.<em>?active.<em>?singer&#x3D;”(.</em>?)”&gt;(.</em>?)</a></td>
</tr>
</tbody></table>
<p>然后再调用 <code>search</code> 方法，它会搜索整个 HTML 文本，找到符合正则表达式的第一个内容返回。</p>
<p>另外，由于代码有换行，所以这里第三个参数需要传入 <code>re.S</code>。整个匹配代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>result &#x3D; re.search(‘&lt;li.<em>?active.<em>?singer&#x3D;”(.</em>?)”&gt;(.</em>?)</a>‘, html, re.S)  <br>if result:  <br>    print(result.group(1), result.group(2))</td>
</tr>
</tbody></table>
<p>由于需要获取的歌手和歌名都已经用小括号包围，所以可以用 <code>group</code> 方法获取。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>齐秦 往事随风</td>
</tr>
</tbody></table>
<p>可以看到，这正是 <code>class</code> 为 <code>active</code> 的 <code>li</code> 节点内部的超链接包含的歌手名和歌名。</p>
<p>如果正则表达式不加 <code>active</code>（也就是匹配不带 <code>class</code> 为 <code>active</code> 的节点内容），那会怎样呢？我们将正则表达式中的 <code>active</code> 去掉，代码改写如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>result &#x3D; re.search(‘&lt;li.<em>?singer&#x3D;”(.*?)”&gt;(.</em>?)</a>‘, html, re.S)  <br>if result:  <br>    print(result.group(1), result.group(2))</td>
</tr>
</tbody></table>
<p>由于 <code>search</code> 方法会返回第一个符合条件的匹配目标，这里结果就变了：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>任贤齐 沧海一声笑</td>
</tr>
</tbody></table>
<p>把 <code>active</code> 标签去掉后，从字符串开头开始搜索，此时符合条件的节点就变成了第二个 <code>li</code> 节点，后面的就不再匹配，所以运行结果就变成第二个 <code>li</code> 节点中的内容了。</p>
<p>注意，在上面的两次匹配中，<code>search</code> 方法的第三个参数都加了 <code>re.S</code>，这使得 <code>.*?</code> 可以匹配换行，所以含有换行符的 <code>li</code> 节点被匹配到了。如果我们将其去掉，结果会是什么？代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>result &#x3D; re.search(‘&lt;li.<em>?singer&#x3D;”(.*?)”&gt;(.</em>?)</a>‘, html)  <br>if result:  <br>    print(result.group(1), result.group(2))</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>beyond 光辉岁月</td>
</tr>
</tbody></table>
<p>可以看到，结果变成了第四个 <code>li</code> 节点的内容。这是因为第二个和第三个 <code>li</code> 节点都包含了换行符，去掉 <code>re.S</code> 之后，<code>.*?</code> 已经不能匹配换行符，所以正则表达式不会匹配到第二个和第三个 <code>li</code> 节点，而第四个 <code>li</code> 节点中不包含换行符，所以成功匹配。</p>
<p>由于绝大部分的 HTML 文本都包含了换行符，所以尽量都需要加上 <code>re.S</code> 修饰符，以免出现匹配不到的问题。</p>
<h2 id="4-findall"><a href="#4-findall" class="headerlink" title="4. findall"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#4-findall" title="4. findall"></a>4. <code>findall</code></h2><p>前面我们介绍了 <code>search</code> 方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要获取匹配正则表达式的所有内容，那该怎么办呢？这时就要借助 <code>findall</code> 方法了。该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p>
<p>还是上面的 HTML 文本，如果想获取所有 <code>a</code> 节点的超链接、歌手和歌名，就可以将 <code>search</code> 方法换成 <code>findall</code> 方法。如果有返回结果的话，就是列表类型，所以需要遍历一下来依次获取每组内容。代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>results &#x3D; re.findall(‘&lt;li.<em>?href&#x3D;”(.<em>?)”.</em>?singer&#x3D;”(.*?)”&gt;(.</em>?)</a>‘, html, re.S)  <br>print(results)  <br>print(type(results))  <br>for result in results:  <br>    print(result)  <br>    print(result[0], result[1], result[2])</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>[(‘&#x2F;2.mp3’, ‘ 任贤齐 ‘, ‘ 沧海一声笑 ‘), (‘&#x2F;3.mp3’, ‘ 齐秦 ‘, ‘ 往事随风 ‘), (‘&#x2F;4.mp3’, ‘beyond’, ‘ 光辉岁月 ‘), (‘&#x2F;5.mp3’, ‘ 陈慧琳 ‘, ‘ 记事本 ‘), (‘&#x2F;6.mp3’, ‘ 邓丽君 ‘, ‘ 但愿人长久 ‘)]  <br>&lt;class ‘list’&gt;  <br>(‘&#x2F;2.mp3’, ‘ 任贤齐 ‘, ‘ 沧海一声笑 ‘)  <br>&#x2F;2.mp3 任贤齐 沧海一声笑  <br>(‘&#x2F;3.mp3’, ‘ 齐秦 ‘, ‘ 往事随风 ‘)  <br>&#x2F;3.mp3 齐秦 往事随风  <br>(‘&#x2F;4.mp3’, ‘beyond’, ‘ 光辉岁月 ‘)  <br>&#x2F;4.mp3 beyond 光辉岁月  <br>(‘&#x2F;5.mp3’, ‘ 陈慧琳 ‘, ‘ 记事本 ‘)  <br>&#x2F;5.mp3 陈慧琳 记事本  <br>(‘&#x2F;6.mp3’, ‘ 邓丽君 ‘, ‘ 但愿人长久 ‘)  <br>&#x2F;6.mp3 邓丽君 但愿人长久</td>
</tr>
</tbody></table>
<p>可以看到，返回的列表中的每个元素都是元组类型，我们用对应的索引依次取出即可。</p>
<p>如果只是获取第一个内容，可以用 <code>search</code> 方法。当需要提取多个内容时，可以用 <code>findall</code> 方法。</p>
<h2 id="5-sub"><a href="#5-sub" class="headerlink" title="5. sub"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#5-sub" title="5. sub"></a>5. <code>sub</code></h2><p>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的 <code>replace</code> 方法，那就太烦琐了，这时可以借助 <code>sub</code> 方法。示例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content &#x3D; ‘54aK54yr5oiR54ix5L2g’  <br>content &#x3D; re.sub(‘\d+’, ‘’, content)  <br>print(content)</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>aKyroiRixLg</td>
</tr>
</tbody></table>
<p>这里只需要给第一个参数传入 <code>\d+</code> 来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串。</p>
<p>在上面的 HTML 文本中，如果想获取所有 <code>li</code> 节点的歌名，直接用正则表达式来提取可能比较烦琐。比如，可以写成这样子：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>results &#x3D; re.findall(‘&lt;li.<em>?&gt;\s</em>?(&lt;a.<em>?&gt;)?(\w+)(</a>)?\s</em>?</li>‘, html, re.S)  <br>for result in results:  <br>    print(result[1])</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>一路上有你  <br>沧海一声笑  <br>往事随风  <br>光辉岁月  <br>记事本  <br>但愿人长久</td>
</tr>
</tbody></table>
<p>此时借助 <code>sub</code> 方法就比较简单了。可以先用 <code>sub</code> 方法将 <code>a</code> 节点去掉，只留下文本，然后再利用 <code>findall</code> 提取就好了：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>html &#x3D; re.sub(‘&lt;a.<em>?&gt;|</a>‘, ‘’, html)  <br>print(html)  <br>results &#x3D; re.findall(‘&lt;li.*?&gt;(.</em>?)</li>‘, html, re.S)  <br>for result in results:  <br>    print(result.strip())</td>
</tr>
</tbody></table>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><div id="songs-list">  <br>    <h2 class="title"> 经典老歌 </h2>  <br>    <p class="introduction">  <br>        经典老歌列表  <br>    </p>  <br>    <ul id="list" class="list-group">  <br>        <li data-view="2"> 一路上有你 </li>  <br>        <li data-view="7">  <br>            沧海一声笑  <br>        </li>  <br>        <li data-view="4" class="active">  <br>            往事随风  <br>        </li>  <br>        <li data-view="6"> 光辉岁月 </li>  <br>        <li data-view="5"> 记事本 </li>  <br>        <li data-view="5">  <br>            但愿人长久  <br>        </li>  <br>    </ul>  <br></div>  <br>一路上有你  <br>沧海一声笑  <br>往事随风  <br>光辉岁月  <br>记事本  <br>但愿人长久</td>
</tr>
</tbody></table>
<p>可以看到，<code>a</code> 节点经过 <code>sub</code> 方法处理后就没有了，然后再通过 <code>findall</code> 方法直接提取即可。可以看到，在适当的时候，借助 <code>sub</code> 方法可以起到事半功倍的效果。</p>
<h2 id="6-compile"><a href="#6-compile" class="headerlink" title="6. compile"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#6-compile" title="6. compile"></a>6. <code>compile</code></h2><p>前面所讲的方法都是用来处理字符串的方法，最后再介绍一下 <code>compile</code> 方法，这个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。示例代码如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>import re  <br>  <br>content1 &#x3D; ‘2019-12-15 12:00’  <br>content2 &#x3D; ‘2019-12-17 12:55’  <br>content3 &#x3D; ‘2019-12-22 13:21’  <br>pattern &#x3D; re.compile(‘\d{2}:\d{2}’)  <br>result1 &#x3D; re.sub(pattern, ‘’, content1)  <br>result2 &#x3D; re.sub(pattern, ‘’, content2)  <br>result3 &#x3D; re.sub(pattern, ‘’, content3)  <br>print(result1, result2, result3)</td>
</tr>
</tbody></table>
<p>例如，这里有 3 个日期，我们想分别将 3 个日期中的时间去掉，这时可以借助 <code>sub</code> 方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写 3 个同样的正则表达式，此时可以借助 <code>compile</code> 方法将正则表达式编译成一个正则表达式对象，以便复用。</p>
<p>运行结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>2019-12-15  2019-12-17  2019-12-22</td>
</tr>
</tbody></table>
<p>另外，<code>compile</code> 还可以传入修饰符，例如 <code>re.S</code> 等修饰符，这样在 <code>search</code>、<code>findall</code> 等方法中就不需要额外传了。所以，<code>compile</code> 方法可以说是给正则表达式做了一层封装，以便我们更好地复用。</p>
<h2 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a><a target="_blank" rel="noopener" href="https://cuiqingcai.com/202223.html#7-%E6%80%BB%E7%BB%93" title="7. 总结"></a>7. 总结</h2><p>到此为止，正则表达式的基本用法就介绍完了，后面会通过具体的实例来讲解正则表达式的用法。</p>
<p>本节代码：<a target="_blank" rel="noopener" href="https://github.com/Python3WebSpider/RegexTest%E3%80%82">https://github.com/Python3WebSpider/RegexTest。</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/Blogs/categories/%E7%A8%8B%E5%BA%8F/" class="category-chain-item">程序</a>
  
  
    <span>></span>
    
  <a href="/Blogs/categories/%E7%A8%8B%E5%BA%8F/03%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/" class="category-chain-item">03高级语言</a>
  
  
    <span>></span>
    
  <a href="/Blogs/categories/%E7%A8%8B%E5%BA%8F/03%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/Python/" class="category-chain-item">Python</a>
  
  
    <span>></span>
    
  <a href="/Blogs/categories/%E7%A8%8B%E5%BA%8F/03%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/Python/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/" class="category-chain-item">python爬虫学习</a>
  
  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/Blogs/tags/%E7%88%AC%E8%99%AB%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="print-no-link">#爬虫编程基础</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>爬虫编程基础</div>
      <div>http://mavericreate.top/Blogs/2025/08/28/爬虫编程基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>唐浩天</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blogs/2025/08/28/%E7%94%B5%E8%B7%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E7%AD%89%E6%95%88/" title="电路定理与等效">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">电路定理与等效</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blogs/2025/08/28/%E7%9F%A9%E9%98%B5/" title="矩阵">
                        <span class="hidden-mobile">矩阵</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/Blogs/js/events.js" ></script>
<script  src="/Blogs/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/Blogs/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/Blogs/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/Blogs/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
